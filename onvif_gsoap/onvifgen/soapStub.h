/* soapStub.h
   Generated by gSOAP 2.8.40 for onvifgen/onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#define SOAP_NAMESPACE_OF_wsc	"http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512"
#define SOAP_NAMESPACE_OF_saml1	"urn:oasis:names:tc:SAML:1.0:assertion"
#define SOAP_NAMESPACE_OF_saml2	"urn:oasis:names:tc:SAML:2.0:assertion"
#include <deque>
#include <list>
#include <vector>
#include <set>
#define SOAP_NAMESPACE_OF_ns1	"http://www.onvif.org/ver10/device/wsdl"
#define SOAP_NAMESPACE_OF_ns2	"http://www.onvif.org/ver10/schema"
#define SOAP_NAMESPACE_OF_ns3	"http://docs.oasis-open.org/wsn/b-2"
#define SOAP_NAMESPACE_OF_ns4	"http://www.w3.org/2004/08/xop/include"
#define SOAP_NAMESPACE_OF_ns5	"http://docs.oasis-open.org/wsrf/bf-2"
#define SOAP_NAMESPACE_OF_ns6	"http://docs.oasis-open.org/wsn/t-1"
#define SOAP_NAMESPACE_OF_ns7	"http://www.onvif.org/ver10/display/wsdl"
#define SOAP_NAMESPACE_OF_ns8	"http://www.onvif.org/ver20/imaging/wsdl"
#define SOAP_NAMESPACE_OF_ns9	"http://www.onvif.org/ver10/media/wsdl"
#define SOAP_NAMESPACE_OF_ns10	"http://www.onvif.org/ver20/media/wsdl"
#define SOAP_NAMESPACE_OF_ns11	"http://www.onvif.org/ver20/ptz/wsdl"
#define SOAP_NAMESPACE_OF_ns12	"http://www.onvif.org/ver10/credential/wsdl"
#define SOAP_NAMESPACE_OF_ns13	"http://www.onvif.org/ver10/pacs"
#define SOAP_NAMESPACE_OF_ns14	"http://www.w3.org/2005/08/addressing"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20840
# error "GSOAP VERSION 20840 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* wsu.h:66 */
#ifndef SOAP_TYPE_wsu__tTimestampFault
#define SOAP_TYPE_wsu__tTimestampFault (8)
/* wsu:tTimestampFault */
enum wsu__tTimestampFault {
	wsu__MessageExpired = 0
};
#endif

/* wsse.h:100 */
#ifndef SOAP_TYPE_wsse__FaultcodeEnum
#define SOAP_TYPE_wsse__FaultcodeEnum (11)
/* wsse:FaultcodeEnum */
enum wsse__FaultcodeEnum {
	wsse__UnsupportedSecurityToken = 0,
	wsse__UnsupportedAlgorithm = 1,
	wsse__InvalidSecurity = 2,
	wsse__InvalidSecurityToken = 3,
	wsse__FailedAuthentication = 4,
	wsse__FailedCheck = 5,
	wsse__SecurityTokenUnavailable = 6
};
#endif

/* wsc.h:62 */
#ifndef SOAP_TYPE_wsc__FaultCodeType
#define SOAP_TYPE_wsc__FaultCodeType (86)
/* wsc:FaultCodeType */
enum wsc__FaultCodeType {
	wsc__BadContextToken = 0,
	wsc__UnsupportedContextToken = 1,
	wsc__UnknownDerivationSource = 2,
	wsc__RenewNeeded = 3,
	wsc__UnableToRenew = 4
};
#endif

/* saml1.h:112 */
#ifndef SOAP_TYPE_saml1__DecisionType
#define SOAP_TYPE_saml1__DecisionType (116)
/* saml1:DecisionType */
enum saml1__DecisionType {
	saml1__DecisionType__Permit = 0,
	saml1__DecisionType__Deny = 1,
	saml1__DecisionType__Indeterminate = 2
};
#endif

/* saml2.h:118 */
#ifndef SOAP_TYPE_saml2__DecisionType
#define SOAP_TYPE_saml2__DecisionType (172)
/* saml2:DecisionType */
enum saml2__DecisionType {
	saml2__DecisionType__Permit = 0,
	saml2__DecisionType__Deny = 1,
	saml2__DecisionType__Indeterminate = 2
};
#endif

/* onvifgen/onvif.h:3797 */
#ifndef SOAP_TYPE_ns1__StorageType
#define SOAP_TYPE_ns1__StorageType (1374)
/* ns1:StorageType */
enum class ns1__StorageType {
	NFS = 0,
	CIFS = 1,
	CDMI = 2
};
#endif

/* onvifgen/onvif.h:3841 */
#ifndef SOAP_TYPE_ns2__RotateMode
#define SOAP_TYPE_ns2__RotateMode (1377)
/* ns2:RotateMode */
enum class ns2__RotateMode {
	OFF = 0,
	ON = 1,
	AUTO = 2
};
#endif

/* onvifgen/onvif.h:3850 */
#ifndef SOAP_TYPE_ns2__VideoEncoding
#define SOAP_TYPE_ns2__VideoEncoding (1378)
/* ns2:VideoEncoding */
enum class ns2__VideoEncoding {
	JPEG = 0,
	MPEG4 = 1,
	H264 = 2
};
#endif

/* onvifgen/onvif.h:3859 */
#ifndef SOAP_TYPE_ns2__Mpeg4Profile
#define SOAP_TYPE_ns2__Mpeg4Profile (1379)
/* ns2:Mpeg4Profile */
enum class ns2__Mpeg4Profile {
	SP = 0,
	ASP = 1
};
#endif

/* onvifgen/onvif.h:3867 */
#ifndef SOAP_TYPE_ns2__H264Profile
#define SOAP_TYPE_ns2__H264Profile (1380)
/* ns2:H264Profile */
enum class ns2__H264Profile {
	Baseline = 0,
	Main = 1,
	Extended = 2,
	High = 3
};
#endif

/* onvifgen/onvif.h:3880 */
#ifndef SOAP_TYPE_ns2__VideoEncodingMimeNames
#define SOAP_TYPE_ns2__VideoEncodingMimeNames (1381)
/* ns2:VideoEncodingMimeNames */
enum class ns2__VideoEncodingMimeNames {
	JPEG = 0,
	MPV4_ES = 1,
	H264 = 2,
	H265 = 3
};
#endif

/* onvifgen/onvif.h:3890 */
#ifndef SOAP_TYPE_ns2__VideoEncodingProfiles
#define SOAP_TYPE_ns2__VideoEncodingProfiles (1382)
/* ns2:VideoEncodingProfiles */
enum class ns2__VideoEncodingProfiles {
	Simple = 0,
	AdvancedSimple = 1,
	Baseline = 2,
	Main = 3,
	Main10 = 4,
	Extended = 5,
	High = 6
};
#endif

/* onvifgen/onvif.h:3903 */
#ifndef SOAP_TYPE_ns2__AudioEncoding
#define SOAP_TYPE_ns2__AudioEncoding (1383)
/* ns2:AudioEncoding */
enum class ns2__AudioEncoding {
	G711 = 0,
	G726 = 1,
	AAC = 2
};
#endif

/* onvifgen/onvif.h:3915 */
#ifndef SOAP_TYPE_ns2__AudioEncodingMimeNames
#define SOAP_TYPE_ns2__AudioEncodingMimeNames (1384)
/* ns2:AudioEncodingMimeNames */
enum class ns2__AudioEncodingMimeNames {
	PCMU = 0,
	G726 = 1,
	MP4A_LATM = 2
};
#endif

/* onvifgen/onvif.h:3924 */
#ifndef SOAP_TYPE_ns2__MetadataCompressionType
#define SOAP_TYPE_ns2__MetadataCompressionType (1385)
/* ns2:MetadataCompressionType */
enum class ns2__MetadataCompressionType {
	None = 0,
	GZIP = 1,
	EXI = 2
};
#endif

/* onvifgen/onvif.h:3933 */
#ifndef SOAP_TYPE_ns2__StreamType
#define SOAP_TYPE_ns2__StreamType (1386)
/* ns2:StreamType */
enum class ns2__StreamType {
	RTP_Unicast = 0,
	RTP_Multicast = 1
};
#endif

/* onvifgen/onvif.h:3941 */
#ifndef SOAP_TYPE_ns2__TransportProtocol
#define SOAP_TYPE_ns2__TransportProtocol (1387)
/* ns2:TransportProtocol */
enum class ns2__TransportProtocol {
	UDP = 0,
	TCP = 1,
	RTSP = 2,
	HTTP = 3
};
#endif

/* onvifgen/onvif.h:3954 */
#ifndef SOAP_TYPE_ns2__ScopeDefinition
#define SOAP_TYPE_ns2__ScopeDefinition (1388)
/* ns2:ScopeDefinition */
enum class ns2__ScopeDefinition {
	Fixed = 0,
	Configurable = 1
};
#endif

/* onvifgen/onvif.h:3962 */
#ifndef SOAP_TYPE_ns2__DiscoveryMode
#define SOAP_TYPE_ns2__DiscoveryMode (1389)
/* ns2:DiscoveryMode */
enum class ns2__DiscoveryMode {
	Discoverable = 0,
	NonDiscoverable = 1
};
#endif

/* onvifgen/onvif.h:3975 */
#ifndef SOAP_TYPE_ns2__Duplex
#define SOAP_TYPE_ns2__Duplex (1391)
/* ns2:Duplex */
enum class ns2__Duplex {
	Full = 0,
	Half = 1
};
#endif

/* onvifgen/onvif.h:3990 */
#ifndef SOAP_TYPE_ns2__IPv6DHCPConfiguration
#define SOAP_TYPE_ns2__IPv6DHCPConfiguration (1393)
/* ns2:IPv6DHCPConfiguration */
enum class ns2__IPv6DHCPConfiguration {
	Auto = 0,
	Stateful = 1,
	Stateless = 2,
	Off = 3
};
#endif

/* onvifgen/onvif.h:4000 */
#ifndef SOAP_TYPE_ns2__NetworkProtocolType
#define SOAP_TYPE_ns2__NetworkProtocolType (1394)
/* ns2:NetworkProtocolType */
enum class ns2__NetworkProtocolType {
	HTTP = 0,
	HTTPS = 1,
	RTSP = 2
};
#endif

/* onvifgen/onvif.h:4009 */
#ifndef SOAP_TYPE_ns2__NetworkHostType
#define SOAP_TYPE_ns2__NetworkHostType (1395)
/* ns2:NetworkHostType */
enum class ns2__NetworkHostType {
	IPv4 = 0,
	IPv6 = 1,
	DNS = 2
};
#endif

/* onvifgen/onvif.h:4030 */
#ifndef SOAP_TYPE_ns2__IPType
#define SOAP_TYPE_ns2__IPType (1399)
/* ns2:IPType */
enum class ns2__IPType {
	IPv4 = 0,
	IPv6 = 1
};
#endif

/* onvifgen/onvif.h:4046 */
#ifndef SOAP_TYPE_ns2__IPAddressFilterType
#define SOAP_TYPE_ns2__IPAddressFilterType (1402)
/* ns2:IPAddressFilterType */
enum class ns2__IPAddressFilterType {
	Allow = 0,
	Deny = 1
};
#endif

/* onvifgen/onvif.h:4054 */
#ifndef SOAP_TYPE_ns2__DynamicDNSType
#define SOAP_TYPE_ns2__DynamicDNSType (1403)
/* ns2:DynamicDNSType */
enum class ns2__DynamicDNSType {
	NoUpdate = 0,
	ClientUpdates = 1,
	ServerUpdates = 2
};
#endif

/* onvifgen/onvif.h:4068 */
#ifndef SOAP_TYPE_ns2__Dot11StationMode
#define SOAP_TYPE_ns2__Dot11StationMode (1405)
/* ns2:Dot11StationMode */
enum class ns2__Dot11StationMode {
	Ad_hoc = 0,
	Infrastructure = 1,
	Extended = 2
};
#endif

/* onvifgen/onvif.h:4077 */
#ifndef SOAP_TYPE_ns2__Dot11SecurityMode
#define SOAP_TYPE_ns2__Dot11SecurityMode (1406)
/* ns2:Dot11SecurityMode */
enum class ns2__Dot11SecurityMode {
	None = 0,
	WEP = 1,
	PSK = 2,
	Dot1X = 3,
	Extended = 4
};
#endif

/* onvifgen/onvif.h:4088 */
#ifndef SOAP_TYPE_ns2__Dot11Cipher
#define SOAP_TYPE_ns2__Dot11Cipher (1407)
/* ns2:Dot11Cipher */
enum class ns2__Dot11Cipher {
	CCMP = 0,
	TKIP = 1,
	Any = 2,
	Extended = 3
};
#endif

/* onvifgen/onvif.h:4108 */
#ifndef SOAP_TYPE_ns2__Dot11SignalStrength
#define SOAP_TYPE_ns2__Dot11SignalStrength (1410)
/* ns2:Dot11SignalStrength */
enum class ns2__Dot11SignalStrength {
	None = 0,
	Very_x0020Bad = 1,
	Bad = 2,
	Good = 3,
	Very_x0020Good = 4,
	Extended = 5
};
#endif

/* onvifgen/onvif.h:4120 */
#ifndef SOAP_TYPE_ns2__Dot11AuthAndMangementSuite
#define SOAP_TYPE_ns2__Dot11AuthAndMangementSuite (1411)
/* ns2:Dot11AuthAndMangementSuite */
enum class ns2__Dot11AuthAndMangementSuite {
	None = 0,
	Dot1X = 1,
	PSK = 2,
	Extended = 3
};
#endif

/* onvifgen/onvif.h:4130 */
#ifndef SOAP_TYPE_ns2__CapabilityCategory
#define SOAP_TYPE_ns2__CapabilityCategory (1412)
/* ns2:CapabilityCategory */
enum class ns2__CapabilityCategory {
	All = 0,
	Analytics = 1,
	Device = 2,
	Events = 3,
	Imaging = 4,
	Media = 5,
	PTZ = 6
};
#endif

/* onvifgen/onvif.h:4146 */
#ifndef SOAP_TYPE_ns2__SystemLogType
#define SOAP_TYPE_ns2__SystemLogType (1413)
/* ns2:SystemLogType */
enum class ns2__SystemLogType {
	System = 0,
	Access = 1
};
#endif

/* onvifgen/onvif.h:4163 */
#ifndef SOAP_TYPE_ns2__FactoryDefaultType
#define SOAP_TYPE_ns2__FactoryDefaultType (1414)
/* ns2:FactoryDefaultType */
enum class ns2__FactoryDefaultType {
	Hard = 0,
	Soft = 1
};
#endif

/* onvifgen/onvif.h:4177 */
#ifndef SOAP_TYPE_ns2__SetDateTimeType
#define SOAP_TYPE_ns2__SetDateTimeType (1415)
/* ns2:SetDateTimeType */
enum class ns2__SetDateTimeType {
	Manual = 0,
	NTP = 1
};
#endif

/* onvifgen/onvif.h:4191 */
#ifndef SOAP_TYPE_ns2__UserLevel
#define SOAP_TYPE_ns2__UserLevel (1416)
/* ns2:UserLevel */
enum class ns2__UserLevel {
	Administrator = 0,
	Operator = 1,
	User = 2,
	Anonymous = 3,
	Extended = 4
};
#endif

/* onvifgen/onvif.h:4202 */
#ifndef SOAP_TYPE_ns2__RelayLogicalState
#define SOAP_TYPE_ns2__RelayLogicalState (1417)
/* ns2:RelayLogicalState */
enum class ns2__RelayLogicalState {
	active = 0,
	inactive = 1
};
#endif

/* onvifgen/onvif.h:4210 */
#ifndef SOAP_TYPE_ns2__RelayIdleState
#define SOAP_TYPE_ns2__RelayIdleState (1418)
/* ns2:RelayIdleState */
enum class ns2__RelayIdleState {
	closed = 0,
	open = 1
};
#endif

/* onvifgen/onvif.h:4218 */
#ifndef SOAP_TYPE_ns2__RelayMode
#define SOAP_TYPE_ns2__RelayMode (1419)
/* ns2:RelayMode */
enum class ns2__RelayMode {
	Monostable = 0,
	Bistable = 1
};
#endif

/* onvifgen/onvif.h:4226 */
#ifndef SOAP_TYPE_ns2__DigitalIdleState
#define SOAP_TYPE_ns2__DigitalIdleState (1420)
/* ns2:DigitalIdleState */
enum class ns2__DigitalIdleState {
	closed = 0,
	open = 1
};
#endif

/* onvifgen/onvif.h:4234 */
#ifndef SOAP_TYPE_ns2__EFlipMode
#define SOAP_TYPE_ns2__EFlipMode (1421)
/* ns2:EFlipMode */
enum class ns2__EFlipMode {
	OFF = 0,
	ON = 1,
	Extended = 2
};
#endif

/* onvifgen/onvif.h:4243 */
#ifndef SOAP_TYPE_ns2__ReverseMode
#define SOAP_TYPE_ns2__ReverseMode (1422)
/* ns2:ReverseMode */
enum class ns2__ReverseMode {
	OFF = 0,
	ON = 1,
	AUTO = 2,
	Extended = 3
};
#endif

/* onvifgen/onvif.h:4258 */
#ifndef SOAP_TYPE_ns2__MoveStatus
#define SOAP_TYPE_ns2__MoveStatus (1424)
/* ns2:MoveStatus */
enum class ns2__MoveStatus {
	IDLE = 0,
	MOVING = 1,
	UNKNOWN = 2
};
#endif

/* onvifgen/onvif.h:4267 */
#ifndef SOAP_TYPE_ns2__PTZPresetTourState
#define SOAP_TYPE_ns2__PTZPresetTourState (1425)
/* ns2:PTZPresetTourState */
enum class ns2__PTZPresetTourState {
	Idle = 0,
	Touring = 1,
	Paused = 2,
	Extended = 3
};
#endif

/* onvifgen/onvif.h:4277 */
#ifndef SOAP_TYPE_ns2__PTZPresetTourDirection
#define SOAP_TYPE_ns2__PTZPresetTourDirection (1426)
/* ns2:PTZPresetTourDirection */
enum class ns2__PTZPresetTourDirection {
	Forward = 0,
	Backward = 1,
	Extended = 2
};
#endif

/* onvifgen/onvif.h:4286 */
#ifndef SOAP_TYPE_ns2__PTZPresetTourOperation
#define SOAP_TYPE_ns2__PTZPresetTourOperation (1427)
/* ns2:PTZPresetTourOperation */
enum class ns2__PTZPresetTourOperation {
	Start = 0,
	Stop = 1,
	Pause = 2,
	Extended = 3
};
#endif

/* onvifgen/onvif.h:4296 */
#ifndef SOAP_TYPE_ns2__AutoFocusMode
#define SOAP_TYPE_ns2__AutoFocusMode (1428)
/* ns2:AutoFocusMode */
enum class ns2__AutoFocusMode {
	AUTO = 0,
	MANUAL = 1
};
#endif

/* onvifgen/onvif.h:4304 */
#ifndef SOAP_TYPE_ns2__WideDynamicMode
#define SOAP_TYPE_ns2__WideDynamicMode (1429)
/* ns2:WideDynamicMode */
enum class ns2__WideDynamicMode {
	OFF = 0,
	ON = 1
};
#endif

/* onvifgen/onvif.h:4315 */
#ifndef SOAP_TYPE_ns2__BacklightCompensationMode
#define SOAP_TYPE_ns2__BacklightCompensationMode (1430)
/* ns2:BacklightCompensationMode */
enum class ns2__BacklightCompensationMode {
	OFF = 0,
	ON = 1
};
#endif

/* onvifgen/onvif.h:4329 */
#ifndef SOAP_TYPE_ns2__ExposurePriority
#define SOAP_TYPE_ns2__ExposurePriority (1431)
/* ns2:ExposurePriority */
enum class ns2__ExposurePriority {
	LowNoise = 0,
	FrameRate = 1
};
#endif

/* onvifgen/onvif.h:4337 */
#ifndef SOAP_TYPE_ns2__ExposureMode
#define SOAP_TYPE_ns2__ExposureMode (1432)
/* ns2:ExposureMode */
enum class ns2__ExposureMode {
	AUTO = 0,
	MANUAL = 1
};
#endif

/* onvifgen/onvif.h:4345 */
#ifndef SOAP_TYPE_ns2__Enabled
#define SOAP_TYPE_ns2__Enabled (1433)
/* ns2:Enabled */
enum class ns2__Enabled {
	ENABLED = 0,
	DISABLED = 1
};
#endif

/* onvifgen/onvif.h:4353 */
#ifndef SOAP_TYPE_ns2__WhiteBalanceMode
#define SOAP_TYPE_ns2__WhiteBalanceMode (1434)
/* ns2:WhiteBalanceMode */
enum class ns2__WhiteBalanceMode {
	AUTO = 0,
	MANUAL = 1
};
#endif

/* onvifgen/onvif.h:4361 */
#ifndef SOAP_TYPE_ns2__IrCutFilterMode
#define SOAP_TYPE_ns2__IrCutFilterMode (1435)
/* ns2:IrCutFilterMode */
enum class ns2__IrCutFilterMode {
	ON = 0,
	OFF = 1,
	AUTO = 2
};
#endif

/* onvifgen/onvif.h:4370 */
#ifndef SOAP_TYPE_ns2__ImageStabilizationMode
#define SOAP_TYPE_ns2__ImageStabilizationMode (1436)
/* ns2:ImageStabilizationMode */
enum class ns2__ImageStabilizationMode {
	OFF = 0,
	ON = 1,
	AUTO = 2,
	Extended = 3
};
#endif

/* onvifgen/onvif.h:4380 */
#ifndef SOAP_TYPE_ns2__IrCutFilterAutoBoundaryType
#define SOAP_TYPE_ns2__IrCutFilterAutoBoundaryType (1437)
/* ns2:IrCutFilterAutoBoundaryType */
enum class ns2__IrCutFilterAutoBoundaryType {
	Common = 0,
	ToOn = 1,
	ToOff = 2,
	Extended = 3
};
#endif

/* onvifgen/onvif.h:4390 */
#ifndef SOAP_TYPE_ns2__ToneCompensationMode
#define SOAP_TYPE_ns2__ToneCompensationMode (1438)
/* ns2:ToneCompensationMode */
enum class ns2__ToneCompensationMode {
	OFF = 0,
	ON = 1,
	AUTO = 2
};
#endif

/* onvifgen/onvif.h:4399 */
#ifndef SOAP_TYPE_ns2__DefoggingMode
#define SOAP_TYPE_ns2__DefoggingMode (1439)
/* ns2:DefoggingMode */
enum class ns2__DefoggingMode {
	OFF = 0,
	ON = 1,
	AUTO = 2
};
#endif

/* onvifgen/onvif.h:4412 */
#ifndef SOAP_TYPE_ns2__PropertyOperation
#define SOAP_TYPE_ns2__PropertyOperation (1441)
/* ns2:PropertyOperation */
enum class ns2__PropertyOperation {
	Initialized = 0,
	Deleted = 1,
	Changed = 2
};
#endif

/* onvifgen/onvif.h:4421 */
#ifndef SOAP_TYPE_ns2__Direction
#define SOAP_TYPE_ns2__Direction (1442)
/* ns2:Direction */
enum class ns2__Direction {
	Left = 0,
	Right = 1,
	Any = 2
};
#endif

/* onvifgen/onvif.h:4430 */
#ifndef SOAP_TYPE_ns2__ClassType
#define SOAP_TYPE_ns2__ClassType (1443)
/* ns2:ClassType */
enum class ns2__ClassType {
	Animal = 0,
	Face = 1,
	Human = 2,
	Vehical = 3,
	Other = 4
};
#endif

/* onvifgen/onvif.h:4444 */
#ifndef SOAP_TYPE_ns2__ReceiverMode
#define SOAP_TYPE_ns2__ReceiverMode (1444)
/* ns2:ReceiverMode */
enum class ns2__ReceiverMode {
	AutoConnect = 0,
	AlwaysConnect = 1,
	NeverConnect = 2,
	Unknown = 3
};
#endif

/* onvifgen/onvif.h:4469 */
#ifndef SOAP_TYPE_ns2__ReceiverState
#define SOAP_TYPE_ns2__ReceiverState (1445)
/* ns2:ReceiverState */
enum class ns2__ReceiverState {
	NotConnected = 0,
	Connecting = 1,
	Connected = 2,
	Unknown = 3
};
#endif

/* onvifgen/onvif.h:4499 */
#ifndef SOAP_TYPE_ns2__SearchState
#define SOAP_TYPE_ns2__SearchState (1448)
/* ns2:SearchState */
enum class ns2__SearchState {
	Queued = 0,
	Searching = 1,
	Completed = 2,
	Unknown = 3
};
#endif

/* onvifgen/onvif.h:4521 */
#ifndef SOAP_TYPE_ns2__RecordingStatus
#define SOAP_TYPE_ns2__RecordingStatus (1449)
/* ns2:RecordingStatus */
enum class ns2__RecordingStatus {
	Initiated = 0,
	Recording = 1,
	Stopped = 2,
	Removing = 3,
	Removed = 4,
	Unknown = 5
};
#endif

/* onvifgen/onvif.h:4536 */
#ifndef SOAP_TYPE_ns2__TrackType
#define SOAP_TYPE_ns2__TrackType (1450)
/* ns2:TrackType */
enum class ns2__TrackType {
	Video = 0,
	Audio = 1,
	Metadata = 2,
	Extended = 3
};
#endif

/* onvifgen/onvif.h:4557 */
#ifndef SOAP_TYPE_ns2__ModeOfOperation
#define SOAP_TYPE_ns2__ModeOfOperation (1453)
/* ns2:ModeOfOperation */
enum class ns2__ModeOfOperation {
	Idle = 0,
	Active = 1,
	Unknown = 2
};
#endif

/* onvifgen/onvif.h:4577 */
#ifndef SOAP_TYPE_ns2__OSDType
#define SOAP_TYPE_ns2__OSDType (1455)
/* ns2:OSDType */
enum class ns2__OSDType {
	Text = 0,
	Image = 1,
	Extended = 2
};
#endif

/* onvifgen/onvif.h:4663 */
#ifndef SOAP_TYPE_ns8__ImagingPresetType
#define SOAP_TYPE_ns8__ImagingPresetType (1459)
/* ns8:ImagingPresetType */
enum class ns8__ImagingPresetType {
	Custom = 0,
	ClearWeather = 1,
	Cloudy = 2,
	Fog = 3,
	Rain = 4,
	Snowing = 5,
	Snow = 6,
	WDR = 7,
	Shade = 8,
	Night = 9,
	Indoor = 10,
	Fluorescent = 11,
	Incandescent = 12,
	Sodium_x0028Natrium_x0029 = 13,
	Sunrise_x0028Horizon_x0029 = 14,
	Sunset_x0028Rear_x0029 = 15,
	ExtremeHot = 16,
	ExtremeCold = 17,
	Underwater = 18,
	CloseUp = 19,
	Motion = 20,
	FlickerFree50 = 21,
	FlickerFree60 = 22
};
#endif

/* onvifgen/onvif.h:4708 */
#ifndef SOAP_TYPE_ns10__ConfigurationEnumeration
#define SOAP_TYPE_ns10__ConfigurationEnumeration (1460)
/* ns10:ConfigurationEnumeration */
enum class ns10__ConfigurationEnumeration {
	All = 0,
	VideoSource = 1,
	VideoEncoder = 2,
	AudioSource = 3,
	AudioEncoder = 4,
	AudioOutput = 5,
	AudioDecoder = 6,
	Metadata = 7,
	Analytics = 8,
	PTZ = 9
};
#endif

/* onvifgen/onvif.h:4724 */
#ifndef SOAP_TYPE_ns10__TransportProtocol
#define SOAP_TYPE_ns10__TransportProtocol (1461)
/* ns10:TransportProtocol */
enum class ns10__TransportProtocol {
	RtspUnicast = 0,
	RtspMulticast = 1,
	RTSP = 2,
	RtspOverHttp = 3
};
#endif

/* onvifgen/onvif.h:4800 */
#ifndef SOAP_TYPE_ns14__RelationshipType
#define SOAP_TYPE_ns14__RelationshipType (1466)
/* ns14:RelationshipType */
enum class ns14__RelationshipType {
	http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply = 0
};
#endif

/* onvifgen/onvif.h:4807 */
#ifndef SOAP_TYPE_ns14__FaultCodesType
#define SOAP_TYPE_ns14__FaultCodesType (1467)
/* ns14:FaultCodesType */
enum class ns14__FaultCodesType {
	ns14__InvalidAddressingHeader = 0,
	ns14__InvalidAddress = 1,
	ns14__InvalidEPR = 2,
	ns14__InvalidCardinality = 3,
	ns14__MissingAddressInEPR = 4,
	ns14__DuplicateMessageID = 5,
	ns14__ActionMismatch = 6,
	ns14__MessageAddressingHeaderRequired = 7,
	ns14__DestinationUnreachable = 8,
	ns14__ActionNotSupported = 9,
	ns14__EndpointUnavailable = 10
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/* dom.h:62 */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (221)
typedef struct soap_dom_element xsd__anyType;
#endif

/* dom.h:65 */
#ifndef SOAP_TYPE_xsd__anyAttribute
#define SOAP_TYPE_xsd__anyAttribute (223)
typedef struct soap_dom_attribute xsd__anyAttribute;
#endif

/* onvifgen/onvif.h:220 */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (225)
typedef std::string xsd__QName;
#endif


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

struct _wsu__Timestamp;	/* wsu.h:76 */
struct wsse__EncodedString;	/* wsse.h:57 */
struct _wsse__UsernameToken;	/* wsse.h:128 */
struct _wsse__BinarySecurityToken;	/* wsse.h:139 */
struct _wsse__Reference;	/* wsse.h:149 */
struct _wsse__Embedded;	/* wsse.h:157 */
struct _wsse__KeyIdentifier;	/* wsse.h:166 */
struct _wsse__SecurityTokenReference;	/* wsse.h:176 */
struct ds__SignatureType;	/* ds.h:46 */
struct _c14n__InclusiveNamespaces;	/* c14n.h:24 */
struct ds__TransformType;	/* ds.h:73 */
struct ds__KeyInfoType;	/* ds.h:48 */
struct ds__SignedInfoType;	/* ds.h:46 */
struct ds__CanonicalizationMethodType;	/* ds.h:59 */
struct ds__SignatureMethodType;	/* ds.h:62 */
struct ds__ReferenceType;	/* ds.h:65 */
struct ds__TransformsType;	/* ds.h:68 */
struct ds__DigestMethodType;	/* ds.h:79 */
struct ds__KeyValueType;	/* ds.h:84 */
struct ds__RetrievalMethodType;	/* ds.h:85 */
struct ds__X509DataType;	/* wsse.h:179 */
struct ds__X509IssuerSerialType;	/* ds.h:102 */
struct ds__DSAKeyValueType;	/* ds.h:123 */
struct ds__RSAKeyValueType;	/* ds.h:126 */
struct xenc__EncryptionPropertyType;	/* xenc.h:84 */
struct xenc__EncryptedType;	/* xenc.h:53 */
struct xenc__EncryptionMethodType;	/* xenc.h:56 */
struct xenc__CipherDataType;	/* xenc.h:59 */
struct xenc__CipherReferenceType;	/* xenc.h:62 */
struct xenc__TransformsType;	/* xenc.h:65 */
struct xenc__AgreementMethodType;	/* xenc.h:74 */
struct xenc__ReferenceType;	/* xenc.h:77 */
struct xenc__EncryptionPropertiesType;	/* xenc.h:80 */
struct __xenc__union_ReferenceList;	/* xenc.h:238 */
struct _xenc__ReferenceList;	/* xenc.h:89 */
struct xenc__EncryptedDataType;	/* xenc.h:68 */
struct xenc__EncryptedKeyType;	/* xenc.h:71 */
struct wsc__SecurityContextTokenType;	/* wsc.h:87 */
union _wsc__union_DerivedKeyTokenType;	/* wsc.h:125 */
struct __wsc__DerivedKeyTokenType_sequence;	/* wsc.h:116 */
struct wsc__DerivedKeyTokenType;	/* wsc.h:109 */
struct wsc__PropertiesType;	/* wsc.h:113 */
struct __saml1__union_AssertionType;	/* saml1.h:145 */
struct saml1__AssertionType;	/* saml1.h:61 */
struct __saml1__union_ConditionsType;	/* saml1.h:187 */
struct saml1__ConditionsType;	/* saml1.h:63 */
struct saml1__ConditionAbstractType;	/* saml1.h:65 */
struct __saml1__union_AdviceType;	/* saml1.h:227 */
struct saml1__AdviceType;	/* saml1.h:71 */
struct saml1__StatementAbstractType;	/* saml1.h:73 */
struct saml1__SubjectType;	/* saml1.h:77 */
struct saml1__SubjectConfirmationType;	/* saml1.h:81 */
struct saml1__SubjectLocalityType;	/* saml1.h:85 */
struct saml1__AuthorityBindingType;	/* saml1.h:87 */
struct __saml1__union_EvidenceType;	/* saml1.h:344 */
struct saml1__EvidenceType;	/* saml1.h:93 */
struct saml1__AttributeDesignatorType;	/* saml1.h:97 */
struct saml1__AudienceRestrictionConditionType;	/* saml1.h:67 */
struct saml1__DoNotCacheConditionType;	/* saml1.h:69 */
struct saml1__SubjectStatementAbstractType;	/* saml1.h:75 */
struct saml1__NameIdentifierType;	/* saml1.h:79 */
struct saml1__ActionType;	/* saml1.h:91 */
struct saml1__AttributeType;	/* saml1.h:99 */
struct saml1__AuthenticationStatementType;	/* saml1.h:83 */
struct saml1__AuthorizationDecisionStatementType;	/* saml1.h:89 */
struct saml1__AttributeStatementType;	/* saml1.h:95 */
struct saml2__BaseIDAbstractType;	/* saml2.h:61 */
struct saml2__EncryptedElementType;	/* saml2.h:65 */
struct __saml2__union_AssertionType;	/* saml2.h:193 */
struct saml2__AssertionType;	/* saml2.h:67 */
struct saml2__SubjectType;	/* saml2.h:69 */
struct saml2__SubjectConfirmationType;	/* saml2.h:71 */
struct __saml2__union_ConditionsType;	/* saml2.h:284 */
struct saml2__ConditionsType;	/* saml2.h:77 */
struct saml2__ConditionAbstractType;	/* saml2.h:79 */
struct __saml2__union_AdviceType;	/* saml2.h:326 */
struct saml2__AdviceType;	/* saml2.h:87 */
struct saml2__StatementAbstractType;	/* saml2.h:89 */
struct saml2__SubjectLocalityType;	/* saml2.h:93 */
struct saml2__AuthnContextType;	/* saml2.h:95 */
struct __saml2__union_EvidenceType;	/* saml2.h:421 */
struct saml2__EvidenceType;	/* saml2.h:101 */
struct saml2__AttributeType;	/* saml2.h:105 */
struct saml2__NameIDType;	/* saml2.h:63 */
struct saml2__SubjectConfirmationDataType;	/* saml2.h:73 */
struct saml2__AudienceRestrictionType;	/* saml2.h:81 */
struct saml2__OneTimeUseType;	/* saml2.h:83 */
struct saml2__ProxyRestrictionType;	/* saml2.h:85 */
struct saml2__AuthnStatementType;	/* saml2.h:91 */
struct saml2__AuthzDecisionStatementType;	/* saml2.h:97 */
struct saml2__ActionType;	/* saml2.h:99 */
struct __saml2__union_AttributeStatementType;	/* saml2.h:653 */
struct saml2__AttributeStatementType;	/* saml2.h:103 */
struct saml2__KeyInfoConfirmationDataType;	/* saml2.h:75 */
struct _wsse__Security;	/* wsse.h:193 */
struct _wsse__Password;	/* wsse.h:129 */
class xsd__base64Binary;	/* onvifgen/onvif.h:223 */
class xsd__hexBinary;	/* onvifgen/onvif.h:231 */
class _ns1__Service_Capabilities;	/* onvifgen/onvif.h:4979 */
class ns1__Service;	/* onvifgen/onvif.h:274 */
class ns1__DeviceServiceCapabilities;	/* onvifgen/onvif.h:277 */
class ns1__NetworkCapabilities;	/* onvifgen/onvif.h:280 */
class ns1__SecurityCapabilities;	/* onvifgen/onvif.h:283 */
class ns1__SystemCapabilities;	/* onvifgen/onvif.h:286 */
class ns1__MiscCapabilities;	/* onvifgen/onvif.h:289 */
class _ns1__UserCredential_Extension;	/* onvifgen/onvif.h:5380 */
class ns1__UserCredential;	/* onvifgen/onvif.h:292 */
class _ns1__StorageConfigurationData_Extension;	/* onvifgen/onvif.h:5434 */
class ns1__StorageConfigurationData;	/* onvifgen/onvif.h:295 */
class _ns1__GetServices;	/* onvifgen/onvif.h:301 */
class _ns1__GetServicesResponse;	/* onvifgen/onvif.h:304 */
class _ns1__GetServiceCapabilities;	/* onvifgen/onvif.h:307 */
class _ns1__GetServiceCapabilitiesResponse;	/* onvifgen/onvif.h:310 */
class _ns1__GetDeviceInformation;	/* onvifgen/onvif.h:313 */
class _ns1__GetDeviceInformationResponse;	/* onvifgen/onvif.h:316 */
class _ns1__SetSystemDateAndTime;	/* onvifgen/onvif.h:319 */
class _ns1__SetSystemDateAndTimeResponse;	/* onvifgen/onvif.h:322 */
class _ns1__GetSystemDateAndTime;	/* onvifgen/onvif.h:325 */
class _ns1__GetSystemDateAndTimeResponse;	/* onvifgen/onvif.h:328 */
class _ns1__SetSystemFactoryDefault;	/* onvifgen/onvif.h:331 */
class _ns1__SetSystemFactoryDefaultResponse;	/* onvifgen/onvif.h:334 */
class _ns1__UpgradeSystemFirmware;	/* onvifgen/onvif.h:337 */
class _ns1__UpgradeSystemFirmwareResponse;	/* onvifgen/onvif.h:340 */
class _ns1__SystemReboot;	/* onvifgen/onvif.h:343 */
class _ns1__SystemRebootResponse;	/* onvifgen/onvif.h:346 */
class _ns1__RestoreSystem;	/* onvifgen/onvif.h:349 */
class _ns1__RestoreSystemResponse;	/* onvifgen/onvif.h:352 */
class _ns1__GetSystemBackup;	/* onvifgen/onvif.h:355 */
class _ns1__GetSystemBackupResponse;	/* onvifgen/onvif.h:358 */
class _ns1__GetSystemSupportInformation;	/* onvifgen/onvif.h:361 */
class _ns1__GetSystemSupportInformationResponse;	/* onvifgen/onvif.h:364 */
class _ns1__GetSystemLog;	/* onvifgen/onvif.h:367 */
class _ns1__GetSystemLogResponse;	/* onvifgen/onvif.h:370 */
class _ns1__GetScopes;	/* onvifgen/onvif.h:373 */
class _ns1__GetScopesResponse;	/* onvifgen/onvif.h:376 */
class _ns1__SetScopes;	/* onvifgen/onvif.h:379 */
class _ns1__SetScopesResponse;	/* onvifgen/onvif.h:382 */
class _ns1__AddScopes;	/* onvifgen/onvif.h:385 */
class _ns1__AddScopesResponse;	/* onvifgen/onvif.h:388 */
class _ns1__RemoveScopes;	/* onvifgen/onvif.h:391 */
class _ns1__RemoveScopesResponse;	/* onvifgen/onvif.h:394 */
class _ns1__GetDiscoveryMode;	/* onvifgen/onvif.h:397 */
class _ns1__GetDiscoveryModeResponse;	/* onvifgen/onvif.h:400 */
class _ns1__SetDiscoveryMode;	/* onvifgen/onvif.h:403 */
class _ns1__SetDiscoveryModeResponse;	/* onvifgen/onvif.h:406 */
class _ns1__GetRemoteDiscoveryMode;	/* onvifgen/onvif.h:409 */
class _ns1__GetRemoteDiscoveryModeResponse;	/* onvifgen/onvif.h:412 */
class _ns1__SetRemoteDiscoveryMode;	/* onvifgen/onvif.h:415 */
class _ns1__SetRemoteDiscoveryModeResponse;	/* onvifgen/onvif.h:418 */
class _ns1__GetDPAddresses;	/* onvifgen/onvif.h:421 */
class _ns1__GetDPAddressesResponse;	/* onvifgen/onvif.h:424 */
class _ns1__SetDPAddresses;	/* onvifgen/onvif.h:427 */
class _ns1__SetDPAddressesResponse;	/* onvifgen/onvif.h:430 */
class _ns1__GetEndpointReference;	/* onvifgen/onvif.h:433 */
class _ns1__GetEndpointReferenceResponse;	/* onvifgen/onvif.h:436 */
class _ns1__GetRemoteUser;	/* onvifgen/onvif.h:439 */
class _ns1__GetRemoteUserResponse;	/* onvifgen/onvif.h:442 */
class _ns1__SetRemoteUser;	/* onvifgen/onvif.h:445 */
class _ns1__SetRemoteUserResponse;	/* onvifgen/onvif.h:448 */
class _ns1__GetUsers;	/* onvifgen/onvif.h:451 */
class _ns1__GetUsersResponse;	/* onvifgen/onvif.h:454 */
class _ns1__CreateUsers;	/* onvifgen/onvif.h:457 */
class _ns1__CreateUsersResponse;	/* onvifgen/onvif.h:460 */
class _ns1__DeleteUsers;	/* onvifgen/onvif.h:463 */
class _ns1__DeleteUsersResponse;	/* onvifgen/onvif.h:466 */
class _ns1__SetUser;	/* onvifgen/onvif.h:469 */
class _ns1__SetUserResponse;	/* onvifgen/onvif.h:472 */
class _ns1__GetWsdlUrl;	/* onvifgen/onvif.h:475 */
class _ns1__GetWsdlUrlResponse;	/* onvifgen/onvif.h:478 */
class _ns1__GetCapabilities;	/* onvifgen/onvif.h:481 */
class _ns1__GetCapabilitiesResponse;	/* onvifgen/onvif.h:484 */
class _ns1__GetHostname;	/* onvifgen/onvif.h:487 */
class _ns1__GetHostnameResponse;	/* onvifgen/onvif.h:490 */
class _ns1__SetHostname;	/* onvifgen/onvif.h:493 */
class _ns1__SetHostnameResponse;	/* onvifgen/onvif.h:496 */
class _ns1__SetHostnameFromDHCP;	/* onvifgen/onvif.h:499 */
class _ns1__SetHostnameFromDHCPResponse;	/* onvifgen/onvif.h:502 */
class _ns1__GetDNS;	/* onvifgen/onvif.h:505 */
class _ns1__GetDNSResponse;	/* onvifgen/onvif.h:508 */
class _ns1__SetDNS;	/* onvifgen/onvif.h:511 */
class _ns1__SetDNSResponse;	/* onvifgen/onvif.h:514 */
class _ns1__GetNTP;	/* onvifgen/onvif.h:517 */
class _ns1__GetNTPResponse;	/* onvifgen/onvif.h:520 */
class _ns1__SetNTP;	/* onvifgen/onvif.h:523 */
class _ns1__SetNTPResponse;	/* onvifgen/onvif.h:526 */
class _ns1__GetDynamicDNS;	/* onvifgen/onvif.h:529 */
class _ns1__GetDynamicDNSResponse;	/* onvifgen/onvif.h:532 */
class _ns1__SetDynamicDNS;	/* onvifgen/onvif.h:535 */
class _ns1__SetDynamicDNSResponse;	/* onvifgen/onvif.h:538 */
class _ns1__GetNetworkInterfaces;	/* onvifgen/onvif.h:541 */
class _ns1__GetNetworkInterfacesResponse;	/* onvifgen/onvif.h:544 */
class _ns1__SetNetworkInterfaces;	/* onvifgen/onvif.h:547 */
class _ns1__SetNetworkInterfacesResponse;	/* onvifgen/onvif.h:550 */
class _ns1__GetNetworkProtocols;	/* onvifgen/onvif.h:553 */
class _ns1__GetNetworkProtocolsResponse;	/* onvifgen/onvif.h:556 */
class _ns1__SetNetworkProtocols;	/* onvifgen/onvif.h:559 */
class _ns1__SetNetworkProtocolsResponse;	/* onvifgen/onvif.h:562 */
class _ns1__GetNetworkDefaultGateway;	/* onvifgen/onvif.h:565 */
class _ns1__GetNetworkDefaultGatewayResponse;	/* onvifgen/onvif.h:568 */
class _ns1__SetNetworkDefaultGateway;	/* onvifgen/onvif.h:571 */
class _ns1__SetNetworkDefaultGatewayResponse;	/* onvifgen/onvif.h:574 */
class _ns1__GetZeroConfiguration;	/* onvifgen/onvif.h:577 */
class _ns1__GetZeroConfigurationResponse;	/* onvifgen/onvif.h:580 */
class _ns1__SetZeroConfiguration;	/* onvifgen/onvif.h:583 */
class _ns1__SetZeroConfigurationResponse;	/* onvifgen/onvif.h:586 */
class _ns1__GetIPAddressFilter;	/* onvifgen/onvif.h:589 */
class _ns1__GetIPAddressFilterResponse;	/* onvifgen/onvif.h:592 */
class _ns1__SetIPAddressFilter;	/* onvifgen/onvif.h:595 */
class _ns1__SetIPAddressFilterResponse;	/* onvifgen/onvif.h:598 */
class _ns1__AddIPAddressFilter;	/* onvifgen/onvif.h:601 */
class _ns1__AddIPAddressFilterResponse;	/* onvifgen/onvif.h:604 */
class _ns1__RemoveIPAddressFilter;	/* onvifgen/onvif.h:607 */
class _ns1__RemoveIPAddressFilterResponse;	/* onvifgen/onvif.h:610 */
class _ns1__GetAccessPolicy;	/* onvifgen/onvif.h:613 */
class _ns1__GetAccessPolicyResponse;	/* onvifgen/onvif.h:616 */
class _ns1__SetAccessPolicy;	/* onvifgen/onvif.h:619 */
class _ns1__SetAccessPolicyResponse;	/* onvifgen/onvif.h:622 */
class _ns1__CreateCertificate;	/* onvifgen/onvif.h:625 */
class _ns1__CreateCertificateResponse;	/* onvifgen/onvif.h:628 */
class _ns1__GetCertificates;	/* onvifgen/onvif.h:631 */
class _ns1__GetCertificatesResponse;	/* onvifgen/onvif.h:634 */
class _ns1__GetCertificatesStatus;	/* onvifgen/onvif.h:637 */
class _ns1__GetCertificatesStatusResponse;	/* onvifgen/onvif.h:640 */
class _ns1__SetCertificatesStatus;	/* onvifgen/onvif.h:643 */
class _ns1__SetCertificatesStatusResponse;	/* onvifgen/onvif.h:646 */
class _ns1__DeleteCertificates;	/* onvifgen/onvif.h:649 */
class _ns1__DeleteCertificatesResponse;	/* onvifgen/onvif.h:652 */
class _ns1__GetPkcs10Request;	/* onvifgen/onvif.h:655 */
class _ns1__GetPkcs10RequestResponse;	/* onvifgen/onvif.h:658 */
class _ns1__LoadCertificates;	/* onvifgen/onvif.h:661 */
class _ns1__LoadCertificatesResponse;	/* onvifgen/onvif.h:664 */
class _ns1__GetClientCertificateMode;	/* onvifgen/onvif.h:667 */
class _ns1__GetClientCertificateModeResponse;	/* onvifgen/onvif.h:670 */
class _ns1__SetClientCertificateMode;	/* onvifgen/onvif.h:673 */
class _ns1__SetClientCertificateModeResponse;	/* onvifgen/onvif.h:676 */
class _ns1__GetCACertificates;	/* onvifgen/onvif.h:679 */
class _ns1__GetCACertificatesResponse;	/* onvifgen/onvif.h:682 */
class _ns1__LoadCertificateWithPrivateKey;	/* onvifgen/onvif.h:685 */
class _ns1__LoadCertificateWithPrivateKeyResponse;	/* onvifgen/onvif.h:688 */
class _ns1__GetCertificateInformation;	/* onvifgen/onvif.h:691 */
class _ns1__GetCertificateInformationResponse;	/* onvifgen/onvif.h:694 */
class _ns1__LoadCACertificates;	/* onvifgen/onvif.h:697 */
class _ns1__LoadCACertificatesResponse;	/* onvifgen/onvif.h:700 */
class _ns1__CreateDot1XConfiguration;	/* onvifgen/onvif.h:703 */
class _ns1__CreateDot1XConfigurationResponse;	/* onvifgen/onvif.h:706 */
class _ns1__SetDot1XConfiguration;	/* onvifgen/onvif.h:709 */
class _ns1__SetDot1XConfigurationResponse;	/* onvifgen/onvif.h:712 */
class _ns1__GetDot1XConfiguration;	/* onvifgen/onvif.h:715 */
class _ns1__GetDot1XConfigurationResponse;	/* onvifgen/onvif.h:718 */
class _ns1__GetDot1XConfigurations;	/* onvifgen/onvif.h:721 */
class _ns1__GetDot1XConfigurationsResponse;	/* onvifgen/onvif.h:724 */
class _ns1__DeleteDot1XConfiguration;	/* onvifgen/onvif.h:727 */
class _ns1__DeleteDot1XConfigurationResponse;	/* onvifgen/onvif.h:730 */
class _ns1__GetRelayOutputs;	/* onvifgen/onvif.h:733 */
class _ns1__GetRelayOutputsResponse;	/* onvifgen/onvif.h:736 */
class _ns1__SetRelayOutputSettings;	/* onvifgen/onvif.h:739 */
class _ns1__SetRelayOutputSettingsResponse;	/* onvifgen/onvif.h:742 */
class _ns1__SetRelayOutputState;	/* onvifgen/onvif.h:745 */
class _ns1__SetRelayOutputStateResponse;	/* onvifgen/onvif.h:748 */
class _ns1__SendAuxiliaryCommand;	/* onvifgen/onvif.h:751 */
class _ns1__SendAuxiliaryCommandResponse;	/* onvifgen/onvif.h:754 */
class _ns1__GetDot11Capabilities;	/* onvifgen/onvif.h:757 */
class _ns1__GetDot11CapabilitiesResponse;	/* onvifgen/onvif.h:760 */
class _ns1__GetDot11Status;	/* onvifgen/onvif.h:763 */
class _ns1__GetDot11StatusResponse;	/* onvifgen/onvif.h:766 */
class _ns1__ScanAvailableDot11Networks;	/* onvifgen/onvif.h:769 */
class _ns1__ScanAvailableDot11NetworksResponse;	/* onvifgen/onvif.h:772 */
class _ns1__GetSystemUris;	/* onvifgen/onvif.h:775 */
class _ns1__GetSystemUrisResponse_Extension;	/* onvifgen/onvif.h:8994 */
class _ns1__GetSystemUrisResponse;	/* onvifgen/onvif.h:778 */
class _ns1__StartFirmwareUpgrade;	/* onvifgen/onvif.h:781 */
class _ns1__StartFirmwareUpgradeResponse;	/* onvifgen/onvif.h:784 */
class _ns1__StartSystemRestore;	/* onvifgen/onvif.h:787 */
class _ns1__StartSystemRestoreResponse;	/* onvifgen/onvif.h:790 */
class _ns1__GetStorageConfigurations;	/* onvifgen/onvif.h:793 */
class _ns1__GetStorageConfigurationsResponse;	/* onvifgen/onvif.h:796 */
class _ns1__CreateStorageConfiguration;	/* onvifgen/onvif.h:799 */
class _ns1__CreateStorageConfigurationResponse;	/* onvifgen/onvif.h:802 */
class _ns1__GetStorageConfiguration;	/* onvifgen/onvif.h:805 */
class _ns1__GetStorageConfigurationResponse;	/* onvifgen/onvif.h:808 */
class _ns1__SetStorageConfiguration;	/* onvifgen/onvif.h:811 */
class _ns1__SetStorageConfigurationResponse;	/* onvifgen/onvif.h:814 */
class _ns1__DeleteStorageConfiguration;	/* onvifgen/onvif.h:817 */
class _ns1__DeleteStorageConfigurationResponse;	/* onvifgen/onvif.h:820 */
class ns2__DeviceEntity;	/* onvifgen/onvif.h:823 */
class ns2__IntRectangle;	/* onvifgen/onvif.h:826 */
class ns2__IntRectangleRange;	/* onvifgen/onvif.h:829 */
class ns2__IntRange;	/* onvifgen/onvif.h:832 */
class ns2__FloatRange;	/* onvifgen/onvif.h:835 */
class ns2__DurationRange;	/* onvifgen/onvif.h:838 */
class ns2__IntList;	/* onvifgen/onvif.h:841 */
class ns2__FloatList;	/* onvifgen/onvif.h:844 */
class ns2__AnyHolder;	/* onvifgen/onvif.h:847 */
class ns2__VideoSourceExtension;	/* onvifgen/onvif.h:853 */
class ns2__VideoSourceExtension2;	/* onvifgen/onvif.h:856 */
class ns2__Profile;	/* onvifgen/onvif.h:862 */
class ns2__ProfileExtension;	/* onvifgen/onvif.h:865 */
class ns2__ProfileExtension2;	/* onvifgen/onvif.h:868 */
class ns2__ConfigurationEntity;	/* onvifgen/onvif.h:871 */
class ns2__VideoSourceConfigurationExtension;	/* onvifgen/onvif.h:877 */
class ns2__VideoSourceConfigurationExtension2;	/* onvifgen/onvif.h:880 */
class ns2__Rotate;	/* onvifgen/onvif.h:883 */
class ns2__RotateExtension;	/* onvifgen/onvif.h:886 */
class ns2__LensProjection;	/* onvifgen/onvif.h:889 */
class ns2__LensOffset;	/* onvifgen/onvif.h:892 */
class ns2__LensDescription;	/* onvifgen/onvif.h:895 */
class ns2__VideoSourceConfigurationOptions;	/* onvifgen/onvif.h:898 */
class ns2__VideoSourceConfigurationOptionsExtension;	/* onvifgen/onvif.h:901 */
class ns2__VideoSourceConfigurationOptionsExtension2;	/* onvifgen/onvif.h:904 */
class ns2__RotateOptions;	/* onvifgen/onvif.h:907 */
class ns2__RotateOptionsExtension;	/* onvifgen/onvif.h:910 */
class ns2__VideoResolution;	/* onvifgen/onvif.h:916 */
class ns2__VideoRateControl;	/* onvifgen/onvif.h:919 */
class ns2__Mpeg4Configuration;	/* onvifgen/onvif.h:922 */
class ns2__H264Configuration;	/* onvifgen/onvif.h:925 */
class ns2__VideoEncoderConfigurationOptions;	/* onvifgen/onvif.h:928 */
class ns2__VideoEncoderOptionsExtension;	/* onvifgen/onvif.h:931 */
class ns2__VideoEncoderOptionsExtension2;	/* onvifgen/onvif.h:934 */
class ns2__JpegOptions;	/* onvifgen/onvif.h:937 */
class ns2__Mpeg4Options;	/* onvifgen/onvif.h:943 */
class ns2__H264Options;	/* onvifgen/onvif.h:949 */
class ns2__VideoResolution2;	/* onvifgen/onvif.h:958 */
class ns2__VideoRateControl2;	/* onvifgen/onvif.h:961 */
class ns2__VideoEncoder2ConfigurationOptions;	/* onvifgen/onvif.h:964 */
class ns2__AudioSourceConfigurationOptions;	/* onvifgen/onvif.h:970 */
class ns2__AudioSourceOptionsExtension;	/* onvifgen/onvif.h:973 */
class ns2__AudioEncoderConfigurationOptions;	/* onvifgen/onvif.h:979 */
class ns2__AudioEncoderConfigurationOption;	/* onvifgen/onvif.h:982 */
class ns2__AudioEncoder2ConfigurationOptions;	/* onvifgen/onvif.h:988 */
class ns2__MetadataConfigurationExtension;	/* onvifgen/onvif.h:997 */
class ns2__PTZFilter;	/* onvifgen/onvif.h:1000 */
class _ns2__EventSubscription_SubscriptionPolicy;	/* onvifgen/onvif.h:10984 */
class ns2__EventSubscription;	/* onvifgen/onvif.h:1003 */
class ns2__MetadataConfigurationOptions;	/* onvifgen/onvif.h:1006 */
class ns2__MetadataConfigurationOptionsExtension;	/* onvifgen/onvif.h:1009 */
class ns2__MetadataConfigurationOptionsExtension2;	/* onvifgen/onvif.h:1012 */
class ns2__PTZStatusFilterOptions;	/* onvifgen/onvif.h:1015 */
class ns2__PTZStatusFilterOptionsExtension;	/* onvifgen/onvif.h:1018 */
class ns2__VideoOutputExtension;	/* onvifgen/onvif.h:1024 */
class ns2__VideoOutputConfigurationOptions;	/* onvifgen/onvif.h:1030 */
class ns2__VideoDecoderConfigurationOptions;	/* onvifgen/onvif.h:1033 */
class ns2__H264DecOptions;	/* onvifgen/onvif.h:1036 */
class ns2__JpegDecOptions;	/* onvifgen/onvif.h:1039 */
class ns2__Mpeg4DecOptions;	/* onvifgen/onvif.h:1042 */
class ns2__VideoDecoderConfigurationOptionsExtension;	/* onvifgen/onvif.h:1045 */
class ns2__AudioOutputConfigurationOptions;	/* onvifgen/onvif.h:1054 */
class ns2__AudioDecoderConfigurationOptions;	/* onvifgen/onvif.h:1060 */
class ns2__G711DecOptions;	/* onvifgen/onvif.h:1063 */
class ns2__AACDecOptions;	/* onvifgen/onvif.h:1066 */
class ns2__G726DecOptions;	/* onvifgen/onvif.h:1069 */
class ns2__AudioDecoderConfigurationOptionsExtension;	/* onvifgen/onvif.h:1072 */
class ns2__MulticastConfiguration;	/* onvifgen/onvif.h:1075 */
class ns2__StreamSetup;	/* onvifgen/onvif.h:1078 */
class ns2__Transport;	/* onvifgen/onvif.h:1081 */
class ns2__MediaUri;	/* onvifgen/onvif.h:1084 */
class ns2__Scope;	/* onvifgen/onvif.h:1087 */
class ns2__NetworkInterfaceExtension;	/* onvifgen/onvif.h:1093 */
class ns2__Dot3Configuration;	/* onvifgen/onvif.h:1096 */
class ns2__NetworkInterfaceExtension2;	/* onvifgen/onvif.h:1099 */
class ns2__NetworkInterfaceLink;	/* onvifgen/onvif.h:1102 */
class ns2__NetworkInterfaceConnectionSetting;	/* onvifgen/onvif.h:1105 */
class ns2__NetworkInterfaceInfo;	/* onvifgen/onvif.h:1108 */
class ns2__IPv6NetworkInterface;	/* onvifgen/onvif.h:1111 */
class ns2__IPv4NetworkInterface;	/* onvifgen/onvif.h:1114 */
class ns2__IPv4Configuration;	/* onvifgen/onvif.h:1117 */
class ns2__IPv6Configuration;	/* onvifgen/onvif.h:1120 */
class ns2__IPv6ConfigurationExtension;	/* onvifgen/onvif.h:1123 */
class ns2__NetworkProtocol;	/* onvifgen/onvif.h:1126 */
class ns2__NetworkProtocolExtension;	/* onvifgen/onvif.h:1129 */
class ns2__NetworkHost;	/* onvifgen/onvif.h:1132 */
class ns2__NetworkHostExtension;	/* onvifgen/onvif.h:1135 */
class ns2__IPAddress;	/* onvifgen/onvif.h:1138 */
class ns2__PrefixedIPv4Address;	/* onvifgen/onvif.h:1141 */
class ns2__PrefixedIPv6Address;	/* onvifgen/onvif.h:1144 */
class ns2__HostnameInformation;	/* onvifgen/onvif.h:1147 */
class ns2__HostnameInformationExtension;	/* onvifgen/onvif.h:1150 */
class ns2__DNSInformation;	/* onvifgen/onvif.h:1153 */
class ns2__DNSInformationExtension;	/* onvifgen/onvif.h:1156 */
class ns2__NTPInformation;	/* onvifgen/onvif.h:1159 */
class ns2__NTPInformationExtension;	/* onvifgen/onvif.h:1162 */
class ns2__DynamicDNSInformation;	/* onvifgen/onvif.h:1165 */
class ns2__DynamicDNSInformationExtension;	/* onvifgen/onvif.h:1168 */
class ns2__NetworkInterfaceSetConfiguration;	/* onvifgen/onvif.h:1171 */
class ns2__NetworkInterfaceSetConfigurationExtension;	/* onvifgen/onvif.h:1174 */
class ns2__IPv6NetworkInterfaceSetConfiguration;	/* onvifgen/onvif.h:1177 */
class ns2__IPv4NetworkInterfaceSetConfiguration;	/* onvifgen/onvif.h:1180 */
class ns2__NetworkGateway;	/* onvifgen/onvif.h:1183 */
class ns2__NetworkZeroConfiguration;	/* onvifgen/onvif.h:1186 */
class ns2__NetworkZeroConfigurationExtension;	/* onvifgen/onvif.h:1189 */
class ns2__NetworkZeroConfigurationExtension2;	/* onvifgen/onvif.h:1192 */
class ns2__IPAddressFilter;	/* onvifgen/onvif.h:1195 */
class ns2__IPAddressFilterExtension;	/* onvifgen/onvif.h:1198 */
class ns2__Dot11Configuration;	/* onvifgen/onvif.h:1201 */
class ns2__Dot11SecurityConfiguration;	/* onvifgen/onvif.h:1204 */
class ns2__Dot11SecurityConfigurationExtension;	/* onvifgen/onvif.h:1207 */
class ns2__Dot11PSKSet;	/* onvifgen/onvif.h:1210 */
class ns2__Dot11PSKSetExtension;	/* onvifgen/onvif.h:1213 */
class ns2__NetworkInterfaceSetConfigurationExtension2;	/* onvifgen/onvif.h:1216 */
class ns2__Dot11Capabilities;	/* onvifgen/onvif.h:1219 */
class ns2__Dot11Status;	/* onvifgen/onvif.h:1222 */
class ns2__Dot11AvailableNetworks;	/* onvifgen/onvif.h:1225 */
class ns2__Dot11AvailableNetworksExtension;	/* onvifgen/onvif.h:1228 */
class ns2__Capabilities;	/* onvifgen/onvif.h:1231 */
class ns2__CapabilitiesExtension;	/* onvifgen/onvif.h:1234 */
class ns2__CapabilitiesExtension2;	/* onvifgen/onvif.h:1237 */
class ns2__AnalyticsCapabilities;	/* onvifgen/onvif.h:1240 */
class ns2__DeviceCapabilities;	/* onvifgen/onvif.h:1243 */
class ns2__DeviceCapabilitiesExtension;	/* onvifgen/onvif.h:1246 */
class ns2__EventCapabilities;	/* onvifgen/onvif.h:1249 */
class ns2__IOCapabilities;	/* onvifgen/onvif.h:1252 */
class ns2__IOCapabilitiesExtension;	/* onvifgen/onvif.h:1255 */
class ns2__IOCapabilitiesExtension2;	/* onvifgen/onvif.h:1258 */
class ns2__MediaCapabilities;	/* onvifgen/onvif.h:1261 */
class ns2__MediaCapabilitiesExtension;	/* onvifgen/onvif.h:1264 */
class ns2__RealTimeStreamingCapabilities;	/* onvifgen/onvif.h:1267 */
class ns2__RealTimeStreamingCapabilitiesExtension;	/* onvifgen/onvif.h:1270 */
class ns2__ProfileCapabilities;	/* onvifgen/onvif.h:1273 */
class ns2__NetworkCapabilities;	/* onvifgen/onvif.h:1276 */
class ns2__NetworkCapabilitiesExtension;	/* onvifgen/onvif.h:1279 */
class ns2__NetworkCapabilitiesExtension2;	/* onvifgen/onvif.h:1282 */
class ns2__SecurityCapabilities;	/* onvifgen/onvif.h:1285 */
class ns2__SecurityCapabilitiesExtension;	/* onvifgen/onvif.h:1288 */
class ns2__SecurityCapabilitiesExtension2;	/* onvifgen/onvif.h:1291 */
class ns2__SystemCapabilities;	/* onvifgen/onvif.h:1294 */
class ns2__SystemCapabilitiesExtension;	/* onvifgen/onvif.h:1297 */
class ns2__SystemCapabilitiesExtension2;	/* onvifgen/onvif.h:1300 */
class ns2__OnvifVersion;	/* onvifgen/onvif.h:1303 */
class ns2__ImagingCapabilities;	/* onvifgen/onvif.h:1306 */
class ns2__PTZCapabilities;	/* onvifgen/onvif.h:1309 */
class ns2__DeviceIOCapabilities;	/* onvifgen/onvif.h:1312 */
class ns2__DisplayCapabilities;	/* onvifgen/onvif.h:1315 */
class ns2__RecordingCapabilities;	/* onvifgen/onvif.h:1318 */
class ns2__SearchCapabilities;	/* onvifgen/onvif.h:1321 */
class ns2__ReplayCapabilities;	/* onvifgen/onvif.h:1324 */
class ns2__ReceiverCapabilities;	/* onvifgen/onvif.h:1327 */
class ns2__AnalyticsDeviceCapabilities;	/* onvifgen/onvif.h:1330 */
class ns2__AnalyticsDeviceExtension;	/* onvifgen/onvif.h:1333 */
class ns2__SystemLog;	/* onvifgen/onvif.h:1336 */
class ns2__SupportInformation;	/* onvifgen/onvif.h:1339 */
class ns2__BinaryData;	/* onvifgen/onvif.h:1342 */
class ns2__AttachmentData;	/* onvifgen/onvif.h:1345 */
class ns2__BackupFile;	/* onvifgen/onvif.h:1348 */
class ns2__SystemLogUriList;	/* onvifgen/onvif.h:1351 */
class ns2__SystemLogUri;	/* onvifgen/onvif.h:1354 */
class ns2__SystemDateTime;	/* onvifgen/onvif.h:1357 */
class ns2__SystemDateTimeExtension;	/* onvifgen/onvif.h:1360 */
class ns2__DateTime;	/* onvifgen/onvif.h:1363 */
class ns2__Date;	/* onvifgen/onvif.h:1366 */
class ns2__Time;	/* onvifgen/onvif.h:1369 */
class ns2__TimeZone;	/* onvifgen/onvif.h:1372 */
class ns2__RemoteUser;	/* onvifgen/onvif.h:1375 */
class ns2__User;	/* onvifgen/onvif.h:1378 */
class ns2__UserExtension;	/* onvifgen/onvif.h:1381 */
class ns2__CertificateGenerationParameters;	/* onvifgen/onvif.h:1384 */
class ns2__CertificateGenerationParametersExtension;	/* onvifgen/onvif.h:1387 */
class ns2__Certificate;	/* onvifgen/onvif.h:1390 */
class ns2__CertificateStatus;	/* onvifgen/onvif.h:1393 */
class ns2__CertificateWithPrivateKey;	/* onvifgen/onvif.h:1396 */
class ns2__CertificateInformation;	/* onvifgen/onvif.h:1399 */
class ns2__CertificateInformationExtension;	/* onvifgen/onvif.h:1405 */
class ns2__Dot1XConfiguration;	/* onvifgen/onvif.h:1408 */
class ns2__Dot1XConfigurationExtension;	/* onvifgen/onvif.h:1411 */
class ns2__EAPMethodConfiguration;	/* onvifgen/onvif.h:1414 */
class ns2__EapMethodExtension;	/* onvifgen/onvif.h:1417 */
class ns2__TLSConfiguration;	/* onvifgen/onvif.h:1420 */
class ns2__GenericEapPwdConfigurationExtension;	/* onvifgen/onvif.h:1423 */
class ns2__RelayOutputSettings;	/* onvifgen/onvif.h:1426 */
class ns2__PTZNodeExtension;	/* onvifgen/onvif.h:1438 */
class ns2__PTZNodeExtension2;	/* onvifgen/onvif.h:1441 */
class ns2__PTZPresetTourSupported;	/* onvifgen/onvif.h:1444 */
class ns2__PTZPresetTourSupportedExtension;	/* onvifgen/onvif.h:1447 */
class ns2__PTZConfigurationExtension;	/* onvifgen/onvif.h:1453 */
class ns2__PTZConfigurationExtension2;	/* onvifgen/onvif.h:1456 */
class ns2__PTControlDirection;	/* onvifgen/onvif.h:1459 */
class ns2__PTControlDirectionExtension;	/* onvifgen/onvif.h:1462 */
class ns2__EFlip;	/* onvifgen/onvif.h:1465 */
class ns2__Reverse;	/* onvifgen/onvif.h:1468 */
class ns2__PTZConfigurationOptions;	/* onvifgen/onvif.h:1471 */
class ns2__PTZConfigurationOptions2;	/* onvifgen/onvif.h:1474 */
class ns2__PTControlDirectionOptions;	/* onvifgen/onvif.h:1477 */
class ns2__PTControlDirectionOptionsExtension;	/* onvifgen/onvif.h:1480 */
class ns2__EFlipOptions;	/* onvifgen/onvif.h:1483 */
class ns2__EFlipOptionsExtension;	/* onvifgen/onvif.h:1486 */
class ns2__ReverseOptions;	/* onvifgen/onvif.h:1489 */
class ns2__ReverseOptionsExtension;	/* onvifgen/onvif.h:1492 */
class ns2__PanTiltLimits;	/* onvifgen/onvif.h:1495 */
class ns2__ZoomLimits;	/* onvifgen/onvif.h:1498 */
class ns2__PTZSpaces;	/* onvifgen/onvif.h:1501 */
class ns2__PTZSpacesExtension;	/* onvifgen/onvif.h:1504 */
class ns2__Space2DDescription;	/* onvifgen/onvif.h:1507 */
class ns2__Space1DDescription;	/* onvifgen/onvif.h:1510 */
class ns2__Vector2D;	/* onvifgen/onvif.h:1513 */
class ns2__Vector1D;	/* onvifgen/onvif.h:1516 */
class ns2__PTZVector;	/* onvifgen/onvif.h:1519 */
class ns2__PTZSpeed;	/* onvifgen/onvif.h:1522 */
class ns2__PTZStatus;	/* onvifgen/onvif.h:1525 */
class ns2__PTZPreset;	/* onvifgen/onvif.h:1528 */
class ns2__PTZMoveStatus;	/* onvifgen/onvif.h:1531 */
class ns2__PresetTour;	/* onvifgen/onvif.h:1534 */
class ns2__PTZPresetTourExtension;	/* onvifgen/onvif.h:1537 */
class ns2__PTZPresetTourSpot;	/* onvifgen/onvif.h:1540 */
class ns2__PTZPresetTourSpotExtension;	/* onvifgen/onvif.h:1543 */
union _ns2__union_PTZPresetTourPresetDetail;	/* onvifgen/onvif.h:16992 */
class ns2__PTZPresetTourPresetDetail;	/* onvifgen/onvif.h:1546 */
class ns2__PTZPresetTourTypeExtension;	/* onvifgen/onvif.h:1549 */
class ns2__PTZPresetTourStatus;	/* onvifgen/onvif.h:1552 */
class ns2__PTZPresetTourStatusExtension;	/* onvifgen/onvif.h:1555 */
class ns2__PTZPresetTourStartingCondition;	/* onvifgen/onvif.h:1558 */
class ns2__PTZPresetTourStartingConditionExtension;	/* onvifgen/onvif.h:1561 */
class ns2__PTZPresetTourOptions;	/* onvifgen/onvif.h:1564 */
class ns2__PTZPresetTourSpotOptions;	/* onvifgen/onvif.h:1567 */
class ns2__PTZPresetTourPresetDetailOptions;	/* onvifgen/onvif.h:1570 */
class ns2__PTZPresetTourPresetDetailOptionsExtension;	/* onvifgen/onvif.h:1573 */
class ns2__PTZPresetTourStartingConditionOptions;	/* onvifgen/onvif.h:1576 */
class ns2__PTZPresetTourStartingConditionOptionsExtension;	/* onvifgen/onvif.h:1579 */
class ns2__ImagingStatus;	/* onvifgen/onvif.h:1582 */
class ns2__FocusStatus;	/* onvifgen/onvif.h:1585 */
class ns2__FocusConfiguration;	/* onvifgen/onvif.h:1588 */
class ns2__ImagingSettings;	/* onvifgen/onvif.h:1591 */
class ns2__ImagingSettingsExtension;	/* onvifgen/onvif.h:1594 */
class ns2__Exposure;	/* onvifgen/onvif.h:1597 */
class ns2__WideDynamicRange;	/* onvifgen/onvif.h:1600 */
class ns2__BacklightCompensation;	/* onvifgen/onvif.h:1603 */
class ns2__ImagingOptions;	/* onvifgen/onvif.h:1606 */
class ns2__WideDynamicRangeOptions;	/* onvifgen/onvif.h:1609 */
class ns2__BacklightCompensationOptions;	/* onvifgen/onvif.h:1612 */
class ns2__FocusOptions;	/* onvifgen/onvif.h:1615 */
class ns2__ExposureOptions;	/* onvifgen/onvif.h:1618 */
class ns2__WhiteBalanceOptions;	/* onvifgen/onvif.h:1621 */
class ns2__FocusMove;	/* onvifgen/onvif.h:1624 */
class ns2__AbsoluteFocus;	/* onvifgen/onvif.h:1627 */
class ns2__RelativeFocus;	/* onvifgen/onvif.h:1630 */
class ns2__ContinuousFocus;	/* onvifgen/onvif.h:1633 */
class ns2__MoveOptions;	/* onvifgen/onvif.h:1636 */
class ns2__AbsoluteFocusOptions;	/* onvifgen/onvif.h:1639 */
class ns2__RelativeFocusOptions;	/* onvifgen/onvif.h:1642 */
class ns2__ContinuousFocusOptions;	/* onvifgen/onvif.h:1645 */
class ns2__WhiteBalance;	/* onvifgen/onvif.h:1648 */
class ns2__ImagingStatus20;	/* onvifgen/onvif.h:1651 */
class ns2__ImagingStatus20Extension;	/* onvifgen/onvif.h:1654 */
class ns2__FocusStatus20;	/* onvifgen/onvif.h:1657 */
class ns2__FocusStatus20Extension;	/* onvifgen/onvif.h:1660 */
class ns2__ImagingSettings20;	/* onvifgen/onvif.h:1663 */
class ns2__ImagingSettingsExtension20;	/* onvifgen/onvif.h:1666 */
class ns2__ImagingSettingsExtension202;	/* onvifgen/onvif.h:1669 */
class ns2__ImagingSettingsExtension203;	/* onvifgen/onvif.h:1672 */
class ns2__ImagingSettingsExtension204;	/* onvifgen/onvif.h:1675 */
class ns2__ImageStabilization;	/* onvifgen/onvif.h:1678 */
class ns2__ImageStabilizationExtension;	/* onvifgen/onvif.h:1681 */
class ns2__IrCutFilterAutoAdjustment;	/* onvifgen/onvif.h:1684 */
class ns2__IrCutFilterAutoAdjustmentExtension;	/* onvifgen/onvif.h:1687 */
class ns2__WideDynamicRange20;	/* onvifgen/onvif.h:1690 */
class ns2__BacklightCompensation20;	/* onvifgen/onvif.h:1693 */
class ns2__Exposure20;	/* onvifgen/onvif.h:1696 */
class ns2__ToneCompensation;	/* onvifgen/onvif.h:1699 */
class ns2__ToneCompensationExtension;	/* onvifgen/onvif.h:1702 */
class ns2__Defogging;	/* onvifgen/onvif.h:1705 */
class ns2__DefoggingExtension;	/* onvifgen/onvif.h:1708 */
class ns2__NoiseReduction;	/* onvifgen/onvif.h:1711 */
class ns2__ImagingOptions20;	/* onvifgen/onvif.h:1714 */
class ns2__ImagingOptions20Extension;	/* onvifgen/onvif.h:1717 */
class ns2__ImagingOptions20Extension2;	/* onvifgen/onvif.h:1720 */
class ns2__ImagingOptions20Extension3;	/* onvifgen/onvif.h:1723 */
class ns2__ImagingOptions20Extension4;	/* onvifgen/onvif.h:1726 */
class ns2__ImageStabilizationOptions;	/* onvifgen/onvif.h:1729 */
class ns2__ImageStabilizationOptionsExtension;	/* onvifgen/onvif.h:1732 */
class ns2__IrCutFilterAutoAdjustmentOptions;	/* onvifgen/onvif.h:1735 */
class ns2__IrCutFilterAutoAdjustmentOptionsExtension;	/* onvifgen/onvif.h:1738 */
class ns2__WideDynamicRangeOptions20;	/* onvifgen/onvif.h:1741 */
class ns2__BacklightCompensationOptions20;	/* onvifgen/onvif.h:1744 */
class ns2__ExposureOptions20;	/* onvifgen/onvif.h:1747 */
class ns2__MoveOptions20;	/* onvifgen/onvif.h:1750 */
class ns2__RelativeFocusOptions20;	/* onvifgen/onvif.h:1753 */
class ns2__WhiteBalance20;	/* onvifgen/onvif.h:1756 */
class ns2__WhiteBalance20Extension;	/* onvifgen/onvif.h:1759 */
class ns2__FocusConfiguration20;	/* onvifgen/onvif.h:1762 */
class ns2__FocusConfiguration20Extension;	/* onvifgen/onvif.h:1765 */
class ns2__WhiteBalanceOptions20;	/* onvifgen/onvif.h:1768 */
class ns2__WhiteBalanceOptions20Extension;	/* onvifgen/onvif.h:1771 */
class ns2__FocusOptions20;	/* onvifgen/onvif.h:1774 */
class ns2__FocusOptions20Extension;	/* onvifgen/onvif.h:1777 */
class ns2__ToneCompensationOptions;	/* onvifgen/onvif.h:1780 */
class ns2__DefoggingOptions;	/* onvifgen/onvif.h:1783 */
class ns2__NoiseReductionOptions;	/* onvifgen/onvif.h:1786 */
class ns2__MessageExtension;	/* onvifgen/onvif.h:1789 */
class _ns2__ItemList_SimpleItem;	/* onvifgen/onvif.h:19937 */
class _ns2__ItemList_ElementItem;	/* onvifgen/onvif.h:19965 */
class ns2__ItemList;	/* onvifgen/onvif.h:1792 */
class ns2__ItemListExtension;	/* onvifgen/onvif.h:1795 */
class ns2__MessageDescription;	/* onvifgen/onvif.h:1798 */
class ns2__MessageDescriptionExtension;	/* onvifgen/onvif.h:1801 */
class _ns2__ItemListDescription_SimpleItemDescription;	/* onvifgen/onvif.h:20128 */
class _ns2__ItemListDescription_ElementItemDescription;	/* onvifgen/onvif.h:20153 */
class ns2__ItemListDescription;	/* onvifgen/onvif.h:1804 */
class ns2__ItemListDescriptionExtension;	/* onvifgen/onvif.h:1807 */
class ns2__Vector;	/* onvifgen/onvif.h:1810 */
class ns2__Rectangle;	/* onvifgen/onvif.h:1813 */
class ns2__Polygon;	/* onvifgen/onvif.h:1816 */
class ns2__Polyline;	/* onvifgen/onvif.h:1819 */
class ns2__Color;	/* onvifgen/onvif.h:1822 */
class ns2__ColorCovariance;	/* onvifgen/onvif.h:1825 */
class ns2__Appearance;	/* onvifgen/onvif.h:1828 */
class ns2__AppearanceExtension;	/* onvifgen/onvif.h:1831 */
class ns2__ShapeDescriptor;	/* onvifgen/onvif.h:1834 */
class ns2__ShapeDescriptorExtension;	/* onvifgen/onvif.h:1837 */
class _ns2__ColorDescriptor_ColorCluster;	/* onvifgen/onvif.h:20494 */
class ns2__ColorDescriptor;	/* onvifgen/onvif.h:1840 */
class ns2__ColorDescriptorExtension;	/* onvifgen/onvif.h:1843 */
class _ns2__ClassDescriptor_ClassCandidate;	/* onvifgen/onvif.h:20567 */
class ns2__ClassDescriptor;	/* onvifgen/onvif.h:1846 */
class ns2__ClassDescriptorExtension;	/* onvifgen/onvif.h:1849 */
class ns2__ClassDescriptorExtension2;	/* onvifgen/onvif.h:1852 */
class ns2__OtherType;	/* onvifgen/onvif.h:1855 */
class ns2__ObjectExtension;	/* onvifgen/onvif.h:1861 */
class ns2__Transformation;	/* onvifgen/onvif.h:1864 */
class ns2__TransformationExtension;	/* onvifgen/onvif.h:1867 */
class ns2__Frame;	/* onvifgen/onvif.h:1870 */
class ns2__FrameExtension;	/* onvifgen/onvif.h:1873 */
class ns2__FrameExtension2;	/* onvifgen/onvif.h:1876 */
class ns2__Merge;	/* onvifgen/onvif.h:1879 */
class ns2__Split;	/* onvifgen/onvif.h:1882 */
class ns2__Rename;	/* onvifgen/onvif.h:1885 */
class ns2__ObjectId;	/* onvifgen/onvif.h:1888 */
class _ns2__Behaviour_Removed;	/* onvifgen/onvif.h:20968 */
class _ns2__Behaviour_Idle;	/* onvifgen/onvif.h:20989 */
class ns2__Behaviour;	/* onvifgen/onvif.h:1891 */
class ns2__BehaviourExtension;	/* onvifgen/onvif.h:1894 */
class ns2__ObjectTree;	/* onvifgen/onvif.h:1897 */
class ns2__ObjectTreeExtension;	/* onvifgen/onvif.h:1900 */
class ns2__MotionInCells;	/* onvifgen/onvif.h:1903 */
class ns2__AnalyticsEngineConfiguration;	/* onvifgen/onvif.h:1906 */
class ns2__AnalyticsEngineConfigurationExtension;	/* onvifgen/onvif.h:1909 */
class ns2__RuleEngineConfiguration;	/* onvifgen/onvif.h:1912 */
class ns2__RuleEngineConfigurationExtension;	/* onvifgen/onvif.h:1915 */
class ns2__Config;	/* onvifgen/onvif.h:1918 */
class _ns2__ConfigDescription_Messages;	/* onvifgen/onvif.h:21325 */
class ns2__ConfigDescription;	/* onvifgen/onvif.h:1921 */
class ns2__ConfigDescriptionExtension;	/* onvifgen/onvif.h:1924 */
class ns2__SupportedRules;	/* onvifgen/onvif.h:1927 */
class ns2__SupportedRulesExtension;	/* onvifgen/onvif.h:1930 */
class ns2__SupportedAnalyticsModules;	/* onvifgen/onvif.h:1933 */
class ns2__SupportedAnalyticsModulesExtension;	/* onvifgen/onvif.h:1936 */
class ns2__PolygonConfiguration;	/* onvifgen/onvif.h:1939 */
class ns2__PolylineArray;	/* onvifgen/onvif.h:1942 */
class ns2__PolylineArrayExtension;	/* onvifgen/onvif.h:1945 */
class ns2__PolylineArrayConfiguration;	/* onvifgen/onvif.h:1948 */
class ns2__MotionExpression;	/* onvifgen/onvif.h:1951 */
class ns2__MotionExpressionConfiguration;	/* onvifgen/onvif.h:1954 */
class ns2__CellLayout;	/* onvifgen/onvif.h:1957 */
union _ns2__union_MetadataStream;	/* onvifgen/onvif.h:21820 */
class __ns2__union_MetadataStream;	/* onvifgen/onvif.h:21807 */
class ns2__MetadataStream;	/* onvifgen/onvif.h:1960 */
class ns2__MetadataStreamExtension;	/* onvifgen/onvif.h:1963 */
class ns2__MetadataStreamExtension2;	/* onvifgen/onvif.h:1966 */
class ns2__AudioAnalyticsStream;	/* onvifgen/onvif.h:1969 */
class ns2__AudioDescriptor;	/* onvifgen/onvif.h:1972 */
class ns2__AudioAnalyticsStreamExtension;	/* onvifgen/onvif.h:1975 */
union _ns2__union_VideoAnalyticsStream;	/* onvifgen/onvif.h:22015 */
class __ns2__union_VideoAnalyticsStream;	/* onvifgen/onvif.h:22005 */
class ns2__VideoAnalyticsStream;	/* onvifgen/onvif.h:1978 */
class ns2__VideoAnalyticsStreamExtension;	/* onvifgen/onvif.h:1981 */
union _ns2__union_PTZStream;	/* onvifgen/onvif.h:22074 */
class __ns2__union_PTZStream;	/* onvifgen/onvif.h:22064 */
class ns2__PTZStream;	/* onvifgen/onvif.h:1984 */
class ns2__PTZStreamExtension;	/* onvifgen/onvif.h:1987 */
union _ns2__union_EventStream;	/* onvifgen/onvif.h:22133 */
class __ns2__union_EventStream;	/* onvifgen/onvif.h:22123 */
class ns2__EventStream;	/* onvifgen/onvif.h:1990 */
class ns2__EventStreamExtension;	/* onvifgen/onvif.h:1993 */
class ns2__PaneConfiguration;	/* onvifgen/onvif.h:1996 */
class ns2__PaneLayout;	/* onvifgen/onvif.h:1999 */
class ns2__Layout;	/* onvifgen/onvif.h:2002 */
class ns2__LayoutExtension;	/* onvifgen/onvif.h:2005 */
class ns2__CodingCapabilities;	/* onvifgen/onvif.h:2008 */
class ns2__LayoutOptions;	/* onvifgen/onvif.h:2011 */
class ns2__LayoutOptionsExtension;	/* onvifgen/onvif.h:2014 */
class ns2__PaneLayoutOptions;	/* onvifgen/onvif.h:2017 */
class ns2__PaneOptionExtension;	/* onvifgen/onvif.h:2020 */
class ns2__Receiver;	/* onvifgen/onvif.h:2023 */
class ns2__ReceiverConfiguration;	/* onvifgen/onvif.h:2026 */
class ns2__ReceiverStateInformation;	/* onvifgen/onvif.h:2029 */
class ns2__SourceReference;	/* onvifgen/onvif.h:2032 */
class ns2__DateTimeRange;	/* onvifgen/onvif.h:2035 */
class ns2__RecordingSummary;	/* onvifgen/onvif.h:2038 */
class ns2__SearchScope;	/* onvifgen/onvif.h:2041 */
class ns2__SearchScopeExtension;	/* onvifgen/onvif.h:2044 */
class ns2__PTZPositionFilter;	/* onvifgen/onvif.h:2050 */
class ns2__MetadataFilter;	/* onvifgen/onvif.h:2053 */
class ns2__FindRecordingResultList;	/* onvifgen/onvif.h:2056 */
class ns2__FindEventResultList;	/* onvifgen/onvif.h:2059 */
class ns2__FindEventResult;	/* onvifgen/onvif.h:2062 */
class ns2__FindPTZPositionResultList;	/* onvifgen/onvif.h:2065 */
class ns2__FindPTZPositionResult;	/* onvifgen/onvif.h:2068 */
class ns2__FindMetadataResultList;	/* onvifgen/onvif.h:2071 */
class ns2__FindMetadataResult;	/* onvifgen/onvif.h:2074 */
class ns2__RecordingInformation;	/* onvifgen/onvif.h:2077 */
class ns2__RecordingSourceInformation;	/* onvifgen/onvif.h:2080 */
class ns2__TrackInformation;	/* onvifgen/onvif.h:2083 */
class ns2__MediaAttributes;	/* onvifgen/onvif.h:2086 */
class ns2__TrackAttributes;	/* onvifgen/onvif.h:2089 */
class ns2__TrackAttributesExtension;	/* onvifgen/onvif.h:2092 */
class ns2__VideoAttributes;	/* onvifgen/onvif.h:2095 */
class ns2__AudioAttributes;	/* onvifgen/onvif.h:2098 */
class ns2__MetadataAttributes;	/* onvifgen/onvif.h:2101 */
class ns2__RecordingConfiguration;	/* onvifgen/onvif.h:2104 */
class ns2__TrackConfiguration;	/* onvifgen/onvif.h:2107 */
class ns2__GetRecordingsResponseItem;	/* onvifgen/onvif.h:2110 */
class ns2__GetTracksResponseList;	/* onvifgen/onvif.h:2113 */
class ns2__GetTracksResponseItem;	/* onvifgen/onvif.h:2116 */
class ns2__RecordingJobConfiguration;	/* onvifgen/onvif.h:2119 */
class ns2__RecordingJobConfigurationExtension;	/* onvifgen/onvif.h:2122 */
class ns2__RecordingJobSource;	/* onvifgen/onvif.h:2125 */
class ns2__RecordingJobSourceExtension;	/* onvifgen/onvif.h:2128 */
class ns2__RecordingJobTrack;	/* onvifgen/onvif.h:2131 */
class ns2__RecordingJobStateInformation;	/* onvifgen/onvif.h:2134 */
class ns2__RecordingJobStateInformationExtension;	/* onvifgen/onvif.h:2137 */
class ns2__RecordingJobStateSource;	/* onvifgen/onvif.h:2140 */
class ns2__RecordingJobStateTracks;	/* onvifgen/onvif.h:2143 */
class ns2__RecordingJobStateTrack;	/* onvifgen/onvif.h:2146 */
class ns2__GetRecordingJobsResponseItem;	/* onvifgen/onvif.h:2149 */
class ns2__ReplayConfiguration;	/* onvifgen/onvif.h:2152 */
class ns2__AnalyticsDeviceEngineConfiguration;	/* onvifgen/onvif.h:2158 */
class ns2__AnalyticsDeviceEngineConfigurationExtension;	/* onvifgen/onvif.h:2161 */
class ns2__EngineConfiguration;	/* onvifgen/onvif.h:2164 */
class ns2__AnalyticsEngineInputInfo;	/* onvifgen/onvif.h:2167 */
class ns2__AnalyticsEngineInputInfoExtension;	/* onvifgen/onvif.h:2170 */
class ns2__SourceIdentification;	/* onvifgen/onvif.h:2176 */
class ns2__SourceIdentificationExtension;	/* onvifgen/onvif.h:2179 */
class ns2__MetadataInput;	/* onvifgen/onvif.h:2182 */
class ns2__MetadataInputExtension;	/* onvifgen/onvif.h:2185 */
class ns2__AnalyticsStateInformation;	/* onvifgen/onvif.h:2191 */
class ns2__AnalyticsState;	/* onvifgen/onvif.h:2194 */
class ns2__ActionEngineEventPayload;	/* onvifgen/onvif.h:2197 */
class ns2__ActionEngineEventPayloadExtension;	/* onvifgen/onvif.h:2200 */
class ns2__AudioClassCandidate;	/* onvifgen/onvif.h:2203 */
class ns2__AudioClassDescriptor;	/* onvifgen/onvif.h:2206 */
class ns2__AudioClassDescriptorExtension;	/* onvifgen/onvif.h:2209 */
class ns2__ActiveConnection;	/* onvifgen/onvif.h:2212 */
class ns2__ProfileStatus;	/* onvifgen/onvif.h:2215 */
class ns2__ProfileStatusExtension;	/* onvifgen/onvif.h:2218 */
class ns2__OSDPosConfiguration;	/* onvifgen/onvif.h:2224 */
class ns2__OSDPosConfigurationExtension;	/* onvifgen/onvif.h:2227 */
class ns2__OSDColor;	/* onvifgen/onvif.h:2230 */
class ns2__OSDTextConfiguration;	/* onvifgen/onvif.h:2233 */
class ns2__OSDTextConfigurationExtension;	/* onvifgen/onvif.h:2236 */
class ns2__OSDImgConfiguration;	/* onvifgen/onvif.h:2239 */
class ns2__OSDImgConfigurationExtension;	/* onvifgen/onvif.h:2242 */
class ns2__ColorspaceRange;	/* onvifgen/onvif.h:2245 */
union _ns2__union_ColorOptions;	/* onvifgen/onvif.h:25269 */
class ns2__ColorOptions;	/* onvifgen/onvif.h:2248 */
class ns2__OSDColorOptions;	/* onvifgen/onvif.h:2251 */
class ns2__OSDColorOptionsExtension;	/* onvifgen/onvif.h:2254 */
class ns2__OSDTextOptions;	/* onvifgen/onvif.h:2257 */
class ns2__OSDTextOptionsExtension;	/* onvifgen/onvif.h:2260 */
class ns2__OSDImgOptions;	/* onvifgen/onvif.h:2263 */
class ns2__OSDImgOptionsExtension;	/* onvifgen/onvif.h:2266 */
class ns2__OSDConfigurationExtension;	/* onvifgen/onvif.h:2272 */
class ns2__MaximumNumberOfOSDs;	/* onvifgen/onvif.h:2275 */
class ns2__OSDConfigurationOptions;	/* onvifgen/onvif.h:2278 */
class ns2__OSDConfigurationOptionsExtension;	/* onvifgen/onvif.h:2281 */
class ns2__FileProgress;	/* onvifgen/onvif.h:2284 */
class ns2__ArrayOfFileProgress;	/* onvifgen/onvif.h:2287 */
class ns2__ArrayOfFileProgressExtension;	/* onvifgen/onvif.h:2290 */
class ns2__StorageReferencePath;	/* onvifgen/onvif.h:2293 */
class ns2__StorageReferencePathExtension;	/* onvifgen/onvif.h:2296 */
class _ns2__Message;	/* onvifgen/onvif.h:2299 */
class ns3__QueryExpressionType;	/* onvifgen/onvif.h:2302 */
class ns3__TopicExpressionType;	/* onvifgen/onvif.h:2305 */
class ns3__FilterType;	/* onvifgen/onvif.h:2308 */
class ns3__SubscriptionPolicyType;	/* onvifgen/onvif.h:2311 */
class _ns3__NotificationMessageHolderType_Message;	/* onvifgen/onvif.h:26029 */
class ns3__NotificationMessageHolderType;	/* onvifgen/onvif.h:2314 */
class _ns3__NotificationProducerRP;	/* onvifgen/onvif.h:2377 */
class _ns3__SubscriptionManagerRP;	/* onvifgen/onvif.h:2380 */
class _ns3__Notify;	/* onvifgen/onvif.h:2383 */
class _ns3__UseRaw;	/* onvifgen/onvif.h:2386 */
class _ns3__Subscribe_SubscriptionPolicy;	/* onvifgen/onvif.h:26176 */
class _ns3__Subscribe;	/* onvifgen/onvif.h:2389 */
class _ns3__SubscribeResponse;	/* onvifgen/onvif.h:2392 */
class _ns3__GetCurrentMessage;	/* onvifgen/onvif.h:2395 */
class _ns3__GetCurrentMessageResponse;	/* onvifgen/onvif.h:2398 */
class _ns3__GetMessages;	/* onvifgen/onvif.h:2401 */
class _ns3__GetMessagesResponse;	/* onvifgen/onvif.h:2404 */
class _ns3__DestroyPullPoint;	/* onvifgen/onvif.h:2407 */
class _ns3__DestroyPullPointResponse;	/* onvifgen/onvif.h:2410 */
class _ns3__CreatePullPoint;	/* onvifgen/onvif.h:2413 */
class _ns3__CreatePullPointResponse;	/* onvifgen/onvif.h:2416 */
class _ns3__Renew;	/* onvifgen/onvif.h:2419 */
class _ns3__RenewResponse;	/* onvifgen/onvif.h:2422 */
class _ns3__Unsubscribe;	/* onvifgen/onvif.h:2425 */
class _ns3__UnsubscribeResponse;	/* onvifgen/onvif.h:2428 */
class _ns3__PauseSubscription;	/* onvifgen/onvif.h:2431 */
class _ns3__PauseSubscriptionResponse;	/* onvifgen/onvif.h:2434 */
class _ns3__ResumeSubscription;	/* onvifgen/onvif.h:2437 */
class _ns3__ResumeSubscriptionResponse;	/* onvifgen/onvif.h:2440 */
class ns4__Include;	/* onvifgen/onvif.h:2443 */
class _ns5__BaseFaultType_ErrorCode;	/* onvifgen/onvif.h:26800 */
class _ns5__BaseFaultType_Description;	/* onvifgen/onvif.h:26821 */
class _ns5__BaseFaultType_FaultCause;	/* onvifgen/onvif.h:26838 */
class ns5__BaseFaultType;	/* onvifgen/onvif.h:2446 */
class ns6__Documentation;	/* onvifgen/onvif.h:2449 */
class ns6__ExtensibleDocumented;	/* onvifgen/onvif.h:2452 */
class ns6__QueryExpressionType;	/* onvifgen/onvif.h:2455 */
class ns7__Capabilities;	/* onvifgen/onvif.h:2467 */
class _ns7__GetServiceCapabilities;	/* onvifgen/onvif.h:2470 */
class _ns7__GetServiceCapabilitiesResponse;	/* onvifgen/onvif.h:2473 */
class _ns7__GetLayout;	/* onvifgen/onvif.h:2476 */
class _ns7__GetLayoutResponse;	/* onvifgen/onvif.h:2479 */
class _ns7__SetLayout;	/* onvifgen/onvif.h:2482 */
class _ns7__SetLayoutResponse;	/* onvifgen/onvif.h:2485 */
class _ns7__GetDisplayOptions;	/* onvifgen/onvif.h:2488 */
class _ns7__GetDisplayOptionsResponse;	/* onvifgen/onvif.h:2491 */
class _ns7__GetPaneConfigurations;	/* onvifgen/onvif.h:2494 */
class _ns7__GetPaneConfigurationsResponse;	/* onvifgen/onvif.h:2497 */
class _ns7__GetPaneConfiguration;	/* onvifgen/onvif.h:2500 */
class _ns7__GetPaneConfigurationResponse;	/* onvifgen/onvif.h:2503 */
class _ns7__SetPaneConfigurations;	/* onvifgen/onvif.h:2506 */
class _ns7__SetPaneConfigurationsResponse;	/* onvifgen/onvif.h:2509 */
class _ns7__SetPaneConfiguration;	/* onvifgen/onvif.h:2512 */
class _ns7__SetPaneConfigurationResponse;	/* onvifgen/onvif.h:2515 */
class _ns7__CreatePaneConfiguration;	/* onvifgen/onvif.h:2518 */
class _ns7__CreatePaneConfigurationResponse;	/* onvifgen/onvif.h:2521 */
class _ns7__DeletePaneConfiguration;	/* onvifgen/onvif.h:2524 */
class _ns7__DeletePaneConfigurationResponse;	/* onvifgen/onvif.h:2527 */
class ns8__Capabilities;	/* onvifgen/onvif.h:2530 */
class ns8__ImagingPreset;	/* onvifgen/onvif.h:2533 */
class _ns8__GetServiceCapabilities;	/* onvifgen/onvif.h:2536 */
class _ns8__GetServiceCapabilitiesResponse;	/* onvifgen/onvif.h:2539 */
class _ns8__GetImagingSettings;	/* onvifgen/onvif.h:2542 */
class _ns8__GetImagingSettingsResponse;	/* onvifgen/onvif.h:2545 */
class _ns8__SetImagingSettings;	/* onvifgen/onvif.h:2548 */
class _ns8__SetImagingSettingsResponse;	/* onvifgen/onvif.h:2551 */
class _ns8__GetOptions;	/* onvifgen/onvif.h:2554 */
class _ns8__GetOptionsResponse;	/* onvifgen/onvif.h:2557 */
class _ns8__Move;	/* onvifgen/onvif.h:2560 */
class _ns8__MoveResponse;	/* onvifgen/onvif.h:2563 */
class _ns8__GetMoveOptions;	/* onvifgen/onvif.h:2566 */
class _ns8__GetMoveOptionsResponse;	/* onvifgen/onvif.h:2569 */
class _ns8__Stop;	/* onvifgen/onvif.h:2572 */
class _ns8__StopResponse;	/* onvifgen/onvif.h:2575 */
class _ns8__GetStatus;	/* onvifgen/onvif.h:2578 */
class _ns8__GetStatusResponse;	/* onvifgen/onvif.h:2581 */
class _ns8__GetPresets;	/* onvifgen/onvif.h:2584 */
class _ns8__GetPresetsResponse;	/* onvifgen/onvif.h:2587 */
class _ns8__GetCurrentPreset;	/* onvifgen/onvif.h:2590 */
class _ns8__GetCurrentPresetResponse;	/* onvifgen/onvif.h:2593 */
class _ns8__SetCurrentPreset;	/* onvifgen/onvif.h:2596 */
class _ns8__SetCurrentPresetResponse;	/* onvifgen/onvif.h:2599 */
class ns9__Capabilities;	/* onvifgen/onvif.h:2602 */
class ns9__ProfileCapabilities;	/* onvifgen/onvif.h:2605 */
class ns9__StreamingCapabilities;	/* onvifgen/onvif.h:2608 */
class ns9__VideoSourceMode;	/* onvifgen/onvif.h:2611 */
class ns9__VideoSourceModeExtension;	/* onvifgen/onvif.h:2614 */
class _ns9__GetServiceCapabilities;	/* onvifgen/onvif.h:2617 */
class _ns9__GetServiceCapabilitiesResponse;	/* onvifgen/onvif.h:2620 */
class _ns9__GetVideoSources;	/* onvifgen/onvif.h:2623 */
class _ns9__GetVideoSourcesResponse;	/* onvifgen/onvif.h:2626 */
class _ns9__GetAudioSources;	/* onvifgen/onvif.h:2629 */
class _ns9__GetAudioSourcesResponse;	/* onvifgen/onvif.h:2632 */
class _ns9__GetAudioOutputs;	/* onvifgen/onvif.h:2635 */
class _ns9__GetAudioOutputsResponse;	/* onvifgen/onvif.h:2638 */
class _ns9__CreateProfile;	/* onvifgen/onvif.h:2641 */
class _ns9__CreateProfileResponse;	/* onvifgen/onvif.h:2644 */
class _ns9__GetProfile;	/* onvifgen/onvif.h:2647 */
class _ns9__GetProfileResponse;	/* onvifgen/onvif.h:2650 */
class _ns9__GetProfiles;	/* onvifgen/onvif.h:2653 */
class _ns9__GetProfilesResponse;	/* onvifgen/onvif.h:2656 */
class _ns9__AddVideoEncoderConfiguration;	/* onvifgen/onvif.h:2659 */
class _ns9__AddVideoEncoderConfigurationResponse;	/* onvifgen/onvif.h:2662 */
class _ns9__RemoveVideoEncoderConfiguration;	/* onvifgen/onvif.h:2665 */
class _ns9__RemoveVideoEncoderConfigurationResponse;	/* onvifgen/onvif.h:2668 */
class _ns9__AddVideoSourceConfiguration;	/* onvifgen/onvif.h:2671 */
class _ns9__AddVideoSourceConfigurationResponse;	/* onvifgen/onvif.h:2674 */
class _ns9__RemoveVideoSourceConfiguration;	/* onvifgen/onvif.h:2677 */
class _ns9__RemoveVideoSourceConfigurationResponse;	/* onvifgen/onvif.h:2680 */
class _ns9__AddAudioEncoderConfiguration;	/* onvifgen/onvif.h:2683 */
class _ns9__AddAudioEncoderConfigurationResponse;	/* onvifgen/onvif.h:2686 */
class _ns9__RemoveAudioEncoderConfiguration;	/* onvifgen/onvif.h:2689 */
class _ns9__RemoveAudioEncoderConfigurationResponse;	/* onvifgen/onvif.h:2692 */
class _ns9__AddAudioSourceConfiguration;	/* onvifgen/onvif.h:2695 */
class _ns9__AddAudioSourceConfigurationResponse;	/* onvifgen/onvif.h:2698 */
class _ns9__RemoveAudioSourceConfiguration;	/* onvifgen/onvif.h:2701 */
class _ns9__RemoveAudioSourceConfigurationResponse;	/* onvifgen/onvif.h:2704 */
class _ns9__AddPTZConfiguration;	/* onvifgen/onvif.h:2707 */
class _ns9__AddPTZConfigurationResponse;	/* onvifgen/onvif.h:2710 */
class _ns9__RemovePTZConfiguration;	/* onvifgen/onvif.h:2713 */
class _ns9__RemovePTZConfigurationResponse;	/* onvifgen/onvif.h:2716 */
class _ns9__AddVideoAnalyticsConfiguration;	/* onvifgen/onvif.h:2719 */
class _ns9__AddVideoAnalyticsConfigurationResponse;	/* onvifgen/onvif.h:2722 */
class _ns9__RemoveVideoAnalyticsConfiguration;	/* onvifgen/onvif.h:2725 */
class _ns9__RemoveVideoAnalyticsConfigurationResponse;	/* onvifgen/onvif.h:2728 */
class _ns9__AddMetadataConfiguration;	/* onvifgen/onvif.h:2731 */
class _ns9__AddMetadataConfigurationResponse;	/* onvifgen/onvif.h:2734 */
class _ns9__RemoveMetadataConfiguration;	/* onvifgen/onvif.h:2737 */
class _ns9__RemoveMetadataConfigurationResponse;	/* onvifgen/onvif.h:2740 */
class _ns9__AddAudioOutputConfiguration;	/* onvifgen/onvif.h:2743 */
class _ns9__AddAudioOutputConfigurationResponse;	/* onvifgen/onvif.h:2746 */
class _ns9__RemoveAudioOutputConfiguration;	/* onvifgen/onvif.h:2749 */
class _ns9__RemoveAudioOutputConfigurationResponse;	/* onvifgen/onvif.h:2752 */
class _ns9__AddAudioDecoderConfiguration;	/* onvifgen/onvif.h:2755 */
class _ns9__AddAudioDecoderConfigurationResponse;	/* onvifgen/onvif.h:2758 */
class _ns9__RemoveAudioDecoderConfiguration;	/* onvifgen/onvif.h:2761 */
class _ns9__RemoveAudioDecoderConfigurationResponse;	/* onvifgen/onvif.h:2764 */
class _ns9__DeleteProfile;	/* onvifgen/onvif.h:2767 */
class _ns9__DeleteProfileResponse;	/* onvifgen/onvif.h:2770 */
class _ns9__GetVideoEncoderConfigurations;	/* onvifgen/onvif.h:2773 */
class _ns9__GetVideoEncoderConfigurationsResponse;	/* onvifgen/onvif.h:2776 */
class _ns9__GetVideoSourceConfigurations;	/* onvifgen/onvif.h:2779 */
class _ns9__GetVideoSourceConfigurationsResponse;	/* onvifgen/onvif.h:2782 */
class _ns9__GetAudioEncoderConfigurations;	/* onvifgen/onvif.h:2785 */
class _ns9__GetAudioEncoderConfigurationsResponse;	/* onvifgen/onvif.h:2788 */
class _ns9__GetAudioSourceConfigurations;	/* onvifgen/onvif.h:2791 */
class _ns9__GetAudioSourceConfigurationsResponse;	/* onvifgen/onvif.h:2794 */
class _ns9__GetVideoAnalyticsConfigurations;	/* onvifgen/onvif.h:2797 */
class _ns9__GetVideoAnalyticsConfigurationsResponse;	/* onvifgen/onvif.h:2800 */
class _ns9__GetMetadataConfigurations;	/* onvifgen/onvif.h:2803 */
class _ns9__GetMetadataConfigurationsResponse;	/* onvifgen/onvif.h:2806 */
class _ns9__GetAudioOutputConfigurations;	/* onvifgen/onvif.h:2809 */
class _ns9__GetAudioOutputConfigurationsResponse;	/* onvifgen/onvif.h:2812 */
class _ns9__GetAudioDecoderConfigurations;	/* onvifgen/onvif.h:2815 */
class _ns9__GetAudioDecoderConfigurationsResponse;	/* onvifgen/onvif.h:2818 */
class _ns9__GetVideoSourceConfiguration;	/* onvifgen/onvif.h:2821 */
class _ns9__GetVideoSourceConfigurationResponse;	/* onvifgen/onvif.h:2824 */
class _ns9__GetVideoEncoderConfiguration;	/* onvifgen/onvif.h:2827 */
class _ns9__GetVideoEncoderConfigurationResponse;	/* onvifgen/onvif.h:2830 */
class _ns9__GetAudioSourceConfiguration;	/* onvifgen/onvif.h:2833 */
class _ns9__GetAudioSourceConfigurationResponse;	/* onvifgen/onvif.h:2836 */
class _ns9__GetAudioEncoderConfiguration;	/* onvifgen/onvif.h:2839 */
class _ns9__GetAudioEncoderConfigurationResponse;	/* onvifgen/onvif.h:2842 */
class _ns9__GetVideoAnalyticsConfiguration;	/* onvifgen/onvif.h:2845 */
class _ns9__GetVideoAnalyticsConfigurationResponse;	/* onvifgen/onvif.h:2848 */
class _ns9__GetMetadataConfiguration;	/* onvifgen/onvif.h:2851 */
class _ns9__GetMetadataConfigurationResponse;	/* onvifgen/onvif.h:2854 */
class _ns9__GetAudioOutputConfiguration;	/* onvifgen/onvif.h:2857 */
class _ns9__GetAudioOutputConfigurationResponse;	/* onvifgen/onvif.h:2860 */
class _ns9__GetAudioDecoderConfiguration;	/* onvifgen/onvif.h:2863 */
class _ns9__GetAudioDecoderConfigurationResponse;	/* onvifgen/onvif.h:2866 */
class _ns9__GetCompatibleVideoEncoderConfigurations;	/* onvifgen/onvif.h:2869 */
class _ns9__GetCompatibleVideoEncoderConfigurationsResponse;	/* onvifgen/onvif.h:2872 */
class _ns9__GetCompatibleVideoSourceConfigurations;	/* onvifgen/onvif.h:2875 */
class _ns9__GetCompatibleVideoSourceConfigurationsResponse;	/* onvifgen/onvif.h:2878 */
class _ns9__GetCompatibleAudioEncoderConfigurations;	/* onvifgen/onvif.h:2881 */
class _ns9__GetCompatibleAudioEncoderConfigurationsResponse;	/* onvifgen/onvif.h:2884 */
class _ns9__GetCompatibleAudioSourceConfigurations;	/* onvifgen/onvif.h:2887 */
class _ns9__GetCompatibleAudioSourceConfigurationsResponse;	/* onvifgen/onvif.h:2890 */
class _ns9__GetCompatibleVideoAnalyticsConfigurations;	/* onvifgen/onvif.h:2893 */
class _ns9__GetCompatibleVideoAnalyticsConfigurationsResponse;	/* onvifgen/onvif.h:2896 */
class _ns9__GetCompatibleMetadataConfigurations;	/* onvifgen/onvif.h:2899 */
class _ns9__GetCompatibleMetadataConfigurationsResponse;	/* onvifgen/onvif.h:2902 */
class _ns9__GetCompatibleAudioOutputConfigurations;	/* onvifgen/onvif.h:2905 */
class _ns9__GetCompatibleAudioOutputConfigurationsResponse;	/* onvifgen/onvif.h:2908 */
class _ns9__GetCompatibleAudioDecoderConfigurations;	/* onvifgen/onvif.h:2911 */
class _ns9__GetCompatibleAudioDecoderConfigurationsResponse;	/* onvifgen/onvif.h:2914 */
class _ns9__SetVideoEncoderConfiguration;	/* onvifgen/onvif.h:2917 */
class _ns9__SetVideoEncoderConfigurationResponse;	/* onvifgen/onvif.h:2920 */
class _ns9__SetVideoSourceConfiguration;	/* onvifgen/onvif.h:2923 */
class _ns9__SetVideoSourceConfigurationResponse;	/* onvifgen/onvif.h:2926 */
class _ns9__SetAudioEncoderConfiguration;	/* onvifgen/onvif.h:2929 */
class _ns9__SetAudioEncoderConfigurationResponse;	/* onvifgen/onvif.h:2932 */
class _ns9__SetAudioSourceConfiguration;	/* onvifgen/onvif.h:2935 */
class _ns9__SetAudioSourceConfigurationResponse;	/* onvifgen/onvif.h:2938 */
class _ns9__SetVideoAnalyticsConfiguration;	/* onvifgen/onvif.h:2941 */
class _ns9__SetVideoAnalyticsConfigurationResponse;	/* onvifgen/onvif.h:2944 */
class _ns9__SetMetadataConfiguration;	/* onvifgen/onvif.h:2947 */
class _ns9__SetMetadataConfigurationResponse;	/* onvifgen/onvif.h:2950 */
class _ns9__SetAudioOutputConfiguration;	/* onvifgen/onvif.h:2953 */
class _ns9__SetAudioOutputConfigurationResponse;	/* onvifgen/onvif.h:2956 */
class _ns9__SetAudioDecoderConfiguration;	/* onvifgen/onvif.h:2959 */
class _ns9__SetAudioDecoderConfigurationResponse;	/* onvifgen/onvif.h:2962 */
class _ns9__GetVideoSourceConfigurationOptions;	/* onvifgen/onvif.h:2965 */
class _ns9__GetVideoSourceConfigurationOptionsResponse;	/* onvifgen/onvif.h:2968 */
class _ns9__GetVideoEncoderConfigurationOptions;	/* onvifgen/onvif.h:2971 */
class _ns9__GetVideoEncoderConfigurationOptionsResponse;	/* onvifgen/onvif.h:2974 */
class _ns9__GetAudioSourceConfigurationOptions;	/* onvifgen/onvif.h:2977 */
class _ns9__GetAudioSourceConfigurationOptionsResponse;	/* onvifgen/onvif.h:2980 */
class _ns9__GetAudioEncoderConfigurationOptions;	/* onvifgen/onvif.h:2983 */
class _ns9__GetAudioEncoderConfigurationOptionsResponse;	/* onvifgen/onvif.h:2986 */
class _ns9__GetMetadataConfigurationOptions;	/* onvifgen/onvif.h:2989 */
class _ns9__GetMetadataConfigurationOptionsResponse;	/* onvifgen/onvif.h:2992 */
class _ns9__GetAudioOutputConfigurationOptions;	/* onvifgen/onvif.h:2995 */
class _ns9__GetAudioOutputConfigurationOptionsResponse;	/* onvifgen/onvif.h:2998 */
class _ns9__GetAudioDecoderConfigurationOptions;	/* onvifgen/onvif.h:3001 */
class _ns9__GetAudioDecoderConfigurationOptionsResponse;	/* onvifgen/onvif.h:3004 */
class _ns9__GetGuaranteedNumberOfVideoEncoderInstances;	/* onvifgen/onvif.h:3007 */
class _ns9__GetGuaranteedNumberOfVideoEncoderInstancesResponse;	/* onvifgen/onvif.h:3010 */
class _ns9__GetStreamUri;	/* onvifgen/onvif.h:3013 */
class _ns9__GetStreamUriResponse;	/* onvifgen/onvif.h:3016 */
class _ns9__StartMulticastStreaming;	/* onvifgen/onvif.h:3019 */
class _ns9__StartMulticastStreamingResponse;	/* onvifgen/onvif.h:3022 */
class _ns9__StopMulticastStreaming;	/* onvifgen/onvif.h:3025 */
class _ns9__StopMulticastStreamingResponse;	/* onvifgen/onvif.h:3028 */
class _ns9__SetSynchronizationPoint;	/* onvifgen/onvif.h:3031 */
class _ns9__SetSynchronizationPointResponse;	/* onvifgen/onvif.h:3034 */
class _ns9__GetSnapshotUri;	/* onvifgen/onvif.h:3037 */
class _ns9__GetSnapshotUriResponse;	/* onvifgen/onvif.h:3040 */
class _ns9__GetVideoSourceModes;	/* onvifgen/onvif.h:3043 */
class _ns9__GetVideoSourceModesResponse;	/* onvifgen/onvif.h:3046 */
class _ns9__SetVideoSourceMode;	/* onvifgen/onvif.h:3049 */
class _ns9__SetVideoSourceModeResponse;	/* onvifgen/onvif.h:3052 */
class _ns9__GetOSDs;	/* onvifgen/onvif.h:3055 */
class _ns9__GetOSDsResponse;	/* onvifgen/onvif.h:3058 */
class _ns9__GetOSD;	/* onvifgen/onvif.h:3061 */
class _ns9__GetOSDResponse;	/* onvifgen/onvif.h:3064 */
class _ns9__SetOSD;	/* onvifgen/onvif.h:3067 */
class _ns9__SetOSDResponse;	/* onvifgen/onvif.h:3070 */
class _ns9__GetOSDOptions;	/* onvifgen/onvif.h:3073 */
class _ns9__GetOSDOptionsResponse;	/* onvifgen/onvif.h:3076 */
class _ns9__CreateOSD;	/* onvifgen/onvif.h:3079 */
class _ns9__CreateOSDResponse;	/* onvifgen/onvif.h:3082 */
class _ns9__DeleteOSD;	/* onvifgen/onvif.h:3085 */
class _ns9__DeleteOSDResponse;	/* onvifgen/onvif.h:3088 */
class ns10__Capabilities2;	/* onvifgen/onvif.h:3091 */
class ns10__ProfileCapabilities;	/* onvifgen/onvif.h:3094 */
class ns10__StreamingCapabilities;	/* onvifgen/onvif.h:3097 */
class ns10__ConfigurationRef;	/* onvifgen/onvif.h:3100 */
class ns10__ConfigurationSet;	/* onvifgen/onvif.h:3103 */
class ns10__MediaProfile;	/* onvifgen/onvif.h:3106 */
class ns10__GetConfiguration;	/* onvifgen/onvif.h:3109 */
class ns10__EncoderInstance;	/* onvifgen/onvif.h:3112 */
class ns10__EncoderInstanceInfo;	/* onvifgen/onvif.h:3115 */
class ns10__StartStopMulticastStreaming;	/* onvifgen/onvif.h:3118 */
class ns10__VideoSourceMode;	/* onvifgen/onvif.h:3121 */
class _ns10__GetServiceCapabilities;	/* onvifgen/onvif.h:3124 */
class _ns10__GetServiceCapabilitiesResponse2;	/* onvifgen/onvif.h:3127 */
class _ns10__CreateProfile;	/* onvifgen/onvif.h:3130 */
class _ns10__CreateProfileResponse;	/* onvifgen/onvif.h:3133 */
class _ns10__GetProfiles;	/* onvifgen/onvif.h:3136 */
class _ns10__GetProfilesResponse;	/* onvifgen/onvif.h:3139 */
class _ns10__AddConfiguration;	/* onvifgen/onvif.h:3142 */
class _ns10__AddConfigurationResponse;	/* onvifgen/onvif.h:3145 */
class _ns10__RemoveConfiguration;	/* onvifgen/onvif.h:3148 */
class _ns10__RemoveConfigurationResponse;	/* onvifgen/onvif.h:3151 */
class _ns10__DeleteProfile;	/* onvifgen/onvif.h:3154 */
class _ns10__DeleteProfileResponse;	/* onvifgen/onvif.h:3157 */
class _ns10__GetVideoEncoderConfigurationsResponse;	/* onvifgen/onvif.h:3160 */
class _ns10__GetVideoSourceConfigurationsResponse;	/* onvifgen/onvif.h:3163 */
class _ns10__GetAudioEncoderConfigurationsResponse;	/* onvifgen/onvif.h:3166 */
class _ns10__GetAudioSourceConfigurationsResponse;	/* onvifgen/onvif.h:3169 */
class _ns10__GetAnalyticsConfigurationsResponse;	/* onvifgen/onvif.h:3172 */
class _ns10__GetMetadataConfigurationsResponse;	/* onvifgen/onvif.h:3175 */
class _ns10__GetAudioOutputConfigurationsResponse;	/* onvifgen/onvif.h:3178 */
class _ns10__GetAudioDecoderConfigurationsResponse;	/* onvifgen/onvif.h:3181 */
class _ns10__SetVideoEncoderConfiguration;	/* onvifgen/onvif.h:3184 */
class _ns10__SetConfigurationResponse;	/* onvifgen/onvif.h:3187 */
class _ns10__SetVideoSourceConfiguration;	/* onvifgen/onvif.h:3190 */
class _ns10__SetAudioEncoderConfiguration;	/* onvifgen/onvif.h:3193 */
class _ns10__SetAudioSourceConfiguration;	/* onvifgen/onvif.h:3196 */
class _ns10__SetMetadataConfiguration;	/* onvifgen/onvif.h:3199 */
class _ns10__SetAudioOutputConfiguration;	/* onvifgen/onvif.h:3202 */
class _ns10__SetAudioDecoderConfiguration;	/* onvifgen/onvif.h:3205 */
class _ns10__GetVideoSourceConfigurationOptionsResponse;	/* onvifgen/onvif.h:3208 */
class _ns10__GetVideoEncoderConfigurationOptionsResponse;	/* onvifgen/onvif.h:3211 */
class _ns10__GetAudioSourceConfigurationOptionsResponse;	/* onvifgen/onvif.h:3214 */
class _ns10__GetAudioEncoderConfigurationOptionsResponse;	/* onvifgen/onvif.h:3217 */
class _ns10__GetMetadataConfigurationOptionsResponse;	/* onvifgen/onvif.h:3220 */
class _ns10__GetAudioOutputConfigurationOptionsResponse;	/* onvifgen/onvif.h:3223 */
class _ns10__GetAudioDecoderConfigurationOptionsResponse;	/* onvifgen/onvif.h:3226 */
class _ns10__GetVideoEncoderInstances;	/* onvifgen/onvif.h:3229 */
class _ns10__GetVideoEncoderInstancesResponse;	/* onvifgen/onvif.h:3232 */
class _ns10__GetStreamUri;	/* onvifgen/onvif.h:3235 */
class _ns10__GetStreamUriResponse;	/* onvifgen/onvif.h:3238 */
class _ns10__SetSynchronizationPoint;	/* onvifgen/onvif.h:3241 */
class _ns10__SetSynchronizationPointResponse;	/* onvifgen/onvif.h:3244 */
class _ns10__GetSnapshotUri;	/* onvifgen/onvif.h:3247 */
class _ns10__GetSnapshotUriResponse;	/* onvifgen/onvif.h:3250 */
class _ns10__StartStopMulticastStreamingResponse;	/* onvifgen/onvif.h:3253 */
class _ns10__GetVideoSourceModes;	/* onvifgen/onvif.h:3256 */
class _ns10__GetVideoSourceModesResponse;	/* onvifgen/onvif.h:3259 */
class _ns10__SetVideoSourceMode;	/* onvifgen/onvif.h:3262 */
class _ns10__SetVideoSourceModeResponse;	/* onvifgen/onvif.h:3265 */
class _ns10__GetOSDs;	/* onvifgen/onvif.h:3268 */
class _ns10__GetOSDsResponse;	/* onvifgen/onvif.h:3271 */
class _ns10__SetOSD;	/* onvifgen/onvif.h:3274 */
class _ns10__GetOSDOptions;	/* onvifgen/onvif.h:3277 */
class _ns10__GetOSDOptionsResponse;	/* onvifgen/onvif.h:3280 */
class _ns10__CreateOSD;	/* onvifgen/onvif.h:3283 */
class _ns10__CreateOSDResponse;	/* onvifgen/onvif.h:3286 */
class _ns10__DeleteOSD;	/* onvifgen/onvif.h:3289 */
class ns11__Capabilities;	/* onvifgen/onvif.h:3292 */
class _ns11__GetServiceCapabilities;	/* onvifgen/onvif.h:3295 */
class _ns11__GetServiceCapabilitiesResponse;	/* onvifgen/onvif.h:3298 */
class _ns11__GetNodes;	/* onvifgen/onvif.h:3301 */
class _ns11__GetNodesResponse;	/* onvifgen/onvif.h:3304 */
class _ns11__GetNode;	/* onvifgen/onvif.h:3307 */
class _ns11__GetNodeResponse;	/* onvifgen/onvif.h:3310 */
class _ns11__GetConfigurations;	/* onvifgen/onvif.h:3313 */
class _ns11__GetConfigurationsResponse;	/* onvifgen/onvif.h:3316 */
class _ns11__GetConfiguration;	/* onvifgen/onvif.h:3319 */
class _ns11__GetConfigurationResponse;	/* onvifgen/onvif.h:3322 */
class _ns11__SetConfiguration;	/* onvifgen/onvif.h:3325 */
class __ns11__SetConfigurationResponse_sequence;	/* onvifgen/onvif.h:34470 */
class _ns11__SetConfigurationResponse;	/* onvifgen/onvif.h:3328 */
class _ns11__GetConfigurationOptions;	/* onvifgen/onvif.h:3331 */
class _ns11__GetConfigurationOptionsResponse;	/* onvifgen/onvif.h:3334 */
class _ns11__SendAuxiliaryCommand;	/* onvifgen/onvif.h:3337 */
class _ns11__SendAuxiliaryCommandResponse;	/* onvifgen/onvif.h:3340 */
class _ns11__GetPresets;	/* onvifgen/onvif.h:3343 */
class _ns11__GetPresetsResponse;	/* onvifgen/onvif.h:3346 */
class _ns11__SetPreset;	/* onvifgen/onvif.h:3349 */
class _ns11__SetPresetResponse;	/* onvifgen/onvif.h:3352 */
class _ns11__RemovePreset;	/* onvifgen/onvif.h:3355 */
class _ns11__RemovePresetResponse;	/* onvifgen/onvif.h:3358 */
class _ns11__GotoPreset;	/* onvifgen/onvif.h:3361 */
class _ns11__GotoPresetResponse;	/* onvifgen/onvif.h:3364 */
class _ns11__GetStatus;	/* onvifgen/onvif.h:3367 */
class _ns11__GetStatusResponse;	/* onvifgen/onvif.h:3370 */
class _ns11__GotoHomePosition;	/* onvifgen/onvif.h:3373 */
class _ns11__GotoHomePositionResponse;	/* onvifgen/onvif.h:3376 */
class _ns11__SetHomePosition;	/* onvifgen/onvif.h:3379 */
class _ns11__SetHomePositionResponse;	/* onvifgen/onvif.h:3382 */
class _ns11__ContinuousMove;	/* onvifgen/onvif.h:3385 */
class _ns11__ContinuousMoveResponse;	/* onvifgen/onvif.h:3388 */
class _ns11__RelativeMove;	/* onvifgen/onvif.h:3391 */
class _ns11__RelativeMoveResponse;	/* onvifgen/onvif.h:3394 */
class _ns11__AbsoluteMove;	/* onvifgen/onvif.h:3397 */
class _ns11__AbsoluteMoveResponse;	/* onvifgen/onvif.h:3400 */
class _ns11__Stop;	/* onvifgen/onvif.h:3403 */
class _ns11__StopResponse;	/* onvifgen/onvif.h:3406 */
class _ns11__GetPresetTours;	/* onvifgen/onvif.h:3409 */
class _ns11__GetPresetToursResponse;	/* onvifgen/onvif.h:3412 */
class _ns11__GetPresetTour;	/* onvifgen/onvif.h:3415 */
class _ns11__GetPresetTourResponse;	/* onvifgen/onvif.h:3418 */
class _ns11__GetPresetTourOptions;	/* onvifgen/onvif.h:3421 */
class _ns11__GetPresetTourOptionsResponse;	/* onvifgen/onvif.h:3424 */
class _ns11__CreatePresetTour;	/* onvifgen/onvif.h:3427 */
class _ns11__CreatePresetTourResponse;	/* onvifgen/onvif.h:3430 */
class _ns11__ModifyPresetTour;	/* onvifgen/onvif.h:3433 */
class _ns11__ModifyPresetTourResponse;	/* onvifgen/onvif.h:3436 */
class _ns11__OperatePresetTour;	/* onvifgen/onvif.h:3439 */
class _ns11__OperatePresetTourResponse;	/* onvifgen/onvif.h:3442 */
class _ns11__RemovePresetTour;	/* onvifgen/onvif.h:3445 */
class _ns11__RemovePresetTourResponse;	/* onvifgen/onvif.h:3448 */
class _ns11__GetCompatibleConfigurations;	/* onvifgen/onvif.h:3451 */
class _ns11__GetCompatibleConfigurationsResponse;	/* onvifgen/onvif.h:3454 */
class ns12__ServiceCapabilities;	/* onvifgen/onvif.h:3457 */
class ns12__ServiceCapabilitiesExtension;	/* onvifgen/onvif.h:3460 */
class ns12__CredentialExtension;	/* onvifgen/onvif.h:3469 */
class ns12__CredentialIdentifier;	/* onvifgen/onvif.h:3472 */
class ns12__CredentialIdentifierType;	/* onvifgen/onvif.h:3475 */
class ns12__CredentialAccessProfile;	/* onvifgen/onvif.h:3478 */
class ns12__CredentialState;	/* onvifgen/onvif.h:3481 */
class ns12__CredentialStateExtension;	/* onvifgen/onvif.h:3484 */
class ns12__AntipassbackState;	/* onvifgen/onvif.h:3487 */
class ns12__CredentialIdentifierFormatTypeInfo;	/* onvifgen/onvif.h:3490 */
class ns12__CredentialIdentifierFormatTypeInfoExtension;	/* onvifgen/onvif.h:3493 */
class _ns12__GetServiceCapabilities;	/* onvifgen/onvif.h:3496 */
class _ns12__GetServiceCapabilitiesResponse;	/* onvifgen/onvif.h:3499 */
class _ns12__GetSupportedFormatTypes;	/* onvifgen/onvif.h:3502 */
class _ns12__GetSupportedFormatTypesResponse;	/* onvifgen/onvif.h:3505 */
class _ns12__GetCredentialInfo;	/* onvifgen/onvif.h:3508 */
class _ns12__GetCredentialInfoResponse;	/* onvifgen/onvif.h:3511 */
class _ns12__GetCredentialInfoList;	/* onvifgen/onvif.h:3514 */
class _ns12__GetCredentialInfoListResponse;	/* onvifgen/onvif.h:3517 */
class _ns12__GetCredentials;	/* onvifgen/onvif.h:3520 */
class _ns12__GetCredentialsResponse;	/* onvifgen/onvif.h:3523 */
class _ns12__GetCredentialList;	/* onvifgen/onvif.h:3526 */
class _ns12__GetCredentialListResponse;	/* onvifgen/onvif.h:3529 */
class _ns12__CreateCredential;	/* onvifgen/onvif.h:3532 */
class _ns12__CreateCredentialResponse;	/* onvifgen/onvif.h:3535 */
class _ns12__ModifyCredential;	/* onvifgen/onvif.h:3538 */
class _ns12__ModifyCredentialResponse;	/* onvifgen/onvif.h:3541 */
class _ns12__DeleteCredential;	/* onvifgen/onvif.h:3544 */
class _ns12__DeleteCredentialResponse;	/* onvifgen/onvif.h:3547 */
class _ns12__GetCredentialState;	/* onvifgen/onvif.h:3550 */
class _ns12__GetCredentialStateResponse;	/* onvifgen/onvif.h:3553 */
class _ns12__EnableCredential;	/* onvifgen/onvif.h:3556 */
class _ns12__EnableCredentialResponse;	/* onvifgen/onvif.h:3559 */
class _ns12__DisableCredential;	/* onvifgen/onvif.h:3562 */
class _ns12__DisableCredentialResponse;	/* onvifgen/onvif.h:3565 */
class _ns12__ResetAntipassbackViolation;	/* onvifgen/onvif.h:3568 */
class _ns12__ResetAntipassbackViolationResponse;	/* onvifgen/onvif.h:3571 */
class _ns12__GetCredentialIdentifiers;	/* onvifgen/onvif.h:3574 */
class _ns12__GetCredentialIdentifiersResponse;	/* onvifgen/onvif.h:3577 */
class _ns12__SetCredentialIdentifier;	/* onvifgen/onvif.h:3580 */
class _ns12__SetCredentialIdentifierResponse;	/* onvifgen/onvif.h:3583 */
class _ns12__DeleteCredentialIdentifier;	/* onvifgen/onvif.h:3586 */
class _ns12__DeleteCredentialIdentifierResponse;	/* onvifgen/onvif.h:3589 */
class _ns12__GetCredentialAccessProfiles;	/* onvifgen/onvif.h:3592 */
class _ns12__GetCredentialAccessProfilesResponse;	/* onvifgen/onvif.h:3595 */
class _ns12__SetCredentialAccessProfiles;	/* onvifgen/onvif.h:3598 */
class _ns12__SetCredentialAccessProfilesResponse;	/* onvifgen/onvif.h:3601 */
class _ns12__DeleteCredentialAccessProfiles;	/* onvifgen/onvif.h:3604 */
class _ns12__DeleteCredentialAccessProfilesResponse;	/* onvifgen/onvif.h:3607 */
class ns13__DataEntity;	/* onvifgen/onvif.h:3610 */
class ns13__Attribute;	/* onvifgen/onvif.h:3613 */
class ns14__EndpointReferenceType;	/* onvifgen/onvif.h:3616 */
class ns14__ReferenceParametersType;	/* onvifgen/onvif.h:3619 */
class ns14__MetadataType;	/* onvifgen/onvif.h:3622 */
class ns14__ProblemActionType;	/* onvifgen/onvif.h:3637 */
class ns1__StorageConfiguration;	/* onvifgen/onvif.h:298 */
class ns2__VideoSource;	/* onvifgen/onvif.h:850 */
class ns2__AudioSource;	/* onvifgen/onvif.h:859 */
class ns2__VideoSourceConfiguration;	/* onvifgen/onvif.h:874 */
class ns2__VideoEncoderConfiguration;	/* onvifgen/onvif.h:913 */
class ns2__JpegOptions2;	/* onvifgen/onvif.h:940 */
class ns2__Mpeg4Options2;	/* onvifgen/onvif.h:946 */
class ns2__H264Options2;	/* onvifgen/onvif.h:952 */
class ns2__VideoEncoder2Configuration;	/* onvifgen/onvif.h:955 */
class ns2__AudioSourceConfiguration;	/* onvifgen/onvif.h:967 */
class ns2__AudioEncoderConfiguration;	/* onvifgen/onvif.h:976 */
class ns2__AudioEncoder2Configuration;	/* onvifgen/onvif.h:985 */
class ns2__VideoAnalyticsConfiguration;	/* onvifgen/onvif.h:991 */
class ns2__MetadataConfiguration;	/* onvifgen/onvif.h:994 */
class ns2__VideoOutput;	/* onvifgen/onvif.h:1021 */
class ns2__VideoOutputConfiguration;	/* onvifgen/onvif.h:1027 */
class ns2__AudioOutput;	/* onvifgen/onvif.h:1048 */
class ns2__AudioOutputConfiguration;	/* onvifgen/onvif.h:1051 */
class ns2__AudioDecoderConfiguration;	/* onvifgen/onvif.h:1057 */
class ns2__NetworkInterface;	/* onvifgen/onvif.h:1090 */
class ns2__CertificateUsage;	/* onvifgen/onvif.h:1402 */
class ns2__RelayOutput;	/* onvifgen/onvif.h:1429 */
class ns2__DigitalInput;	/* onvifgen/onvif.h:1432 */
class ns2__PTZNode;	/* onvifgen/onvif.h:1435 */
class ns2__PTZConfiguration;	/* onvifgen/onvif.h:1450 */
class ns2__Object;	/* onvifgen/onvif.h:1858 */
class ns2__EventFilter;	/* onvifgen/onvif.h:2047 */
class ns2__AnalyticsEngine;	/* onvifgen/onvif.h:2155 */
class ns2__AnalyticsEngineInput;	/* onvifgen/onvif.h:2173 */
class ns2__AnalyticsEngineControl;	/* onvifgen/onvif.h:2188 */
class ns2__OSDConfiguration;	/* onvifgen/onvif.h:2269 */
class ns3__SubscribeCreationFailedFaultType;	/* onvifgen/onvif.h:2317 */
class ns3__InvalidFilterFaultType;	/* onvifgen/onvif.h:2320 */
class ns3__TopicExpressionDialectUnknownFaultType;	/* onvifgen/onvif.h:2323 */
class ns3__InvalidTopicExpressionFaultType;	/* onvifgen/onvif.h:2326 */
class ns3__TopicNotSupportedFaultType;	/* onvifgen/onvif.h:2329 */
class ns3__MultipleTopicsSpecifiedFaultType;	/* onvifgen/onvif.h:2332 */
class ns3__InvalidProducerPropertiesExpressionFaultType;	/* onvifgen/onvif.h:2335 */
class ns3__InvalidMessageContentExpressionFaultType;	/* onvifgen/onvif.h:2338 */
class ns3__UnrecognizedPolicyRequestFaultType;	/* onvifgen/onvif.h:2341 */
class ns3__UnsupportedPolicyRequestFaultType;	/* onvifgen/onvif.h:2344 */
class ns3__NotifyMessageNotSupportedFaultType;	/* onvifgen/onvif.h:2347 */
class ns3__UnacceptableInitialTerminationTimeFaultType;	/* onvifgen/onvif.h:2350 */
class ns3__NoCurrentMessageOnTopicFaultType;	/* onvifgen/onvif.h:2353 */
class ns3__UnableToGetMessagesFaultType;	/* onvifgen/onvif.h:2356 */
class ns3__UnableToDestroyPullPointFaultType;	/* onvifgen/onvif.h:2359 */
class ns3__UnableToCreatePullPointFaultType;	/* onvifgen/onvif.h:2362 */
class ns3__UnacceptableTerminationTimeFaultType;	/* onvifgen/onvif.h:2365 */
class ns3__UnableToDestroySubscriptionFaultType;	/* onvifgen/onvif.h:2368 */
class ns3__PauseFailedFaultType;	/* onvifgen/onvif.h:2371 */
class ns3__ResumeFailedFaultType;	/* onvifgen/onvif.h:2374 */
class _ns6__TopicNamespaceType_Topic;	/* onvifgen/onvif.h:40768 */
class ns6__TopicNamespaceType;	/* onvifgen/onvif.h:2458 */
class ns6__TopicType;	/* onvifgen/onvif.h:2461 */
class ns6__TopicSetType;	/* onvifgen/onvif.h:2464 */
class ns12__CredentialInfo;	/* onvifgen/onvif.h:3463 */
class ns14__RelatesToType;	/* onvifgen/onvif.h:3625 */
class ns14__AttributedURIType;	/* onvifgen/onvif.h:3628 */
class ns14__AttributedUnsignedLongType;	/* onvifgen/onvif.h:3631 */
class ns14__AttributedQNameType;	/* onvifgen/onvif.h:3634 */
class ns2__OSDReference;	/* onvifgen/onvif.h:2221 */
class ns12__Credential;	/* onvifgen/onvif.h:3466 */
struct __ns1__GetServices;	/* onvifgen/onvif.h:42480 */
struct __ns1__GetServiceCapabilities;	/* onvifgen/onvif.h:42549 */
struct __ns1__GetDeviceInformation;	/* onvifgen/onvif.h:42617 */
struct __ns1__SetSystemDateAndTime;	/* onvifgen/onvif.h:42699 */
struct __ns1__GetSystemDateAndTime;	/* onvifgen/onvif.h:42773 */
struct __ns1__SetSystemFactoryDefault;	/* onvifgen/onvif.h:42841 */
struct __ns1__UpgradeSystemFirmware;	/* onvifgen/onvif.h:42915 */
struct __ns1__SystemReboot;	/* onvifgen/onvif.h:42983 */
struct __ns1__RestoreSystem;	/* onvifgen/onvif.h:43059 */
struct __ns1__GetSystemBackup;	/* onvifgen/onvif.h:43134 */
struct __ns1__GetSystemLog;	/* onvifgen/onvif.h:43203 */
struct __ns1__GetSystemSupportInformation;	/* onvifgen/onvif.h:43271 */
struct __ns1__GetScopes;	/* onvifgen/onvif.h:43354 */
struct __ns1__SetScopes;	/* onvifgen/onvif.h:43430 */
struct __ns1__AddScopes;	/* onvifgen/onvif.h:43502 */
struct __ns1__RemoveScopes;	/* onvifgen/onvif.h:43576 */
struct __ns1__GetDiscoveryMode;	/* onvifgen/onvif.h:43648 */
struct __ns1__SetDiscoveryMode;	/* onvifgen/onvif.h:43721 */
struct __ns1__GetRemoteDiscoveryMode;	/* onvifgen/onvif.h:43795 */
struct __ns1__SetRemoteDiscoveryMode;	/* onvifgen/onvif.h:43869 */
struct __ns1__GetDPAddresses;	/* onvifgen/onvif.h:43941 */
struct __ns1__GetEndpointReference;	/* onvifgen/onvif.h:44015 */
struct __ns1__GetRemoteUser;	/* onvifgen/onvif.h:44089 */
struct __ns1__SetRemoteUser;	/* onvifgen/onvif.h:44168 */
struct __ns1__GetUsers;	/* onvifgen/onvif.h:44240 */
struct __ns1__CreateUsers;	/* onvifgen/onvif.h:44320 */
struct __ns1__DeleteUsers;	/* onvifgen/onvif.h:44395 */
struct __ns1__SetUser;	/* onvifgen/onvif.h:44468 */
struct __ns1__GetWsdlUrl;	/* onvifgen/onvif.h:44543 */
struct __ns1__GetCapabilities;	/* onvifgen/onvif.h:44620 */
struct __ns1__SetDPAddresses;	/* onvifgen/onvif.h:44693 */
struct __ns1__GetHostname;	/* onvifgen/onvif.h:44764 */
struct __ns1__SetHostname;	/* onvifgen/onvif.h:44839 */
struct __ns1__SetHostnameFromDHCP;	/* onvifgen/onvif.h:44907 */
struct __ns1__GetDNS;	/* onvifgen/onvif.h:44977 */
struct __ns1__SetDNS;	/* onvifgen/onvif.h:45047 */
struct __ns1__GetNTP;	/* onvifgen/onvif.h:45118 */
struct __ns1__SetNTP;	/* onvifgen/onvif.h:45196 */
struct __ns1__GetDynamicDNS;	/* onvifgen/onvif.h:45268 */
struct __ns1__SetDynamicDNS;	/* onvifgen/onvif.h:45340 */
struct __ns1__GetNetworkInterfaces;	/* onvifgen/onvif.h:45412 */
struct __ns1__SetNetworkInterfaces;	/* onvifgen/onvif.h:45489 */
struct __ns1__GetNetworkProtocols;	/* onvifgen/onvif.h:45560 */
struct __ns1__SetNetworkProtocols;	/* onvifgen/onvif.h:45631 */
struct __ns1__GetNetworkDefaultGateway;	/* onvifgen/onvif.h:45702 */
struct __ns1__SetNetworkDefaultGateway;	/* onvifgen/onvif.h:45772 */
struct __ns1__GetZeroConfiguration;	/* onvifgen/onvif.h:45847 */
struct __ns1__SetZeroConfiguration;	/* onvifgen/onvif.h:45916 */
struct __ns1__GetIPAddressFilter;	/* onvifgen/onvif.h:45988 */
struct __ns1__SetIPAddressFilter;	/* onvifgen/onvif.h:46062 */
struct __ns1__AddIPAddressFilter;	/* onvifgen/onvif.h:46135 */
struct __ns1__RemoveIPAddressFilter;	/* onvifgen/onvif.h:46208 */
struct __ns1__GetAccessPolicy;	/* onvifgen/onvif.h:46290 */
struct __ns1__SetAccessPolicy;	/* onvifgen/onvif.h:46363 */
struct __ns1__CreateCertificate;	/* onvifgen/onvif.h:46446 */
struct __ns1__GetCertificates;	/* onvifgen/onvif.h:46526 */
struct __ns1__GetCertificatesStatus;	/* onvifgen/onvif.h:46597 */
struct __ns1__SetCertificatesStatus;	/* onvifgen/onvif.h:46670 */
struct __ns1__DeleteCertificates;	/* onvifgen/onvif.h:46746 */
struct __ns1__GetPkcs10Request;	/* onvifgen/onvif.h:46827 */
struct __ns1__LoadCertificates;	/* onvifgen/onvif.h:46918 */
struct __ns1__GetClientCertificateMode;	/* onvifgen/onvif.h:46989 */
struct __ns1__SetClientCertificateMode;	/* onvifgen/onvif.h:47060 */
struct __ns1__GetRelayOutputs;	/* onvifgen/onvif.h:47130 */
struct __ns1__SetRelayOutputSettings;	/* onvifgen/onvif.h:47200 */
struct __ns1__SetRelayOutputState;	/* onvifgen/onvif.h:47270 */
struct __ns1__SendAuxiliaryCommand;	/* onvifgen/onvif.h:47369 */
struct __ns1__GetCACertificates;	/* onvifgen/onvif.h:47448 */
struct __ns1__LoadCertificateWithPrivateKey;	/* onvifgen/onvif.h:47539 */
struct __ns1__GetCertificateInformation;	/* onvifgen/onvif.h:47617 */
struct __ns1__LoadCACertificates;	/* onvifgen/onvif.h:47702 */
struct __ns1__CreateDot1XConfiguration;	/* onvifgen/onvif.h:47778 */
struct __ns1__SetDot1XConfiguration;	/* onvifgen/onvif.h:47850 */
struct __ns1__GetDot1XConfiguration;	/* onvifgen/onvif.h:47926 */
struct __ns1__GetDot1XConfigurations;	/* onvifgen/onvif.h:48005 */
struct __ns1__DeleteDot1XConfiguration;	/* onvifgen/onvif.h:48078 */
struct __ns1__GetDot11Capabilities;	/* onvifgen/onvif.h:48147 */
struct __ns1__GetDot11Status;	/* onvifgen/onvif.h:48217 */
struct __ns1__ScanAvailableDot11Networks;	/* onvifgen/onvif.h:48287 */
struct __ns1__GetSystemUris;	/* onvifgen/onvif.h:48374 */
struct __ns1__StartFirmwareUpgrade;	/* onvifgen/onvif.h:48470 */
struct __ns1__StartSystemRestore;	/* onvifgen/onvif.h:48565 */
struct __ns1__GetStorageConfigurations;	/* onvifgen/onvif.h:48636 */
struct __ns1__CreateStorageConfiguration;	/* onvifgen/onvif.h:48708 */
struct __ns1__GetStorageConfiguration;	/* onvifgen/onvif.h:48779 */
struct __ns1__SetStorageConfiguration;	/* onvifgen/onvif.h:48849 */
struct __ns1__DeleteStorageConfiguration;	/* onvifgen/onvif.h:48920 */
struct __ns10__GetServiceCapabilities;	/* onvifgen/onvif.h:49007 */
struct __ns10__CreateProfile;	/* onvifgen/onvif.h:49081 */
struct __ns10__GetProfiles;	/* onvifgen/onvif.h:49159 */
struct __ns10__AddConfiguration;	/* onvifgen/onvif.h:49235 */
struct __ns10__RemoveConfiguration;	/* onvifgen/onvif.h:49308 */
struct __ns10__DeleteProfile;	/* onvifgen/onvif.h:49377 */
struct __ns10__GetVideoSourceConfigurations;	/* onvifgen/onvif.h:49448 */
struct __ns10__GetVideoEncoderConfigurations;	/* onvifgen/onvif.h:49519 */
struct __ns10__GetAudioSourceConfigurations;	/* onvifgen/onvif.h:49590 */
struct __ns10__GetAudioEncoderConfigurations;	/* onvifgen/onvif.h:49661 */
struct __ns10__GetAnalyticsConfigurations;	/* onvifgen/onvif.h:49732 */
struct __ns10__GetMetadataConfigurations;	/* onvifgen/onvif.h:49803 */
struct __ns10__GetAudioOutputConfigurations;	/* onvifgen/onvif.h:49874 */
struct __ns10__GetAudioDecoderConfigurations;	/* onvifgen/onvif.h:49945 */
struct __ns10__SetVideoSourceConfiguration;	/* onvifgen/onvif.h:50017 */
struct __ns10__SetVideoEncoderConfiguration;	/* onvifgen/onvif.h:50092 */
struct __ns10__SetAudioSourceConfiguration;	/* onvifgen/onvif.h:50167 */
struct __ns10__SetAudioEncoderConfiguration;	/* onvifgen/onvif.h:50241 */
struct __ns10__SetMetadataConfiguration;	/* onvifgen/onvif.h:50315 */
struct __ns10__SetAudioOutputConfiguration;	/* onvifgen/onvif.h:50383 */
struct __ns10__SetAudioDecoderConfiguration;	/* onvifgen/onvif.h:50451 */
struct __ns10__GetVideoSourceConfigurationOptions;	/* onvifgen/onvif.h:50525 */
struct __ns10__GetVideoEncoderConfigurationOptions;	/* onvifgen/onvif.h:50607 */
struct __ns10__GetAudioSourceConfigurationOptions;	/* onvifgen/onvif.h:50681 */
struct __ns10__GetAudioEncoderConfigurationOptions;	/* onvifgen/onvif.h:50751 */
struct __ns10__GetMetadataConfigurationOptions;	/* onvifgen/onvif.h:50820 */
struct __ns10__GetAudioOutputConfigurationOptions;	/* onvifgen/onvif.h:50889 */
struct __ns10__GetAudioDecoderConfigurationOptions;	/* onvifgen/onvif.h:50959 */
struct __ns10__GetVideoEncoderInstances;	/* onvifgen/onvif.h:51030 */
struct __ns10__GetStreamUri;	/* onvifgen/onvif.h:51120 */
struct __ns10__StartMulticastStreaming;	/* onvifgen/onvif.h:51197 */
struct __ns10__StopMulticastStreaming;	/* onvifgen/onvif.h:51265 */
struct __ns10__SetSynchronizationPoint;	/* onvifgen/onvif.h:51350 */
struct __ns10__GetSnapshotUri;	/* onvifgen/onvif.h:51428 */
struct __ns10__GetVideoSourceModes;	/* onvifgen/onvif.h:51498 */
struct __ns10__SetVideoSourceMode;	/* onvifgen/onvif.h:51569 */
struct __ns10__GetOSDs;	/* onvifgen/onvif.h:51648 */
struct __ns10__GetOSDOptions;	/* onvifgen/onvif.h:51716 */
struct __ns10__SetOSD;	/* onvifgen/onvif.h:51784 */
struct __ns10__CreateOSD;	/* onvifgen/onvif.h:51852 */
struct __ns10__DeleteOSD;	/* onvifgen/onvif.h:51920 */
struct __ns11__GetServiceCapabilities;	/* onvifgen/onvif.h:52006 */
struct __ns11__GetConfigurations;	/* onvifgen/onvif.h:52103 */
struct __ns11__GetPresets;	/* onvifgen/onvif.h:52174 */
struct __ns11__SetPreset;	/* onvifgen/onvif.h:52260 */
struct __ns11__RemovePreset;	/* onvifgen/onvif.h:52335 */
struct __ns11__GotoPreset;	/* onvifgen/onvif.h:52406 */
struct __ns11__GetStatus;	/* onvifgen/onvif.h:52477 */
struct __ns11__GetConfiguration;	/* onvifgen/onvif.h:52574 */
struct __ns11__GetNodes;	/* onvifgen/onvif.h:52653 */
struct __ns11__GetNode;	/* onvifgen/onvif.h:52723 */
struct __ns11__SetConfiguration;	/* onvifgen/onvif.h:52793 */
struct __ns11__GetConfigurationOptions;	/* onvifgen/onvif.h:52873 */
struct __ns11__GotoHomePosition;	/* onvifgen/onvif.h:52943 */
struct __ns11__SetHomePosition;	/* onvifgen/onvif.h:53016 */
struct __ns11__ContinuousMove;	/* onvifgen/onvif.h:53087 */
struct __ns11__RelativeMove;	/* onvifgen/onvif.h:53163 */
struct __ns11__SendAuxiliaryCommand;	/* onvifgen/onvif.h:53236 */
struct __ns11__AbsoluteMove;	/* onvifgen/onvif.h:53311 */
struct __ns11__Stop;	/* onvifgen/onvif.h:53382 */
struct __ns11__GetPresetTours;	/* onvifgen/onvif.h:53450 */
struct __ns11__GetPresetTour;	/* onvifgen/onvif.h:53518 */
struct __ns11__GetPresetTourOptions;	/* onvifgen/onvif.h:53586 */
struct __ns11__CreatePresetTour;	/* onvifgen/onvif.h:53654 */
struct __ns11__ModifyPresetTour;	/* onvifgen/onvif.h:53722 */
struct __ns11__OperatePresetTour;	/* onvifgen/onvif.h:53790 */
struct __ns11__RemovePresetTour;	/* onvifgen/onvif.h:53858 */
struct __ns11__GetCompatibleConfigurations;	/* onvifgen/onvif.h:53934 */
struct __ns12__GetServiceCapabilities;	/* onvifgen/onvif.h:54020 */
struct __ns12__GetSupportedFormatTypes;	/* onvifgen/onvif.h:54092 */
struct __ns12__GetCredentialInfo;	/* onvifgen/onvif.h:54171 */
struct __ns12__GetCredentialInfoList;	/* onvifgen/onvif.h:54250 */
struct __ns12__GetCredentials;	/* onvifgen/onvif.h:54327 */
struct __ns12__GetCredentialList;	/* onvifgen/onvif.h:54405 */
struct __ns12__CreateCredential;	/* onvifgen/onvif.h:54484 */
struct __ns12__ModifyCredential;	/* onvifgen/onvif.h:54562 */
struct __ns12__DeleteCredential;	/* onvifgen/onvif.h:54635 */
struct __ns12__GetCredentialState;	/* onvifgen/onvif.h:54710 */
struct __ns12__EnableCredential;	/* onvifgen/onvif.h:54780 */
struct __ns12__DisableCredential;	/* onvifgen/onvif.h:54850 */
struct __ns12__ResetAntipassbackViolation;	/* onvifgen/onvif.h:54921 */
struct __ns12__GetCredentialIdentifiers;	/* onvifgen/onvif.h:54992 */
struct __ns12__SetCredentialIdentifier;	/* onvifgen/onvif.h:55067 */
struct __ns12__DeleteCredentialIdentifier;	/* onvifgen/onvif.h:55140 */
struct __ns12__GetCredentialAccessProfiles;	/* onvifgen/onvif.h:55211 */
struct __ns12__SetCredentialAccessProfiles;	/* onvifgen/onvif.h:55286 */
struct __ns12__DeleteCredentialAccessProfiles;	/* onvifgen/onvif.h:55360 */
struct __ns7__GetServiceCapabilities;	/* onvifgen/onvif.h:55447 */
struct __ns7__GetLayout;	/* onvifgen/onvif.h:55519 */
struct __ns7__SetLayout;	/* onvifgen/onvif.h:55596 */
struct __ns7__GetDisplayOptions;	/* onvifgen/onvif.h:55668 */
struct __ns7__GetPaneConfigurations;	/* onvifgen/onvif.h:55744 */
struct __ns7__GetPaneConfiguration;	/* onvifgen/onvif.h:55812 */
struct __ns7__SetPaneConfigurations;	/* onvifgen/onvif.h:55884 */
struct __ns7__SetPaneConfiguration;	/* onvifgen/onvif.h:55952 */
struct __ns7__CreatePaneConfiguration;	/* onvifgen/onvif.h:56026 */
struct __ns7__DeletePaneConfiguration;	/* onvifgen/onvif.h:56098 */
struct __ns8__GetServiceCapabilities;	/* onvifgen/onvif.h:56185 */
struct __ns8__GetImagingSettings;	/* onvifgen/onvif.h:56253 */
struct __ns8__SetImagingSettings;	/* onvifgen/onvif.h:56321 */
struct __ns8__GetOptions;	/* onvifgen/onvif.h:56399 */
struct __ns8__Move;	/* onvifgen/onvif.h:56489 */
struct __ns8__Stop;	/* onvifgen/onvif.h:56560 */
struct __ns8__GetStatus;	/* onvifgen/onvif.h:56630 */
struct __ns8__GetMoveOptions;	/* onvifgen/onvif.h:56698 */
struct __ns8__GetPresets;	/* onvifgen/onvif.h:56766 */
struct __ns8__GetCurrentPreset;	/* onvifgen/onvif.h:56838 */
struct __ns8__SetCurrentPreset;	/* onvifgen/onvif.h:56914 */
struct __ns9__GetServiceCapabilities;	/* onvifgen/onvif.h:57001 */
struct __ns9__GetVideoSources;	/* onvifgen/onvif.h:57069 */
struct __ns9__GetAudioSources;	/* onvifgen/onvif.h:57137 */
struct __ns9__GetAudioOutputs;	/* onvifgen/onvif.h:57205 */
struct __ns9__CreateProfile;	/* onvifgen/onvif.h:57277 */
struct __ns9__GetProfile;	/* onvifgen/onvif.h:57346 */
struct __ns9__GetProfiles;	/* onvifgen/onvif.h:57419 */
struct __ns9__AddVideoEncoderConfiguration;	/* onvifgen/onvif.h:57494 */
struct __ns9__AddVideoSourceConfiguration;	/* onvifgen/onvif.h:57565 */
struct __ns9__AddAudioEncoderConfiguration;	/* onvifgen/onvif.h:57640 */
struct __ns9__AddAudioSourceConfiguration;	/* onvifgen/onvif.h:57711 */
struct __ns9__AddPTZConfiguration;	/* onvifgen/onvif.h:57786 */
struct __ns9__AddVideoAnalyticsConfiguration;	/* onvifgen/onvif.h:57864 */
struct __ns9__AddMetadataConfiguration;	/* onvifgen/onvif.h:57936 */
struct __ns9__AddAudioOutputConfiguration;	/* onvifgen/onvif.h:58006 */
struct __ns9__AddAudioDecoderConfiguration;	/* onvifgen/onvif.h:58076 */
struct __ns9__RemoveVideoEncoderConfiguration;	/* onvifgen/onvif.h:58147 */
struct __ns9__RemoveVideoSourceConfiguration;	/* onvifgen/onvif.h:58220 */
struct __ns9__RemoveAudioEncoderConfiguration;	/* onvifgen/onvif.h:58292 */
struct __ns9__RemoveAudioSourceConfiguration;	/* onvifgen/onvif.h:58366 */
struct __ns9__RemovePTZConfiguration;	/* onvifgen/onvif.h:58437 */
struct __ns9__RemoveVideoAnalyticsConfiguration;	/* onvifgen/onvif.h:58508 */
struct __ns9__RemoveMetadataConfiguration;	/* onvifgen/onvif.h:58578 */
struct __ns9__RemoveAudioOutputConfiguration;	/* onvifgen/onvif.h:58648 */
struct __ns9__RemoveAudioDecoderConfiguration;	/* onvifgen/onvif.h:58718 */
struct __ns9__DeleteProfile;	/* onvifgen/onvif.h:58787 */
struct __ns9__GetVideoSourceConfigurations;	/* onvifgen/onvif.h:58857 */
struct __ns9__GetVideoEncoderConfigurations;	/* onvifgen/onvif.h:58928 */
struct __ns9__GetAudioSourceConfigurations;	/* onvifgen/onvif.h:58999 */
struct __ns9__GetAudioEncoderConfigurations;	/* onvifgen/onvif.h:59069 */
struct __ns9__GetVideoAnalyticsConfigurations;	/* onvifgen/onvif.h:59139 */
struct __ns9__GetMetadataConfigurations;	/* onvifgen/onvif.h:59208 */
struct __ns9__GetAudioOutputConfigurations;	/* onvifgen/onvif.h:59277 */
struct __ns9__GetAudioDecoderConfigurations;	/* onvifgen/onvif.h:59348 */
struct __ns9__GetVideoSourceConfiguration;	/* onvifgen/onvif.h:59417 */
struct __ns9__GetVideoEncoderConfiguration;	/* onvifgen/onvif.h:59486 */
struct __ns9__GetAudioSourceConfiguration;	/* onvifgen/onvif.h:59555 */
struct __ns9__GetAudioEncoderConfiguration;	/* onvifgen/onvif.h:59624 */
struct __ns9__GetVideoAnalyticsConfiguration;	/* onvifgen/onvif.h:59693 */
struct __ns9__GetMetadataConfiguration;	/* onvifgen/onvif.h:59762 */
struct __ns9__GetAudioOutputConfiguration;	/* onvifgen/onvif.h:59831 */
struct __ns9__GetAudioDecoderConfiguration;	/* onvifgen/onvif.h:59900 */
struct __ns9__GetCompatibleVideoEncoderConfigurations;	/* onvifgen/onvif.h:59972 */
struct __ns9__GetCompatibleVideoSourceConfigurations;	/* onvifgen/onvif.h:60046 */
struct __ns9__GetCompatibleAudioEncoderConfigurations;	/* onvifgen/onvif.h:60118 */
struct __ns9__GetCompatibleAudioSourceConfigurations;	/* onvifgen/onvif.h:60190 */
struct __ns9__GetCompatibleVideoAnalyticsConfigurations;	/* onvifgen/onvif.h:60262 */
struct __ns9__GetCompatibleMetadataConfigurations;	/* onvifgen/onvif.h:60334 */
struct __ns9__GetCompatibleAudioOutputConfigurations;	/* onvifgen/onvif.h:60405 */
struct __ns9__GetCompatibleAudioDecoderConfigurations;	/* onvifgen/onvif.h:60476 */
struct __ns9__SetVideoSourceConfiguration;	/* onvifgen/onvif.h:60549 */
struct __ns9__SetVideoEncoderConfiguration;	/* onvifgen/onvif.h:60626 */
struct __ns9__SetAudioSourceConfiguration;	/* onvifgen/onvif.h:60701 */
struct __ns9__SetAudioEncoderConfiguration;	/* onvifgen/onvif.h:60777 */
struct __ns9__SetVideoAnalyticsConfiguration;	/* onvifgen/onvif.h:60855 */
struct __ns9__SetMetadataConfiguration;	/* onvifgen/onvif.h:60932 */
struct __ns9__SetAudioOutputConfiguration;	/* onvifgen/onvif.h:61002 */
struct __ns9__SetAudioDecoderConfiguration;	/* onvifgen/onvif.h:61072 */
struct __ns9__GetVideoSourceConfigurationOptions;	/* onvifgen/onvif.h:61146 */
struct __ns9__GetVideoEncoderConfigurationOptions;	/* onvifgen/onvif.h:61228 */
struct __ns9__GetAudioSourceConfigurationOptions;	/* onvifgen/onvif.h:61302 */
struct __ns9__GetAudioEncoderConfigurationOptions;	/* onvifgen/onvif.h:61372 */
struct __ns9__GetMetadataConfigurationOptions;	/* onvifgen/onvif.h:61441 */
struct __ns9__GetAudioOutputConfigurationOptions;	/* onvifgen/onvif.h:61510 */
struct __ns9__GetAudioDecoderConfigurationOptions;	/* onvifgen/onvif.h:61580 */
struct __ns9__GetGuaranteedNumberOfVideoEncoderInstances;	/* onvifgen/onvif.h:61650 */
struct __ns9__GetStreamUri;	/* onvifgen/onvif.h:61742 */
struct __ns9__StartMulticastStreaming;	/* onvifgen/onvif.h:61817 */
struct __ns9__StopMulticastStreaming;	/* onvifgen/onvif.h:61885 */
struct __ns9__SetSynchronizationPoint;	/* onvifgen/onvif.h:61970 */
struct __ns9__GetSnapshotUri;	/* onvifgen/onvif.h:62048 */
struct __ns9__GetVideoSourceModes;	/* onvifgen/onvif.h:62118 */
struct __ns9__SetVideoSourceMode;	/* onvifgen/onvif.h:62189 */
struct __ns9__GetOSDs;	/* onvifgen/onvif.h:62257 */
struct __ns9__GetOSD;	/* onvifgen/onvif.h:62325 */
struct __ns9__GetOSDOptions;	/* onvifgen/onvif.h:62393 */
struct __ns9__SetOSD;	/* onvifgen/onvif.h:62461 */
struct __ns9__CreateOSD;	/* onvifgen/onvif.h:62529 */
struct __ns9__DeleteOSD;	/* onvifgen/onvif.h:62597 */

/* wsu.h:76 */
#ifndef SOAP_TYPE__wsu__Timestamp
#define SOAP_TYPE__wsu__Timestamp (9)
/* complex XSD type 'wsu:Timestamp': */
struct SOAP_CMAC _wsu__Timestamp {
      public:
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional element 'wsu:Created' of XSD type 'xsd:string' */
        char *Created;
        /** Optional element 'wsu:Expires' of XSD type 'xsd:string' */
        char *Expires;
      public:
        /** Return unique type id SOAP_TYPE__wsu__Timestamp */
        int soap_type() const { return SOAP_TYPE__wsu__Timestamp; }
        /** Constructor with member initializations */
        _wsu__Timestamp()
        {
          wsu__Id = (char *)0;
          Created = (char *)0;
          Expires = (char *)0;
        }
        /** Friend allocator used by soap_new__wsu__Timestamp(struct soap*, int) */
        friend SOAP_FMAC1 _wsu__Timestamp * SOAP_FMAC2 soap_instantiate__wsu__Timestamp(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:57 */
#ifndef SOAP_TYPE_wsse__EncodedString
#define SOAP_TYPE_wsse__EncodedString (10)
/* simple XSD type 'wsse:EncodedString': */
struct SOAP_CMAC wsse__EncodedString {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'EncodingType' of XSD type 'xsd:string' */
        char *EncodingType;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE_wsse__EncodedString */
        int soap_type() const { return SOAP_TYPE_wsse__EncodedString; }
        /** Constructor with member initializations */
        wsse__EncodedString()
        {
          __item = (char *)0;
          EncodingType = (char *)0;
          wsu__Id = (char *)0;
        }
        /** Friend allocator used by soap_new_wsse__EncodedString(struct soap*, int) */
        friend SOAP_FMAC1 wsse__EncodedString * SOAP_FMAC2 soap_instantiate_wsse__EncodedString(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:128 */
#ifndef SOAP_TYPE__wsse__UsernameToken
#define SOAP_TYPE__wsse__UsernameToken (12)
/* complex XSD type 'wsse:UsernameToken': */
struct SOAP_CMAC _wsse__UsernameToken {
      public:
        /** Optional element 'wsse:Username' of XSD type 'xsd:string' */
        char *Username;
        /** Optional element 'wsse:Password' of XSD type 'wsse:Password' */
        struct _wsse__Password *Password;
        /** Optional element 'wsse:Nonce' of XSD type 'wsse:EncodedString' */
        struct wsse__EncodedString *Nonce;
        /** Optional element 'wsu:Created' of XSD type 'xsd:string' */
        char *wsu__Created;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE__wsse__UsernameToken */
        int soap_type() const { return SOAP_TYPE__wsse__UsernameToken; }
        /** Constructor with member initializations */
        _wsse__UsernameToken()
        {
          Username = (char *)0;
          Password = (struct _wsse__Password *)0;
          Nonce = (struct wsse__EncodedString *)0;
          wsu__Created = (char *)0;
          wsu__Id = (char *)0;
        }
        /** Friend allocator used by soap_new__wsse__UsernameToken(struct soap*, int) */
        friend SOAP_FMAC1 _wsse__UsernameToken * SOAP_FMAC2 soap_instantiate__wsse__UsernameToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:139 */
#ifndef SOAP_TYPE__wsse__BinarySecurityToken
#define SOAP_TYPE__wsse__BinarySecurityToken (16)
/* simple XSD type 'wsse:BinarySecurityToken': */
struct SOAP_CMAC _wsse__BinarySecurityToken {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'ValueType' of XSD type 'xsd:string' */
        char *ValueType;
        /** Optional attribute 'EncodingType' of XSD type 'xsd:string' */
        char *EncodingType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__BinarySecurityToken */
        int soap_type() const { return SOAP_TYPE__wsse__BinarySecurityToken; }
        /** Constructor with member initializations */
        _wsse__BinarySecurityToken()
        {
          __item = (char *)0;
          wsu__Id = (char *)0;
          ValueType = (char *)0;
          EncodingType = (char *)0;
        }
        /** Friend allocator used by soap_new__wsse__BinarySecurityToken(struct soap*, int) */
        friend SOAP_FMAC1 _wsse__BinarySecurityToken * SOAP_FMAC2 soap_instantiate__wsse__BinarySecurityToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:149 */
#ifndef SOAP_TYPE__wsse__Reference
#define SOAP_TYPE__wsse__Reference (17)
/* complex XSD type 'wsse:Reference': */
struct SOAP_CMAC _wsse__Reference {
      public:
        /** Optional attribute 'URI' of XSD type 'xsd:string' */
        char *URI;
        /** Optional attribute 'ValueType' of XSD type 'xsd:string' */
        char *ValueType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Reference */
        int soap_type() const { return SOAP_TYPE__wsse__Reference; }
        /** Constructor with member initializations */
        _wsse__Reference()
        {
          URI = (char *)0;
          ValueType = (char *)0;
        }
        /** Friend allocator used by soap_new__wsse__Reference(struct soap*, int) */
        friend SOAP_FMAC1 _wsse__Reference * SOAP_FMAC2 soap_instantiate__wsse__Reference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:157 */
#ifndef SOAP_TYPE__wsse__Embedded
#define SOAP_TYPE__wsse__Embedded (18)
/* complex XSD type 'wsse:Embedded': */
struct SOAP_CMAC _wsse__Embedded {
      public:
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'ValueType' of XSD type 'xsd:string' */
        char *ValueType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Embedded */
        int soap_type() const { return SOAP_TYPE__wsse__Embedded; }
        /** Constructor with member initializations */
        _wsse__Embedded()
        {
          wsu__Id = (char *)0;
          ValueType = (char *)0;
        }
        /** Friend allocator used by soap_new__wsse__Embedded(struct soap*, int) */
        friend SOAP_FMAC1 _wsse__Embedded * SOAP_FMAC2 soap_instantiate__wsse__Embedded(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:166 */
#ifndef SOAP_TYPE__wsse__KeyIdentifier
#define SOAP_TYPE__wsse__KeyIdentifier (19)
/* simple XSD type 'wsse:KeyIdentifier': */
struct SOAP_CMAC _wsse__KeyIdentifier {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'ValueType' of XSD type 'xsd:string' */
        char *ValueType;
        /** Optional attribute 'EncodingType' of XSD type 'xsd:string' */
        char *EncodingType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__KeyIdentifier */
        int soap_type() const { return SOAP_TYPE__wsse__KeyIdentifier; }
        /** Constructor with member initializations */
        _wsse__KeyIdentifier()
        {
          __item = (char *)0;
          wsu__Id = (char *)0;
          ValueType = (char *)0;
          EncodingType = (char *)0;
        }
        /** Friend allocator used by soap_new__wsse__KeyIdentifier(struct soap*, int) */
        friend SOAP_FMAC1 _wsse__KeyIdentifier * SOAP_FMAC2 soap_instantiate__wsse__KeyIdentifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:176 */
#ifndef SOAP_TYPE__wsse__SecurityTokenReference
#define SOAP_TYPE__wsse__SecurityTokenReference (20)
/* complex XSD type 'wsse:SecurityTokenReference': */
struct SOAP_CMAC _wsse__SecurityTokenReference {
      public:
        /** Optional element 'wsse:Reference' of XSD type 'wsse:Reference' */
        struct _wsse__Reference *Reference;
        /** Optional element 'wsse:KeyIdentifier' of XSD type 'wsse:KeyIdentifier' */
        struct _wsse__KeyIdentifier *KeyIdentifier;
        /** Optional element 'wsse:Embedded' of XSD type 'wsse:Embedded' */
        struct _wsse__Embedded *Embedded;
        /** Optional element 'ds:X509Data' of XSD type 'ds:X509DataType' */
        struct ds__X509DataType *ds__X509Data;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'wsc:Instance' of XSD type 'xsd:string' */
        char *wsc__Instance;
        /** Optional attribute 'Usage' of XSD type 'xsd:string' */
        char *Usage;
      public:
        /** Return unique type id SOAP_TYPE__wsse__SecurityTokenReference */
        int soap_type() const { return SOAP_TYPE__wsse__SecurityTokenReference; }
        /** Constructor with member initializations */
        _wsse__SecurityTokenReference()
        {
          Reference = (struct _wsse__Reference *)0;
          KeyIdentifier = (struct _wsse__KeyIdentifier *)0;
          Embedded = (struct _wsse__Embedded *)0;
          ds__X509Data = (struct ds__X509DataType *)0;
          wsu__Id = (char *)0;
          wsc__Instance = (char *)0;
          Usage = (char *)0;
        }
        /** Friend allocator used by soap_new__wsse__SecurityTokenReference(struct soap*, int) */
        friend SOAP_FMAC1 _wsse__SecurityTokenReference * SOAP_FMAC2 soap_instantiate__wsse__SecurityTokenReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:46 */
#ifndef SOAP_TYPE_ds__SignatureType
#define SOAP_TYPE_ds__SignatureType (27)
/* complex XSD type 'ds:SignatureType': */
struct SOAP_CMAC ds__SignatureType {
      public:
        /** Optional element 'ds:SignedInfo' of XSD type 'ds:SignedInfoType' */
        struct ds__SignedInfoType *SignedInfo;
        /** Optional element 'ds:SignatureValue' of XSD type 'ds:SignatureValue' */
        char *SignatureValue;
        /** Optional element 'ds:KeyInfo' of XSD type 'ds:KeyInfoType' */
        struct ds__KeyInfoType *KeyInfo;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_ds__SignatureType */
        int soap_type() const { return SOAP_TYPE_ds__SignatureType; }
        /** Constructor with member initializations */
        ds__SignatureType()
        {
          SignedInfo = (struct ds__SignedInfoType *)0;
          SignatureValue = (char *)0;
          KeyInfo = (struct ds__KeyInfoType *)0;
          Id = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__SignatureType(struct soap*, int) */
        friend SOAP_FMAC1 ds__SignatureType * SOAP_FMAC2 soap_instantiate_ds__SignatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* c14n.h:24 */
#ifndef SOAP_TYPE__c14n__InclusiveNamespaces
#define SOAP_TYPE__c14n__InclusiveNamespaces (37)
/* complex XSD type 'c14n:InclusiveNamespaces': */
struct SOAP_CMAC _c14n__InclusiveNamespaces {
      public:
        /** Optional attribute 'PrefixList' of XSD type 'xsd:string' */
        char *PrefixList;
      public:
        /** Return unique type id SOAP_TYPE__c14n__InclusiveNamespaces */
        int soap_type() const { return SOAP_TYPE__c14n__InclusiveNamespaces; }
        /** Constructor with member initializations */
        _c14n__InclusiveNamespaces()
        {
          PrefixList = (char *)0;
        }
        /** Friend allocator used by soap_new__c14n__InclusiveNamespaces(struct soap*, int) */
        friend SOAP_FMAC1 _c14n__InclusiveNamespaces * SOAP_FMAC2 soap_instantiate__c14n__InclusiveNamespaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:73 */
#ifndef SOAP_TYPE_ds__TransformType
#define SOAP_TYPE_ds__TransformType (38)
/* complex XSD type 'ds:TransformType': */
struct SOAP_CMAC ds__TransformType {
      public:
        /** Optional element 'c14n:InclusiveNamespaces' of XSD type 'c14n:InclusiveNamespaces' */
        struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;
        char *__any;
        /** Optional attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_ds__TransformType */
        int soap_type() const { return SOAP_TYPE_ds__TransformType; }
        /** Constructor with member initializations */
        ds__TransformType()
        {
          c14n__InclusiveNamespaces = (struct _c14n__InclusiveNamespaces *)0;
          __any = (char *)0;
          Algorithm = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__TransformType(struct soap*, int) */
        friend SOAP_FMAC1 ds__TransformType * SOAP_FMAC2 soap_instantiate_ds__TransformType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:48 */
#ifndef SOAP_TYPE_ds__KeyInfoType
#define SOAP_TYPE_ds__KeyInfoType (30)
/* complex XSD type 'ds:KeyInfoType': */
struct SOAP_CMAC ds__KeyInfoType {
      public:
        /** Optional element 'ds:KeyName' of XSD type 'xsd:string' */
        char *KeyName;
        /** Optional element 'ds:KeyValue' of XSD type 'ds:KeyValueType' */
        struct ds__KeyValueType *KeyValue;
        /** Optional element 'ds:RetrievalMethod' of XSD type 'ds:RetrievalMethodType' */
        struct ds__RetrievalMethodType *RetrievalMethod;
        /** Optional element 'ds:X509Data' of XSD type 'ds:X509DataType' */
        struct ds__X509DataType *X509Data;
        /** Optional element 'wsse:SecurityTokenReference' of XSD type 'wsse:SecurityTokenReference' */
        struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_ds__KeyInfoType */
        int soap_type() const { return SOAP_TYPE_ds__KeyInfoType; }
        /** Constructor with member initializations */
        ds__KeyInfoType()
        {
          KeyName = (char *)0;
          KeyValue = (struct ds__KeyValueType *)0;
          RetrievalMethod = (struct ds__RetrievalMethodType *)0;
          X509Data = (struct ds__X509DataType *)0;
          wsse__SecurityTokenReference = (struct _wsse__SecurityTokenReference *)0;
          Id = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__KeyInfoType(struct soap*, int) */
        friend SOAP_FMAC1 ds__KeyInfoType * SOAP_FMAC2 soap_instantiate_ds__KeyInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:46 */
#ifndef SOAP_TYPE_ds__SignedInfoType
#define SOAP_TYPE_ds__SignedInfoType (28)
/* complex XSD type 'ds:SignedInfoType': */
struct SOAP_CMAC ds__SignedInfoType {
      public:
        /** Required element 'ds:CanonicalizationMethod' of XSD type 'ds:CanonicalizationMethodType' */
        struct ds__CanonicalizationMethodType *CanonicalizationMethod;
        /** Required element 'ds:SignatureMethod' of XSD type 'ds:SignatureMethodType' */
        struct ds__SignatureMethodType *SignatureMethod;
        /** Sequence of elements 'ds:Reference' of XSD type 'ds:ReferenceType' stored in dynamic array Reference of length __sizeReference */
        int __sizeReference;
        struct ds__ReferenceType **Reference;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_ds__SignedInfoType */
        int soap_type() const { return SOAP_TYPE_ds__SignedInfoType; }
        /** Constructor with member initializations */
        ds__SignedInfoType()
        {
          CanonicalizationMethod = (struct ds__CanonicalizationMethodType *)0;
          SignatureMethod = (struct ds__SignatureMethodType *)0;
          __sizeReference = 0;
          Reference = NULL;
          Id = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__SignedInfoType(struct soap*, int) */
        friend SOAP_FMAC1 ds__SignedInfoType * SOAP_FMAC2 soap_instantiate_ds__SignedInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:59 */
#ifndef SOAP_TYPE_ds__CanonicalizationMethodType
#define SOAP_TYPE_ds__CanonicalizationMethodType (33)
/* complex XSD type 'ds:CanonicalizationMethodType': */
struct SOAP_CMAC ds__CanonicalizationMethodType {
      public:
        /** Required attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
        /** Optional element 'c14n:InclusiveNamespaces' of XSD type 'c14n:InclusiveNamespaces' */
        struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;
      public:
        /** Return unique type id SOAP_TYPE_ds__CanonicalizationMethodType */
        int soap_type() const { return SOAP_TYPE_ds__CanonicalizationMethodType; }
        /** Constructor with member initializations */
        ds__CanonicalizationMethodType()
        {
          Algorithm = (char *)0;
          c14n__InclusiveNamespaces = (struct _c14n__InclusiveNamespaces *)0;
        }
        /** Friend allocator used by soap_new_ds__CanonicalizationMethodType(struct soap*, int) */
        friend SOAP_FMAC1 ds__CanonicalizationMethodType * SOAP_FMAC2 soap_instantiate_ds__CanonicalizationMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:62 */
#ifndef SOAP_TYPE_ds__SignatureMethodType
#define SOAP_TYPE_ds__SignatureMethodType (34)
/* complex XSD type 'ds:SignatureMethodType': */
struct SOAP_CMAC ds__SignatureMethodType {
      public:
        /** Optional element 'ds:HMACOutputLength' of XSD type 'xsd:int' */
        int *HMACOutputLength;
        /** Required attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_ds__SignatureMethodType */
        int soap_type() const { return SOAP_TYPE_ds__SignatureMethodType; }
        /** Constructor with member initializations */
        ds__SignatureMethodType()
        {
          HMACOutputLength = (int *)0;
          Algorithm = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__SignatureMethodType(struct soap*, int) */
        friend SOAP_FMAC1 ds__SignatureMethodType * SOAP_FMAC2 soap_instantiate_ds__SignatureMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:65 */
#ifndef SOAP_TYPE_ds__ReferenceType
#define SOAP_TYPE_ds__ReferenceType (35)
/* complex XSD type 'ds:ReferenceType': */
struct SOAP_CMAC ds__ReferenceType {
      public:
        /** Optional element 'ds:Transforms' of XSD type 'ds:TransformsType' */
        struct ds__TransformsType *Transforms;
        /** Required element 'ds:DigestMethod' of XSD type 'ds:DigestMethodType' */
        struct ds__DigestMethodType *DigestMethod;
        /** Required element 'ds:DigestValue' of XSD type 'xsd:string' */
        char *DigestValue;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
        /** Optional attribute 'URI' of XSD type 'xsd:string' */
        char *URI;
        /** Optional attribute 'Type' of XSD type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE_ds__ReferenceType */
        int soap_type() const { return SOAP_TYPE_ds__ReferenceType; }
        /** Constructor with member initializations */
        ds__ReferenceType()
        {
          Transforms = (struct ds__TransformsType *)0;
          DigestMethod = (struct ds__DigestMethodType *)0;
          DigestValue = (char *)0;
          Id = (char *)0;
          URI = (char *)0;
          Type = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__ReferenceType(struct soap*, int) */
        friend SOAP_FMAC1 ds__ReferenceType * SOAP_FMAC2 soap_instantiate_ds__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:68 */
#ifndef SOAP_TYPE_ds__TransformsType
#define SOAP_TYPE_ds__TransformsType (36)
/* complex XSD type 'ds:TransformsType': */
struct SOAP_CMAC ds__TransformsType {
      public:
        /** Sequence of elements 'ds:Transform' of XSD type 'ds:TransformType' stored in dynamic array Transform of length __sizeTransform */
        int __sizeTransform;
        struct ds__TransformType *Transform;
      public:
        /** Return unique type id SOAP_TYPE_ds__TransformsType */
        int soap_type() const { return SOAP_TYPE_ds__TransformsType; }
        /** Constructor with member initializations */
        ds__TransformsType()
        {
          __sizeTransform = 0;
          Transform = NULL;
        }
        /** Friend allocator used by soap_new_ds__TransformsType(struct soap*, int) */
        friend SOAP_FMAC1 ds__TransformsType * SOAP_FMAC2 soap_instantiate_ds__TransformsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:79 */
#ifndef SOAP_TYPE_ds__DigestMethodType
#define SOAP_TYPE_ds__DigestMethodType (41)
/* complex XSD type 'ds:DigestMethodType': */
struct SOAP_CMAC ds__DigestMethodType {
      public:
        /** Required attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_ds__DigestMethodType */
        int soap_type() const { return SOAP_TYPE_ds__DigestMethodType; }
        /** Constructor with member initializations */
        ds__DigestMethodType()
        {
          Algorithm = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__DigestMethodType(struct soap*, int) */
        friend SOAP_FMAC1 ds__DigestMethodType * SOAP_FMAC2 soap_instantiate_ds__DigestMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:84 */
#ifndef SOAP_TYPE_ds__KeyValueType
#define SOAP_TYPE_ds__KeyValueType (42)
/* complex XSD type 'ds:KeyValueType': */
struct SOAP_CMAC ds__KeyValueType {
      public:
        /** Optional element 'ds:DSAKeyValue' of XSD type 'ds:DSAKeyValueType' */
        struct ds__DSAKeyValueType *DSAKeyValue;
        /** Optional element 'ds:RSAKeyValue' of XSD type 'ds:RSAKeyValueType' */
        struct ds__RSAKeyValueType *RSAKeyValue;
      public:
        /** Return unique type id SOAP_TYPE_ds__KeyValueType */
        int soap_type() const { return SOAP_TYPE_ds__KeyValueType; }
        /** Constructor with member initializations */
        ds__KeyValueType()
        {
          DSAKeyValue = (struct ds__DSAKeyValueType *)0;
          RSAKeyValue = (struct ds__RSAKeyValueType *)0;
        }
        /** Friend allocator used by soap_new_ds__KeyValueType(struct soap*, int) */
        friend SOAP_FMAC1 ds__KeyValueType * SOAP_FMAC2 soap_instantiate_ds__KeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:85 */
#ifndef SOAP_TYPE_ds__RetrievalMethodType
#define SOAP_TYPE_ds__RetrievalMethodType (44)
/* complex XSD type 'ds:RetrievalMethodType': */
struct SOAP_CMAC ds__RetrievalMethodType {
      public:
        /** Optional element 'ds:Transforms' of XSD type 'ds:TransformsType' */
        struct ds__TransformsType *Transforms;
        /** Optional attribute 'URI' of XSD type 'xsd:string' */
        char *URI;
        /** Optional attribute 'Type' of XSD type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE_ds__RetrievalMethodType */
        int soap_type() const { return SOAP_TYPE_ds__RetrievalMethodType; }
        /** Constructor with member initializations */
        ds__RetrievalMethodType()
        {
          Transforms = (struct ds__TransformsType *)0;
          URI = (char *)0;
          Type = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__RetrievalMethodType(struct soap*, int) */
        friend SOAP_FMAC1 ds__RetrievalMethodType * SOAP_FMAC2 soap_instantiate_ds__RetrievalMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:179 */
#ifndef SOAP_TYPE_ds__X509DataType
#define SOAP_TYPE_ds__X509DataType (24)
/* complex XSD type 'ds:X509DataType': */
struct SOAP_CMAC ds__X509DataType {
      public:
        /** Optional element 'ds:X509IssuerSerial' of XSD type 'ds:X509IssuerSerialType' */
        struct ds__X509IssuerSerialType *X509IssuerSerial;
        /** Optional element 'ds:X509SKI' of XSD type 'xsd:string' */
        char *X509SKI;
        /** Optional element 'ds:X509SubjectName' of XSD type 'xsd:string' */
        char *X509SubjectName;
        /** Optional element 'ds:X509Certificate' of XSD type 'xsd:string' */
        char *X509Certificate;
        /** Optional element 'ds:X509CRL' of XSD type 'xsd:string' */
        char *X509CRL;
      public:
        /** Return unique type id SOAP_TYPE_ds__X509DataType */
        int soap_type() const { return SOAP_TYPE_ds__X509DataType; }
        /** Constructor with member initializations */
        ds__X509DataType()
        {
          X509IssuerSerial = (struct ds__X509IssuerSerialType *)0;
          X509SKI = (char *)0;
          X509SubjectName = (char *)0;
          X509Certificate = (char *)0;
          X509CRL = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__X509DataType(struct soap*, int) */
        friend SOAP_FMAC1 ds__X509DataType * SOAP_FMAC2 soap_instantiate_ds__X509DataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:102 */
#ifndef SOAP_TYPE_ds__X509IssuerSerialType
#define SOAP_TYPE_ds__X509IssuerSerialType (48)
/* complex XSD type 'ds:X509IssuerSerialType': */
struct SOAP_CMAC ds__X509IssuerSerialType {
      public:
        /** Required element 'ds:X509IssuerName' of XSD type 'xsd:string' */
        char *X509IssuerName;
        /** Required element 'ds:X509SerialNumber' of XSD type 'xsd:string' */
        char *X509SerialNumber;
      public:
        /** Return unique type id SOAP_TYPE_ds__X509IssuerSerialType */
        int soap_type() const { return SOAP_TYPE_ds__X509IssuerSerialType; }
        /** Constructor with member initializations */
        ds__X509IssuerSerialType()
        {
          X509IssuerName = (char *)0;
          X509SerialNumber = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__X509IssuerSerialType(struct soap*, int) */
        friend SOAP_FMAC1 ds__X509IssuerSerialType * SOAP_FMAC2 soap_instantiate_ds__X509IssuerSerialType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:123 */
#ifndef SOAP_TYPE_ds__DSAKeyValueType
#define SOAP_TYPE_ds__DSAKeyValueType (49)
/* complex XSD type 'ds:DSAKeyValueType': */
struct SOAP_CMAC ds__DSAKeyValueType {
      public:
        /** Optional element 'ds:G' of XSD type 'xsd:string' */
        char *G;
        /** Required element 'ds:Y' of XSD type 'xsd:string' */
        char *Y;
        /** Optional element 'ds:J' of XSD type 'xsd:string' */
        char *J;
        /** Required element 'ds:P' of XSD type 'xsd:string' */
        char *P;
        /** Required element 'ds:Q' of XSD type 'xsd:string' */
        char *Q;
        /** Required element 'ds:Seed' of XSD type 'xsd:string' */
        char *Seed;
        /** Required element 'ds:PgenCounter' of XSD type 'xsd:string' */
        char *PgenCounter;
      public:
        /** Return unique type id SOAP_TYPE_ds__DSAKeyValueType */
        int soap_type() const { return SOAP_TYPE_ds__DSAKeyValueType; }
        /** Constructor with member initializations */
        ds__DSAKeyValueType()
        {
          G = (char *)0;
          Y = (char *)0;
          J = (char *)0;
          P = (char *)0;
          Q = (char *)0;
          Seed = (char *)0;
          PgenCounter = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__DSAKeyValueType(struct soap*, int) */
        friend SOAP_FMAC1 ds__DSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__DSAKeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:126 */
#ifndef SOAP_TYPE_ds__RSAKeyValueType
#define SOAP_TYPE_ds__RSAKeyValueType (50)
/* complex XSD type 'ds:RSAKeyValueType': */
struct SOAP_CMAC ds__RSAKeyValueType {
      public:
        /** Required element 'ds:Modulus' of XSD type 'xsd:string' */
        char *Modulus;
        /** Required element 'ds:Exponent' of XSD type 'xsd:string' */
        char *Exponent;
      public:
        /** Return unique type id SOAP_TYPE_ds__RSAKeyValueType */
        int soap_type() const { return SOAP_TYPE_ds__RSAKeyValueType; }
        /** Constructor with member initializations */
        ds__RSAKeyValueType()
        {
          Modulus = (char *)0;
          Exponent = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__RSAKeyValueType(struct soap*, int) */
        friend SOAP_FMAC1 ds__RSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__RSAKeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:84 */
#ifndef SOAP_TYPE_xenc__EncryptionPropertyType
#define SOAP_TYPE_xenc__EncryptionPropertyType (72)
/* complex XSD type 'xenc:EncryptionPropertyType': */
struct SOAP_CMAC xenc__EncryptionPropertyType {
      public:
        /** Optional attribute 'Target' of XSD type 'xsd:string' */
        char *Target;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptionPropertyType */
        int soap_type() const { return SOAP_TYPE_xenc__EncryptionPropertyType; }
        /** Constructor with member initializations */
        xenc__EncryptionPropertyType()
        {
          Target = (char *)0;
          Id = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__EncryptionPropertyType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__EncryptionPropertyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:53 */
#ifndef SOAP_TYPE_xenc__EncryptedType
#define SOAP_TYPE_xenc__EncryptedType (62)
/* complex XSD type 'xenc:EncryptedType': */
struct SOAP_CMAC xenc__EncryptedType {
      public:
        /** Optional element 'xenc:EncryptionMethod' of XSD type 'xenc:EncryptionMethodType' */
        struct xenc__EncryptionMethodType *EncryptionMethod;
        /** Optional element 'ds:KeyInfo' of XSD type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
        /** Required element 'xenc:CipherData' of XSD type 'xenc:CipherDataType' */
        struct xenc__CipherDataType *CipherData;
        /** Optional element 'xenc:EncryptionProperties' of XSD type 'xenc:EncryptionPropertiesType' */
        struct xenc__EncryptionPropertiesType *EncryptionProperties;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
        /** Optional attribute 'Type' of XSD type 'xsd:string' */
        char *Type;
        /** Optional attribute 'MimeType' of XSD type 'xsd:string' */
        char *MimeType;
        /** Optional attribute 'Encoding' of XSD type 'xsd:string' */
        char *Encoding;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptedType */
        int soap_type() const { return SOAP_TYPE_xenc__EncryptedType; }
        /** Constructor with member initializations */
        xenc__EncryptedType()
        {
          EncryptionMethod = (struct xenc__EncryptionMethodType *)0;
          ds__KeyInfo = (struct ds__KeyInfoType *)0;
          CipherData = (struct xenc__CipherDataType *)0;
          EncryptionProperties = (struct xenc__EncryptionPropertiesType *)0;
          Id = (char *)0;
          Type = (char *)0;
          MimeType = (char *)0;
          Encoding = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__EncryptedType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__EncryptedType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:56 */
#ifndef SOAP_TYPE_xenc__EncryptionMethodType
#define SOAP_TYPE_xenc__EncryptionMethodType (63)
/* complex XSD type 'xenc:EncryptionMethodType': */
struct SOAP_CMAC xenc__EncryptionMethodType {
      public:
        /** Optional element 'xenc:KeySize' of XSD type 'xsd:int' */
        int *KeySize;
        /** Optional element 'xenc:OAEPparams' of XSD type 'xsd:string' */
        char *OAEPparams;
        /** Required attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
        /** Optional element 'ds:DigestMethod' of XSD type 'ds:DigestMethodType' */
        struct ds__DigestMethodType *ds__DigestMethod;
        char *__mixed;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptionMethodType */
        int soap_type() const { return SOAP_TYPE_xenc__EncryptionMethodType; }
        /** Constructor with member initializations */
        xenc__EncryptionMethodType()
        {
          KeySize = (int *)0;
          OAEPparams = (char *)0;
          Algorithm = (char *)0;
          ds__DigestMethod = (struct ds__DigestMethodType *)0;
          __mixed = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__EncryptionMethodType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__EncryptionMethodType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:59 */
#ifndef SOAP_TYPE_xenc__CipherDataType
#define SOAP_TYPE_xenc__CipherDataType (64)
/* complex XSD type 'xenc:CipherDataType': */
struct SOAP_CMAC xenc__CipherDataType {
      public:
        /** Optional element 'xenc:CipherValue' of XSD type 'xsd:string' */
        char *CipherValue;
        /** Optional element 'xenc:CipherReference' of XSD type 'xenc:CipherReferenceType' */
        struct xenc__CipherReferenceType *CipherReference;
      public:
        /** Return unique type id SOAP_TYPE_xenc__CipherDataType */
        int soap_type() const { return SOAP_TYPE_xenc__CipherDataType; }
        /** Constructor with member initializations */
        xenc__CipherDataType()
        {
          CipherValue = (char *)0;
          CipherReference = (struct xenc__CipherReferenceType *)0;
        }
        /** Friend allocator used by soap_new_xenc__CipherDataType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__CipherDataType * SOAP_FMAC2 soap_instantiate_xenc__CipherDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:62 */
#ifndef SOAP_TYPE_xenc__CipherReferenceType
#define SOAP_TYPE_xenc__CipherReferenceType (65)
/* complex XSD type 'xenc:CipherReferenceType': */
struct SOAP_CMAC xenc__CipherReferenceType {
      public:
        /** Optional element 'xenc:Transforms' of XSD type 'xenc:TransformsType' */
        struct xenc__TransformsType *Transforms;
        /** Required attribute 'URI' of XSD type 'xsd:string' */
        char *URI;
      public:
        /** Return unique type id SOAP_TYPE_xenc__CipherReferenceType */
        int soap_type() const { return SOAP_TYPE_xenc__CipherReferenceType; }
        /** Constructor with member initializations */
        xenc__CipherReferenceType()
        {
          Transforms = (struct xenc__TransformsType *)0;
          URI = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__CipherReferenceType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__CipherReferenceType * SOAP_FMAC2 soap_instantiate_xenc__CipherReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:65 */
#ifndef SOAP_TYPE_xenc__TransformsType
#define SOAP_TYPE_xenc__TransformsType (66)
/* complex XSD type 'xenc:TransformsType': */
struct SOAP_CMAC xenc__TransformsType {
      public:
        /** Required element 'ds:Transform' of XSD type 'ds:Transform' */
        struct ds__TransformType ds__Transform;
      public:
        /** Return unique type id SOAP_TYPE_xenc__TransformsType */
        int soap_type() const { return SOAP_TYPE_xenc__TransformsType; }
        /** Constructor with member initializations */
        xenc__TransformsType()
        {
        }
        /** Friend allocator used by soap_new_xenc__TransformsType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__TransformsType * SOAP_FMAC2 soap_instantiate_xenc__TransformsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:74 */
#ifndef SOAP_TYPE_xenc__AgreementMethodType
#define SOAP_TYPE_xenc__AgreementMethodType (69)
/* complex XSD type 'xenc:AgreementMethodType': */
struct SOAP_CMAC xenc__AgreementMethodType {
      public:
        /** Optional element 'xenc:KA-Nonce' of XSD type 'xsd:string' */
        char *KA_Nonce;
        /** Optional element 'xenc:OriginatorKeyInfo' of XSD type 'ds:KeyInfoType' */
        struct ds__KeyInfoType *OriginatorKeyInfo;
        /** Optional element 'xenc:RecipientKeyInfo' of XSD type 'ds:KeyInfoType' */
        struct ds__KeyInfoType *RecipientKeyInfo;
        /** Required attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
        char *__mixed;
      public:
        /** Return unique type id SOAP_TYPE_xenc__AgreementMethodType */
        int soap_type() const { return SOAP_TYPE_xenc__AgreementMethodType; }
        /** Constructor with member initializations */
        xenc__AgreementMethodType()
        {
          KA_Nonce = (char *)0;
          OriginatorKeyInfo = (struct ds__KeyInfoType *)0;
          RecipientKeyInfo = (struct ds__KeyInfoType *)0;
          Algorithm = (char *)0;
          __mixed = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__AgreementMethodType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__AgreementMethodType * SOAP_FMAC2 soap_instantiate_xenc__AgreementMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:77 */
#ifndef SOAP_TYPE_xenc__ReferenceType
#define SOAP_TYPE_xenc__ReferenceType (70)
/* complex XSD type 'xenc:ReferenceType': */
struct SOAP_CMAC xenc__ReferenceType {
      public:
        /** Required attribute 'URI' of XSD type 'xsd:string' */
        char *URI;
      public:
        /** Return unique type id SOAP_TYPE_xenc__ReferenceType */
        int soap_type() const { return SOAP_TYPE_xenc__ReferenceType; }
        /** Constructor with member initializations */
        xenc__ReferenceType()
        {
          URI = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__ReferenceType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__ReferenceType * SOAP_FMAC2 soap_instantiate_xenc__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:80 */
#ifndef SOAP_TYPE_xenc__EncryptionPropertiesType
#define SOAP_TYPE_xenc__EncryptionPropertiesType (71)
/* complex XSD type 'xenc:EncryptionPropertiesType': */
struct SOAP_CMAC xenc__EncryptionPropertiesType {
      public:
        /** Sequence of at least 1 elements 'xenc:EncryptionProperty' of XSD type 'xenc:EncryptionPropertyType' stored in dynamic array EncryptionProperty of length __sizeEncryptionProperty */
        int __sizeEncryptionProperty;
        struct xenc__EncryptionPropertyType *EncryptionProperty;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptionPropertiesType */
        int soap_type() const { return SOAP_TYPE_xenc__EncryptionPropertiesType; }
        /** Constructor with member initializations */
        xenc__EncryptionPropertiesType()
        {
          __sizeEncryptionProperty = 0;
          EncryptionProperty = NULL;
          Id = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__EncryptionPropertiesType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__EncryptionPropertiesType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:238 */
#ifndef SOAP_TYPE___xenc__union_ReferenceList
#define SOAP_TYPE___xenc__union_ReferenceList (81)
/* Wrapper: */
struct SOAP_CMAC __xenc__union_ReferenceList {
      public:
        /** Optional element 'xenc:DataReference' of XSD type 'xenc:ReferenceType' */
        struct xenc__ReferenceType *DataReference;
        /** Optional element 'xenc:KeyReference' of XSD type 'xenc:ReferenceType' */
        struct xenc__ReferenceType *KeyReference;
      public:
        /** Return unique type id SOAP_TYPE___xenc__union_ReferenceList */
        int soap_type() const { return SOAP_TYPE___xenc__union_ReferenceList; }
        /** Constructor with member initializations */
        __xenc__union_ReferenceList()
        {
          DataReference = (struct xenc__ReferenceType *)0;
          KeyReference = (struct xenc__ReferenceType *)0;
        }
        /** Friend allocator used by soap_new___xenc__union_ReferenceList(struct soap*, int) */
        friend SOAP_FMAC1 __xenc__union_ReferenceList * SOAP_FMAC2 soap_instantiate___xenc__union_ReferenceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:89 */
#ifndef SOAP_TYPE__xenc__ReferenceList
#define SOAP_TYPE__xenc__ReferenceList (73)
/* complex XSD type 'xenc:ReferenceList': */
struct SOAP_CMAC _xenc__ReferenceList {
      public:
        /** Sequence of at least 1 elements '-union-ReferenceList' of XSD type '-xenc:union-ReferenceList' stored in dynamic array __union_ReferenceList of length __size_ReferenceList */
        int __size_ReferenceList;
        struct __xenc__union_ReferenceList *__union_ReferenceList;
      public:
        /** Return unique type id SOAP_TYPE__xenc__ReferenceList */
        int soap_type() const { return SOAP_TYPE__xenc__ReferenceList; }
        /** Constructor with member initializations */
        _xenc__ReferenceList()
        {
          __size_ReferenceList = 0;
          __union_ReferenceList = NULL;
        }
        /** Friend allocator used by soap_new__xenc__ReferenceList(struct soap*, int) */
        friend SOAP_FMAC1 _xenc__ReferenceList * SOAP_FMAC2 soap_instantiate__xenc__ReferenceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:68 */
#ifndef SOAP_TYPE_xenc__EncryptedDataType
#define SOAP_TYPE_xenc__EncryptedDataType (67)
/* complex XSD type 'xenc:EncryptedDataType': */
struct SOAP_CMAC xenc__EncryptedDataType {
      public:
        /** Optional element 'xenc:EncryptionMethod' of XSD type 'xenc:EncryptionMethodType' */
        struct xenc__EncryptionMethodType *EncryptionMethod;
        /** Optional element 'ds:KeyInfo' of XSD type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
        /** Required element 'xenc:CipherData' of XSD type 'xenc:CipherDataType' */
        struct xenc__CipherDataType *CipherData;
        /** Optional element 'xenc:EncryptionProperties' of XSD type 'xenc:EncryptionPropertiesType' */
        struct xenc__EncryptionPropertiesType *EncryptionProperties;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
        /** Optional attribute 'Type' of XSD type 'xsd:string' */
        char *Type;
        /** Optional attribute 'MimeType' of XSD type 'xsd:string' */
        char *MimeType;
        /** Optional attribute 'Encoding' of XSD type 'xsd:string' */
        char *Encoding;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptedDataType */
        int soap_type() const { return SOAP_TYPE_xenc__EncryptedDataType; }
        /** Constructor with member initializations */
        xenc__EncryptedDataType()
        {
          EncryptionMethod = (struct xenc__EncryptionMethodType *)0;
          ds__KeyInfo = (struct ds__KeyInfoType *)0;
          CipherData = (struct xenc__CipherDataType *)0;
          EncryptionProperties = (struct xenc__EncryptionPropertiesType *)0;
          Id = (char *)0;
          Type = (char *)0;
          MimeType = (char *)0;
          Encoding = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__EncryptedDataType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__EncryptedDataType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:71 */
#ifndef SOAP_TYPE_xenc__EncryptedKeyType
#define SOAP_TYPE_xenc__EncryptedKeyType (68)
/* complex XSD type 'xenc:EncryptedKeyType': */
struct SOAP_CMAC xenc__EncryptedKeyType {
      public:
        /** Optional element 'xenc:EncryptionMethod' of XSD type 'xenc:EncryptionMethodType' */
        struct xenc__EncryptionMethodType *EncryptionMethod;
        /** Optional element 'ds:KeyInfo' of XSD type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
        /** Required element 'xenc:CipherData' of XSD type 'xenc:CipherDataType' */
        struct xenc__CipherDataType *CipherData;
        /** Optional element 'xenc:EncryptionProperties' of XSD type 'xenc:EncryptionPropertiesType' */
        struct xenc__EncryptionPropertiesType *EncryptionProperties;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
        /** Optional attribute 'Type' of XSD type 'xsd:string' */
        char *Type;
        /** Optional attribute 'MimeType' of XSD type 'xsd:string' */
        char *MimeType;
        /** Optional attribute 'Encoding' of XSD type 'xsd:string' */
        char *Encoding;
        /** Optional element 'xenc:ReferenceList' of XSD type 'xenc:ReferenceList' */
        struct _xenc__ReferenceList *ReferenceList;
        /** Optional element 'xenc:CarriedKeyName' of XSD type 'xsd:string' */
        char *CarriedKeyName;
        /** Optional attribute 'Recipient' of XSD type 'xsd:string' */
        char *Recipient;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptedKeyType */
        int soap_type() const { return SOAP_TYPE_xenc__EncryptedKeyType; }
        /** Constructor with member initializations */
        xenc__EncryptedKeyType()
        {
          EncryptionMethod = (struct xenc__EncryptionMethodType *)0;
          ds__KeyInfo = (struct ds__KeyInfoType *)0;
          CipherData = (struct xenc__CipherDataType *)0;
          EncryptionProperties = (struct xenc__EncryptionPropertiesType *)0;
          Id = (char *)0;
          Type = (char *)0;
          MimeType = (char *)0;
          Encoding = (char *)0;
          ReferenceList = (struct _xenc__ReferenceList *)0;
          CarriedKeyName = (char *)0;
          Recipient = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__EncryptedKeyType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__EncryptedKeyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedKeyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:87 */
#ifndef SOAP_TYPE_wsc__SecurityContextTokenType
#define SOAP_TYPE_wsc__SecurityContextTokenType (87)
/* complex XSD type 'wsc:SecurityContextTokenType': */
struct SOAP_CMAC wsc__SecurityContextTokenType {
      public:
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional element 'wsc:Identifier' of XSD type 'xsd:string' */
        char *Identifier;
        /** Optional element 'wsc:Instance' of XSD type 'xsd:string' */
        char *Instance;
      public:
        /** Return unique type id SOAP_TYPE_wsc__SecurityContextTokenType */
        int soap_type() const { return SOAP_TYPE_wsc__SecurityContextTokenType; }
        /** Constructor with member initializations */
        wsc__SecurityContextTokenType()
        {
          wsu__Id = (char *)0;
          Identifier = (char *)0;
          Instance = (char *)0;
        }
        /** Friend allocator used by soap_new_wsc__SecurityContextTokenType(struct soap*, int) */
        friend SOAP_FMAC1 wsc__SecurityContextTokenType * SOAP_FMAC2 soap_instantiate_wsc__SecurityContextTokenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:125 */
#ifndef SOAP_TYPE__wsc__union_DerivedKeyTokenType
#define SOAP_TYPE__wsc__union_DerivedKeyTokenType (93)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _wsc__union_DerivedKeyTokenType
{
        #define SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation	(1)	/**< union variant selector value for member Generation */
        ULONG64 Generation;
        #define SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset	(2)	/**< union variant selector value for member Offset */
        ULONG64 Offset;
};
#endif

/* wsc.h:116 */
#ifndef SOAP_TYPE___wsc__DerivedKeyTokenType_sequence
#define SOAP_TYPE___wsc__DerivedKeyTokenType_sequence (91)
/* Wrapper: */
struct SOAP_CMAC __wsc__DerivedKeyTokenType_sequence {
      public:
        /** Union with union _wsc__union_DerivedKeyTokenType variant selector __union_DerivedKeyTokenType set to one of: SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset */
        int __union_DerivedKeyTokenType;
        union _wsc__union_DerivedKeyTokenType union_DerivedKeyTokenType;
        /** Optional element 'wsc:Length' of XSD type 'xsd:unsignedLong' */
        ULONG64 *Length;
      public:
        /** Return unique type id SOAP_TYPE___wsc__DerivedKeyTokenType_sequence */
        int soap_type() const { return SOAP_TYPE___wsc__DerivedKeyTokenType_sequence; }
        /** Constructor with member initializations */
        __wsc__DerivedKeyTokenType_sequence()
        {
          __union_DerivedKeyTokenType = -1;
          Length = (ULONG64 *)0;
        }
        /** Friend allocator used by soap_new___wsc__DerivedKeyTokenType_sequence(struct soap*, int) */
        friend SOAP_FMAC1 __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC2 soap_instantiate___wsc__DerivedKeyTokenType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:109 */
#ifndef SOAP_TYPE_wsc__DerivedKeyTokenType
#define SOAP_TYPE_wsc__DerivedKeyTokenType (88)
/* complex XSD type 'wsc:DerivedKeyTokenType': */
struct SOAP_CMAC wsc__DerivedKeyTokenType {
      public:
        /** Optional element 'wsse:SecurityTokenReference' of XSD type 'wsse:SecurityTokenReference' */
        struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;
        /** Optional element 'wsc:Properties' of XSD type 'wsc:PropertiesType' */
        struct wsc__PropertiesType *Properties;
        struct __wsc__DerivedKeyTokenType_sequence *__DerivedKeyTokenType_sequence;
        /** Optional element 'wsc:Label' of XSD type 'xsd:string' */
        char *Label;
        /** Optional element 'wsc:Nonce' of XSD type 'xsd:string' */
        char *Nonce;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_wsc__DerivedKeyTokenType */
        int soap_type() const { return SOAP_TYPE_wsc__DerivedKeyTokenType; }
        /** Constructor with member initializations */
        wsc__DerivedKeyTokenType()
        {
          wsse__SecurityTokenReference = (struct _wsse__SecurityTokenReference *)0;
          Properties = (struct wsc__PropertiesType *)0;
          __DerivedKeyTokenType_sequence = (struct __wsc__DerivedKeyTokenType_sequence *)0;
          Label = (char *)0;
          Nonce = (char *)0;
          wsu__Id = (char *)0;
          Algorithm = (char *)0;
        }
        /** Friend allocator used by soap_new_wsc__DerivedKeyTokenType(struct soap*, int) */
        friend SOAP_FMAC1 wsc__DerivedKeyTokenType * SOAP_FMAC2 soap_instantiate_wsc__DerivedKeyTokenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:113 */
#ifndef SOAP_TYPE_wsc__PropertiesType
#define SOAP_TYPE_wsc__PropertiesType (89)
/* complex XSD type 'wsc:PropertiesType': */
struct SOAP_CMAC wsc__PropertiesType {
      public:
        /** Return unique type id SOAP_TYPE_wsc__PropertiesType */
        int soap_type() const { return SOAP_TYPE_wsc__PropertiesType; }
        /** Constructor with member initializations */
        wsc__PropertiesType()
        {
        }
        /** Friend allocator used by soap_new_wsc__PropertiesType(struct soap*, int) */
        friend SOAP_FMAC1 wsc__PropertiesType * SOAP_FMAC2 soap_instantiate_wsc__PropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:145 */
#ifndef SOAP_TYPE___saml1__union_AssertionType
#define SOAP_TYPE___saml1__union_AssertionType (119)
/* Wrapper: */
struct SOAP_CMAC __saml1__union_AssertionType {
      public:
        /** Optional element 'saml1:Statement' of XSD type 'saml1:StatementAbstractType' */
        struct saml1__StatementAbstractType *saml1__Statement;
        /** Optional element 'saml1:SubjectStatement' of XSD type 'saml1:SubjectStatementAbstractType' */
        struct saml1__SubjectStatementAbstractType *saml1__SubjectStatement;
        /** Optional element 'saml1:AuthenticationStatement' of XSD type 'saml1:AuthenticationStatementType' */
        struct saml1__AuthenticationStatementType *saml1__AuthenticationStatement;
        /** Optional element 'saml1:AuthorizationDecisionStatement' of XSD type 'saml1:AuthorizationDecisionStatementType' */
        struct saml1__AuthorizationDecisionStatementType *saml1__AuthorizationDecisionStatement;
        /** Optional element 'saml1:AttributeStatement' of XSD type 'saml1:AttributeStatementType' */
        struct saml1__AttributeStatementType *saml1__AttributeStatement;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_AssertionType */
        int soap_type() const { return SOAP_TYPE___saml1__union_AssertionType; }
        /** Constructor with member initializations */
        __saml1__union_AssertionType()
        {
          saml1__Statement = (struct saml1__StatementAbstractType *)0;
          saml1__SubjectStatement = (struct saml1__SubjectStatementAbstractType *)0;
          saml1__AuthenticationStatement = (struct saml1__AuthenticationStatementType *)0;
          saml1__AuthorizationDecisionStatement = (struct saml1__AuthorizationDecisionStatementType *)0;
          saml1__AttributeStatement = (struct saml1__AttributeStatementType *)0;
        }
        /** Friend allocator used by soap_new___saml1__union_AssertionType(struct soap*, int) */
        friend SOAP_FMAC1 __saml1__union_AssertionType * SOAP_FMAC2 soap_instantiate___saml1__union_AssertionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:61 */
#ifndef SOAP_TYPE_saml1__AssertionType
#define SOAP_TYPE_saml1__AssertionType (96)
/* Type saml1__AssertionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'saml1:AssertionType': */
struct SOAP_CMAC saml1__AssertionType {
      public:
        /** Optional element 'saml1:Conditions' of XSD type 'saml1:ConditionsType' */
        struct saml1__ConditionsType *saml1__Conditions;
        /** Optional element 'saml1:Advice' of XSD type 'saml1:AdviceType' */
        struct saml1__AdviceType *saml1__Advice;
        /** Sequence of elements '-union-AssertionType' of XSD type '-saml1:union-AssertionType' stored in dynamic array __union_AssertionType of length __size_AssertionType */
        int __size_AssertionType;
        struct __saml1__union_AssertionType *__union_AssertionType;
        /** Optional element 'ds:Signature' of XSD type 'ds:Signature' */
        struct ds__SignatureType *ds__Signature;
        /** Required attribute 'MajorVersion' of XSD type 'xsd:string' */
        char *MajorVersion;
        /** Required attribute 'MinorVersion' of XSD type 'xsd:string' */
        char *MinorVersion;
        /** Required attribute 'AssertionID' of XSD type 'xsd:string' */
        char *AssertionID;
        /** Required attribute 'Issuer' of XSD type 'xsd:string' */
        char *Issuer;
        /** Required attribute 'IssueInstant' of XSD type 'xsd:dateTime' */
        time_t IssueInstant;
        /** Required attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AssertionType */
        int soap_type() const { return SOAP_TYPE_saml1__AssertionType; }
        /** Constructor with member initializations */
        saml1__AssertionType()
        {
          saml1__Conditions = (struct saml1__ConditionsType *)0;
          saml1__Advice = (struct saml1__AdviceType *)0;
          __size_AssertionType = 0;
          __union_AssertionType = NULL;
          ds__Signature = (struct ds__SignatureType *)0;
          MajorVersion = (char *)0;
          MinorVersion = (char *)0;
          AssertionID = (char *)0;
          Issuer = (char *)0;
          IssueInstant = (time_t)0;
          wsu__Id = (char *)0;
        }
        /** Friend allocator used by soap_new_saml1__AssertionType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__AssertionType * SOAP_FMAC2 soap_instantiate_saml1__AssertionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:187 */
#ifndef SOAP_TYPE___saml1__union_ConditionsType
#define SOAP_TYPE___saml1__union_ConditionsType (128)
/* Wrapper: */
struct SOAP_CMAC __saml1__union_ConditionsType {
      public:
        /** Optional element 'saml1:AudienceRestrictionCondition' of XSD type 'saml1:AudienceRestrictionConditionType' */
        struct saml1__AudienceRestrictionConditionType *saml1__AudienceRestrictionCondition;
        /** Optional element 'saml1:DoNotCacheCondition' of XSD type 'saml1:DoNotCacheConditionType' */
        struct saml1__DoNotCacheConditionType *saml1__DoNotCacheCondition;
        /** Optional element 'saml1:Condition' of XSD type 'saml1:ConditionAbstractType' */
        struct saml1__ConditionAbstractType *saml1__Condition;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_ConditionsType */
        int soap_type() const { return SOAP_TYPE___saml1__union_ConditionsType; }
        /** Constructor with member initializations */
        __saml1__union_ConditionsType()
        {
          saml1__AudienceRestrictionCondition = (struct saml1__AudienceRestrictionConditionType *)0;
          saml1__DoNotCacheCondition = (struct saml1__DoNotCacheConditionType *)0;
          saml1__Condition = (struct saml1__ConditionAbstractType *)0;
        }
        /** Friend allocator used by soap_new___saml1__union_ConditionsType(struct soap*, int) */
        friend SOAP_FMAC1 __saml1__union_ConditionsType * SOAP_FMAC2 soap_instantiate___saml1__union_ConditionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:63 */
#ifndef SOAP_TYPE_saml1__ConditionsType
#define SOAP_TYPE_saml1__ConditionsType (97)
/* complex XSD type 'saml1:ConditionsType': */
struct SOAP_CMAC saml1__ConditionsType {
      public:
        /** Sequence of elements '-union-ConditionsType' of XSD type '-saml1:union-ConditionsType' stored in dynamic array __union_ConditionsType of length __size_ConditionsType */
        int __size_ConditionsType;
        struct __saml1__union_ConditionsType *__union_ConditionsType;
        /** Optional attribute 'NotBefore' of XSD type 'xsd:dateTime' */
        time_t *NotBefore;
        /** Optional attribute 'NotOnOrAfter' of XSD type 'xsd:dateTime' */
        time_t *NotOnOrAfter;
      public:
        /** Return unique type id SOAP_TYPE_saml1__ConditionsType */
        int soap_type() const { return SOAP_TYPE_saml1__ConditionsType; }
        /** Constructor with member initializations */
        saml1__ConditionsType()
        {
          __size_ConditionsType = 0;
          __union_ConditionsType = NULL;
          NotBefore = (time_t *)0;
          NotOnOrAfter = (time_t *)0;
        }
        /** Friend allocator used by soap_new_saml1__ConditionsType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__ConditionsType * SOAP_FMAC2 soap_instantiate_saml1__ConditionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:65 */
#ifndef SOAP_TYPE_saml1__ConditionAbstractType
#define SOAP_TYPE_saml1__ConditionAbstractType (98)
/* complex XSD type 'saml1:ConditionAbstractType': */
struct SOAP_CMAC saml1__ConditionAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml1__ConditionAbstractType */
        int soap_type() const { return SOAP_TYPE_saml1__ConditionAbstractType; }
        /** Constructor with member initializations */
        saml1__ConditionAbstractType()
        {
        }
        /** Friend allocator used by soap_new_saml1__ConditionAbstractType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__ConditionAbstractType * SOAP_FMAC2 soap_instantiate_saml1__ConditionAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:227 */
#ifndef SOAP_TYPE___saml1__union_AdviceType
#define SOAP_TYPE___saml1__union_AdviceType (134)
/* Wrapper: */
struct SOAP_CMAC __saml1__union_AdviceType {
      public:
        /** Optional element 'saml1:AssertionIDReference' of XSD type 'xsd:string' */
        char *saml1__AssertionIDReference;
        /** Optional element 'saml1:Assertion' of XSD type 'saml1:AssertionType' */
        struct saml1__AssertionType *saml1__Assertion;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_AdviceType */
        int soap_type() const { return SOAP_TYPE___saml1__union_AdviceType; }
        /** Constructor with member initializations */
        __saml1__union_AdviceType()
        {
          saml1__AssertionIDReference = (char *)0;
          saml1__Assertion = (struct saml1__AssertionType *)0;
        }
        /** Friend allocator used by soap_new___saml1__union_AdviceType(struct soap*, int) */
        friend SOAP_FMAC1 __saml1__union_AdviceType * SOAP_FMAC2 soap_instantiate___saml1__union_AdviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:71 */
#ifndef SOAP_TYPE_saml1__AdviceType
#define SOAP_TYPE_saml1__AdviceType (101)
/* complex XSD type 'saml1:AdviceType': */
struct SOAP_CMAC saml1__AdviceType {
      public:
        /** Sequence of elements '-union-AdviceType' of XSD type '-saml1:union-AdviceType' stored in dynamic array __union_AdviceType of length __size_AdviceType */
        int __size_AdviceType;
        struct __saml1__union_AdviceType *__union_AdviceType;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AdviceType */
        int soap_type() const { return SOAP_TYPE_saml1__AdviceType; }
        /** Constructor with member initializations */
        saml1__AdviceType()
        {
          __size_AdviceType = 0;
          __union_AdviceType = NULL;
        }
        /** Friend allocator used by soap_new_saml1__AdviceType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__AdviceType * SOAP_FMAC2 soap_instantiate_saml1__AdviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:73 */
#ifndef SOAP_TYPE_saml1__StatementAbstractType
#define SOAP_TYPE_saml1__StatementAbstractType (102)
/* complex XSD type 'saml1:StatementAbstractType': */
struct SOAP_CMAC saml1__StatementAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml1__StatementAbstractType */
        int soap_type() const { return SOAP_TYPE_saml1__StatementAbstractType; }
        /** Constructor with member initializations */
        saml1__StatementAbstractType()
        {
        }
        /** Friend allocator used by soap_new_saml1__StatementAbstractType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__StatementAbstractType * SOAP_FMAC2 soap_instantiate_saml1__StatementAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:77 */
#ifndef SOAP_TYPE_saml1__SubjectType
#define SOAP_TYPE_saml1__SubjectType (104)
/* complex XSD type 'saml1:SubjectType': */
struct SOAP_CMAC saml1__SubjectType {
      public:
        /** Optional element 'saml1:NameIdentifier' of XSD type 'saml1:NameIdentifierType' */
        struct saml1__NameIdentifierType *saml1__NameIdentifier;
        /** Optional element 'saml1:SubjectConfirmation' of XSD type 'saml1:SubjectConfirmationType' */
        struct saml1__SubjectConfirmationType *saml1__SubjectConfirmation;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectType */
        int soap_type() const { return SOAP_TYPE_saml1__SubjectType; }
        /** Constructor with member initializations */
        saml1__SubjectType()
        {
          saml1__NameIdentifier = (struct saml1__NameIdentifierType *)0;
          saml1__SubjectConfirmation = (struct saml1__SubjectConfirmationType *)0;
        }
        /** Friend allocator used by soap_new_saml1__SubjectType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__SubjectType * SOAP_FMAC2 soap_instantiate_saml1__SubjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:81 */
#ifndef SOAP_TYPE_saml1__SubjectConfirmationType
#define SOAP_TYPE_saml1__SubjectConfirmationType (106)
/* complex XSD type 'saml1:SubjectConfirmationType': */
struct SOAP_CMAC saml1__SubjectConfirmationType {
      public:
        /** Sequence of at least 1 elements 'saml1:ConfirmationMethod' of XSD type 'xsd:string' stored in dynamic array saml1__ConfirmationMethod of length __sizeConfirmationMethod */
        int __sizeConfirmationMethod;
        char **saml1__ConfirmationMethod;
        /** Optional element 'saml1:SubjectConfirmationData' of XSD type 'xsd:anyType' */
        char *saml1__SubjectConfirmationData;
        /** Optional element 'ds:KeyInfo' of XSD type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectConfirmationType */
        int soap_type() const { return SOAP_TYPE_saml1__SubjectConfirmationType; }
        /** Constructor with member initializations */
        saml1__SubjectConfirmationType()
        {
          __sizeConfirmationMethod = 0;
          saml1__ConfirmationMethod = NULL;
          saml1__SubjectConfirmationData = (char *)0;
          ds__KeyInfo = (struct ds__KeyInfoType *)0;
        }
        /** Friend allocator used by soap_new_saml1__SubjectConfirmationType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__SubjectConfirmationType * SOAP_FMAC2 soap_instantiate_saml1__SubjectConfirmationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:85 */
#ifndef SOAP_TYPE_saml1__SubjectLocalityType
#define SOAP_TYPE_saml1__SubjectLocalityType (108)
/* complex XSD type 'saml1:SubjectLocalityType': */
struct SOAP_CMAC saml1__SubjectLocalityType {
      public:
        /** Optional attribute 'IPAddress' of XSD type 'xsd:string' */
        char *IPAddress;
        /** Optional attribute 'DNSAddress' of XSD type 'xsd:string' */
        char *DNSAddress;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectLocalityType */
        int soap_type() const { return SOAP_TYPE_saml1__SubjectLocalityType; }
        /** Constructor with member initializations */
        saml1__SubjectLocalityType()
        {
          IPAddress = (char *)0;
          DNSAddress = (char *)0;
        }
        /** Friend allocator used by soap_new_saml1__SubjectLocalityType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__SubjectLocalityType * SOAP_FMAC2 soap_instantiate_saml1__SubjectLocalityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:87 */
#ifndef SOAP_TYPE_saml1__AuthorityBindingType
#define SOAP_TYPE_saml1__AuthorityBindingType (109)
/* complex XSD type 'saml1:AuthorityBindingType': */
struct SOAP_CMAC saml1__AuthorityBindingType {
      public:
        /** Required attribute 'AuthorityKind' of XSD type 'xsd:QName' */
        char *AuthorityKind;
        /** Required attribute 'Location' of XSD type 'xsd:string' */
        char *Location;
        /** Required attribute 'Binding' of XSD type 'xsd:string' */
        char *Binding;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AuthorityBindingType */
        int soap_type() const { return SOAP_TYPE_saml1__AuthorityBindingType; }
        /** Constructor with member initializations */
        saml1__AuthorityBindingType()
        {
          AuthorityKind = (char *)0;
          Location = (char *)0;
          Binding = (char *)0;
        }
        /** Friend allocator used by soap_new_saml1__AuthorityBindingType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__AuthorityBindingType * SOAP_FMAC2 soap_instantiate_saml1__AuthorityBindingType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:344 */
#ifndef SOAP_TYPE___saml1__union_EvidenceType
#define SOAP_TYPE___saml1__union_EvidenceType (140)
/* Wrapper: */
struct SOAP_CMAC __saml1__union_EvidenceType {
      public:
        /** Optional element 'saml1:AssertionIDReference' of XSD type 'xsd:string' */
        char *saml1__AssertionIDReference;
        /** Optional element 'saml1:Assertion' of XSD type 'saml1:AssertionType' */
        struct saml1__AssertionType *saml1__Assertion;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_EvidenceType */
        int soap_type() const { return SOAP_TYPE___saml1__union_EvidenceType; }
        /** Constructor with member initializations */
        __saml1__union_EvidenceType()
        {
          saml1__AssertionIDReference = (char *)0;
          saml1__Assertion = (struct saml1__AssertionType *)0;
        }
        /** Friend allocator used by soap_new___saml1__union_EvidenceType(struct soap*, int) */
        friend SOAP_FMAC1 __saml1__union_EvidenceType * SOAP_FMAC2 soap_instantiate___saml1__union_EvidenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:93 */
#ifndef SOAP_TYPE_saml1__EvidenceType
#define SOAP_TYPE_saml1__EvidenceType (112)
/* complex XSD type 'saml1:EvidenceType': */
struct SOAP_CMAC saml1__EvidenceType {
      public:
        /** Sequence of elements '-union-EvidenceType' of XSD type '-saml1:union-EvidenceType' stored in dynamic array __union_EvidenceType of length __size_EvidenceType */
        int __size_EvidenceType;
        struct __saml1__union_EvidenceType *__union_EvidenceType;
      public:
        /** Return unique type id SOAP_TYPE_saml1__EvidenceType */
        int soap_type() const { return SOAP_TYPE_saml1__EvidenceType; }
        /** Constructor with member initializations */
        saml1__EvidenceType()
        {
          __size_EvidenceType = 0;
          __union_EvidenceType = NULL;
        }
        /** Friend allocator used by soap_new_saml1__EvidenceType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__EvidenceType * SOAP_FMAC2 soap_instantiate_saml1__EvidenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:97 */
#ifndef SOAP_TYPE_saml1__AttributeDesignatorType
#define SOAP_TYPE_saml1__AttributeDesignatorType (114)
/* complex XSD type 'saml1:AttributeDesignatorType': */
struct SOAP_CMAC saml1__AttributeDesignatorType {
      public:
        /** Required attribute 'AttributeName' of XSD type 'xsd:string' */
        char *AttributeName;
        /** Required attribute 'AttributeNamespace' of XSD type 'xsd:string' */
        char *AttributeNamespace;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AttributeDesignatorType */
        int soap_type() const { return SOAP_TYPE_saml1__AttributeDesignatorType; }
        /** Constructor with member initializations */
        saml1__AttributeDesignatorType()
        {
          AttributeName = (char *)0;
          AttributeNamespace = (char *)0;
        }
        /** Friend allocator used by soap_new_saml1__AttributeDesignatorType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__AttributeDesignatorType * SOAP_FMAC2 soap_instantiate_saml1__AttributeDesignatorType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:67 */
#ifndef SOAP_TYPE_saml1__AudienceRestrictionConditionType
#define SOAP_TYPE_saml1__AudienceRestrictionConditionType (99)
/* complex XSD type 'saml1:AudienceRestrictionConditionType': */
struct SOAP_CMAC saml1__AudienceRestrictionConditionType {
      public:
        /** Sequence of at least 1 elements 'saml1:Audience' of XSD type 'xsd:string' stored in dynamic array saml1__Audience of length __sizeAudience */
        int __sizeAudience;
        char **saml1__Audience;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AudienceRestrictionConditionType */
        int soap_type() const { return SOAP_TYPE_saml1__AudienceRestrictionConditionType; }
        /** Constructor with member initializations */
        saml1__AudienceRestrictionConditionType()
        {
          __sizeAudience = 0;
          saml1__Audience = NULL;
        }
        /** Friend allocator used by soap_new_saml1__AudienceRestrictionConditionType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__AudienceRestrictionConditionType * SOAP_FMAC2 soap_instantiate_saml1__AudienceRestrictionConditionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:69 */
#ifndef SOAP_TYPE_saml1__DoNotCacheConditionType
#define SOAP_TYPE_saml1__DoNotCacheConditionType (100)
/* complex XSD type 'saml1:DoNotCacheConditionType': */
struct SOAP_CMAC saml1__DoNotCacheConditionType {
      public:
        /** Return unique type id SOAP_TYPE_saml1__DoNotCacheConditionType */
        int soap_type() const { return SOAP_TYPE_saml1__DoNotCacheConditionType; }
        /** Constructor with member initializations */
        saml1__DoNotCacheConditionType()
        {
        }
        /** Friend allocator used by soap_new_saml1__DoNotCacheConditionType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__DoNotCacheConditionType * SOAP_FMAC2 soap_instantiate_saml1__DoNotCacheConditionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:75 */
#ifndef SOAP_TYPE_saml1__SubjectStatementAbstractType
#define SOAP_TYPE_saml1__SubjectStatementAbstractType (103)
/* complex XSD type 'saml1:SubjectStatementAbstractType': */
struct SOAP_CMAC saml1__SubjectStatementAbstractType {
      public:
        /** Required element 'saml1:Subject' of XSD type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectStatementAbstractType */
        int soap_type() const { return SOAP_TYPE_saml1__SubjectStatementAbstractType; }
        /** Constructor with member initializations */
        saml1__SubjectStatementAbstractType()
        {
          saml1__Subject = (struct saml1__SubjectType *)0;
        }
        /** Friend allocator used by soap_new_saml1__SubjectStatementAbstractType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__SubjectStatementAbstractType * SOAP_FMAC2 soap_instantiate_saml1__SubjectStatementAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:79 */
#ifndef SOAP_TYPE_saml1__NameIdentifierType
#define SOAP_TYPE_saml1__NameIdentifierType (105)
/* simple XSD type 'saml1:NameIdentifierType': */
struct SOAP_CMAC saml1__NameIdentifierType {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'NameQualifier' of XSD type 'xsd:string' */
        char *NameQualifier;
        /** Optional attribute 'Format' of XSD type 'xsd:string' */
        char *Format;
      public:
        /** Return unique type id SOAP_TYPE_saml1__NameIdentifierType */
        int soap_type() const { return SOAP_TYPE_saml1__NameIdentifierType; }
        /** Constructor with member initializations */
        saml1__NameIdentifierType()
        {
          __item = (char *)0;
          NameQualifier = (char *)0;
          Format = (char *)0;
        }
        /** Friend allocator used by soap_new_saml1__NameIdentifierType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__NameIdentifierType * SOAP_FMAC2 soap_instantiate_saml1__NameIdentifierType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:91 */
#ifndef SOAP_TYPE_saml1__ActionType
#define SOAP_TYPE_saml1__ActionType (111)
/* simple XSD type 'saml1:ActionType': */
struct SOAP_CMAC saml1__ActionType {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'Namespace' of XSD type 'xsd:string' */
        char *Namespace;
      public:
        /** Return unique type id SOAP_TYPE_saml1__ActionType */
        int soap_type() const { return SOAP_TYPE_saml1__ActionType; }
        /** Constructor with member initializations */
        saml1__ActionType()
        {
          __item = (char *)0;
          Namespace = (char *)0;
        }
        /** Friend allocator used by soap_new_saml1__ActionType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__ActionType * SOAP_FMAC2 soap_instantiate_saml1__ActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:99 */
#ifndef SOAP_TYPE_saml1__AttributeType
#define SOAP_TYPE_saml1__AttributeType (115)
/* complex XSD type 'saml1:AttributeType': */
struct SOAP_CMAC saml1__AttributeType {
      public:
        /** Required attribute 'AttributeName' of XSD type 'xsd:string' */
        char *AttributeName;
        /** Required attribute 'AttributeNamespace' of XSD type 'xsd:string' */
        char *AttributeNamespace;
        /** Sequence of at least 1 elements 'saml1:AttributeValue' of XSD type 'xsd:anyType' stored in dynamic array saml1__AttributeValue of length __sizeAttributeValue */
        int __sizeAttributeValue;
        char **saml1__AttributeValue;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AttributeType */
        int soap_type() const { return SOAP_TYPE_saml1__AttributeType; }
        /** Constructor with member initializations */
        saml1__AttributeType()
        {
          AttributeName = (char *)0;
          AttributeNamespace = (char *)0;
          __sizeAttributeValue = 0;
          saml1__AttributeValue = NULL;
        }
        /** Friend allocator used by soap_new_saml1__AttributeType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__AttributeType * SOAP_FMAC2 soap_instantiate_saml1__AttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:83 */
#ifndef SOAP_TYPE_saml1__AuthenticationStatementType
#define SOAP_TYPE_saml1__AuthenticationStatementType (107)
/* complex XSD type 'saml1:AuthenticationStatementType': */
struct SOAP_CMAC saml1__AuthenticationStatementType {
      public:
        /** Required element 'saml1:Subject' of XSD type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
        /** Optional element 'saml1:SubjectLocality' of XSD type 'saml1:SubjectLocalityType' */
        struct saml1__SubjectLocalityType *saml1__SubjectLocality;
        /** Sequence of elements 'saml1:AuthorityBinding' of XSD type 'saml1:AuthorityBindingType' stored in dynamic array saml1__AuthorityBinding of length __sizeAuthorityBinding */
        int __sizeAuthorityBinding;
        struct saml1__AuthorityBindingType *saml1__AuthorityBinding;
        /** Required attribute 'AuthenticationMethod' of XSD type 'xsd:string' */
        char *AuthenticationMethod;
        /** Required attribute 'AuthenticationInstant' of XSD type 'xsd:dateTime' */
        time_t AuthenticationInstant;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AuthenticationStatementType */
        int soap_type() const { return SOAP_TYPE_saml1__AuthenticationStatementType; }
        /** Constructor with member initializations */
        saml1__AuthenticationStatementType()
        {
          saml1__Subject = (struct saml1__SubjectType *)0;
          saml1__SubjectLocality = (struct saml1__SubjectLocalityType *)0;
          __sizeAuthorityBinding = 0;
          saml1__AuthorityBinding = NULL;
          AuthenticationMethod = (char *)0;
          AuthenticationInstant = (time_t)0;
        }
        /** Friend allocator used by soap_new_saml1__AuthenticationStatementType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__AuthenticationStatementType * SOAP_FMAC2 soap_instantiate_saml1__AuthenticationStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:89 */
#ifndef SOAP_TYPE_saml1__AuthorizationDecisionStatementType
#define SOAP_TYPE_saml1__AuthorizationDecisionStatementType (110)
/* complex XSD type 'saml1:AuthorizationDecisionStatementType': */
struct SOAP_CMAC saml1__AuthorizationDecisionStatementType {
      public:
        /** Required element 'saml1:Subject' of XSD type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
        /** Sequence of at least 1 elements 'saml1:Action' of XSD type 'saml1:ActionType' stored in dynamic array saml1__Action of length __sizeAction */
        int __sizeAction;
        struct saml1__ActionType *saml1__Action;
        /** Optional element 'saml1:Evidence' of XSD type 'saml1:EvidenceType' */
        struct saml1__EvidenceType *saml1__Evidence;
        /** Required attribute 'Resource' of XSD type 'xsd:string' */
        char *Resource;
        /** Required attribute 'Decision' of XSD type 'saml1:DecisionType' */
        enum saml1__DecisionType Decision;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AuthorizationDecisionStatementType */
        int soap_type() const { return SOAP_TYPE_saml1__AuthorizationDecisionStatementType; }
        /** Constructor with member initializations */
        saml1__AuthorizationDecisionStatementType()
        {
          saml1__Subject = (struct saml1__SubjectType *)0;
          __sizeAction = 0;
          saml1__Action = NULL;
          saml1__Evidence = (struct saml1__EvidenceType *)0;
          Resource = (char *)0;
          Decision = (enum saml1__DecisionType)0;
        }
        /** Friend allocator used by soap_new_saml1__AuthorizationDecisionStatementType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__AuthorizationDecisionStatementType * SOAP_FMAC2 soap_instantiate_saml1__AuthorizationDecisionStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:95 */
#ifndef SOAP_TYPE_saml1__AttributeStatementType
#define SOAP_TYPE_saml1__AttributeStatementType (113)
/* complex XSD type 'saml1:AttributeStatementType': */
struct SOAP_CMAC saml1__AttributeStatementType {
      public:
        /** Required element 'saml1:Subject' of XSD type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
        /** Sequence of at least 1 elements 'saml1:Attribute' of XSD type 'saml1:AttributeType' stored in dynamic array saml1__Attribute of length __sizeAttribute */
        int __sizeAttribute;
        struct saml1__AttributeType *saml1__Attribute;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AttributeStatementType */
        int soap_type() const { return SOAP_TYPE_saml1__AttributeStatementType; }
        /** Constructor with member initializations */
        saml1__AttributeStatementType()
        {
          saml1__Subject = (struct saml1__SubjectType *)0;
          __sizeAttribute = 0;
          saml1__Attribute = NULL;
        }
        /** Friend allocator used by soap_new_saml1__AttributeStatementType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__AttributeStatementType * SOAP_FMAC2 soap_instantiate_saml1__AttributeStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:61 */
#ifndef SOAP_TYPE_saml2__BaseIDAbstractType
#define SOAP_TYPE_saml2__BaseIDAbstractType (149)
/* complex XSD type 'saml2:BaseIDAbstractType': */
struct SOAP_CMAC saml2__BaseIDAbstractType {
      public:
        /** Optional attribute 'NameQualifier' of XSD type 'xsd:string' */
        char *NameQualifier;
        /** Optional attribute 'SPNameQualifier' of XSD type 'xsd:string' */
        char *SPNameQualifier;
      public:
        /** Return unique type id SOAP_TYPE_saml2__BaseIDAbstractType */
        int soap_type() const { return SOAP_TYPE_saml2__BaseIDAbstractType; }
        /** Constructor with member initializations */
        saml2__BaseIDAbstractType()
        {
          NameQualifier = (char *)0;
          SPNameQualifier = (char *)0;
        }
        /** Friend allocator used by soap_new_saml2__BaseIDAbstractType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__BaseIDAbstractType * SOAP_FMAC2 soap_instantiate_saml2__BaseIDAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:65 */
#ifndef SOAP_TYPE_saml2__EncryptedElementType
#define SOAP_TYPE_saml2__EncryptedElementType (151)
/* complex XSD type 'saml2:EncryptedElementType': */
struct SOAP_CMAC saml2__EncryptedElementType {
      public:
        /** Required element 'xenc:EncryptedData' of XSD type 'xenc:EncryptedDataType' */
        struct xenc__EncryptedDataType xenc__EncryptedData;
        /** Sequence of elements 'xenc:EncryptedKey' of XSD type 'xenc:EncryptedKeyType' stored in dynamic array xenc__EncryptedKey of length __sizexenc__EncryptedKey */
        int __sizexenc__EncryptedKey;
        struct xenc__EncryptedKeyType **xenc__EncryptedKey;
      public:
        /** Return unique type id SOAP_TYPE_saml2__EncryptedElementType */
        int soap_type() const { return SOAP_TYPE_saml2__EncryptedElementType; }
        /** Constructor with member initializations */
        saml2__EncryptedElementType()
        {
          __sizexenc__EncryptedKey = 0;
          xenc__EncryptedKey = NULL;
        }
        /** Friend allocator used by soap_new_saml2__EncryptedElementType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__EncryptedElementType * SOAP_FMAC2 soap_instantiate_saml2__EncryptedElementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:193 */
#ifndef SOAP_TYPE___saml2__union_AssertionType
#define SOAP_TYPE___saml2__union_AssertionType (179)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_AssertionType {
      public:
        /** Optional element 'saml2:Statement' of XSD type 'saml2:StatementAbstractType' */
        struct saml2__StatementAbstractType *saml2__Statement;
        /** Optional element 'saml2:AuthnStatement' of XSD type 'saml2:AuthnStatementType' */
        struct saml2__AuthnStatementType *saml2__AuthnStatement;
        /** Optional element 'saml2:AuthzDecisionStatement' of XSD type 'saml2:AuthzDecisionStatementType' */
        struct saml2__AuthzDecisionStatementType *saml2__AuthzDecisionStatement;
        /** Optional element 'saml2:AttributeStatement' of XSD type 'saml2:AttributeStatementType' */
        struct saml2__AttributeStatementType *saml2__AttributeStatement;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_AssertionType */
        int soap_type() const { return SOAP_TYPE___saml2__union_AssertionType; }
        /** Constructor with member initializations */
        __saml2__union_AssertionType()
        {
          saml2__Statement = (struct saml2__StatementAbstractType *)0;
          saml2__AuthnStatement = (struct saml2__AuthnStatementType *)0;
          saml2__AuthzDecisionStatement = (struct saml2__AuthzDecisionStatementType *)0;
          saml2__AttributeStatement = (struct saml2__AttributeStatementType *)0;
        }
        /** Friend allocator used by soap_new___saml2__union_AssertionType(struct soap*, int) */
        friend SOAP_FMAC1 __saml2__union_AssertionType * SOAP_FMAC2 soap_instantiate___saml2__union_AssertionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:67 */
#ifndef SOAP_TYPE_saml2__AssertionType
#define SOAP_TYPE_saml2__AssertionType (152)
/* Type saml2__AssertionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'saml2:AssertionType': */
struct SOAP_CMAC saml2__AssertionType {
      public:
        /** Required element 'saml2:Issuer' of XSD type 'saml2:NameIDType' */
        struct saml2__NameIDType *saml2__Issuer;
        /** Optional element 'ds:Signature' of XSD type 'ds:Signature' */
        struct ds__SignatureType *ds__Signature;
        /** Optional element 'saml2:Subject' of XSD type 'saml2:SubjectType' */
        struct saml2__SubjectType *saml2__Subject;
        /** Optional element 'saml2:Conditions' of XSD type 'saml2:ConditionsType' */
        struct saml2__ConditionsType *saml2__Conditions;
        /** Optional element 'saml2:Advice' of XSD type 'saml2:AdviceType' */
        struct saml2__AdviceType *saml2__Advice;
        /** Sequence of elements '-union-AssertionType' of XSD type '-saml2:union-AssertionType' stored in dynamic array __union_AssertionType of length __size_AssertionType */
        int __size_AssertionType;
        struct __saml2__union_AssertionType *__union_AssertionType;
        /** Required attribute 'Version' of XSD type 'xsd:string' */
        char *Version;
        /** Required attribute 'ID' of XSD type 'xsd:string' */
        char *ID;
        /** Required attribute 'IssueInstant' of XSD type 'xsd:dateTime' */
        time_t IssueInstant;
        /** Required attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AssertionType */
        int soap_type() const { return SOAP_TYPE_saml2__AssertionType; }
        /** Constructor with member initializations */
        saml2__AssertionType()
        {
          saml2__Issuer = (struct saml2__NameIDType *)0;
          ds__Signature = (struct ds__SignatureType *)0;
          saml2__Subject = (struct saml2__SubjectType *)0;
          saml2__Conditions = (struct saml2__ConditionsType *)0;
          saml2__Advice = (struct saml2__AdviceType *)0;
          __size_AssertionType = 0;
          __union_AssertionType = NULL;
          Version = (char *)0;
          ID = (char *)0;
          IssueInstant = (time_t)0;
          wsu__Id = (char *)0;
        }
        /** Friend allocator used by soap_new_saml2__AssertionType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__AssertionType * SOAP_FMAC2 soap_instantiate_saml2__AssertionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:69 */
#ifndef SOAP_TYPE_saml2__SubjectType
#define SOAP_TYPE_saml2__SubjectType (153)
/* complex XSD type 'saml2:SubjectType': */
struct SOAP_CMAC saml2__SubjectType {
      public:
        /** Optional element 'saml2:BaseID' of XSD type 'saml2:BaseIDAbstractType' */
        struct saml2__BaseIDAbstractType *saml2__BaseID;
        /** Optional element 'saml2:NameID' of XSD type 'saml2:NameIDType' */
        struct saml2__NameIDType *saml2__NameID;
        /** Optional element 'saml2:EncryptedID' of XSD type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedID;
        /** Sequence of elements 'saml2:SubjectConfirmation' of XSD type 'saml2:SubjectConfirmationType' stored in dynamic array saml2__SubjectConfirmation of length __sizeSubjectConfirmation */
        int __sizeSubjectConfirmation;
        struct saml2__SubjectConfirmationType *saml2__SubjectConfirmation;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectType */
        int soap_type() const { return SOAP_TYPE_saml2__SubjectType; }
        /** Constructor with member initializations */
        saml2__SubjectType()
        {
          saml2__BaseID = (struct saml2__BaseIDAbstractType *)0;
          saml2__NameID = (struct saml2__NameIDType *)0;
          saml2__EncryptedID = (struct saml2__EncryptedElementType *)0;
          __sizeSubjectConfirmation = 0;
          saml2__SubjectConfirmation = NULL;
        }
        /** Friend allocator used by soap_new_saml2__SubjectType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__SubjectType * SOAP_FMAC2 soap_instantiate_saml2__SubjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:71 */
#ifndef SOAP_TYPE_saml2__SubjectConfirmationType
#define SOAP_TYPE_saml2__SubjectConfirmationType (154)
/* complex XSD type 'saml2:SubjectConfirmationType': */
struct SOAP_CMAC saml2__SubjectConfirmationType {
      public:
        /** Optional element 'saml2:BaseID' of XSD type 'saml2:BaseIDAbstractType' */
        struct saml2__BaseIDAbstractType *saml2__BaseID;
        /** Optional element 'saml2:NameID' of XSD type 'saml2:NameIDType' */
        struct saml2__NameIDType *saml2__NameID;
        /** Optional element 'saml2:EncryptedID' of XSD type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedID;
        /** Optional element 'saml2:SubjectConfirmationData' of XSD type 'saml2:SubjectConfirmationDataType' */
        struct saml2__SubjectConfirmationDataType *saml2__SubjectConfirmationData;
        /** Required attribute 'Method' of XSD type 'xsd:string' */
        char *Method;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectConfirmationType */
        int soap_type() const { return SOAP_TYPE_saml2__SubjectConfirmationType; }
        /** Constructor with member initializations */
        saml2__SubjectConfirmationType()
        {
          saml2__BaseID = (struct saml2__BaseIDAbstractType *)0;
          saml2__NameID = (struct saml2__NameIDType *)0;
          saml2__EncryptedID = (struct saml2__EncryptedElementType *)0;
          saml2__SubjectConfirmationData = (struct saml2__SubjectConfirmationDataType *)0;
          Method = (char *)0;
        }
        /** Friend allocator used by soap_new_saml2__SubjectConfirmationType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__SubjectConfirmationType * SOAP_FMAC2 soap_instantiate_saml2__SubjectConfirmationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:284 */
#ifndef SOAP_TYPE___saml2__union_ConditionsType
#define SOAP_TYPE___saml2__union_ConditionsType (189)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_ConditionsType {
      public:
        /** Optional element 'saml2:Condition' of XSD type 'saml2:ConditionAbstractType' */
        struct saml2__ConditionAbstractType *saml2__Condition;
        /** Optional element 'saml2:AudienceRestriction' of XSD type 'saml2:AudienceRestrictionType' */
        struct saml2__AudienceRestrictionType *saml2__AudienceRestriction;
        /** Optional element 'saml2:OneTimeUse' of XSD type 'saml2:OneTimeUseType' */
        struct saml2__OneTimeUseType *saml2__OneTimeUse;
        /** Optional element 'saml2:ProxyRestriction' of XSD type 'saml2:ProxyRestrictionType' */
        struct saml2__ProxyRestrictionType *saml2__ProxyRestriction;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_ConditionsType */
        int soap_type() const { return SOAP_TYPE___saml2__union_ConditionsType; }
        /** Constructor with member initializations */
        __saml2__union_ConditionsType()
        {
          saml2__Condition = (struct saml2__ConditionAbstractType *)0;
          saml2__AudienceRestriction = (struct saml2__AudienceRestrictionType *)0;
          saml2__OneTimeUse = (struct saml2__OneTimeUseType *)0;
          saml2__ProxyRestriction = (struct saml2__ProxyRestrictionType *)0;
        }
        /** Friend allocator used by soap_new___saml2__union_ConditionsType(struct soap*, int) */
        friend SOAP_FMAC1 __saml2__union_ConditionsType * SOAP_FMAC2 soap_instantiate___saml2__union_ConditionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:77 */
#ifndef SOAP_TYPE_saml2__ConditionsType
#define SOAP_TYPE_saml2__ConditionsType (157)
/* complex XSD type 'saml2:ConditionsType': */
struct SOAP_CMAC saml2__ConditionsType {
      public:
        /** Sequence of elements '-union-ConditionsType' of XSD type '-saml2:union-ConditionsType' stored in dynamic array __union_ConditionsType of length __size_ConditionsType */
        int __size_ConditionsType;
        struct __saml2__union_ConditionsType *__union_ConditionsType;
        /** Optional attribute 'NotBefore' of XSD type 'xsd:dateTime' */
        time_t *NotBefore;
        /** Optional attribute 'NotOnOrAfter' of XSD type 'xsd:dateTime' */
        time_t *NotOnOrAfter;
      public:
        /** Return unique type id SOAP_TYPE_saml2__ConditionsType */
        int soap_type() const { return SOAP_TYPE_saml2__ConditionsType; }
        /** Constructor with member initializations */
        saml2__ConditionsType()
        {
          __size_ConditionsType = 0;
          __union_ConditionsType = NULL;
          NotBefore = (time_t *)0;
          NotOnOrAfter = (time_t *)0;
        }
        /** Friend allocator used by soap_new_saml2__ConditionsType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__ConditionsType * SOAP_FMAC2 soap_instantiate_saml2__ConditionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:79 */
#ifndef SOAP_TYPE_saml2__ConditionAbstractType
#define SOAP_TYPE_saml2__ConditionAbstractType (158)
/* complex XSD type 'saml2:ConditionAbstractType': */
struct SOAP_CMAC saml2__ConditionAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml2__ConditionAbstractType */
        int soap_type() const { return SOAP_TYPE_saml2__ConditionAbstractType; }
        /** Constructor with member initializations */
        saml2__ConditionAbstractType()
        {
        }
        /** Friend allocator used by soap_new_saml2__ConditionAbstractType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__ConditionAbstractType * SOAP_FMAC2 soap_instantiate_saml2__ConditionAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:326 */
#ifndef SOAP_TYPE___saml2__union_AdviceType
#define SOAP_TYPE___saml2__union_AdviceType (195)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_AdviceType {
      public:
        /** Optional element 'saml2:AssertionIDRef' of XSD type 'xsd:string' */
        char *saml2__AssertionIDRef;
        /** Optional element 'saml2:AssertionURIRef' of XSD type 'xsd:string' */
        char *saml2__AssertionURIRef;
        /** Optional element 'saml2:Assertion' of XSD type 'saml2:AssertionType' */
        struct saml2__AssertionType *saml2__Assertion;
        /** Optional element 'saml2:EncryptedAssertion' of XSD type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedAssertion;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_AdviceType */
        int soap_type() const { return SOAP_TYPE___saml2__union_AdviceType; }
        /** Constructor with member initializations */
        __saml2__union_AdviceType()
        {
          saml2__AssertionIDRef = (char *)0;
          saml2__AssertionURIRef = (char *)0;
          saml2__Assertion = (struct saml2__AssertionType *)0;
          saml2__EncryptedAssertion = (struct saml2__EncryptedElementType *)0;
        }
        /** Friend allocator used by soap_new___saml2__union_AdviceType(struct soap*, int) */
        friend SOAP_FMAC1 __saml2__union_AdviceType * SOAP_FMAC2 soap_instantiate___saml2__union_AdviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:87 */
#ifndef SOAP_TYPE_saml2__AdviceType
#define SOAP_TYPE_saml2__AdviceType (162)
/* complex XSD type 'saml2:AdviceType': */
struct SOAP_CMAC saml2__AdviceType {
      public:
        /** Sequence of elements '-union-AdviceType' of XSD type '-saml2:union-AdviceType' stored in dynamic array __union_AdviceType of length __size_AdviceType */
        int __size_AdviceType;
        struct __saml2__union_AdviceType *__union_AdviceType;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AdviceType */
        int soap_type() const { return SOAP_TYPE_saml2__AdviceType; }
        /** Constructor with member initializations */
        saml2__AdviceType()
        {
          __size_AdviceType = 0;
          __union_AdviceType = NULL;
        }
        /** Friend allocator used by soap_new_saml2__AdviceType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__AdviceType * SOAP_FMAC2 soap_instantiate_saml2__AdviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:89 */
#ifndef SOAP_TYPE_saml2__StatementAbstractType
#define SOAP_TYPE_saml2__StatementAbstractType (163)
/* complex XSD type 'saml2:StatementAbstractType': */
struct SOAP_CMAC saml2__StatementAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml2__StatementAbstractType */
        int soap_type() const { return SOAP_TYPE_saml2__StatementAbstractType; }
        /** Constructor with member initializations */
        saml2__StatementAbstractType()
        {
        }
        /** Friend allocator used by soap_new_saml2__StatementAbstractType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__StatementAbstractType * SOAP_FMAC2 soap_instantiate_saml2__StatementAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:93 */
#ifndef SOAP_TYPE_saml2__SubjectLocalityType
#define SOAP_TYPE_saml2__SubjectLocalityType (165)
/* complex XSD type 'saml2:SubjectLocalityType': */
struct SOAP_CMAC saml2__SubjectLocalityType {
      public:
        /** Optional attribute 'Address' of XSD type 'xsd:string' */
        char *Address;
        /** Optional attribute 'DNSName' of XSD type 'xsd:string' */
        char *DNSName;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectLocalityType */
        int soap_type() const { return SOAP_TYPE_saml2__SubjectLocalityType; }
        /** Constructor with member initializations */
        saml2__SubjectLocalityType()
        {
          Address = (char *)0;
          DNSName = (char *)0;
        }
        /** Friend allocator used by soap_new_saml2__SubjectLocalityType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__SubjectLocalityType * SOAP_FMAC2 soap_instantiate_saml2__SubjectLocalityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:95 */
#ifndef SOAP_TYPE_saml2__AuthnContextType
#define SOAP_TYPE_saml2__AuthnContextType (166)
/* complex XSD type 'saml2:AuthnContextType': */
struct SOAP_CMAC saml2__AuthnContextType {
      public:
        /** Optional element 'saml2:AuthnContextClassRef' of XSD type 'xsd:string' */
        char *saml2__AuthnContextClassRef;
        /** Optional element 'saml2:AuthnContextDecl' of XSD type 'xsd:anyType' */
        char *saml2__AuthnContextDecl;
        /** Optional element 'saml2:AuthnContextDeclRef' of XSD type 'xsd:string' */
        char *saml2__AuthnContextDeclRef;
        /** Sequence of elements 'saml2:AuthenticatingAuthority' of XSD type 'xsd:string' stored in dynamic array saml2__AuthenticatingAuthority of length __sizeAuthenticatingAuthority */
        int __sizeAuthenticatingAuthority;
        char **saml2__AuthenticatingAuthority;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AuthnContextType */
        int soap_type() const { return SOAP_TYPE_saml2__AuthnContextType; }
        /** Constructor with member initializations */
        saml2__AuthnContextType()
        {
          saml2__AuthnContextClassRef = (char *)0;
          saml2__AuthnContextDecl = (char *)0;
          saml2__AuthnContextDeclRef = (char *)0;
          __sizeAuthenticatingAuthority = 0;
          saml2__AuthenticatingAuthority = NULL;
        }
        /** Friend allocator used by soap_new_saml2__AuthnContextType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__AuthnContextType * SOAP_FMAC2 soap_instantiate_saml2__AuthnContextType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:421 */
#ifndef SOAP_TYPE___saml2__union_EvidenceType
#define SOAP_TYPE___saml2__union_EvidenceType (198)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_EvidenceType {
      public:
        /** Optional element 'saml2:AssertionIDRef' of XSD type 'xsd:string' */
        char *saml2__AssertionIDRef;
        /** Optional element 'saml2:AssertionURIRef' of XSD type 'xsd:string' */
        char *saml2__AssertionURIRef;
        /** Optional element 'saml2:Assertion' of XSD type 'saml2:AssertionType' */
        struct saml2__AssertionType *saml2__Assertion;
        /** Optional element 'saml2:EncryptedAssertion' of XSD type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedAssertion;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_EvidenceType */
        int soap_type() const { return SOAP_TYPE___saml2__union_EvidenceType; }
        /** Constructor with member initializations */
        __saml2__union_EvidenceType()
        {
          saml2__AssertionIDRef = (char *)0;
          saml2__AssertionURIRef = (char *)0;
          saml2__Assertion = (struct saml2__AssertionType *)0;
          saml2__EncryptedAssertion = (struct saml2__EncryptedElementType *)0;
        }
        /** Friend allocator used by soap_new___saml2__union_EvidenceType(struct soap*, int) */
        friend SOAP_FMAC1 __saml2__union_EvidenceType * SOAP_FMAC2 soap_instantiate___saml2__union_EvidenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:101 */
#ifndef SOAP_TYPE_saml2__EvidenceType
#define SOAP_TYPE_saml2__EvidenceType (169)
/* complex XSD type 'saml2:EvidenceType': */
struct SOAP_CMAC saml2__EvidenceType {
      public:
        /** Sequence of elements '-union-EvidenceType' of XSD type '-saml2:union-EvidenceType' stored in dynamic array __union_EvidenceType of length __size_EvidenceType */
        int __size_EvidenceType;
        struct __saml2__union_EvidenceType *__union_EvidenceType;
      public:
        /** Return unique type id SOAP_TYPE_saml2__EvidenceType */
        int soap_type() const { return SOAP_TYPE_saml2__EvidenceType; }
        /** Constructor with member initializations */
        saml2__EvidenceType()
        {
          __size_EvidenceType = 0;
          __union_EvidenceType = NULL;
        }
        /** Friend allocator used by soap_new_saml2__EvidenceType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__EvidenceType * SOAP_FMAC2 soap_instantiate_saml2__EvidenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:105 */
#ifndef SOAP_TYPE_saml2__AttributeType
#define SOAP_TYPE_saml2__AttributeType (171)
/* complex XSD type 'saml2:AttributeType': */
struct SOAP_CMAC saml2__AttributeType {
      public:
        /** Sequence of elements 'saml2:AttributeValue' of XSD type 'xsd:anyType' stored in dynamic array saml2__AttributeValue of length __sizeAttributeValue */
        int __sizeAttributeValue;
        char **saml2__AttributeValue;
        /** Required attribute 'Name' of XSD type 'xsd:string' */
        char *Name;
        /** Optional attribute 'NameFormat' of XSD type 'xsd:string' */
        char *NameFormat;
        /** Optional attribute 'FriendlyName' of XSD type 'xsd:string' */
        char *FriendlyName;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AttributeType */
        int soap_type() const { return SOAP_TYPE_saml2__AttributeType; }
        /** Constructor with member initializations */
        saml2__AttributeType()
        {
          __sizeAttributeValue = 0;
          saml2__AttributeValue = NULL;
          Name = (char *)0;
          NameFormat = (char *)0;
          FriendlyName = (char *)0;
        }
        /** Friend allocator used by soap_new_saml2__AttributeType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__AttributeType * SOAP_FMAC2 soap_instantiate_saml2__AttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:63 */
#ifndef SOAP_TYPE_saml2__NameIDType
#define SOAP_TYPE_saml2__NameIDType (150)
/* simple XSD type 'saml2:NameIDType': */
struct SOAP_CMAC saml2__NameIDType {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'Format' of XSD type 'xsd:string' */
        char *Format;
        /** Optional attribute 'SPProvidedID' of XSD type 'xsd:string' */
        char *SPProvidedID;
        /** Optional attribute 'NameQualifier' of XSD type 'xsd:string' */
        char *NameQualifier;
        /** Optional attribute 'SPNameQualifier' of XSD type 'xsd:string' */
        char *SPNameQualifier;
      public:
        /** Return unique type id SOAP_TYPE_saml2__NameIDType */
        int soap_type() const { return SOAP_TYPE_saml2__NameIDType; }
        /** Constructor with member initializations */
        saml2__NameIDType()
        {
          __item = (char *)0;
          Format = (char *)0;
          SPProvidedID = (char *)0;
          NameQualifier = (char *)0;
          SPNameQualifier = (char *)0;
        }
        /** Friend allocator used by soap_new_saml2__NameIDType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__NameIDType * SOAP_FMAC2 soap_instantiate_saml2__NameIDType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:73 */
#ifndef SOAP_TYPE_saml2__SubjectConfirmationDataType
#define SOAP_TYPE_saml2__SubjectConfirmationDataType (155)
/* complex XSD type 'saml2:SubjectConfirmationDataType': */
struct SOAP_CMAC saml2__SubjectConfirmationDataType {
      public:
        /** Optional attribute 'NotBefore' of XSD type 'xsd:dateTime' */
        time_t *NotBefore;
        /** Optional attribute 'NotOnOrAfter' of XSD type 'xsd:dateTime' */
        time_t *NotOnOrAfter;
        /** Optional attribute 'Recipient' of XSD type 'xsd:string' */
        char *Recipient;
        /** Optional attribute 'InResponseTo' of XSD type 'xsd:string' */
        char *InResponseTo;
        /** Optional attribute 'Address' of XSD type 'xsd:string' */
        char *Address;
        char *__mixed;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectConfirmationDataType */
        int soap_type() const { return SOAP_TYPE_saml2__SubjectConfirmationDataType; }
        /** Constructor with member initializations */
        saml2__SubjectConfirmationDataType()
        {
          NotBefore = (time_t *)0;
          NotOnOrAfter = (time_t *)0;
          Recipient = (char *)0;
          InResponseTo = (char *)0;
          Address = (char *)0;
          __mixed = (char *)0;
        }
        /** Friend allocator used by soap_new_saml2__SubjectConfirmationDataType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__SubjectConfirmationDataType * SOAP_FMAC2 soap_instantiate_saml2__SubjectConfirmationDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:81 */
#ifndef SOAP_TYPE_saml2__AudienceRestrictionType
#define SOAP_TYPE_saml2__AudienceRestrictionType (159)
/* complex XSD type 'saml2:AudienceRestrictionType': */
struct SOAP_CMAC saml2__AudienceRestrictionType {
      public:
        /** Sequence of at least 1 elements 'saml2:Audience' of XSD type 'xsd:string' stored in dynamic array saml2__Audience of length __sizeAudience */
        int __sizeAudience;
        char **saml2__Audience;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AudienceRestrictionType */
        int soap_type() const { return SOAP_TYPE_saml2__AudienceRestrictionType; }
        /** Constructor with member initializations */
        saml2__AudienceRestrictionType()
        {
          __sizeAudience = 0;
          saml2__Audience = NULL;
        }
        /** Friend allocator used by soap_new_saml2__AudienceRestrictionType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__AudienceRestrictionType * SOAP_FMAC2 soap_instantiate_saml2__AudienceRestrictionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:83 */
#ifndef SOAP_TYPE_saml2__OneTimeUseType
#define SOAP_TYPE_saml2__OneTimeUseType (160)
/* complex XSD type 'saml2:OneTimeUseType': */
struct SOAP_CMAC saml2__OneTimeUseType {
      public:
        /** Return unique type id SOAP_TYPE_saml2__OneTimeUseType */
        int soap_type() const { return SOAP_TYPE_saml2__OneTimeUseType; }
        /** Constructor with member initializations */
        saml2__OneTimeUseType()
        {
        }
        /** Friend allocator used by soap_new_saml2__OneTimeUseType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__OneTimeUseType * SOAP_FMAC2 soap_instantiate_saml2__OneTimeUseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:85 */
#ifndef SOAP_TYPE_saml2__ProxyRestrictionType
#define SOAP_TYPE_saml2__ProxyRestrictionType (161)
/* complex XSD type 'saml2:ProxyRestrictionType': */
struct SOAP_CMAC saml2__ProxyRestrictionType {
      public:
        /** Sequence of elements 'saml2:Audience' of XSD type 'xsd:string' stored in dynamic array saml2__Audience of length __sizeAudience */
        int __sizeAudience;
        char **saml2__Audience;
        /** Optional attribute 'Count' of XSD type 'xsd:string' */
        char *Count;
      public:
        /** Return unique type id SOAP_TYPE_saml2__ProxyRestrictionType */
        int soap_type() const { return SOAP_TYPE_saml2__ProxyRestrictionType; }
        /** Constructor with member initializations */
        saml2__ProxyRestrictionType()
        {
          __sizeAudience = 0;
          saml2__Audience = NULL;
          Count = (char *)0;
        }
        /** Friend allocator used by soap_new_saml2__ProxyRestrictionType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__ProxyRestrictionType * SOAP_FMAC2 soap_instantiate_saml2__ProxyRestrictionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:91 */
#ifndef SOAP_TYPE_saml2__AuthnStatementType
#define SOAP_TYPE_saml2__AuthnStatementType (164)
/* complex XSD type 'saml2:AuthnStatementType': */
struct SOAP_CMAC saml2__AuthnStatementType {
      public:
        /** Optional element 'saml2:SubjectLocality' of XSD type 'saml2:SubjectLocalityType' */
        struct saml2__SubjectLocalityType *saml2__SubjectLocality;
        /** Required element 'saml2:AuthnContext' of XSD type 'saml2:AuthnContextType' */
        struct saml2__AuthnContextType *saml2__AuthnContext;
        /** Required attribute 'AuthnInstant' of XSD type 'xsd:dateTime' */
        time_t AuthnInstant;
        /** Optional attribute 'SessionIndex' of XSD type 'xsd:string' */
        char *SessionIndex;
        /** Optional attribute 'SessionNotOnOrAfter' of XSD type 'xsd:dateTime' */
        time_t *SessionNotOnOrAfter;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AuthnStatementType */
        int soap_type() const { return SOAP_TYPE_saml2__AuthnStatementType; }
        /** Constructor with member initializations */
        saml2__AuthnStatementType()
        {
          saml2__SubjectLocality = (struct saml2__SubjectLocalityType *)0;
          saml2__AuthnContext = (struct saml2__AuthnContextType *)0;
          AuthnInstant = (time_t)0;
          SessionIndex = (char *)0;
          SessionNotOnOrAfter = (time_t *)0;
        }
        /** Friend allocator used by soap_new_saml2__AuthnStatementType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__AuthnStatementType * SOAP_FMAC2 soap_instantiate_saml2__AuthnStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:97 */
#ifndef SOAP_TYPE_saml2__AuthzDecisionStatementType
#define SOAP_TYPE_saml2__AuthzDecisionStatementType (167)
/* complex XSD type 'saml2:AuthzDecisionStatementType': */
struct SOAP_CMAC saml2__AuthzDecisionStatementType {
      public:
        /** Sequence of at least 1 elements 'saml2:Action' of XSD type 'saml2:ActionType' stored in dynamic array saml2__Action of length __sizeAction */
        int __sizeAction;
        struct saml2__ActionType *saml2__Action;
        /** Optional element 'saml2:Evidence' of XSD type 'saml2:EvidenceType' */
        struct saml2__EvidenceType *saml2__Evidence;
        /** Required attribute 'Resource' of XSD type 'xsd:string' */
        char *Resource;
        /** Required attribute 'Decision' of XSD type 'saml2:DecisionType' */
        enum saml2__DecisionType Decision;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AuthzDecisionStatementType */
        int soap_type() const { return SOAP_TYPE_saml2__AuthzDecisionStatementType; }
        /** Constructor with member initializations */
        saml2__AuthzDecisionStatementType()
        {
          __sizeAction = 0;
          saml2__Action = NULL;
          saml2__Evidence = (struct saml2__EvidenceType *)0;
          Resource = (char *)0;
          Decision = (enum saml2__DecisionType)0;
        }
        /** Friend allocator used by soap_new_saml2__AuthzDecisionStatementType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__AuthzDecisionStatementType * SOAP_FMAC2 soap_instantiate_saml2__AuthzDecisionStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:99 */
#ifndef SOAP_TYPE_saml2__ActionType
#define SOAP_TYPE_saml2__ActionType (168)
/* simple XSD type 'saml2:ActionType': */
struct SOAP_CMAC saml2__ActionType {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Required attribute 'Namespace' of XSD type 'xsd:string' */
        char *Namespace;
      public:
        /** Return unique type id SOAP_TYPE_saml2__ActionType */
        int soap_type() const { return SOAP_TYPE_saml2__ActionType; }
        /** Constructor with member initializations */
        saml2__ActionType()
        {
          __item = (char *)0;
          Namespace = (char *)0;
        }
        /** Friend allocator used by soap_new_saml2__ActionType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__ActionType * SOAP_FMAC2 soap_instantiate_saml2__ActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:653 */
#ifndef SOAP_TYPE___saml2__union_AttributeStatementType
#define SOAP_TYPE___saml2__union_AttributeStatementType (204)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_AttributeStatementType {
      public:
        /** Optional element 'saml2:Attribute' of XSD type 'saml2:AttributeType' */
        struct saml2__AttributeType *saml2__Attribute;
        /** Optional element 'saml2:EncryptedAttribute' of XSD type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedAttribute;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_AttributeStatementType */
        int soap_type() const { return SOAP_TYPE___saml2__union_AttributeStatementType; }
        /** Constructor with member initializations */
        __saml2__union_AttributeStatementType()
        {
          saml2__Attribute = (struct saml2__AttributeType *)0;
          saml2__EncryptedAttribute = (struct saml2__EncryptedElementType *)0;
        }
        /** Friend allocator used by soap_new___saml2__union_AttributeStatementType(struct soap*, int) */
        friend SOAP_FMAC1 __saml2__union_AttributeStatementType * SOAP_FMAC2 soap_instantiate___saml2__union_AttributeStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:103 */
#ifndef SOAP_TYPE_saml2__AttributeStatementType
#define SOAP_TYPE_saml2__AttributeStatementType (170)
/* complex XSD type 'saml2:AttributeStatementType': */
struct SOAP_CMAC saml2__AttributeStatementType {
      public:
        /** Sequence of elements '-union-AttributeStatementType' of XSD type '-saml2:union-AttributeStatementType' stored in dynamic array __union_AttributeStatementType of length __size_AttributeStatementType */
        int __size_AttributeStatementType;
        struct __saml2__union_AttributeStatementType *__union_AttributeStatementType;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AttributeStatementType */
        int soap_type() const { return SOAP_TYPE_saml2__AttributeStatementType; }
        /** Constructor with member initializations */
        saml2__AttributeStatementType()
        {
          __size_AttributeStatementType = 0;
          __union_AttributeStatementType = NULL;
        }
        /** Friend allocator used by soap_new_saml2__AttributeStatementType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__AttributeStatementType * SOAP_FMAC2 soap_instantiate_saml2__AttributeStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:75 */
#ifndef SOAP_TYPE_saml2__KeyInfoConfirmationDataType
#define SOAP_TYPE_saml2__KeyInfoConfirmationDataType (156)
/* complex XSD type 'saml2:KeyInfoConfirmationDataType': */
struct SOAP_CMAC saml2__KeyInfoConfirmationDataType {
      public:
        /** Sequence of at least 1 elements 'ds:KeyInfo' of XSD type 'ds:KeyInfo' stored in dynamic array ds__KeyInfo of length __sizeds__KeyInfo */
        int __sizeds__KeyInfo;
        struct ds__KeyInfoType **ds__KeyInfo;
      public:
        /** Return unique type id SOAP_TYPE_saml2__KeyInfoConfirmationDataType */
        int soap_type() const { return SOAP_TYPE_saml2__KeyInfoConfirmationDataType; }
        /** Constructor with member initializations */
        saml2__KeyInfoConfirmationDataType()
        {
          __sizeds__KeyInfo = 0;
          ds__KeyInfo = NULL;
        }
        /** Friend allocator used by soap_new_saml2__KeyInfoConfirmationDataType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__KeyInfoConfirmationDataType * SOAP_FMAC2 soap_instantiate_saml2__KeyInfoConfirmationDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:193 */
#ifndef SOAP_TYPE__wsse__Security
#define SOAP_TYPE__wsse__Security (208)
/* complex XSD type 'wsse:Security': */
struct SOAP_CMAC _wsse__Security {
      public:
        /** Optional element 'wsu:Timestamp' of XSD type 'wsu:Timestamp' */
        struct _wsu__Timestamp *wsu__Timestamp;
        /** Optional element 'wsse:UsernameToken' of XSD type 'wsse:UsernameToken' */
        struct _wsse__UsernameToken *UsernameToken;
        /** Optional element 'wsse:BinarySecurityToken' of XSD type 'wsse:BinarySecurityToken' */
        struct _wsse__BinarySecurityToken *BinarySecurityToken;
        /** Optional element 'xenc:EncryptedKey' of XSD type 'xenc:EncryptedKeyType' */
        struct xenc__EncryptedKeyType *xenc__EncryptedKey;
        /** Optional element 'xenc:ReferenceList' of XSD type 'xenc:ReferenceList' */
        struct _xenc__ReferenceList *xenc__ReferenceList;
        /** Optional element 'wsc:SecurityContextToken' of XSD type 'wsc:SecurityContextTokenType' */
        struct wsc__SecurityContextTokenType *wsc__SecurityContextToken;
        /** Optional element 'ds:Signature' of XSD type 'ds:SignatureType' */
        struct ds__SignatureType *ds__Signature;
        /** Optional element 'saml1:Assertion' of XSD type 'saml1:AssertionType' */
        struct saml1__AssertionType *saml1__Assertion;
        /** Optional element 'saml2:Assertion' of XSD type 'saml2:AssertionType' */
        struct saml2__AssertionType *saml2__Assertion;
        /** Optional attribute 'SOAP-ENV:actor' of XSD type 'xsd:string' */
        char *SOAP_ENV__actor;
        /** Optional attribute 'SOAP-ENV:role' of XSD type 'xsd:string' */
        char *SOAP_ENV__role;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Security */
        int soap_type() const { return SOAP_TYPE__wsse__Security; }
        /** Constructor with member initializations */
        _wsse__Security()
        {
          wsu__Timestamp = (struct _wsu__Timestamp *)0;
          UsernameToken = (struct _wsse__UsernameToken *)0;
          BinarySecurityToken = (struct _wsse__BinarySecurityToken *)0;
          xenc__EncryptedKey = (struct xenc__EncryptedKeyType *)0;
          xenc__ReferenceList = (struct _xenc__ReferenceList *)0;
          wsc__SecurityContextToken = (struct wsc__SecurityContextTokenType *)0;
          ds__Signature = (struct ds__SignatureType *)0;
          saml1__Assertion = (struct saml1__AssertionType *)0;
          saml2__Assertion = (struct saml2__AssertionType *)0;
          SOAP_ENV__actor = (char *)0;
          SOAP_ENV__role = (char *)0;
        }
        /** Friend allocator used by soap_new__wsse__Security(struct soap*, int) */
        friend SOAP_FMAC1 _wsse__Security * SOAP_FMAC2 soap_instantiate__wsse__Security(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:129 */
#ifndef SOAP_TYPE__wsse__Password
#define SOAP_TYPE__wsse__Password (13)
/* simple XSD type 'wsse:Password': */
struct SOAP_CMAC _wsse__Password {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'Type' of XSD type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Password */
        int soap_type() const { return SOAP_TYPE__wsse__Password; }
        /** Constructor with member initializations */
        _wsse__Password()
        {
          __item = (char *)0;
          Type = (char *)0;
        }
        /** Friend allocator used by soap_new__wsse__Password(struct soap*, int) */
        friend SOAP_FMAC1 _wsse__Password * SOAP_FMAC2 soap_instantiate__wsse__Password(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:225 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (214)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** MustUnderstand */
        struct _wsse__Security *wsse__Security;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header()
        {
          wsse__Security = (struct _wsse__Security *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Header(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* onvifgen/onvif.h:223 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (226)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XSD type 'xsd:string'
        char *id;
        /// Optional element 'type' of XSD type 'xsd:string'
        char *type;
        /// Optional element 'options' of XSD type 'xsd:string'
        char *options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW(xsd__base64Binary); }
      public:
        /// Constructor with initializations
        xsd__base64Binary()
        {
          __ptr = (unsigned char *)0;
          __size = 0;
          id = NULL;
          type = (char *)0;
          options = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:231 */
#ifndef SOAP_TYPE_xsd__hexBinary
#define SOAP_TYPE_xsd__hexBinary (231)
/* hexBinary XSD type: */
class SOAP_CMAC xsd__hexBinary {
      public:
        unsigned char *__ptr;
        int __size;
      public:
        /// Return unique type id SOAP_TYPE_xsd__hexBinary
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__hexBinary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__hexBinary, default initialized and not managed by a soap context
        virtual xsd__hexBinary *soap_alloc(void) const { return SOAP_NEW(xsd__hexBinary); }
      public:
        /// Constructor with initializations
        xsd__hexBinary()
        {
          __ptr = (unsigned char *)0;
          __size = (int)0;
        }
        virtual ~xsd__hexBinary() { }
        /// Friend allocator used by soap_new_xsd__hexBinary(struct soap*, int)
        friend SOAP_FMAC1 xsd__hexBinary * SOAP_FMAC2 soap_instantiate_xsd__hexBinary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:4979 */
#ifndef SOAP_TYPE__ns1__Service_Capabilities
#define SOAP_TYPE__ns1__Service_Capabilities (1473)
/* complex XSD type 'ns1:Service-Capabilities': */
class SOAP_CMAC _ns1__Service_Capabilities {
      public:
        /// XML DOM element node graph
        struct soap_dom_element __any;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Service_Capabilities
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__Service_Capabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Service_Capabilities, default initialized and not managed by a soap context
        virtual _ns1__Service_Capabilities *soap_alloc(void) const { return SOAP_NEW(_ns1__Service_Capabilities); }
      public:
        /// Constructor with initializations
        _ns1__Service_Capabilities()
        {
        }
        virtual ~_ns1__Service_Capabilities() { }
        /// Friend allocator used by soap_new__ns1__Service_Capabilities(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Service_Capabilities * SOAP_FMAC2 soap_instantiate__ns1__Service_Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:274 */
#ifndef SOAP_TYPE_ns1__Service
#define SOAP_TYPE_ns1__Service (242)
/* complex XSD type 'ns1:Service': */
class SOAP_CMAC ns1__Service {
      public:
        /// Required element 'ns1:Namespace' of XSD type 'xsd:anyURI'
        std::string Namespace;
        /// Required element 'ns1:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Optional element 'ns1:Capabilities' of XSD type 'ns1:Service-Capabilities'
        _ns1__Service_Capabilities *Capabilities;
        /// Required element 'ns1:Version' of XSD type 'ns2:OnvifVersion'
        ns2__OnvifVersion *Version;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Service
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__Service; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Service, default initialized and not managed by a soap context
        virtual ns1__Service *soap_alloc(void) const { return SOAP_NEW(ns1__Service); }
      public:
        /// Constructor with initializations
        ns1__Service()
        {
          Capabilities = (_ns1__Service_Capabilities *)0;
          Version = (ns2__OnvifVersion *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns1__Service() { }
        /// Friend allocator used by soap_new_ns1__Service(struct soap*, int)
        friend SOAP_FMAC1 ns1__Service * SOAP_FMAC2 soap_instantiate_ns1__Service(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:277 */
#ifndef SOAP_TYPE_ns1__DeviceServiceCapabilities
#define SOAP_TYPE_ns1__DeviceServiceCapabilities (243)
/* complex XSD type 'ns1:DeviceServiceCapabilities': */
class SOAP_CMAC ns1__DeviceServiceCapabilities {
      public:
        /// Required element 'ns1:Network' of XSD type 'ns1:NetworkCapabilities'
        ns1__NetworkCapabilities *Network;
        /// Required element 'ns1:Security' of XSD type 'ns1:SecurityCapabilities'
        ns1__SecurityCapabilities *Security;
        /// Required element 'ns1:System' of XSD type 'ns1:SystemCapabilities'
        ns1__SystemCapabilities *System;
        /// Optional element 'ns1:Misc' of XSD type 'ns1:MiscCapabilities'
        ns1__MiscCapabilities *Misc;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DeviceServiceCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DeviceServiceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DeviceServiceCapabilities, default initialized and not managed by a soap context
        virtual ns1__DeviceServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(ns1__DeviceServiceCapabilities); }
      public:
        /// Constructor with initializations
        ns1__DeviceServiceCapabilities()
        {
          Network = (ns1__NetworkCapabilities *)0;
          Security = (ns1__SecurityCapabilities *)0;
          System = (ns1__SystemCapabilities *)0;
          Misc = (ns1__MiscCapabilities *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns1__DeviceServiceCapabilities() { }
        /// Friend allocator used by soap_new_ns1__DeviceServiceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns1__DeviceServiceCapabilities * SOAP_FMAC2 soap_instantiate_ns1__DeviceServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:280 */
#ifndef SOAP_TYPE_ns1__NetworkCapabilities
#define SOAP_TYPE_ns1__NetworkCapabilities (244)
/* complex XSD type 'ns1:NetworkCapabilities': */
class SOAP_CMAC ns1__NetworkCapabilities {
      public:
        /// optional attribute 'IPFilter' of XSD type 'xsd:boolean'
        bool *IPFilter;
        /// optional attribute 'ZeroConfiguration' of XSD type 'xsd:boolean'
        bool *ZeroConfiguration;
        /// optional attribute 'IPVersion6' of XSD type 'xsd:boolean'
        bool *IPVersion6;
        /// optional attribute 'DynDNS' of XSD type 'xsd:boolean'
        bool *DynDNS;
        /// optional attribute 'Dot11Configuration' of XSD type 'xsd:boolean'
        bool *Dot11Configuration;
        /// optional attribute 'Dot1XConfigurations' of XSD type 'xsd:int'
        int *Dot1XConfigurations;
        /// optional attribute 'HostnameFromDHCP' of XSD type 'xsd:boolean'
        bool *HostnameFromDHCP;
        /// optional attribute 'NTP' of XSD type 'xsd:int'
        int *NTP;
        /// optional attribute 'DHCPv6' of XSD type 'xsd:boolean'
        bool *DHCPv6;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__NetworkCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__NetworkCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__NetworkCapabilities, default initialized and not managed by a soap context
        virtual ns1__NetworkCapabilities *soap_alloc(void) const { return SOAP_NEW(ns1__NetworkCapabilities); }
      public:
        /// Constructor with initializations
        ns1__NetworkCapabilities()
        {
          IPFilter = (bool *)0;
          ZeroConfiguration = (bool *)0;
          IPVersion6 = (bool *)0;
          DynDNS = (bool *)0;
          Dot11Configuration = (bool *)0;
          Dot1XConfigurations = (int *)0;
          HostnameFromDHCP = (bool *)0;
          NTP = (int *)0;
          DHCPv6 = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns1__NetworkCapabilities() { }
        /// Friend allocator used by soap_new_ns1__NetworkCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns1__NetworkCapabilities * SOAP_FMAC2 soap_instantiate_ns1__NetworkCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:283 */
#ifndef SOAP_TYPE_ns1__SecurityCapabilities
#define SOAP_TYPE_ns1__SecurityCapabilities (245)
/* complex XSD type 'ns1:SecurityCapabilities': */
class SOAP_CMAC ns1__SecurityCapabilities {
      public:
        /// optional attribute 'TLS1.0' of XSD type 'xsd:boolean'
        bool *TLS1_x002e0;
        /// optional attribute 'TLS1.1' of XSD type 'xsd:boolean'
        bool *TLS1_x002e1;
        /// optional attribute 'TLS1.2' of XSD type 'xsd:boolean'
        bool *TLS1_x002e2;
        /// optional attribute 'OnboardKeyGeneration' of XSD type 'xsd:boolean'
        bool *OnboardKeyGeneration;
        /// optional attribute 'AccessPolicyConfig' of XSD type 'xsd:boolean'
        bool *AccessPolicyConfig;
        /// optional attribute 'DefaultAccessPolicy' of XSD type 'xsd:boolean'
        bool *DefaultAccessPolicy;
        /// optional attribute 'Dot1X' of XSD type 'xsd:boolean'
        bool *Dot1X;
        /// optional attribute 'RemoteUserHandling' of XSD type 'xsd:boolean'
        bool *RemoteUserHandling;
        /// optional attribute 'X.509Token' of XSD type 'xsd:boolean'
        bool *X_x002e509Token;
        /// optional attribute 'SAMLToken' of XSD type 'xsd:boolean'
        bool *SAMLToken;
        /// optional attribute 'KerberosToken' of XSD type 'xsd:boolean'
        bool *KerberosToken;
        /// optional attribute 'UsernameToken' of XSD type 'xsd:boolean'
        bool *UsernameToken;
        /// optional attribute 'HttpDigest' of XSD type 'xsd:boolean'
        bool *HttpDigest;
        /// optional attribute 'RELToken' of XSD type 'xsd:boolean'
        bool *RELToken;
        /// optional attribute 'SupportedEAPMethods' of XSD type 'ns1:EAPMethodTypes'
        std::string *SupportedEAPMethods;
        /// optional attribute 'MaxUsers' of XSD type 'xsd:int'
        int *MaxUsers;
        /// optional attribute 'MaxUserNameLength' of XSD type 'xsd:int'
        int *MaxUserNameLength;
        /// optional attribute 'MaxPasswordLength' of XSD type 'xsd:int'
        int *MaxPasswordLength;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SecurityCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SecurityCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SecurityCapabilities, default initialized and not managed by a soap context
        virtual ns1__SecurityCapabilities *soap_alloc(void) const { return SOAP_NEW(ns1__SecurityCapabilities); }
      public:
        /// Constructor with initializations
        ns1__SecurityCapabilities()
        {
          TLS1_x002e0 = (bool *)0;
          TLS1_x002e1 = (bool *)0;
          TLS1_x002e2 = (bool *)0;
          OnboardKeyGeneration = (bool *)0;
          AccessPolicyConfig = (bool *)0;
          DefaultAccessPolicy = (bool *)0;
          Dot1X = (bool *)0;
          RemoteUserHandling = (bool *)0;
          X_x002e509Token = (bool *)0;
          SAMLToken = (bool *)0;
          KerberosToken = (bool *)0;
          UsernameToken = (bool *)0;
          HttpDigest = (bool *)0;
          RELToken = (bool *)0;
          SupportedEAPMethods = (std::string *)0;
          MaxUsers = (int *)0;
          MaxUserNameLength = (int *)0;
          MaxPasswordLength = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns1__SecurityCapabilities() { }
        /// Friend allocator used by soap_new_ns1__SecurityCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns1__SecurityCapabilities * SOAP_FMAC2 soap_instantiate_ns1__SecurityCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:286 */
#ifndef SOAP_TYPE_ns1__SystemCapabilities
#define SOAP_TYPE_ns1__SystemCapabilities (246)
/* complex XSD type 'ns1:SystemCapabilities': */
class SOAP_CMAC ns1__SystemCapabilities {
      public:
        /// optional attribute 'DiscoveryResolve' of XSD type 'xsd:boolean'
        bool *DiscoveryResolve;
        /// optional attribute 'DiscoveryBye' of XSD type 'xsd:boolean'
        bool *DiscoveryBye;
        /// optional attribute 'RemoteDiscovery' of XSD type 'xsd:boolean'
        bool *RemoteDiscovery;
        /// optional attribute 'SystemBackup' of XSD type 'xsd:boolean'
        bool *SystemBackup;
        /// optional attribute 'SystemLogging' of XSD type 'xsd:boolean'
        bool *SystemLogging;
        /// optional attribute 'FirmwareUpgrade' of XSD type 'xsd:boolean'
        bool *FirmwareUpgrade;
        /// optional attribute 'HttpFirmwareUpgrade' of XSD type 'xsd:boolean'
        bool *HttpFirmwareUpgrade;
        /// optional attribute 'HttpSystemBackup' of XSD type 'xsd:boolean'
        bool *HttpSystemBackup;
        /// optional attribute 'HttpSystemLogging' of XSD type 'xsd:boolean'
        bool *HttpSystemLogging;
        /// optional attribute 'HttpSupportInformation' of XSD type 'xsd:boolean'
        bool *HttpSupportInformation;
        /// optional attribute 'StorageConfiguration' of XSD type 'xsd:boolean'
        bool *StorageConfiguration;
        /// optional attribute 'MaxStorageConfigurations' of XSD type 'xsd:int'
        int *MaxStorageConfigurations;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SystemCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SystemCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SystemCapabilities, default initialized and not managed by a soap context
        virtual ns1__SystemCapabilities *soap_alloc(void) const { return SOAP_NEW(ns1__SystemCapabilities); }
      public:
        /// Constructor with initializations
        ns1__SystemCapabilities()
        {
          DiscoveryResolve = (bool *)0;
          DiscoveryBye = (bool *)0;
          RemoteDiscovery = (bool *)0;
          SystemBackup = (bool *)0;
          SystemLogging = (bool *)0;
          FirmwareUpgrade = (bool *)0;
          HttpFirmwareUpgrade = (bool *)0;
          HttpSystemBackup = (bool *)0;
          HttpSystemLogging = (bool *)0;
          HttpSupportInformation = (bool *)0;
          StorageConfiguration = (bool *)0;
          MaxStorageConfigurations = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns1__SystemCapabilities() { }
        /// Friend allocator used by soap_new_ns1__SystemCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns1__SystemCapabilities * SOAP_FMAC2 soap_instantiate_ns1__SystemCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:289 */
#ifndef SOAP_TYPE_ns1__MiscCapabilities
#define SOAP_TYPE_ns1__MiscCapabilities (247)
/* complex XSD type 'ns1:MiscCapabilities': */
class SOAP_CMAC ns1__MiscCapabilities {
      public:
        /// optional attribute 'AuxiliaryCommands' of XSD type 'ns2:StringAttrList'
        std::string *AuxiliaryCommands;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MiscCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MiscCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MiscCapabilities, default initialized and not managed by a soap context
        virtual ns1__MiscCapabilities *soap_alloc(void) const { return SOAP_NEW(ns1__MiscCapabilities); }
      public:
        /// Constructor with initializations
        ns1__MiscCapabilities()
        {
          AuxiliaryCommands = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns1__MiscCapabilities() { }
        /// Friend allocator used by soap_new_ns1__MiscCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns1__MiscCapabilities * SOAP_FMAC2 soap_instantiate_ns1__MiscCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:5380 */
#ifndef SOAP_TYPE__ns1__UserCredential_Extension
#define SOAP_TYPE__ns1__UserCredential_Extension (1486)
/* complex XSD type 'ns1:UserCredential-Extension': */
class SOAP_CMAC _ns1__UserCredential_Extension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UserCredential_Extension
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UserCredential_Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UserCredential_Extension, default initialized and not managed by a soap context
        virtual _ns1__UserCredential_Extension *soap_alloc(void) const { return SOAP_NEW(_ns1__UserCredential_Extension); }
      public:
        /// Constructor with initializations
        _ns1__UserCredential_Extension()
        {
        }
        virtual ~_ns1__UserCredential_Extension() { }
        /// Friend allocator used by soap_new__ns1__UserCredential_Extension(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UserCredential_Extension * SOAP_FMAC2 soap_instantiate__ns1__UserCredential_Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:292 */
#ifndef SOAP_TYPE_ns1__UserCredential
#define SOAP_TYPE_ns1__UserCredential (248)
/* complex XSD type 'ns1:UserCredential': */
class SOAP_CMAC ns1__UserCredential {
      public:
        /// Required element 'ns1:UserName' of XSD type 'xsd:string'
        std::string UserName;
        /// Optional element 'ns1:Password' of XSD type 'xsd:string'
        std::string *Password;
        /// Optional element 'ns1:Extension' of XSD type 'ns1:UserCredential-Extension'
        _ns1__UserCredential_Extension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__UserCredential
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__UserCredential; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__UserCredential, default initialized and not managed by a soap context
        virtual ns1__UserCredential *soap_alloc(void) const { return SOAP_NEW(ns1__UserCredential); }
      public:
        /// Constructor with initializations
        ns1__UserCredential()
        {
          Password = (std::string *)0;
          Extension = (_ns1__UserCredential_Extension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns1__UserCredential() { }
        /// Friend allocator used by soap_new_ns1__UserCredential(struct soap*, int)
        friend SOAP_FMAC1 ns1__UserCredential * SOAP_FMAC2 soap_instantiate_ns1__UserCredential(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:5434 */
#ifndef SOAP_TYPE__ns1__StorageConfigurationData_Extension
#define SOAP_TYPE__ns1__StorageConfigurationData_Extension (1490)
/* complex XSD type 'ns1:StorageConfigurationData-Extension': */
class SOAP_CMAC _ns1__StorageConfigurationData_Extension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
      public:
        /// Return unique type id SOAP_TYPE__ns1__StorageConfigurationData_Extension
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__StorageConfigurationData_Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__StorageConfigurationData_Extension, default initialized and not managed by a soap context
        virtual _ns1__StorageConfigurationData_Extension *soap_alloc(void) const { return SOAP_NEW(_ns1__StorageConfigurationData_Extension); }
      public:
        /// Constructor with initializations
        _ns1__StorageConfigurationData_Extension()
        {
        }
        virtual ~_ns1__StorageConfigurationData_Extension() { }
        /// Friend allocator used by soap_new__ns1__StorageConfigurationData_Extension(struct soap*, int)
        friend SOAP_FMAC1 _ns1__StorageConfigurationData_Extension * SOAP_FMAC2 soap_instantiate__ns1__StorageConfigurationData_Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:295 */
#ifndef SOAP_TYPE_ns1__StorageConfigurationData
#define SOAP_TYPE_ns1__StorageConfigurationData (249)
/* complex XSD type 'ns1:StorageConfigurationData': */
class SOAP_CMAC ns1__StorageConfigurationData {
      public:
        /// Optional element 'ns1:LocalPath' of XSD type 'xsd:anyURI'
        std::string *LocalPath;
        /// Optional element 'ns1:StorageUri' of XSD type 'xsd:anyURI'
        std::string *StorageUri;
        /// Optional element 'ns1:User' of XSD type 'ns1:UserCredential'
        ns1__UserCredential *User;
        /// Optional element 'ns1:Extension' of XSD type 'ns1:StorageConfigurationData-Extension'
        _ns1__StorageConfigurationData_Extension *Extension;
        /// required attribute 'type' of XSD type 'xsd:string'
        std::string type;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__StorageConfigurationData
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__StorageConfigurationData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__StorageConfigurationData, default initialized and not managed by a soap context
        virtual ns1__StorageConfigurationData *soap_alloc(void) const { return SOAP_NEW(ns1__StorageConfigurationData); }
      public:
        /// Constructor with initializations
        ns1__StorageConfigurationData()
        {
          LocalPath = (std::string *)0;
          StorageUri = (std::string *)0;
          User = (ns1__UserCredential *)0;
          Extension = (_ns1__StorageConfigurationData_Extension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns1__StorageConfigurationData() { }
        /// Friend allocator used by soap_new_ns1__StorageConfigurationData(struct soap*, int)
        friend SOAP_FMAC1 ns1__StorageConfigurationData * SOAP_FMAC2 soap_instantiate_ns1__StorageConfigurationData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:301 */
#ifndef SOAP_TYPE__ns1__GetServices
#define SOAP_TYPE__ns1__GetServices (251)
/* complex XSD type 'ns1:GetServices': */
class SOAP_CMAC _ns1__GetServices {
      public:
        /// Required element 'ns1:IncludeCapability' of XSD type 'xsd:boolean'
        bool IncludeCapability;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetServices
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetServices; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetServices, default initialized and not managed by a soap context
        virtual _ns1__GetServices *soap_alloc(void) const { return SOAP_NEW(_ns1__GetServices); }
      public:
        /// Constructor with initializations
        _ns1__GetServices()
        {
          IncludeCapability = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetServices() { }
        /// Friend allocator used by soap_new__ns1__GetServices(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetServices * SOAP_FMAC2 soap_instantiate__ns1__GetServices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:304 */
#ifndef SOAP_TYPE__ns1__GetServicesResponse
#define SOAP_TYPE__ns1__GetServicesResponse (252)
/* complex XSD type 'ns1:GetServicesResponse': */
class SOAP_CMAC _ns1__GetServicesResponse {
      public:
        /// Required element 'ns1:Service' of XSD type 'ns1:Service'
        std::vector<ns1__Service *> Service;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetServicesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetServicesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetServicesResponse, default initialized and not managed by a soap context
        virtual _ns1__GetServicesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetServicesResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetServicesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetServicesResponse() { }
        /// Friend allocator used by soap_new__ns1__GetServicesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetServicesResponse * SOAP_FMAC2 soap_instantiate__ns1__GetServicesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:307 */
#ifndef SOAP_TYPE__ns1__GetServiceCapabilities
#define SOAP_TYPE__ns1__GetServiceCapabilities (253)
/* complex XSD type 'ns1:GetServiceCapabilities': */
class SOAP_CMAC _ns1__GetServiceCapabilities {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetServiceCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetServiceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetServiceCapabilities, default initialized and not managed by a soap context
        virtual _ns1__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_ns1__GetServiceCapabilities); }
      public:
        /// Constructor with initializations
        _ns1__GetServiceCapabilities()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetServiceCapabilities() { }
        /// Friend allocator used by soap_new__ns1__GetServiceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__ns1__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:310 */
#ifndef SOAP_TYPE__ns1__GetServiceCapabilitiesResponse
#define SOAP_TYPE__ns1__GetServiceCapabilitiesResponse (254)
/* complex XSD type 'ns1:GetServiceCapabilitiesResponse': */
class SOAP_CMAC _ns1__GetServiceCapabilitiesResponse {
      public:
        /// Required element 'ns1:Capabilities' of XSD type 'ns1:DeviceServiceCapabilities'
        ns1__DeviceServiceCapabilities *Capabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetServiceCapabilitiesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetServiceCapabilitiesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
        virtual _ns1__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetServiceCapabilitiesResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetServiceCapabilitiesResponse()
        {
          Capabilities = (ns1__DeviceServiceCapabilities *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetServiceCapabilitiesResponse() { }
        /// Friend allocator used by soap_new__ns1__GetServiceCapabilitiesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__ns1__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:313 */
#ifndef SOAP_TYPE__ns1__GetDeviceInformation
#define SOAP_TYPE__ns1__GetDeviceInformation (255)
/* complex XSD type 'ns1:GetDeviceInformation': */
class SOAP_CMAC _ns1__GetDeviceInformation {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetDeviceInformation
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetDeviceInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetDeviceInformation, default initialized and not managed by a soap context
        virtual _ns1__GetDeviceInformation *soap_alloc(void) const { return SOAP_NEW(_ns1__GetDeviceInformation); }
      public:
        /// Constructor with initializations
        _ns1__GetDeviceInformation()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetDeviceInformation() { }
        /// Friend allocator used by soap_new__ns1__GetDeviceInformation(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetDeviceInformation * SOAP_FMAC2 soap_instantiate__ns1__GetDeviceInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:316 */
#ifndef SOAP_TYPE__ns1__GetDeviceInformationResponse
#define SOAP_TYPE__ns1__GetDeviceInformationResponse (256)
/* complex XSD type 'ns1:GetDeviceInformationResponse': */
class SOAP_CMAC _ns1__GetDeviceInformationResponse {
      public:
        /// Required element 'ns1:Manufacturer' of XSD type 'xsd:string'
        std::string Manufacturer;
        /// Required element 'ns1:Model' of XSD type 'xsd:string'
        std::string Model;
        /// Required element 'ns1:FirmwareVersion' of XSD type 'xsd:string'
        std::string FirmwareVersion;
        /// Required element 'ns1:SerialNumber' of XSD type 'xsd:string'
        std::string SerialNumber;
        /// Required element 'ns1:HardwareId' of XSD type 'xsd:string'
        std::string HardwareId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetDeviceInformationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetDeviceInformationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetDeviceInformationResponse, default initialized and not managed by a soap context
        virtual _ns1__GetDeviceInformationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetDeviceInformationResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetDeviceInformationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetDeviceInformationResponse() { }
        /// Friend allocator used by soap_new__ns1__GetDeviceInformationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetDeviceInformationResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDeviceInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:319 */
#ifndef SOAP_TYPE__ns1__SetSystemDateAndTime
#define SOAP_TYPE__ns1__SetSystemDateAndTime (257)
/* complex XSD type 'ns1:SetSystemDateAndTime': */
class SOAP_CMAC _ns1__SetSystemDateAndTime {
      public:
        /// Required element 'ns1:DateTimeType' of XSD type 'ns2:SetDateTimeType'
        ns2__SetDateTimeType DateTimeType;
        /// Required element 'ns1:DaylightSavings' of XSD type 'xsd:boolean'
        bool DaylightSavings;
        /// Optional element 'ns1:TimeZone' of XSD type 'ns2:TimeZone'
        ns2__TimeZone *TimeZone;
        /// Optional element 'ns1:UTCDateTime' of XSD type 'ns2:DateTime'
        ns2__DateTime *UTCDateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetSystemDateAndTime
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetSystemDateAndTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetSystemDateAndTime, default initialized and not managed by a soap context
        virtual _ns1__SetSystemDateAndTime *soap_alloc(void) const { return SOAP_NEW(_ns1__SetSystemDateAndTime); }
      public:
        /// Constructor with initializations
        _ns1__SetSystemDateAndTime()
        {
          DateTimeType = (ns2__SetDateTimeType)0;
          DaylightSavings = (bool)0;
          TimeZone = (ns2__TimeZone *)0;
          UTCDateTime = (ns2__DateTime *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetSystemDateAndTime() { }
        /// Friend allocator used by soap_new__ns1__SetSystemDateAndTime(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetSystemDateAndTime * SOAP_FMAC2 soap_instantiate__ns1__SetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:322 */
#ifndef SOAP_TYPE__ns1__SetSystemDateAndTimeResponse
#define SOAP_TYPE__ns1__SetSystemDateAndTimeResponse (258)
/* complex XSD type 'ns1:SetSystemDateAndTimeResponse': */
class SOAP_CMAC _ns1__SetSystemDateAndTimeResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetSystemDateAndTimeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetSystemDateAndTimeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetSystemDateAndTimeResponse, default initialized and not managed by a soap context
        virtual _ns1__SetSystemDateAndTimeResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetSystemDateAndTimeResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetSystemDateAndTimeResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetSystemDateAndTimeResponse() { }
        /// Friend allocator used by soap_new__ns1__SetSystemDateAndTimeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetSystemDateAndTimeResponse * SOAP_FMAC2 soap_instantiate__ns1__SetSystemDateAndTimeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:325 */
#ifndef SOAP_TYPE__ns1__GetSystemDateAndTime
#define SOAP_TYPE__ns1__GetSystemDateAndTime (259)
/* complex XSD type 'ns1:GetSystemDateAndTime': */
class SOAP_CMAC _ns1__GetSystemDateAndTime {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSystemDateAndTime
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSystemDateAndTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSystemDateAndTime, default initialized and not managed by a soap context
        virtual _ns1__GetSystemDateAndTime *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSystemDateAndTime); }
      public:
        /// Constructor with initializations
        _ns1__GetSystemDateAndTime()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetSystemDateAndTime() { }
        /// Friend allocator used by soap_new__ns1__GetSystemDateAndTime(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSystemDateAndTime * SOAP_FMAC2 soap_instantiate__ns1__GetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:328 */
#ifndef SOAP_TYPE__ns1__GetSystemDateAndTimeResponse
#define SOAP_TYPE__ns1__GetSystemDateAndTimeResponse (260)
/* complex XSD type 'ns1:GetSystemDateAndTimeResponse': */
class SOAP_CMAC _ns1__GetSystemDateAndTimeResponse {
      public:
        /// Required element 'ns1:SystemDateAndTime' of XSD type 'ns2:SystemDateTime'
        ns2__SystemDateTime *SystemDateAndTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSystemDateAndTimeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSystemDateAndTimeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSystemDateAndTimeResponse, default initialized and not managed by a soap context
        virtual _ns1__GetSystemDateAndTimeResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSystemDateAndTimeResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetSystemDateAndTimeResponse()
        {
          SystemDateAndTime = (ns2__SystemDateTime *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetSystemDateAndTimeResponse() { }
        /// Friend allocator used by soap_new__ns1__GetSystemDateAndTimeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSystemDateAndTimeResponse * SOAP_FMAC2 soap_instantiate__ns1__GetSystemDateAndTimeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:331 */
#ifndef SOAP_TYPE__ns1__SetSystemFactoryDefault
#define SOAP_TYPE__ns1__SetSystemFactoryDefault (261)
/* complex XSD type 'ns1:SetSystemFactoryDefault': */
class SOAP_CMAC _ns1__SetSystemFactoryDefault {
      public:
        /// Required element 'ns1:FactoryDefault' of XSD type 'ns2:FactoryDefaultType'
        ns2__FactoryDefaultType FactoryDefault;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetSystemFactoryDefault
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetSystemFactoryDefault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetSystemFactoryDefault, default initialized and not managed by a soap context
        virtual _ns1__SetSystemFactoryDefault *soap_alloc(void) const { return SOAP_NEW(_ns1__SetSystemFactoryDefault); }
      public:
        /// Constructor with initializations
        _ns1__SetSystemFactoryDefault()
        {
          FactoryDefault = (ns2__FactoryDefaultType)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetSystemFactoryDefault() { }
        /// Friend allocator used by soap_new__ns1__SetSystemFactoryDefault(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetSystemFactoryDefault * SOAP_FMAC2 soap_instantiate__ns1__SetSystemFactoryDefault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:334 */
#ifndef SOAP_TYPE__ns1__SetSystemFactoryDefaultResponse
#define SOAP_TYPE__ns1__SetSystemFactoryDefaultResponse (262)
/* complex XSD type 'ns1:SetSystemFactoryDefaultResponse': */
class SOAP_CMAC _ns1__SetSystemFactoryDefaultResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetSystemFactoryDefaultResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetSystemFactoryDefaultResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetSystemFactoryDefaultResponse, default initialized and not managed by a soap context
        virtual _ns1__SetSystemFactoryDefaultResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetSystemFactoryDefaultResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetSystemFactoryDefaultResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetSystemFactoryDefaultResponse() { }
        /// Friend allocator used by soap_new__ns1__SetSystemFactoryDefaultResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetSystemFactoryDefaultResponse * SOAP_FMAC2 soap_instantiate__ns1__SetSystemFactoryDefaultResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:337 */
#ifndef SOAP_TYPE__ns1__UpgradeSystemFirmware
#define SOAP_TYPE__ns1__UpgradeSystemFirmware (263)
/* complex XSD type 'ns1:UpgradeSystemFirmware': */
class SOAP_CMAC _ns1__UpgradeSystemFirmware {
      public:
        /// Required element 'ns1:Firmware' of XSD type 'ns2:AttachmentData'
        ns2__AttachmentData *Firmware;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UpgradeSystemFirmware
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UpgradeSystemFirmware; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UpgradeSystemFirmware, default initialized and not managed by a soap context
        virtual _ns1__UpgradeSystemFirmware *soap_alloc(void) const { return SOAP_NEW(_ns1__UpgradeSystemFirmware); }
      public:
        /// Constructor with initializations
        _ns1__UpgradeSystemFirmware()
        {
          Firmware = (ns2__AttachmentData *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__UpgradeSystemFirmware() { }
        /// Friend allocator used by soap_new__ns1__UpgradeSystemFirmware(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UpgradeSystemFirmware * SOAP_FMAC2 soap_instantiate__ns1__UpgradeSystemFirmware(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:340 */
#ifndef SOAP_TYPE__ns1__UpgradeSystemFirmwareResponse
#define SOAP_TYPE__ns1__UpgradeSystemFirmwareResponse (264)
/* complex XSD type 'ns1:UpgradeSystemFirmwareResponse': */
class SOAP_CMAC _ns1__UpgradeSystemFirmwareResponse {
      public:
        /// Optional element 'ns1:Message' of XSD type 'xsd:string'
        std::string *Message;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UpgradeSystemFirmwareResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UpgradeSystemFirmwareResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UpgradeSystemFirmwareResponse, default initialized and not managed by a soap context
        virtual _ns1__UpgradeSystemFirmwareResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__UpgradeSystemFirmwareResponse); }
      public:
        /// Constructor with initializations
        _ns1__UpgradeSystemFirmwareResponse()
        {
          Message = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__UpgradeSystemFirmwareResponse() { }
        /// Friend allocator used by soap_new__ns1__UpgradeSystemFirmwareResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UpgradeSystemFirmwareResponse * SOAP_FMAC2 soap_instantiate__ns1__UpgradeSystemFirmwareResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:343 */
#ifndef SOAP_TYPE__ns1__SystemReboot
#define SOAP_TYPE__ns1__SystemReboot (265)
/* complex XSD type 'ns1:SystemReboot': */
class SOAP_CMAC _ns1__SystemReboot {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SystemReboot
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SystemReboot; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SystemReboot, default initialized and not managed by a soap context
        virtual _ns1__SystemReboot *soap_alloc(void) const { return SOAP_NEW(_ns1__SystemReboot); }
      public:
        /// Constructor with initializations
        _ns1__SystemReboot()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SystemReboot() { }
        /// Friend allocator used by soap_new__ns1__SystemReboot(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SystemReboot * SOAP_FMAC2 soap_instantiate__ns1__SystemReboot(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:346 */
#ifndef SOAP_TYPE__ns1__SystemRebootResponse
#define SOAP_TYPE__ns1__SystemRebootResponse (266)
/* complex XSD type 'ns1:SystemRebootResponse': */
class SOAP_CMAC _ns1__SystemRebootResponse {
      public:
        /// Required element 'ns1:Message' of XSD type 'xsd:string'
        std::string Message;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SystemRebootResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SystemRebootResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SystemRebootResponse, default initialized and not managed by a soap context
        virtual _ns1__SystemRebootResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SystemRebootResponse); }
      public:
        /// Constructor with initializations
        _ns1__SystemRebootResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SystemRebootResponse() { }
        /// Friend allocator used by soap_new__ns1__SystemRebootResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SystemRebootResponse * SOAP_FMAC2 soap_instantiate__ns1__SystemRebootResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:349 */
#ifndef SOAP_TYPE__ns1__RestoreSystem
#define SOAP_TYPE__ns1__RestoreSystem (267)
/* complex XSD type 'ns1:RestoreSystem': */
class SOAP_CMAC _ns1__RestoreSystem {
      public:
        /// Required element 'ns1:BackupFiles' of XSD type 'ns2:BackupFile'
        std::vector<ns2__BackupFile *> BackupFiles;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RestoreSystem
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RestoreSystem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RestoreSystem, default initialized and not managed by a soap context
        virtual _ns1__RestoreSystem *soap_alloc(void) const { return SOAP_NEW(_ns1__RestoreSystem); }
      public:
        /// Constructor with initializations
        _ns1__RestoreSystem()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RestoreSystem() { }
        /// Friend allocator used by soap_new__ns1__RestoreSystem(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RestoreSystem * SOAP_FMAC2 soap_instantiate__ns1__RestoreSystem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:352 */
#ifndef SOAP_TYPE__ns1__RestoreSystemResponse
#define SOAP_TYPE__ns1__RestoreSystemResponse (268)
/* complex XSD type 'ns1:RestoreSystemResponse': */
class SOAP_CMAC _ns1__RestoreSystemResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RestoreSystemResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RestoreSystemResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RestoreSystemResponse, default initialized and not managed by a soap context
        virtual _ns1__RestoreSystemResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__RestoreSystemResponse); }
      public:
        /// Constructor with initializations
        _ns1__RestoreSystemResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RestoreSystemResponse() { }
        /// Friend allocator used by soap_new__ns1__RestoreSystemResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RestoreSystemResponse * SOAP_FMAC2 soap_instantiate__ns1__RestoreSystemResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:355 */
#ifndef SOAP_TYPE__ns1__GetSystemBackup
#define SOAP_TYPE__ns1__GetSystemBackup (269)
/* complex XSD type 'ns1:GetSystemBackup': */
class SOAP_CMAC _ns1__GetSystemBackup {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSystemBackup
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSystemBackup; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSystemBackup, default initialized and not managed by a soap context
        virtual _ns1__GetSystemBackup *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSystemBackup); }
      public:
        /// Constructor with initializations
        _ns1__GetSystemBackup()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetSystemBackup() { }
        /// Friend allocator used by soap_new__ns1__GetSystemBackup(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSystemBackup * SOAP_FMAC2 soap_instantiate__ns1__GetSystemBackup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:358 */
#ifndef SOAP_TYPE__ns1__GetSystemBackupResponse
#define SOAP_TYPE__ns1__GetSystemBackupResponse (270)
/* complex XSD type 'ns1:GetSystemBackupResponse': */
class SOAP_CMAC _ns1__GetSystemBackupResponse {
      public:
        /// Required element 'ns1:BackupFiles' of XSD type 'ns2:BackupFile'
        std::vector<ns2__BackupFile *> BackupFiles;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSystemBackupResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSystemBackupResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSystemBackupResponse, default initialized and not managed by a soap context
        virtual _ns1__GetSystemBackupResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSystemBackupResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetSystemBackupResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetSystemBackupResponse() { }
        /// Friend allocator used by soap_new__ns1__GetSystemBackupResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSystemBackupResponse * SOAP_FMAC2 soap_instantiate__ns1__GetSystemBackupResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:361 */
#ifndef SOAP_TYPE__ns1__GetSystemSupportInformation
#define SOAP_TYPE__ns1__GetSystemSupportInformation (271)
/* complex XSD type 'ns1:GetSystemSupportInformation': */
class SOAP_CMAC _ns1__GetSystemSupportInformation {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSystemSupportInformation
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSystemSupportInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSystemSupportInformation, default initialized and not managed by a soap context
        virtual _ns1__GetSystemSupportInformation *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSystemSupportInformation); }
      public:
        /// Constructor with initializations
        _ns1__GetSystemSupportInformation()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetSystemSupportInformation() { }
        /// Friend allocator used by soap_new__ns1__GetSystemSupportInformation(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSystemSupportInformation * SOAP_FMAC2 soap_instantiate__ns1__GetSystemSupportInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:364 */
#ifndef SOAP_TYPE__ns1__GetSystemSupportInformationResponse
#define SOAP_TYPE__ns1__GetSystemSupportInformationResponse (272)
/* complex XSD type 'ns1:GetSystemSupportInformationResponse': */
class SOAP_CMAC _ns1__GetSystemSupportInformationResponse {
      public:
        /// Required element 'ns1:SupportInformation' of XSD type 'ns2:SupportInformation'
        ns2__SupportInformation *SupportInformation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSystemSupportInformationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSystemSupportInformationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSystemSupportInformationResponse, default initialized and not managed by a soap context
        virtual _ns1__GetSystemSupportInformationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSystemSupportInformationResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetSystemSupportInformationResponse()
        {
          SupportInformation = (ns2__SupportInformation *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetSystemSupportInformationResponse() { }
        /// Friend allocator used by soap_new__ns1__GetSystemSupportInformationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSystemSupportInformationResponse * SOAP_FMAC2 soap_instantiate__ns1__GetSystemSupportInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:367 */
#ifndef SOAP_TYPE__ns1__GetSystemLog
#define SOAP_TYPE__ns1__GetSystemLog (273)
/* complex XSD type 'ns1:GetSystemLog': */
class SOAP_CMAC _ns1__GetSystemLog {
      public:
        /// Required element 'ns1:LogType' of XSD type 'ns2:SystemLogType'
        ns2__SystemLogType LogType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSystemLog
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSystemLog; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSystemLog, default initialized and not managed by a soap context
        virtual _ns1__GetSystemLog *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSystemLog); }
      public:
        /// Constructor with initializations
        _ns1__GetSystemLog()
        {
          LogType = (ns2__SystemLogType)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetSystemLog() { }
        /// Friend allocator used by soap_new__ns1__GetSystemLog(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSystemLog * SOAP_FMAC2 soap_instantiate__ns1__GetSystemLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:370 */
#ifndef SOAP_TYPE__ns1__GetSystemLogResponse
#define SOAP_TYPE__ns1__GetSystemLogResponse (274)
/* complex XSD type 'ns1:GetSystemLogResponse': */
class SOAP_CMAC _ns1__GetSystemLogResponse {
      public:
        /// Required element 'ns1:SystemLog' of XSD type 'ns2:SystemLog'
        ns2__SystemLog *SystemLog;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSystemLogResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSystemLogResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSystemLogResponse, default initialized and not managed by a soap context
        virtual _ns1__GetSystemLogResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSystemLogResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetSystemLogResponse()
        {
          SystemLog = (ns2__SystemLog *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetSystemLogResponse() { }
        /// Friend allocator used by soap_new__ns1__GetSystemLogResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSystemLogResponse * SOAP_FMAC2 soap_instantiate__ns1__GetSystemLogResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:373 */
#ifndef SOAP_TYPE__ns1__GetScopes
#define SOAP_TYPE__ns1__GetScopes (275)
/* complex XSD type 'ns1:GetScopes': */
class SOAP_CMAC _ns1__GetScopes {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetScopes
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetScopes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetScopes, default initialized and not managed by a soap context
        virtual _ns1__GetScopes *soap_alloc(void) const { return SOAP_NEW(_ns1__GetScopes); }
      public:
        /// Constructor with initializations
        _ns1__GetScopes()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetScopes() { }
        /// Friend allocator used by soap_new__ns1__GetScopes(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetScopes * SOAP_FMAC2 soap_instantiate__ns1__GetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:376 */
#ifndef SOAP_TYPE__ns1__GetScopesResponse
#define SOAP_TYPE__ns1__GetScopesResponse (276)
/* complex XSD type 'ns1:GetScopesResponse': */
class SOAP_CMAC _ns1__GetScopesResponse {
      public:
        /// Required element 'ns1:Scopes' of XSD type 'ns2:Scope'
        std::vector<ns2__Scope *> Scopes;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetScopesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetScopesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetScopesResponse, default initialized and not managed by a soap context
        virtual _ns1__GetScopesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetScopesResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetScopesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetScopesResponse() { }
        /// Friend allocator used by soap_new__ns1__GetScopesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetScopesResponse * SOAP_FMAC2 soap_instantiate__ns1__GetScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:379 */
#ifndef SOAP_TYPE__ns1__SetScopes
#define SOAP_TYPE__ns1__SetScopes (277)
/* complex XSD type 'ns1:SetScopes': */
class SOAP_CMAC _ns1__SetScopes {
      public:
        /// Required element 'ns1:Scopes' of XSD type 'xsd:anyURI'
        std::vector<std::string> Scopes;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetScopes
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetScopes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetScopes, default initialized and not managed by a soap context
        virtual _ns1__SetScopes *soap_alloc(void) const { return SOAP_NEW(_ns1__SetScopes); }
      public:
        /// Constructor with initializations
        _ns1__SetScopes()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetScopes() { }
        /// Friend allocator used by soap_new__ns1__SetScopes(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetScopes * SOAP_FMAC2 soap_instantiate__ns1__SetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:382 */
#ifndef SOAP_TYPE__ns1__SetScopesResponse
#define SOAP_TYPE__ns1__SetScopesResponse (278)
/* complex XSD type 'ns1:SetScopesResponse': */
class SOAP_CMAC _ns1__SetScopesResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetScopesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetScopesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetScopesResponse, default initialized and not managed by a soap context
        virtual _ns1__SetScopesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetScopesResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetScopesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetScopesResponse() { }
        /// Friend allocator used by soap_new__ns1__SetScopesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetScopesResponse * SOAP_FMAC2 soap_instantiate__ns1__SetScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:385 */
#ifndef SOAP_TYPE__ns1__AddScopes
#define SOAP_TYPE__ns1__AddScopes (279)
/* complex XSD type 'ns1:AddScopes': */
class SOAP_CMAC _ns1__AddScopes {
      public:
        /// Required element 'ns1:ScopeItem' of XSD type 'xsd:anyURI'
        std::vector<std::string> ScopeItem;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__AddScopes
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__AddScopes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__AddScopes, default initialized and not managed by a soap context
        virtual _ns1__AddScopes *soap_alloc(void) const { return SOAP_NEW(_ns1__AddScopes); }
      public:
        /// Constructor with initializations
        _ns1__AddScopes()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__AddScopes() { }
        /// Friend allocator used by soap_new__ns1__AddScopes(struct soap*, int)
        friend SOAP_FMAC1 _ns1__AddScopes * SOAP_FMAC2 soap_instantiate__ns1__AddScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:388 */
#ifndef SOAP_TYPE__ns1__AddScopesResponse
#define SOAP_TYPE__ns1__AddScopesResponse (280)
/* complex XSD type 'ns1:AddScopesResponse': */
class SOAP_CMAC _ns1__AddScopesResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__AddScopesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__AddScopesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__AddScopesResponse, default initialized and not managed by a soap context
        virtual _ns1__AddScopesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__AddScopesResponse); }
      public:
        /// Constructor with initializations
        _ns1__AddScopesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__AddScopesResponse() { }
        /// Friend allocator used by soap_new__ns1__AddScopesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__AddScopesResponse * SOAP_FMAC2 soap_instantiate__ns1__AddScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:391 */
#ifndef SOAP_TYPE__ns1__RemoveScopes
#define SOAP_TYPE__ns1__RemoveScopes (281)
/* complex XSD type 'ns1:RemoveScopes': */
class SOAP_CMAC _ns1__RemoveScopes {
      public:
        /// Required element 'ns1:ScopeItem' of XSD type 'xsd:anyURI'
        std::vector<std::string> ScopeItem;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RemoveScopes
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RemoveScopes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RemoveScopes, default initialized and not managed by a soap context
        virtual _ns1__RemoveScopes *soap_alloc(void) const { return SOAP_NEW(_ns1__RemoveScopes); }
      public:
        /// Constructor with initializations
        _ns1__RemoveScopes()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RemoveScopes() { }
        /// Friend allocator used by soap_new__ns1__RemoveScopes(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RemoveScopes * SOAP_FMAC2 soap_instantiate__ns1__RemoveScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:394 */
#ifndef SOAP_TYPE__ns1__RemoveScopesResponse
#define SOAP_TYPE__ns1__RemoveScopesResponse (282)
/* complex XSD type 'ns1:RemoveScopesResponse': */
class SOAP_CMAC _ns1__RemoveScopesResponse {
      public:
        /// Optional element 'ns1:ScopeItem' of XSD type 'xsd:anyURI'
        std::vector<std::string> ScopeItem;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RemoveScopesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RemoveScopesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RemoveScopesResponse, default initialized and not managed by a soap context
        virtual _ns1__RemoveScopesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__RemoveScopesResponse); }
      public:
        /// Constructor with initializations
        _ns1__RemoveScopesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RemoveScopesResponse() { }
        /// Friend allocator used by soap_new__ns1__RemoveScopesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RemoveScopesResponse * SOAP_FMAC2 soap_instantiate__ns1__RemoveScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:397 */
#ifndef SOAP_TYPE__ns1__GetDiscoveryMode
#define SOAP_TYPE__ns1__GetDiscoveryMode (283)
/* complex XSD type 'ns1:GetDiscoveryMode': */
class SOAP_CMAC _ns1__GetDiscoveryMode {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetDiscoveryMode
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetDiscoveryMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetDiscoveryMode, default initialized and not managed by a soap context
        virtual _ns1__GetDiscoveryMode *soap_alloc(void) const { return SOAP_NEW(_ns1__GetDiscoveryMode); }
      public:
        /// Constructor with initializations
        _ns1__GetDiscoveryMode()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetDiscoveryMode() { }
        /// Friend allocator used by soap_new__ns1__GetDiscoveryMode(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetDiscoveryMode * SOAP_FMAC2 soap_instantiate__ns1__GetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:400 */
#ifndef SOAP_TYPE__ns1__GetDiscoveryModeResponse
#define SOAP_TYPE__ns1__GetDiscoveryModeResponse (284)
/* complex XSD type 'ns1:GetDiscoveryModeResponse': */
class SOAP_CMAC _ns1__GetDiscoveryModeResponse {
      public:
        /// Required element 'ns1:DiscoveryMode' of XSD type 'ns2:DiscoveryMode'
        ns2__DiscoveryMode DiscoveryMode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetDiscoveryModeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetDiscoveryModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetDiscoveryModeResponse, default initialized and not managed by a soap context
        virtual _ns1__GetDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetDiscoveryModeResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetDiscoveryModeResponse()
        {
          DiscoveryMode = (ns2__DiscoveryMode)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetDiscoveryModeResponse() { }
        /// Friend allocator used by soap_new__ns1__GetDiscoveryModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:403 */
#ifndef SOAP_TYPE__ns1__SetDiscoveryMode
#define SOAP_TYPE__ns1__SetDiscoveryMode (285)
/* complex XSD type 'ns1:SetDiscoveryMode': */
class SOAP_CMAC _ns1__SetDiscoveryMode {
      public:
        /// Required element 'ns1:DiscoveryMode' of XSD type 'ns2:DiscoveryMode'
        ns2__DiscoveryMode DiscoveryMode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetDiscoveryMode
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetDiscoveryMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetDiscoveryMode, default initialized and not managed by a soap context
        virtual _ns1__SetDiscoveryMode *soap_alloc(void) const { return SOAP_NEW(_ns1__SetDiscoveryMode); }
      public:
        /// Constructor with initializations
        _ns1__SetDiscoveryMode()
        {
          DiscoveryMode = (ns2__DiscoveryMode)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetDiscoveryMode() { }
        /// Friend allocator used by soap_new__ns1__SetDiscoveryMode(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetDiscoveryMode * SOAP_FMAC2 soap_instantiate__ns1__SetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:406 */
#ifndef SOAP_TYPE__ns1__SetDiscoveryModeResponse
#define SOAP_TYPE__ns1__SetDiscoveryModeResponse (286)
/* complex XSD type 'ns1:SetDiscoveryModeResponse': */
class SOAP_CMAC _ns1__SetDiscoveryModeResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetDiscoveryModeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetDiscoveryModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetDiscoveryModeResponse, default initialized and not managed by a soap context
        virtual _ns1__SetDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetDiscoveryModeResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetDiscoveryModeResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetDiscoveryModeResponse() { }
        /// Friend allocator used by soap_new__ns1__SetDiscoveryModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__ns1__SetDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:409 */
#ifndef SOAP_TYPE__ns1__GetRemoteDiscoveryMode
#define SOAP_TYPE__ns1__GetRemoteDiscoveryMode (287)
/* complex XSD type 'ns1:GetRemoteDiscoveryMode': */
class SOAP_CMAC _ns1__GetRemoteDiscoveryMode {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetRemoteDiscoveryMode
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetRemoteDiscoveryMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetRemoteDiscoveryMode, default initialized and not managed by a soap context
        virtual _ns1__GetRemoteDiscoveryMode *soap_alloc(void) const { return SOAP_NEW(_ns1__GetRemoteDiscoveryMode); }
      public:
        /// Constructor with initializations
        _ns1__GetRemoteDiscoveryMode()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetRemoteDiscoveryMode() { }
        /// Friend allocator used by soap_new__ns1__GetRemoteDiscoveryMode(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate__ns1__GetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:412 */
#ifndef SOAP_TYPE__ns1__GetRemoteDiscoveryModeResponse
#define SOAP_TYPE__ns1__GetRemoteDiscoveryModeResponse (288)
/* complex XSD type 'ns1:GetRemoteDiscoveryModeResponse': */
class SOAP_CMAC _ns1__GetRemoteDiscoveryModeResponse {
      public:
        /// Required element 'ns1:RemoteDiscoveryMode' of XSD type 'ns2:DiscoveryMode'
        ns2__DiscoveryMode RemoteDiscoveryMode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetRemoteDiscoveryModeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetRemoteDiscoveryModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetRemoteDiscoveryModeResponse, default initialized and not managed by a soap context
        virtual _ns1__GetRemoteDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetRemoteDiscoveryModeResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetRemoteDiscoveryModeResponse()
        {
          RemoteDiscoveryMode = (ns2__DiscoveryMode)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetRemoteDiscoveryModeResponse() { }
        /// Friend allocator used by soap_new__ns1__GetRemoteDiscoveryModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetRemoteDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__ns1__GetRemoteDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:415 */
#ifndef SOAP_TYPE__ns1__SetRemoteDiscoveryMode
#define SOAP_TYPE__ns1__SetRemoteDiscoveryMode (289)
/* complex XSD type 'ns1:SetRemoteDiscoveryMode': */
class SOAP_CMAC _ns1__SetRemoteDiscoveryMode {
      public:
        /// Required element 'ns1:RemoteDiscoveryMode' of XSD type 'ns2:DiscoveryMode'
        ns2__DiscoveryMode RemoteDiscoveryMode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetRemoteDiscoveryMode
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetRemoteDiscoveryMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetRemoteDiscoveryMode, default initialized and not managed by a soap context
        virtual _ns1__SetRemoteDiscoveryMode *soap_alloc(void) const { return SOAP_NEW(_ns1__SetRemoteDiscoveryMode); }
      public:
        /// Constructor with initializations
        _ns1__SetRemoteDiscoveryMode()
        {
          RemoteDiscoveryMode = (ns2__DiscoveryMode)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetRemoteDiscoveryMode() { }
        /// Friend allocator used by soap_new__ns1__SetRemoteDiscoveryMode(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate__ns1__SetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:418 */
#ifndef SOAP_TYPE__ns1__SetRemoteDiscoveryModeResponse
#define SOAP_TYPE__ns1__SetRemoteDiscoveryModeResponse (290)
/* complex XSD type 'ns1:SetRemoteDiscoveryModeResponse': */
class SOAP_CMAC _ns1__SetRemoteDiscoveryModeResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetRemoteDiscoveryModeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetRemoteDiscoveryModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetRemoteDiscoveryModeResponse, default initialized and not managed by a soap context
        virtual _ns1__SetRemoteDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetRemoteDiscoveryModeResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetRemoteDiscoveryModeResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetRemoteDiscoveryModeResponse() { }
        /// Friend allocator used by soap_new__ns1__SetRemoteDiscoveryModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetRemoteDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__ns1__SetRemoteDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:421 */
#ifndef SOAP_TYPE__ns1__GetDPAddresses
#define SOAP_TYPE__ns1__GetDPAddresses (291)
/* complex XSD type 'ns1:GetDPAddresses': */
class SOAP_CMAC _ns1__GetDPAddresses {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetDPAddresses
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetDPAddresses; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetDPAddresses, default initialized and not managed by a soap context
        virtual _ns1__GetDPAddresses *soap_alloc(void) const { return SOAP_NEW(_ns1__GetDPAddresses); }
      public:
        /// Constructor with initializations
        _ns1__GetDPAddresses()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetDPAddresses() { }
        /// Friend allocator used by soap_new__ns1__GetDPAddresses(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetDPAddresses * SOAP_FMAC2 soap_instantiate__ns1__GetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:424 */
#ifndef SOAP_TYPE__ns1__GetDPAddressesResponse
#define SOAP_TYPE__ns1__GetDPAddressesResponse (292)
/* complex XSD type 'ns1:GetDPAddressesResponse': */
class SOAP_CMAC _ns1__GetDPAddressesResponse {
      public:
        /// Optional element 'ns1:DPAddress' of XSD type 'ns2:NetworkHost'
        std::vector<ns2__NetworkHost *> DPAddress;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetDPAddressesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetDPAddressesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetDPAddressesResponse, default initialized and not managed by a soap context
        virtual _ns1__GetDPAddressesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetDPAddressesResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetDPAddressesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetDPAddressesResponse() { }
        /// Friend allocator used by soap_new__ns1__GetDPAddressesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetDPAddressesResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDPAddressesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:427 */
#ifndef SOAP_TYPE__ns1__SetDPAddresses
#define SOAP_TYPE__ns1__SetDPAddresses (293)
/* complex XSD type 'ns1:SetDPAddresses': */
class SOAP_CMAC _ns1__SetDPAddresses {
      public:
        /// Optional element 'ns1:DPAddress' of XSD type 'ns2:NetworkHost'
        std::vector<ns2__NetworkHost *> DPAddress;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetDPAddresses
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetDPAddresses; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetDPAddresses, default initialized and not managed by a soap context
        virtual _ns1__SetDPAddresses *soap_alloc(void) const { return SOAP_NEW(_ns1__SetDPAddresses); }
      public:
        /// Constructor with initializations
        _ns1__SetDPAddresses()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetDPAddresses() { }
        /// Friend allocator used by soap_new__ns1__SetDPAddresses(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetDPAddresses * SOAP_FMAC2 soap_instantiate__ns1__SetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:430 */
#ifndef SOAP_TYPE__ns1__SetDPAddressesResponse
#define SOAP_TYPE__ns1__SetDPAddressesResponse (294)
/* complex XSD type 'ns1:SetDPAddressesResponse': */
class SOAP_CMAC _ns1__SetDPAddressesResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetDPAddressesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetDPAddressesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetDPAddressesResponse, default initialized and not managed by a soap context
        virtual _ns1__SetDPAddressesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetDPAddressesResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetDPAddressesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetDPAddressesResponse() { }
        /// Friend allocator used by soap_new__ns1__SetDPAddressesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetDPAddressesResponse * SOAP_FMAC2 soap_instantiate__ns1__SetDPAddressesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:433 */
#ifndef SOAP_TYPE__ns1__GetEndpointReference
#define SOAP_TYPE__ns1__GetEndpointReference (295)
/* complex XSD type 'ns1:GetEndpointReference': */
class SOAP_CMAC _ns1__GetEndpointReference {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetEndpointReference
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetEndpointReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetEndpointReference, default initialized and not managed by a soap context
        virtual _ns1__GetEndpointReference *soap_alloc(void) const { return SOAP_NEW(_ns1__GetEndpointReference); }
      public:
        /// Constructor with initializations
        _ns1__GetEndpointReference()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetEndpointReference() { }
        /// Friend allocator used by soap_new__ns1__GetEndpointReference(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetEndpointReference * SOAP_FMAC2 soap_instantiate__ns1__GetEndpointReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:436 */
#ifndef SOAP_TYPE__ns1__GetEndpointReferenceResponse
#define SOAP_TYPE__ns1__GetEndpointReferenceResponse (296)
/* complex XSD type 'ns1:GetEndpointReferenceResponse': */
class SOAP_CMAC _ns1__GetEndpointReferenceResponse {
      public:
        /// Required element 'ns1:GUID' of XSD type 'xsd:string'
        std::string GUID;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetEndpointReferenceResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetEndpointReferenceResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetEndpointReferenceResponse, default initialized and not managed by a soap context
        virtual _ns1__GetEndpointReferenceResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetEndpointReferenceResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetEndpointReferenceResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetEndpointReferenceResponse() { }
        /// Friend allocator used by soap_new__ns1__GetEndpointReferenceResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetEndpointReferenceResponse * SOAP_FMAC2 soap_instantiate__ns1__GetEndpointReferenceResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:439 */
#ifndef SOAP_TYPE__ns1__GetRemoteUser
#define SOAP_TYPE__ns1__GetRemoteUser (297)
/* complex XSD type 'ns1:GetRemoteUser': */
class SOAP_CMAC _ns1__GetRemoteUser {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetRemoteUser
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetRemoteUser; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetRemoteUser, default initialized and not managed by a soap context
        virtual _ns1__GetRemoteUser *soap_alloc(void) const { return SOAP_NEW(_ns1__GetRemoteUser); }
      public:
        /// Constructor with initializations
        _ns1__GetRemoteUser()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetRemoteUser() { }
        /// Friend allocator used by soap_new__ns1__GetRemoteUser(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetRemoteUser * SOAP_FMAC2 soap_instantiate__ns1__GetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:442 */
#ifndef SOAP_TYPE__ns1__GetRemoteUserResponse
#define SOAP_TYPE__ns1__GetRemoteUserResponse (298)
/* complex XSD type 'ns1:GetRemoteUserResponse': */
class SOAP_CMAC _ns1__GetRemoteUserResponse {
      public:
        /// Optional element 'ns1:RemoteUser' of XSD type 'ns2:RemoteUser'
        ns2__RemoteUser *RemoteUser;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetRemoteUserResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetRemoteUserResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetRemoteUserResponse, default initialized and not managed by a soap context
        virtual _ns1__GetRemoteUserResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetRemoteUserResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetRemoteUserResponse()
        {
          RemoteUser = (ns2__RemoteUser *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetRemoteUserResponse() { }
        /// Friend allocator used by soap_new__ns1__GetRemoteUserResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetRemoteUserResponse * SOAP_FMAC2 soap_instantiate__ns1__GetRemoteUserResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:445 */
#ifndef SOAP_TYPE__ns1__SetRemoteUser
#define SOAP_TYPE__ns1__SetRemoteUser (299)
/* complex XSD type 'ns1:SetRemoteUser': */
class SOAP_CMAC _ns1__SetRemoteUser {
      public:
        /// Optional element 'ns1:RemoteUser' of XSD type 'ns2:RemoteUser'
        ns2__RemoteUser *RemoteUser;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetRemoteUser
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetRemoteUser; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetRemoteUser, default initialized and not managed by a soap context
        virtual _ns1__SetRemoteUser *soap_alloc(void) const { return SOAP_NEW(_ns1__SetRemoteUser); }
      public:
        /// Constructor with initializations
        _ns1__SetRemoteUser()
        {
          RemoteUser = (ns2__RemoteUser *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetRemoteUser() { }
        /// Friend allocator used by soap_new__ns1__SetRemoteUser(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetRemoteUser * SOAP_FMAC2 soap_instantiate__ns1__SetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:448 */
#ifndef SOAP_TYPE__ns1__SetRemoteUserResponse
#define SOAP_TYPE__ns1__SetRemoteUserResponse (300)
/* complex XSD type 'ns1:SetRemoteUserResponse': */
class SOAP_CMAC _ns1__SetRemoteUserResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetRemoteUserResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetRemoteUserResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetRemoteUserResponse, default initialized and not managed by a soap context
        virtual _ns1__SetRemoteUserResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetRemoteUserResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetRemoteUserResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetRemoteUserResponse() { }
        /// Friend allocator used by soap_new__ns1__SetRemoteUserResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetRemoteUserResponse * SOAP_FMAC2 soap_instantiate__ns1__SetRemoteUserResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:451 */
#ifndef SOAP_TYPE__ns1__GetUsers
#define SOAP_TYPE__ns1__GetUsers (301)
/* complex XSD type 'ns1:GetUsers': */
class SOAP_CMAC _ns1__GetUsers {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetUsers
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetUsers; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetUsers, default initialized and not managed by a soap context
        virtual _ns1__GetUsers *soap_alloc(void) const { return SOAP_NEW(_ns1__GetUsers); }
      public:
        /// Constructor with initializations
        _ns1__GetUsers()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetUsers() { }
        /// Friend allocator used by soap_new__ns1__GetUsers(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetUsers * SOAP_FMAC2 soap_instantiate__ns1__GetUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:454 */
#ifndef SOAP_TYPE__ns1__GetUsersResponse
#define SOAP_TYPE__ns1__GetUsersResponse (302)
/* complex XSD type 'ns1:GetUsersResponse': */
class SOAP_CMAC _ns1__GetUsersResponse {
      public:
        /// Optional element 'ns1:User' of XSD type 'ns2:User'
        std::vector<ns2__User *> User;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetUsersResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetUsersResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetUsersResponse, default initialized and not managed by a soap context
        virtual _ns1__GetUsersResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetUsersResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetUsersResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetUsersResponse() { }
        /// Friend allocator used by soap_new__ns1__GetUsersResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetUsersResponse * SOAP_FMAC2 soap_instantiate__ns1__GetUsersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:457 */
#ifndef SOAP_TYPE__ns1__CreateUsers
#define SOAP_TYPE__ns1__CreateUsers (303)
/* complex XSD type 'ns1:CreateUsers': */
class SOAP_CMAC _ns1__CreateUsers {
      public:
        /// Required element 'ns1:User' of XSD type 'ns2:User'
        std::vector<ns2__User *> User;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateUsers
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateUsers; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateUsers, default initialized and not managed by a soap context
        virtual _ns1__CreateUsers *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateUsers); }
      public:
        /// Constructor with initializations
        _ns1__CreateUsers()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateUsers() { }
        /// Friend allocator used by soap_new__ns1__CreateUsers(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateUsers * SOAP_FMAC2 soap_instantiate__ns1__CreateUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:460 */
#ifndef SOAP_TYPE__ns1__CreateUsersResponse
#define SOAP_TYPE__ns1__CreateUsersResponse (304)
/* complex XSD type 'ns1:CreateUsersResponse': */
class SOAP_CMAC _ns1__CreateUsersResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateUsersResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateUsersResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateUsersResponse, default initialized and not managed by a soap context
        virtual _ns1__CreateUsersResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateUsersResponse); }
      public:
        /// Constructor with initializations
        _ns1__CreateUsersResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateUsersResponse() { }
        /// Friend allocator used by soap_new__ns1__CreateUsersResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateUsersResponse * SOAP_FMAC2 soap_instantiate__ns1__CreateUsersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:463 */
#ifndef SOAP_TYPE__ns1__DeleteUsers
#define SOAP_TYPE__ns1__DeleteUsers (305)
/* complex XSD type 'ns1:DeleteUsers': */
class SOAP_CMAC _ns1__DeleteUsers {
      public:
        /// Required element 'ns1:Username' of XSD type 'xsd:string'
        std::vector<std::string> Username;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DeleteUsers
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DeleteUsers; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DeleteUsers, default initialized and not managed by a soap context
        virtual _ns1__DeleteUsers *soap_alloc(void) const { return SOAP_NEW(_ns1__DeleteUsers); }
      public:
        /// Constructor with initializations
        _ns1__DeleteUsers()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__DeleteUsers() { }
        /// Friend allocator used by soap_new__ns1__DeleteUsers(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DeleteUsers * SOAP_FMAC2 soap_instantiate__ns1__DeleteUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:466 */
#ifndef SOAP_TYPE__ns1__DeleteUsersResponse
#define SOAP_TYPE__ns1__DeleteUsersResponse (306)
/* complex XSD type 'ns1:DeleteUsersResponse': */
class SOAP_CMAC _ns1__DeleteUsersResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DeleteUsersResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DeleteUsersResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DeleteUsersResponse, default initialized and not managed by a soap context
        virtual _ns1__DeleteUsersResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__DeleteUsersResponse); }
      public:
        /// Constructor with initializations
        _ns1__DeleteUsersResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__DeleteUsersResponse() { }
        /// Friend allocator used by soap_new__ns1__DeleteUsersResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DeleteUsersResponse * SOAP_FMAC2 soap_instantiate__ns1__DeleteUsersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:469 */
#ifndef SOAP_TYPE__ns1__SetUser
#define SOAP_TYPE__ns1__SetUser (307)
/* complex XSD type 'ns1:SetUser': */
class SOAP_CMAC _ns1__SetUser {
      public:
        /// Required element 'ns1:User' of XSD type 'ns2:User'
        std::vector<ns2__User *> User;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetUser
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetUser; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetUser, default initialized and not managed by a soap context
        virtual _ns1__SetUser *soap_alloc(void) const { return SOAP_NEW(_ns1__SetUser); }
      public:
        /// Constructor with initializations
        _ns1__SetUser()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetUser() { }
        /// Friend allocator used by soap_new__ns1__SetUser(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetUser * SOAP_FMAC2 soap_instantiate__ns1__SetUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:472 */
#ifndef SOAP_TYPE__ns1__SetUserResponse
#define SOAP_TYPE__ns1__SetUserResponse (308)
/* complex XSD type 'ns1:SetUserResponse': */
class SOAP_CMAC _ns1__SetUserResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetUserResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetUserResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetUserResponse, default initialized and not managed by a soap context
        virtual _ns1__SetUserResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetUserResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetUserResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetUserResponse() { }
        /// Friend allocator used by soap_new__ns1__SetUserResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetUserResponse * SOAP_FMAC2 soap_instantiate__ns1__SetUserResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:475 */
#ifndef SOAP_TYPE__ns1__GetWsdlUrl
#define SOAP_TYPE__ns1__GetWsdlUrl (309)
/* complex XSD type 'ns1:GetWsdlUrl': */
class SOAP_CMAC _ns1__GetWsdlUrl {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetWsdlUrl
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetWsdlUrl; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetWsdlUrl, default initialized and not managed by a soap context
        virtual _ns1__GetWsdlUrl *soap_alloc(void) const { return SOAP_NEW(_ns1__GetWsdlUrl); }
      public:
        /// Constructor with initializations
        _ns1__GetWsdlUrl()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetWsdlUrl() { }
        /// Friend allocator used by soap_new__ns1__GetWsdlUrl(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetWsdlUrl * SOAP_FMAC2 soap_instantiate__ns1__GetWsdlUrl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:478 */
#ifndef SOAP_TYPE__ns1__GetWsdlUrlResponse
#define SOAP_TYPE__ns1__GetWsdlUrlResponse (310)
/* complex XSD type 'ns1:GetWsdlUrlResponse': */
class SOAP_CMAC _ns1__GetWsdlUrlResponse {
      public:
        /// Required element 'ns1:WsdlUrl' of XSD type 'xsd:anyURI'
        std::string WsdlUrl;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetWsdlUrlResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetWsdlUrlResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetWsdlUrlResponse, default initialized and not managed by a soap context
        virtual _ns1__GetWsdlUrlResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetWsdlUrlResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetWsdlUrlResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetWsdlUrlResponse() { }
        /// Friend allocator used by soap_new__ns1__GetWsdlUrlResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetWsdlUrlResponse * SOAP_FMAC2 soap_instantiate__ns1__GetWsdlUrlResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:481 */
#ifndef SOAP_TYPE__ns1__GetCapabilities
#define SOAP_TYPE__ns1__GetCapabilities (311)
/* complex XSD type 'ns1:GetCapabilities': */
class SOAP_CMAC _ns1__GetCapabilities {
      public:
        /// Optional element 'ns1:Category' of XSD type 'ns2:CapabilityCategory'
        std::vector<ns2__CapabilityCategory> Category;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCapabilities, default initialized and not managed by a soap context
        virtual _ns1__GetCapabilities *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCapabilities); }
      public:
        /// Constructor with initializations
        _ns1__GetCapabilities()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCapabilities() { }
        /// Friend allocator used by soap_new__ns1__GetCapabilities(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCapabilities * SOAP_FMAC2 soap_instantiate__ns1__GetCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:484 */
#ifndef SOAP_TYPE__ns1__GetCapabilitiesResponse
#define SOAP_TYPE__ns1__GetCapabilitiesResponse (312)
/* complex XSD type 'ns1:GetCapabilitiesResponse': */
class SOAP_CMAC _ns1__GetCapabilitiesResponse {
      public:
        /// Required element 'ns1:Capabilities' of XSD type 'ns2:Capabilities'
        ns2__Capabilities *Capabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCapabilitiesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCapabilitiesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCapabilitiesResponse, default initialized and not managed by a soap context
        virtual _ns1__GetCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCapabilitiesResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetCapabilitiesResponse()
        {
          Capabilities = (ns2__Capabilities *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCapabilitiesResponse() { }
        /// Friend allocator used by soap_new__ns1__GetCapabilitiesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__ns1__GetCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:487 */
#ifndef SOAP_TYPE__ns1__GetHostname
#define SOAP_TYPE__ns1__GetHostname (313)
/* complex XSD type 'ns1:GetHostname': */
class SOAP_CMAC _ns1__GetHostname {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetHostname
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetHostname; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetHostname, default initialized and not managed by a soap context
        virtual _ns1__GetHostname *soap_alloc(void) const { return SOAP_NEW(_ns1__GetHostname); }
      public:
        /// Constructor with initializations
        _ns1__GetHostname()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetHostname() { }
        /// Friend allocator used by soap_new__ns1__GetHostname(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetHostname * SOAP_FMAC2 soap_instantiate__ns1__GetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:490 */
#ifndef SOAP_TYPE__ns1__GetHostnameResponse
#define SOAP_TYPE__ns1__GetHostnameResponse (314)
/* complex XSD type 'ns1:GetHostnameResponse': */
class SOAP_CMAC _ns1__GetHostnameResponse {
      public:
        /// Required element 'ns1:HostnameInformation' of XSD type 'ns2:HostnameInformation'
        ns2__HostnameInformation *HostnameInformation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetHostnameResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetHostnameResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetHostnameResponse, default initialized and not managed by a soap context
        virtual _ns1__GetHostnameResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetHostnameResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetHostnameResponse()
        {
          HostnameInformation = (ns2__HostnameInformation *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetHostnameResponse() { }
        /// Friend allocator used by soap_new__ns1__GetHostnameResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetHostnameResponse * SOAP_FMAC2 soap_instantiate__ns1__GetHostnameResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:493 */
#ifndef SOAP_TYPE__ns1__SetHostname
#define SOAP_TYPE__ns1__SetHostname (315)
/* complex XSD type 'ns1:SetHostname': */
class SOAP_CMAC _ns1__SetHostname {
      public:
        /// Required element 'ns1:Name' of XSD type 'xsd:token'
        std::string Name;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetHostname
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetHostname; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetHostname, default initialized and not managed by a soap context
        virtual _ns1__SetHostname *soap_alloc(void) const { return SOAP_NEW(_ns1__SetHostname); }
      public:
        /// Constructor with initializations
        _ns1__SetHostname()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetHostname() { }
        /// Friend allocator used by soap_new__ns1__SetHostname(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetHostname * SOAP_FMAC2 soap_instantiate__ns1__SetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:496 */
#ifndef SOAP_TYPE__ns1__SetHostnameResponse
#define SOAP_TYPE__ns1__SetHostnameResponse (316)
/* complex XSD type 'ns1:SetHostnameResponse': */
class SOAP_CMAC _ns1__SetHostnameResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetHostnameResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetHostnameResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetHostnameResponse, default initialized and not managed by a soap context
        virtual _ns1__SetHostnameResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetHostnameResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetHostnameResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetHostnameResponse() { }
        /// Friend allocator used by soap_new__ns1__SetHostnameResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetHostnameResponse * SOAP_FMAC2 soap_instantiate__ns1__SetHostnameResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:499 */
#ifndef SOAP_TYPE__ns1__SetHostnameFromDHCP
#define SOAP_TYPE__ns1__SetHostnameFromDHCP (317)
/* complex XSD type 'ns1:SetHostnameFromDHCP': */
class SOAP_CMAC _ns1__SetHostnameFromDHCP {
      public:
        /// Required element 'ns1:FromDHCP' of XSD type 'xsd:boolean'
        bool FromDHCP;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetHostnameFromDHCP
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetHostnameFromDHCP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetHostnameFromDHCP, default initialized and not managed by a soap context
        virtual _ns1__SetHostnameFromDHCP *soap_alloc(void) const { return SOAP_NEW(_ns1__SetHostnameFromDHCP); }
      public:
        /// Constructor with initializations
        _ns1__SetHostnameFromDHCP()
        {
          FromDHCP = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetHostnameFromDHCP() { }
        /// Friend allocator used by soap_new__ns1__SetHostnameFromDHCP(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetHostnameFromDHCP * SOAP_FMAC2 soap_instantiate__ns1__SetHostnameFromDHCP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:502 */
#ifndef SOAP_TYPE__ns1__SetHostnameFromDHCPResponse
#define SOAP_TYPE__ns1__SetHostnameFromDHCPResponse (318)
/* complex XSD type 'ns1:SetHostnameFromDHCPResponse': */
class SOAP_CMAC _ns1__SetHostnameFromDHCPResponse {
      public:
        /// Required element 'ns1:RebootNeeded' of XSD type 'xsd:boolean'
        bool RebootNeeded;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetHostnameFromDHCPResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetHostnameFromDHCPResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetHostnameFromDHCPResponse, default initialized and not managed by a soap context
        virtual _ns1__SetHostnameFromDHCPResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetHostnameFromDHCPResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetHostnameFromDHCPResponse()
        {
          RebootNeeded = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetHostnameFromDHCPResponse() { }
        /// Friend allocator used by soap_new__ns1__SetHostnameFromDHCPResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetHostnameFromDHCPResponse * SOAP_FMAC2 soap_instantiate__ns1__SetHostnameFromDHCPResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:505 */
#ifndef SOAP_TYPE__ns1__GetDNS
#define SOAP_TYPE__ns1__GetDNS (319)
/* complex XSD type 'ns1:GetDNS': */
class SOAP_CMAC _ns1__GetDNS {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetDNS
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetDNS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetDNS, default initialized and not managed by a soap context
        virtual _ns1__GetDNS *soap_alloc(void) const { return SOAP_NEW(_ns1__GetDNS); }
      public:
        /// Constructor with initializations
        _ns1__GetDNS()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetDNS() { }
        /// Friend allocator used by soap_new__ns1__GetDNS(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetDNS * SOAP_FMAC2 soap_instantiate__ns1__GetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:508 */
#ifndef SOAP_TYPE__ns1__GetDNSResponse
#define SOAP_TYPE__ns1__GetDNSResponse (320)
/* complex XSD type 'ns1:GetDNSResponse': */
class SOAP_CMAC _ns1__GetDNSResponse {
      public:
        /// Required element 'ns1:DNSInformation' of XSD type 'ns2:DNSInformation'
        ns2__DNSInformation *DNSInformation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetDNSResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetDNSResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetDNSResponse, default initialized and not managed by a soap context
        virtual _ns1__GetDNSResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetDNSResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetDNSResponse()
        {
          DNSInformation = (ns2__DNSInformation *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetDNSResponse() { }
        /// Friend allocator used by soap_new__ns1__GetDNSResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetDNSResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:511 */
#ifndef SOAP_TYPE__ns1__SetDNS
#define SOAP_TYPE__ns1__SetDNS (321)
/* complex XSD type 'ns1:SetDNS': */
class SOAP_CMAC _ns1__SetDNS {
      public:
        /// Required element 'ns1:FromDHCP' of XSD type 'xsd:boolean'
        bool FromDHCP;
        /// Optional element 'ns1:SearchDomain' of XSD type 'xsd:token'
        std::vector<std::string> SearchDomain;
        /// Optional element 'ns1:DNSManual' of XSD type 'ns2:IPAddress'
        std::vector<ns2__IPAddress *> DNSManual;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetDNS
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetDNS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetDNS, default initialized and not managed by a soap context
        virtual _ns1__SetDNS *soap_alloc(void) const { return SOAP_NEW(_ns1__SetDNS); }
      public:
        /// Constructor with initializations
        _ns1__SetDNS()
        {
          FromDHCP = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetDNS() { }
        /// Friend allocator used by soap_new__ns1__SetDNS(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetDNS * SOAP_FMAC2 soap_instantiate__ns1__SetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:514 */
#ifndef SOAP_TYPE__ns1__SetDNSResponse
#define SOAP_TYPE__ns1__SetDNSResponse (322)
/* complex XSD type 'ns1:SetDNSResponse': */
class SOAP_CMAC _ns1__SetDNSResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetDNSResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetDNSResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetDNSResponse, default initialized and not managed by a soap context
        virtual _ns1__SetDNSResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetDNSResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetDNSResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetDNSResponse() { }
        /// Friend allocator used by soap_new__ns1__SetDNSResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetDNSResponse * SOAP_FMAC2 soap_instantiate__ns1__SetDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:517 */
#ifndef SOAP_TYPE__ns1__GetNTP
#define SOAP_TYPE__ns1__GetNTP (323)
/* complex XSD type 'ns1:GetNTP': */
class SOAP_CMAC _ns1__GetNTP {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetNTP
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetNTP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetNTP, default initialized and not managed by a soap context
        virtual _ns1__GetNTP *soap_alloc(void) const { return SOAP_NEW(_ns1__GetNTP); }
      public:
        /// Constructor with initializations
        _ns1__GetNTP()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetNTP() { }
        /// Friend allocator used by soap_new__ns1__GetNTP(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetNTP * SOAP_FMAC2 soap_instantiate__ns1__GetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:520 */
#ifndef SOAP_TYPE__ns1__GetNTPResponse
#define SOAP_TYPE__ns1__GetNTPResponse (324)
/* complex XSD type 'ns1:GetNTPResponse': */
class SOAP_CMAC _ns1__GetNTPResponse {
      public:
        /// Required element 'ns1:NTPInformation' of XSD type 'ns2:NTPInformation'
        ns2__NTPInformation *NTPInformation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetNTPResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetNTPResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetNTPResponse, default initialized and not managed by a soap context
        virtual _ns1__GetNTPResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetNTPResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetNTPResponse()
        {
          NTPInformation = (ns2__NTPInformation *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetNTPResponse() { }
        /// Friend allocator used by soap_new__ns1__GetNTPResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetNTPResponse * SOAP_FMAC2 soap_instantiate__ns1__GetNTPResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:523 */
#ifndef SOAP_TYPE__ns1__SetNTP
#define SOAP_TYPE__ns1__SetNTP (325)
/* complex XSD type 'ns1:SetNTP': */
class SOAP_CMAC _ns1__SetNTP {
      public:
        /// Required element 'ns1:FromDHCP' of XSD type 'xsd:boolean'
        bool FromDHCP;
        /// Optional element 'ns1:NTPManual' of XSD type 'ns2:NetworkHost'
        std::vector<ns2__NetworkHost *> NTPManual;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetNTP
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetNTP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetNTP, default initialized and not managed by a soap context
        virtual _ns1__SetNTP *soap_alloc(void) const { return SOAP_NEW(_ns1__SetNTP); }
      public:
        /// Constructor with initializations
        _ns1__SetNTP()
        {
          FromDHCP = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetNTP() { }
        /// Friend allocator used by soap_new__ns1__SetNTP(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetNTP * SOAP_FMAC2 soap_instantiate__ns1__SetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:526 */
#ifndef SOAP_TYPE__ns1__SetNTPResponse
#define SOAP_TYPE__ns1__SetNTPResponse (326)
/* complex XSD type 'ns1:SetNTPResponse': */
class SOAP_CMAC _ns1__SetNTPResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetNTPResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetNTPResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetNTPResponse, default initialized and not managed by a soap context
        virtual _ns1__SetNTPResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetNTPResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetNTPResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetNTPResponse() { }
        /// Friend allocator used by soap_new__ns1__SetNTPResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetNTPResponse * SOAP_FMAC2 soap_instantiate__ns1__SetNTPResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:529 */
#ifndef SOAP_TYPE__ns1__GetDynamicDNS
#define SOAP_TYPE__ns1__GetDynamicDNS (327)
/* complex XSD type 'ns1:GetDynamicDNS': */
class SOAP_CMAC _ns1__GetDynamicDNS {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetDynamicDNS
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetDynamicDNS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetDynamicDNS, default initialized and not managed by a soap context
        virtual _ns1__GetDynamicDNS *soap_alloc(void) const { return SOAP_NEW(_ns1__GetDynamicDNS); }
      public:
        /// Constructor with initializations
        _ns1__GetDynamicDNS()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetDynamicDNS() { }
        /// Friend allocator used by soap_new__ns1__GetDynamicDNS(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetDynamicDNS * SOAP_FMAC2 soap_instantiate__ns1__GetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:532 */
#ifndef SOAP_TYPE__ns1__GetDynamicDNSResponse
#define SOAP_TYPE__ns1__GetDynamicDNSResponse (328)
/* complex XSD type 'ns1:GetDynamicDNSResponse': */
class SOAP_CMAC _ns1__GetDynamicDNSResponse {
      public:
        /// Required element 'ns1:DynamicDNSInformation' of XSD type 'ns2:DynamicDNSInformation'
        ns2__DynamicDNSInformation *DynamicDNSInformation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetDynamicDNSResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetDynamicDNSResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetDynamicDNSResponse, default initialized and not managed by a soap context
        virtual _ns1__GetDynamicDNSResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetDynamicDNSResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetDynamicDNSResponse()
        {
          DynamicDNSInformation = (ns2__DynamicDNSInformation *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetDynamicDNSResponse() { }
        /// Friend allocator used by soap_new__ns1__GetDynamicDNSResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetDynamicDNSResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDynamicDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:535 */
#ifndef SOAP_TYPE__ns1__SetDynamicDNS
#define SOAP_TYPE__ns1__SetDynamicDNS (329)
/* complex XSD type 'ns1:SetDynamicDNS': */
class SOAP_CMAC _ns1__SetDynamicDNS {
      public:
        /// Required element 'ns1:Type' of XSD type 'ns2:DynamicDNSType'
        ns2__DynamicDNSType Type;
        /// Optional element 'ns1:Name' of XSD type 'ns2:DNSName'
        std::string *Name;
        /// Optional element 'ns1:TTL' of XSD type 'xsd:duration'
        std::string *TTL;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetDynamicDNS
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetDynamicDNS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetDynamicDNS, default initialized and not managed by a soap context
        virtual _ns1__SetDynamicDNS *soap_alloc(void) const { return SOAP_NEW(_ns1__SetDynamicDNS); }
      public:
        /// Constructor with initializations
        _ns1__SetDynamicDNS()
        {
          Type = (ns2__DynamicDNSType)0;
          Name = (std::string *)0;
          TTL = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetDynamicDNS() { }
        /// Friend allocator used by soap_new__ns1__SetDynamicDNS(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetDynamicDNS * SOAP_FMAC2 soap_instantiate__ns1__SetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:538 */
#ifndef SOAP_TYPE__ns1__SetDynamicDNSResponse
#define SOAP_TYPE__ns1__SetDynamicDNSResponse (330)
/* complex XSD type 'ns1:SetDynamicDNSResponse': */
class SOAP_CMAC _ns1__SetDynamicDNSResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetDynamicDNSResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetDynamicDNSResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetDynamicDNSResponse, default initialized and not managed by a soap context
        virtual _ns1__SetDynamicDNSResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetDynamicDNSResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetDynamicDNSResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetDynamicDNSResponse() { }
        /// Friend allocator used by soap_new__ns1__SetDynamicDNSResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetDynamicDNSResponse * SOAP_FMAC2 soap_instantiate__ns1__SetDynamicDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:541 */
#ifndef SOAP_TYPE__ns1__GetNetworkInterfaces
#define SOAP_TYPE__ns1__GetNetworkInterfaces (331)
/* complex XSD type 'ns1:GetNetworkInterfaces': */
class SOAP_CMAC _ns1__GetNetworkInterfaces {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetNetworkInterfaces
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetNetworkInterfaces; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetNetworkInterfaces, default initialized and not managed by a soap context
        virtual _ns1__GetNetworkInterfaces *soap_alloc(void) const { return SOAP_NEW(_ns1__GetNetworkInterfaces); }
      public:
        /// Constructor with initializations
        _ns1__GetNetworkInterfaces()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetNetworkInterfaces() { }
        /// Friend allocator used by soap_new__ns1__GetNetworkInterfaces(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetNetworkInterfaces * SOAP_FMAC2 soap_instantiate__ns1__GetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:544 */
#ifndef SOAP_TYPE__ns1__GetNetworkInterfacesResponse
#define SOAP_TYPE__ns1__GetNetworkInterfacesResponse (332)
/* complex XSD type 'ns1:GetNetworkInterfacesResponse': */
class SOAP_CMAC _ns1__GetNetworkInterfacesResponse {
      public:
        /// Required element 'ns1:NetworkInterfaces' of XSD type 'ns2:NetworkInterface'
        std::vector<ns2__NetworkInterface *> NetworkInterfaces;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetNetworkInterfacesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetNetworkInterfacesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetNetworkInterfacesResponse, default initialized and not managed by a soap context
        virtual _ns1__GetNetworkInterfacesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetNetworkInterfacesResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetNetworkInterfacesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetNetworkInterfacesResponse() { }
        /// Friend allocator used by soap_new__ns1__GetNetworkInterfacesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetNetworkInterfacesResponse * SOAP_FMAC2 soap_instantiate__ns1__GetNetworkInterfacesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:547 */
#ifndef SOAP_TYPE__ns1__SetNetworkInterfaces
#define SOAP_TYPE__ns1__SetNetworkInterfaces (333)
/* complex XSD type 'ns1:SetNetworkInterfaces': */
class SOAP_CMAC _ns1__SetNetworkInterfaces {
      public:
        /// Required element 'ns1:InterfaceToken' of XSD type 'ns2:ReferenceToken'
        std::string InterfaceToken;
        /// Required element 'ns1:NetworkInterface' of XSD type 'ns2:NetworkInterfaceSetConfiguration'
        ns2__NetworkInterfaceSetConfiguration *NetworkInterface;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetNetworkInterfaces
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetNetworkInterfaces; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetNetworkInterfaces, default initialized and not managed by a soap context
        virtual _ns1__SetNetworkInterfaces *soap_alloc(void) const { return SOAP_NEW(_ns1__SetNetworkInterfaces); }
      public:
        /// Constructor with initializations
        _ns1__SetNetworkInterfaces()
        {
          NetworkInterface = (ns2__NetworkInterfaceSetConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetNetworkInterfaces() { }
        /// Friend allocator used by soap_new__ns1__SetNetworkInterfaces(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetNetworkInterfaces * SOAP_FMAC2 soap_instantiate__ns1__SetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:550 */
#ifndef SOAP_TYPE__ns1__SetNetworkInterfacesResponse
#define SOAP_TYPE__ns1__SetNetworkInterfacesResponse (334)
/* complex XSD type 'ns1:SetNetworkInterfacesResponse': */
class SOAP_CMAC _ns1__SetNetworkInterfacesResponse {
      public:
        /// Required element 'ns1:RebootNeeded' of XSD type 'xsd:boolean'
        bool RebootNeeded;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetNetworkInterfacesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetNetworkInterfacesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetNetworkInterfacesResponse, default initialized and not managed by a soap context
        virtual _ns1__SetNetworkInterfacesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetNetworkInterfacesResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetNetworkInterfacesResponse()
        {
          RebootNeeded = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetNetworkInterfacesResponse() { }
        /// Friend allocator used by soap_new__ns1__SetNetworkInterfacesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetNetworkInterfacesResponse * SOAP_FMAC2 soap_instantiate__ns1__SetNetworkInterfacesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:553 */
#ifndef SOAP_TYPE__ns1__GetNetworkProtocols
#define SOAP_TYPE__ns1__GetNetworkProtocols (335)
/* complex XSD type 'ns1:GetNetworkProtocols': */
class SOAP_CMAC _ns1__GetNetworkProtocols {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetNetworkProtocols
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetNetworkProtocols; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetNetworkProtocols, default initialized and not managed by a soap context
        virtual _ns1__GetNetworkProtocols *soap_alloc(void) const { return SOAP_NEW(_ns1__GetNetworkProtocols); }
      public:
        /// Constructor with initializations
        _ns1__GetNetworkProtocols()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetNetworkProtocols() { }
        /// Friend allocator used by soap_new__ns1__GetNetworkProtocols(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetNetworkProtocols * SOAP_FMAC2 soap_instantiate__ns1__GetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:556 */
#ifndef SOAP_TYPE__ns1__GetNetworkProtocolsResponse
#define SOAP_TYPE__ns1__GetNetworkProtocolsResponse (336)
/* complex XSD type 'ns1:GetNetworkProtocolsResponse': */
class SOAP_CMAC _ns1__GetNetworkProtocolsResponse {
      public:
        /// Optional element 'ns1:NetworkProtocols' of XSD type 'ns2:NetworkProtocol'
        std::vector<ns2__NetworkProtocol *> NetworkProtocols;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetNetworkProtocolsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetNetworkProtocolsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetNetworkProtocolsResponse, default initialized and not managed by a soap context
        virtual _ns1__GetNetworkProtocolsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetNetworkProtocolsResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetNetworkProtocolsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetNetworkProtocolsResponse() { }
        /// Friend allocator used by soap_new__ns1__GetNetworkProtocolsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetNetworkProtocolsResponse * SOAP_FMAC2 soap_instantiate__ns1__GetNetworkProtocolsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:559 */
#ifndef SOAP_TYPE__ns1__SetNetworkProtocols
#define SOAP_TYPE__ns1__SetNetworkProtocols (337)
/* complex XSD type 'ns1:SetNetworkProtocols': */
class SOAP_CMAC _ns1__SetNetworkProtocols {
      public:
        /// Required element 'ns1:NetworkProtocols' of XSD type 'ns2:NetworkProtocol'
        std::vector<ns2__NetworkProtocol *> NetworkProtocols;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetNetworkProtocols
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetNetworkProtocols; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetNetworkProtocols, default initialized and not managed by a soap context
        virtual _ns1__SetNetworkProtocols *soap_alloc(void) const { return SOAP_NEW(_ns1__SetNetworkProtocols); }
      public:
        /// Constructor with initializations
        _ns1__SetNetworkProtocols()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetNetworkProtocols() { }
        /// Friend allocator used by soap_new__ns1__SetNetworkProtocols(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetNetworkProtocols * SOAP_FMAC2 soap_instantiate__ns1__SetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:562 */
#ifndef SOAP_TYPE__ns1__SetNetworkProtocolsResponse
#define SOAP_TYPE__ns1__SetNetworkProtocolsResponse (338)
/* complex XSD type 'ns1:SetNetworkProtocolsResponse': */
class SOAP_CMAC _ns1__SetNetworkProtocolsResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetNetworkProtocolsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetNetworkProtocolsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetNetworkProtocolsResponse, default initialized and not managed by a soap context
        virtual _ns1__SetNetworkProtocolsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetNetworkProtocolsResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetNetworkProtocolsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetNetworkProtocolsResponse() { }
        /// Friend allocator used by soap_new__ns1__SetNetworkProtocolsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetNetworkProtocolsResponse * SOAP_FMAC2 soap_instantiate__ns1__SetNetworkProtocolsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:565 */
#ifndef SOAP_TYPE__ns1__GetNetworkDefaultGateway
#define SOAP_TYPE__ns1__GetNetworkDefaultGateway (339)
/* complex XSD type 'ns1:GetNetworkDefaultGateway': */
class SOAP_CMAC _ns1__GetNetworkDefaultGateway {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetNetworkDefaultGateway
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetNetworkDefaultGateway; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetNetworkDefaultGateway, default initialized and not managed by a soap context
        virtual _ns1__GetNetworkDefaultGateway *soap_alloc(void) const { return SOAP_NEW(_ns1__GetNetworkDefaultGateway); }
      public:
        /// Constructor with initializations
        _ns1__GetNetworkDefaultGateway()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetNetworkDefaultGateway() { }
        /// Friend allocator used by soap_new__ns1__GetNetworkDefaultGateway(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate__ns1__GetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:568 */
#ifndef SOAP_TYPE__ns1__GetNetworkDefaultGatewayResponse
#define SOAP_TYPE__ns1__GetNetworkDefaultGatewayResponse (340)
/* complex XSD type 'ns1:GetNetworkDefaultGatewayResponse': */
class SOAP_CMAC _ns1__GetNetworkDefaultGatewayResponse {
      public:
        /// Required element 'ns1:NetworkGateway' of XSD type 'ns2:NetworkGateway'
        ns2__NetworkGateway *NetworkGateway;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetNetworkDefaultGatewayResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetNetworkDefaultGatewayResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetNetworkDefaultGatewayResponse, default initialized and not managed by a soap context
        virtual _ns1__GetNetworkDefaultGatewayResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetNetworkDefaultGatewayResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetNetworkDefaultGatewayResponse()
        {
          NetworkGateway = (ns2__NetworkGateway *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetNetworkDefaultGatewayResponse() { }
        /// Friend allocator used by soap_new__ns1__GetNetworkDefaultGatewayResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetNetworkDefaultGatewayResponse * SOAP_FMAC2 soap_instantiate__ns1__GetNetworkDefaultGatewayResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:571 */
#ifndef SOAP_TYPE__ns1__SetNetworkDefaultGateway
#define SOAP_TYPE__ns1__SetNetworkDefaultGateway (341)
/* complex XSD type 'ns1:SetNetworkDefaultGateway': */
class SOAP_CMAC _ns1__SetNetworkDefaultGateway {
      public:
        /// Optional element 'ns1:IPv4Address' of XSD type 'ns2:IPv4Address'
        std::vector<std::string> IPv4Address;
        /// Optional element 'ns1:IPv6Address' of XSD type 'ns2:IPv6Address'
        std::vector<std::string> IPv6Address;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetNetworkDefaultGateway
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetNetworkDefaultGateway; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetNetworkDefaultGateway, default initialized and not managed by a soap context
        virtual _ns1__SetNetworkDefaultGateway *soap_alloc(void) const { return SOAP_NEW(_ns1__SetNetworkDefaultGateway); }
      public:
        /// Constructor with initializations
        _ns1__SetNetworkDefaultGateway()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetNetworkDefaultGateway() { }
        /// Friend allocator used by soap_new__ns1__SetNetworkDefaultGateway(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate__ns1__SetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:574 */
#ifndef SOAP_TYPE__ns1__SetNetworkDefaultGatewayResponse
#define SOAP_TYPE__ns1__SetNetworkDefaultGatewayResponse (342)
/* complex XSD type 'ns1:SetNetworkDefaultGatewayResponse': */
class SOAP_CMAC _ns1__SetNetworkDefaultGatewayResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetNetworkDefaultGatewayResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetNetworkDefaultGatewayResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetNetworkDefaultGatewayResponse, default initialized and not managed by a soap context
        virtual _ns1__SetNetworkDefaultGatewayResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetNetworkDefaultGatewayResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetNetworkDefaultGatewayResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetNetworkDefaultGatewayResponse() { }
        /// Friend allocator used by soap_new__ns1__SetNetworkDefaultGatewayResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetNetworkDefaultGatewayResponse * SOAP_FMAC2 soap_instantiate__ns1__SetNetworkDefaultGatewayResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:577 */
#ifndef SOAP_TYPE__ns1__GetZeroConfiguration
#define SOAP_TYPE__ns1__GetZeroConfiguration (343)
/* complex XSD type 'ns1:GetZeroConfiguration': */
class SOAP_CMAC _ns1__GetZeroConfiguration {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetZeroConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetZeroConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetZeroConfiguration, default initialized and not managed by a soap context
        virtual _ns1__GetZeroConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns1__GetZeroConfiguration); }
      public:
        /// Constructor with initializations
        _ns1__GetZeroConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetZeroConfiguration() { }
        /// Friend allocator used by soap_new__ns1__GetZeroConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetZeroConfiguration * SOAP_FMAC2 soap_instantiate__ns1__GetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:580 */
#ifndef SOAP_TYPE__ns1__GetZeroConfigurationResponse
#define SOAP_TYPE__ns1__GetZeroConfigurationResponse (344)
/* complex XSD type 'ns1:GetZeroConfigurationResponse': */
class SOAP_CMAC _ns1__GetZeroConfigurationResponse {
      public:
        /// Required element 'ns1:ZeroConfiguration' of XSD type 'ns2:NetworkZeroConfiguration'
        ns2__NetworkZeroConfiguration *ZeroConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetZeroConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetZeroConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetZeroConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns1__GetZeroConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetZeroConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetZeroConfigurationResponse()
        {
          ZeroConfiguration = (ns2__NetworkZeroConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetZeroConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns1__GetZeroConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetZeroConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns1__GetZeroConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:583 */
#ifndef SOAP_TYPE__ns1__SetZeroConfiguration
#define SOAP_TYPE__ns1__SetZeroConfiguration (345)
/* complex XSD type 'ns1:SetZeroConfiguration': */
class SOAP_CMAC _ns1__SetZeroConfiguration {
      public:
        /// Required element 'ns1:InterfaceToken' of XSD type 'ns2:ReferenceToken'
        std::string InterfaceToken;
        /// Required element 'ns1:Enabled' of XSD type 'xsd:boolean'
        bool Enabled;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetZeroConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetZeroConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetZeroConfiguration, default initialized and not managed by a soap context
        virtual _ns1__SetZeroConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns1__SetZeroConfiguration); }
      public:
        /// Constructor with initializations
        _ns1__SetZeroConfiguration()
        {
          Enabled = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetZeroConfiguration() { }
        /// Friend allocator used by soap_new__ns1__SetZeroConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetZeroConfiguration * SOAP_FMAC2 soap_instantiate__ns1__SetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:586 */
#ifndef SOAP_TYPE__ns1__SetZeroConfigurationResponse
#define SOAP_TYPE__ns1__SetZeroConfigurationResponse (346)
/* complex XSD type 'ns1:SetZeroConfigurationResponse': */
class SOAP_CMAC _ns1__SetZeroConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetZeroConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetZeroConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetZeroConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns1__SetZeroConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetZeroConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetZeroConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetZeroConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns1__SetZeroConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetZeroConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns1__SetZeroConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:589 */
#ifndef SOAP_TYPE__ns1__GetIPAddressFilter
#define SOAP_TYPE__ns1__GetIPAddressFilter (347)
/* complex XSD type 'ns1:GetIPAddressFilter': */
class SOAP_CMAC _ns1__GetIPAddressFilter {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetIPAddressFilter
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetIPAddressFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetIPAddressFilter, default initialized and not managed by a soap context
        virtual _ns1__GetIPAddressFilter *soap_alloc(void) const { return SOAP_NEW(_ns1__GetIPAddressFilter); }
      public:
        /// Constructor with initializations
        _ns1__GetIPAddressFilter()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetIPAddressFilter() { }
        /// Friend allocator used by soap_new__ns1__GetIPAddressFilter(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetIPAddressFilter * SOAP_FMAC2 soap_instantiate__ns1__GetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:592 */
#ifndef SOAP_TYPE__ns1__GetIPAddressFilterResponse
#define SOAP_TYPE__ns1__GetIPAddressFilterResponse (348)
/* complex XSD type 'ns1:GetIPAddressFilterResponse': */
class SOAP_CMAC _ns1__GetIPAddressFilterResponse {
      public:
        /// Required element 'ns1:IPAddressFilter' of XSD type 'ns2:IPAddressFilter'
        ns2__IPAddressFilter *IPAddressFilter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetIPAddressFilterResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetIPAddressFilterResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetIPAddressFilterResponse, default initialized and not managed by a soap context
        virtual _ns1__GetIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetIPAddressFilterResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetIPAddressFilterResponse()
        {
          IPAddressFilter = (ns2__IPAddressFilter *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetIPAddressFilterResponse() { }
        /// Friend allocator used by soap_new__ns1__GetIPAddressFilterResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__ns1__GetIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:595 */
#ifndef SOAP_TYPE__ns1__SetIPAddressFilter
#define SOAP_TYPE__ns1__SetIPAddressFilter (349)
/* complex XSD type 'ns1:SetIPAddressFilter': */
class SOAP_CMAC _ns1__SetIPAddressFilter {
      public:
        /// Required element 'ns1:IPAddressFilter' of XSD type 'ns2:IPAddressFilter'
        ns2__IPAddressFilter *IPAddressFilter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetIPAddressFilter
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetIPAddressFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetIPAddressFilter, default initialized and not managed by a soap context
        virtual _ns1__SetIPAddressFilter *soap_alloc(void) const { return SOAP_NEW(_ns1__SetIPAddressFilter); }
      public:
        /// Constructor with initializations
        _ns1__SetIPAddressFilter()
        {
          IPAddressFilter = (ns2__IPAddressFilter *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetIPAddressFilter() { }
        /// Friend allocator used by soap_new__ns1__SetIPAddressFilter(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetIPAddressFilter * SOAP_FMAC2 soap_instantiate__ns1__SetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:598 */
#ifndef SOAP_TYPE__ns1__SetIPAddressFilterResponse
#define SOAP_TYPE__ns1__SetIPAddressFilterResponse (350)
/* complex XSD type 'ns1:SetIPAddressFilterResponse': */
class SOAP_CMAC _ns1__SetIPAddressFilterResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetIPAddressFilterResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetIPAddressFilterResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetIPAddressFilterResponse, default initialized and not managed by a soap context
        virtual _ns1__SetIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetIPAddressFilterResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetIPAddressFilterResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetIPAddressFilterResponse() { }
        /// Friend allocator used by soap_new__ns1__SetIPAddressFilterResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__ns1__SetIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:601 */
#ifndef SOAP_TYPE__ns1__AddIPAddressFilter
#define SOAP_TYPE__ns1__AddIPAddressFilter (351)
/* complex XSD type 'ns1:AddIPAddressFilter': */
class SOAP_CMAC _ns1__AddIPAddressFilter {
      public:
        /// Required element 'ns1:IPAddressFilter' of XSD type 'ns2:IPAddressFilter'
        ns2__IPAddressFilter *IPAddressFilter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__AddIPAddressFilter
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__AddIPAddressFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__AddIPAddressFilter, default initialized and not managed by a soap context
        virtual _ns1__AddIPAddressFilter *soap_alloc(void) const { return SOAP_NEW(_ns1__AddIPAddressFilter); }
      public:
        /// Constructor with initializations
        _ns1__AddIPAddressFilter()
        {
          IPAddressFilter = (ns2__IPAddressFilter *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__AddIPAddressFilter() { }
        /// Friend allocator used by soap_new__ns1__AddIPAddressFilter(struct soap*, int)
        friend SOAP_FMAC1 _ns1__AddIPAddressFilter * SOAP_FMAC2 soap_instantiate__ns1__AddIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:604 */
#ifndef SOAP_TYPE__ns1__AddIPAddressFilterResponse
#define SOAP_TYPE__ns1__AddIPAddressFilterResponse (352)
/* complex XSD type 'ns1:AddIPAddressFilterResponse': */
class SOAP_CMAC _ns1__AddIPAddressFilterResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__AddIPAddressFilterResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__AddIPAddressFilterResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__AddIPAddressFilterResponse, default initialized and not managed by a soap context
        virtual _ns1__AddIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__AddIPAddressFilterResponse); }
      public:
        /// Constructor with initializations
        _ns1__AddIPAddressFilterResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__AddIPAddressFilterResponse() { }
        /// Friend allocator used by soap_new__ns1__AddIPAddressFilterResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__AddIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__ns1__AddIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:607 */
#ifndef SOAP_TYPE__ns1__RemoveIPAddressFilter
#define SOAP_TYPE__ns1__RemoveIPAddressFilter (353)
/* complex XSD type 'ns1:RemoveIPAddressFilter': */
class SOAP_CMAC _ns1__RemoveIPAddressFilter {
      public:
        /// Required element 'ns1:IPAddressFilter' of XSD type 'ns2:IPAddressFilter'
        ns2__IPAddressFilter *IPAddressFilter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RemoveIPAddressFilter
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RemoveIPAddressFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RemoveIPAddressFilter, default initialized and not managed by a soap context
        virtual _ns1__RemoveIPAddressFilter *soap_alloc(void) const { return SOAP_NEW(_ns1__RemoveIPAddressFilter); }
      public:
        /// Constructor with initializations
        _ns1__RemoveIPAddressFilter()
        {
          IPAddressFilter = (ns2__IPAddressFilter *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RemoveIPAddressFilter() { }
        /// Friend allocator used by soap_new__ns1__RemoveIPAddressFilter(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RemoveIPAddressFilter * SOAP_FMAC2 soap_instantiate__ns1__RemoveIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:610 */
#ifndef SOAP_TYPE__ns1__RemoveIPAddressFilterResponse
#define SOAP_TYPE__ns1__RemoveIPAddressFilterResponse (354)
/* complex XSD type 'ns1:RemoveIPAddressFilterResponse': */
class SOAP_CMAC _ns1__RemoveIPAddressFilterResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RemoveIPAddressFilterResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RemoveIPAddressFilterResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RemoveIPAddressFilterResponse, default initialized and not managed by a soap context
        virtual _ns1__RemoveIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__RemoveIPAddressFilterResponse); }
      public:
        /// Constructor with initializations
        _ns1__RemoveIPAddressFilterResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RemoveIPAddressFilterResponse() { }
        /// Friend allocator used by soap_new__ns1__RemoveIPAddressFilterResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RemoveIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__ns1__RemoveIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:613 */
#ifndef SOAP_TYPE__ns1__GetAccessPolicy
#define SOAP_TYPE__ns1__GetAccessPolicy (355)
/* complex XSD type 'ns1:GetAccessPolicy': */
class SOAP_CMAC _ns1__GetAccessPolicy {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetAccessPolicy
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetAccessPolicy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetAccessPolicy, default initialized and not managed by a soap context
        virtual _ns1__GetAccessPolicy *soap_alloc(void) const { return SOAP_NEW(_ns1__GetAccessPolicy); }
      public:
        /// Constructor with initializations
        _ns1__GetAccessPolicy()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetAccessPolicy() { }
        /// Friend allocator used by soap_new__ns1__GetAccessPolicy(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetAccessPolicy * SOAP_FMAC2 soap_instantiate__ns1__GetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:616 */
#ifndef SOAP_TYPE__ns1__GetAccessPolicyResponse
#define SOAP_TYPE__ns1__GetAccessPolicyResponse (356)
/* complex XSD type 'ns1:GetAccessPolicyResponse': */
class SOAP_CMAC _ns1__GetAccessPolicyResponse {
      public:
        /// Required element 'ns1:PolicyFile' of XSD type 'ns2:BinaryData'
        ns2__BinaryData *PolicyFile;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetAccessPolicyResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetAccessPolicyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetAccessPolicyResponse, default initialized and not managed by a soap context
        virtual _ns1__GetAccessPolicyResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetAccessPolicyResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetAccessPolicyResponse()
        {
          PolicyFile = (ns2__BinaryData *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetAccessPolicyResponse() { }
        /// Friend allocator used by soap_new__ns1__GetAccessPolicyResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetAccessPolicyResponse * SOAP_FMAC2 soap_instantiate__ns1__GetAccessPolicyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:619 */
#ifndef SOAP_TYPE__ns1__SetAccessPolicy
#define SOAP_TYPE__ns1__SetAccessPolicy (357)
/* complex XSD type 'ns1:SetAccessPolicy': */
class SOAP_CMAC _ns1__SetAccessPolicy {
      public:
        /// Required element 'ns1:PolicyFile' of XSD type 'ns2:BinaryData'
        ns2__BinaryData *PolicyFile;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetAccessPolicy
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetAccessPolicy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetAccessPolicy, default initialized and not managed by a soap context
        virtual _ns1__SetAccessPolicy *soap_alloc(void) const { return SOAP_NEW(_ns1__SetAccessPolicy); }
      public:
        /// Constructor with initializations
        _ns1__SetAccessPolicy()
        {
          PolicyFile = (ns2__BinaryData *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetAccessPolicy() { }
        /// Friend allocator used by soap_new__ns1__SetAccessPolicy(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetAccessPolicy * SOAP_FMAC2 soap_instantiate__ns1__SetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:622 */
#ifndef SOAP_TYPE__ns1__SetAccessPolicyResponse
#define SOAP_TYPE__ns1__SetAccessPolicyResponse (358)
/* complex XSD type 'ns1:SetAccessPolicyResponse': */
class SOAP_CMAC _ns1__SetAccessPolicyResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetAccessPolicyResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetAccessPolicyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetAccessPolicyResponse, default initialized and not managed by a soap context
        virtual _ns1__SetAccessPolicyResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetAccessPolicyResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetAccessPolicyResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetAccessPolicyResponse() { }
        /// Friend allocator used by soap_new__ns1__SetAccessPolicyResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetAccessPolicyResponse * SOAP_FMAC2 soap_instantiate__ns1__SetAccessPolicyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:625 */
#ifndef SOAP_TYPE__ns1__CreateCertificate
#define SOAP_TYPE__ns1__CreateCertificate (359)
/* complex XSD type 'ns1:CreateCertificate': */
class SOAP_CMAC _ns1__CreateCertificate {
      public:
        /// Optional element 'ns1:CertificateID' of XSD type 'xsd:token'
        std::string *CertificateID;
        /// Optional element 'ns1:Subject' of XSD type 'xsd:string'
        std::string *Subject;
        /// Optional element 'ns1:ValidNotBefore' of XSD type 'xsd:dateTime'
        time_t *ValidNotBefore;
        /// Optional element 'ns1:ValidNotAfter' of XSD type 'xsd:dateTime'
        time_t *ValidNotAfter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateCertificate
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateCertificate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateCertificate, default initialized and not managed by a soap context
        virtual _ns1__CreateCertificate *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateCertificate); }
      public:
        /// Constructor with initializations
        _ns1__CreateCertificate()
        {
          CertificateID = (std::string *)0;
          Subject = (std::string *)0;
          ValidNotBefore = (time_t *)0;
          ValidNotAfter = (time_t *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateCertificate() { }
        /// Friend allocator used by soap_new__ns1__CreateCertificate(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateCertificate * SOAP_FMAC2 soap_instantiate__ns1__CreateCertificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:628 */
#ifndef SOAP_TYPE__ns1__CreateCertificateResponse
#define SOAP_TYPE__ns1__CreateCertificateResponse (360)
/* complex XSD type 'ns1:CreateCertificateResponse': */
class SOAP_CMAC _ns1__CreateCertificateResponse {
      public:
        /// Required element 'ns1:NvtCertificate' of XSD type 'ns2:Certificate'
        ns2__Certificate *NvtCertificate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateCertificateResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateCertificateResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateCertificateResponse, default initialized and not managed by a soap context
        virtual _ns1__CreateCertificateResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateCertificateResponse); }
      public:
        /// Constructor with initializations
        _ns1__CreateCertificateResponse()
        {
          NvtCertificate = (ns2__Certificate *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateCertificateResponse() { }
        /// Friend allocator used by soap_new__ns1__CreateCertificateResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateCertificateResponse * SOAP_FMAC2 soap_instantiate__ns1__CreateCertificateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:631 */
#ifndef SOAP_TYPE__ns1__GetCertificates
#define SOAP_TYPE__ns1__GetCertificates (361)
/* complex XSD type 'ns1:GetCertificates': */
class SOAP_CMAC _ns1__GetCertificates {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCertificates
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCertificates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCertificates, default initialized and not managed by a soap context
        virtual _ns1__GetCertificates *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCertificates); }
      public:
        /// Constructor with initializations
        _ns1__GetCertificates()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCertificates() { }
        /// Friend allocator used by soap_new__ns1__GetCertificates(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCertificates * SOAP_FMAC2 soap_instantiate__ns1__GetCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:634 */
#ifndef SOAP_TYPE__ns1__GetCertificatesResponse
#define SOAP_TYPE__ns1__GetCertificatesResponse (362)
/* complex XSD type 'ns1:GetCertificatesResponse': */
class SOAP_CMAC _ns1__GetCertificatesResponse {
      public:
        /// Optional element 'ns1:NvtCertificate' of XSD type 'ns2:Certificate'
        std::vector<ns2__Certificate *> NvtCertificate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCertificatesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCertificatesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCertificatesResponse, default initialized and not managed by a soap context
        virtual _ns1__GetCertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCertificatesResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetCertificatesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCertificatesResponse() { }
        /// Friend allocator used by soap_new__ns1__GetCertificatesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCertificatesResponse * SOAP_FMAC2 soap_instantiate__ns1__GetCertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:637 */
#ifndef SOAP_TYPE__ns1__GetCertificatesStatus
#define SOAP_TYPE__ns1__GetCertificatesStatus (363)
/* complex XSD type 'ns1:GetCertificatesStatus': */
class SOAP_CMAC _ns1__GetCertificatesStatus {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCertificatesStatus
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCertificatesStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCertificatesStatus, default initialized and not managed by a soap context
        virtual _ns1__GetCertificatesStatus *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCertificatesStatus); }
      public:
        /// Constructor with initializations
        _ns1__GetCertificatesStatus()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCertificatesStatus() { }
        /// Friend allocator used by soap_new__ns1__GetCertificatesStatus(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCertificatesStatus * SOAP_FMAC2 soap_instantiate__ns1__GetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:640 */
#ifndef SOAP_TYPE__ns1__GetCertificatesStatusResponse
#define SOAP_TYPE__ns1__GetCertificatesStatusResponse (364)
/* complex XSD type 'ns1:GetCertificatesStatusResponse': */
class SOAP_CMAC _ns1__GetCertificatesStatusResponse {
      public:
        /// Optional element 'ns1:CertificateStatus' of XSD type 'ns2:CertificateStatus'
        std::vector<ns2__CertificateStatus *> CertificateStatus;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCertificatesStatusResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCertificatesStatusResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCertificatesStatusResponse, default initialized and not managed by a soap context
        virtual _ns1__GetCertificatesStatusResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCertificatesStatusResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetCertificatesStatusResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCertificatesStatusResponse() { }
        /// Friend allocator used by soap_new__ns1__GetCertificatesStatusResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCertificatesStatusResponse * SOAP_FMAC2 soap_instantiate__ns1__GetCertificatesStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:643 */
#ifndef SOAP_TYPE__ns1__SetCertificatesStatus
#define SOAP_TYPE__ns1__SetCertificatesStatus (365)
/* complex XSD type 'ns1:SetCertificatesStatus': */
class SOAP_CMAC _ns1__SetCertificatesStatus {
      public:
        /// Optional element 'ns1:CertificateStatus' of XSD type 'ns2:CertificateStatus'
        std::vector<ns2__CertificateStatus *> CertificateStatus;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetCertificatesStatus
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetCertificatesStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetCertificatesStatus, default initialized and not managed by a soap context
        virtual _ns1__SetCertificatesStatus *soap_alloc(void) const { return SOAP_NEW(_ns1__SetCertificatesStatus); }
      public:
        /// Constructor with initializations
        _ns1__SetCertificatesStatus()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetCertificatesStatus() { }
        /// Friend allocator used by soap_new__ns1__SetCertificatesStatus(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetCertificatesStatus * SOAP_FMAC2 soap_instantiate__ns1__SetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:646 */
#ifndef SOAP_TYPE__ns1__SetCertificatesStatusResponse
#define SOAP_TYPE__ns1__SetCertificatesStatusResponse (366)
/* complex XSD type 'ns1:SetCertificatesStatusResponse': */
class SOAP_CMAC _ns1__SetCertificatesStatusResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetCertificatesStatusResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetCertificatesStatusResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetCertificatesStatusResponse, default initialized and not managed by a soap context
        virtual _ns1__SetCertificatesStatusResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetCertificatesStatusResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetCertificatesStatusResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetCertificatesStatusResponse() { }
        /// Friend allocator used by soap_new__ns1__SetCertificatesStatusResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetCertificatesStatusResponse * SOAP_FMAC2 soap_instantiate__ns1__SetCertificatesStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:649 */
#ifndef SOAP_TYPE__ns1__DeleteCertificates
#define SOAP_TYPE__ns1__DeleteCertificates (367)
/* complex XSD type 'ns1:DeleteCertificates': */
class SOAP_CMAC _ns1__DeleteCertificates {
      public:
        /// Required element 'ns1:CertificateID' of XSD type 'xsd:token'
        std::vector<std::string> CertificateID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DeleteCertificates
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DeleteCertificates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DeleteCertificates, default initialized and not managed by a soap context
        virtual _ns1__DeleteCertificates *soap_alloc(void) const { return SOAP_NEW(_ns1__DeleteCertificates); }
      public:
        /// Constructor with initializations
        _ns1__DeleteCertificates()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__DeleteCertificates() { }
        /// Friend allocator used by soap_new__ns1__DeleteCertificates(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DeleteCertificates * SOAP_FMAC2 soap_instantiate__ns1__DeleteCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:652 */
#ifndef SOAP_TYPE__ns1__DeleteCertificatesResponse
#define SOAP_TYPE__ns1__DeleteCertificatesResponse (368)
/* complex XSD type 'ns1:DeleteCertificatesResponse': */
class SOAP_CMAC _ns1__DeleteCertificatesResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DeleteCertificatesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DeleteCertificatesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DeleteCertificatesResponse, default initialized and not managed by a soap context
        virtual _ns1__DeleteCertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__DeleteCertificatesResponse); }
      public:
        /// Constructor with initializations
        _ns1__DeleteCertificatesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__DeleteCertificatesResponse() { }
        /// Friend allocator used by soap_new__ns1__DeleteCertificatesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DeleteCertificatesResponse * SOAP_FMAC2 soap_instantiate__ns1__DeleteCertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:655 */
#ifndef SOAP_TYPE__ns1__GetPkcs10Request
#define SOAP_TYPE__ns1__GetPkcs10Request (369)
/* complex XSD type 'ns1:GetPkcs10Request': */
class SOAP_CMAC _ns1__GetPkcs10Request {
      public:
        /// Required element 'ns1:CertificateID' of XSD type 'xsd:token'
        std::string CertificateID;
        /// Optional element 'ns1:Subject' of XSD type 'xsd:string'
        std::string *Subject;
        /// Optional element 'ns1:Attributes' of XSD type 'ns2:BinaryData'
        ns2__BinaryData *Attributes;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetPkcs10Request
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetPkcs10Request; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetPkcs10Request, default initialized and not managed by a soap context
        virtual _ns1__GetPkcs10Request *soap_alloc(void) const { return SOAP_NEW(_ns1__GetPkcs10Request); }
      public:
        /// Constructor with initializations
        _ns1__GetPkcs10Request()
        {
          Subject = (std::string *)0;
          Attributes = (ns2__BinaryData *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetPkcs10Request() { }
        /// Friend allocator used by soap_new__ns1__GetPkcs10Request(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetPkcs10Request * SOAP_FMAC2 soap_instantiate__ns1__GetPkcs10Request(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:658 */
#ifndef SOAP_TYPE__ns1__GetPkcs10RequestResponse
#define SOAP_TYPE__ns1__GetPkcs10RequestResponse (370)
/* complex XSD type 'ns1:GetPkcs10RequestResponse': */
class SOAP_CMAC _ns1__GetPkcs10RequestResponse {
      public:
        /// Required element 'ns1:Pkcs10Request' of XSD type 'ns2:BinaryData'
        ns2__BinaryData *Pkcs10Request;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetPkcs10RequestResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetPkcs10RequestResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetPkcs10RequestResponse, default initialized and not managed by a soap context
        virtual _ns1__GetPkcs10RequestResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetPkcs10RequestResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetPkcs10RequestResponse()
        {
          Pkcs10Request = (ns2__BinaryData *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetPkcs10RequestResponse() { }
        /// Friend allocator used by soap_new__ns1__GetPkcs10RequestResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetPkcs10RequestResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPkcs10RequestResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:661 */
#ifndef SOAP_TYPE__ns1__LoadCertificates
#define SOAP_TYPE__ns1__LoadCertificates (371)
/* complex XSD type 'ns1:LoadCertificates': */
class SOAP_CMAC _ns1__LoadCertificates {
      public:
        /// Required element 'ns1:NVTCertificate' of XSD type 'ns2:Certificate'
        std::vector<ns2__Certificate *> NVTCertificate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LoadCertificates
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LoadCertificates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LoadCertificates, default initialized and not managed by a soap context
        virtual _ns1__LoadCertificates *soap_alloc(void) const { return SOAP_NEW(_ns1__LoadCertificates); }
      public:
        /// Constructor with initializations
        _ns1__LoadCertificates()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__LoadCertificates() { }
        /// Friend allocator used by soap_new__ns1__LoadCertificates(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LoadCertificates * SOAP_FMAC2 soap_instantiate__ns1__LoadCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:664 */
#ifndef SOAP_TYPE__ns1__LoadCertificatesResponse
#define SOAP_TYPE__ns1__LoadCertificatesResponse (372)
/* complex XSD type 'ns1:LoadCertificatesResponse': */
class SOAP_CMAC _ns1__LoadCertificatesResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LoadCertificatesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LoadCertificatesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LoadCertificatesResponse, default initialized and not managed by a soap context
        virtual _ns1__LoadCertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__LoadCertificatesResponse); }
      public:
        /// Constructor with initializations
        _ns1__LoadCertificatesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__LoadCertificatesResponse() { }
        /// Friend allocator used by soap_new__ns1__LoadCertificatesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LoadCertificatesResponse * SOAP_FMAC2 soap_instantiate__ns1__LoadCertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:667 */
#ifndef SOAP_TYPE__ns1__GetClientCertificateMode
#define SOAP_TYPE__ns1__GetClientCertificateMode (373)
/* complex XSD type 'ns1:GetClientCertificateMode': */
class SOAP_CMAC _ns1__GetClientCertificateMode {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetClientCertificateMode
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetClientCertificateMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetClientCertificateMode, default initialized and not managed by a soap context
        virtual _ns1__GetClientCertificateMode *soap_alloc(void) const { return SOAP_NEW(_ns1__GetClientCertificateMode); }
      public:
        /// Constructor with initializations
        _ns1__GetClientCertificateMode()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetClientCertificateMode() { }
        /// Friend allocator used by soap_new__ns1__GetClientCertificateMode(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetClientCertificateMode * SOAP_FMAC2 soap_instantiate__ns1__GetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:670 */
#ifndef SOAP_TYPE__ns1__GetClientCertificateModeResponse
#define SOAP_TYPE__ns1__GetClientCertificateModeResponse (374)
/* complex XSD type 'ns1:GetClientCertificateModeResponse': */
class SOAP_CMAC _ns1__GetClientCertificateModeResponse {
      public:
        /// Required element 'ns1:Enabled' of XSD type 'xsd:boolean'
        bool Enabled;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetClientCertificateModeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetClientCertificateModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetClientCertificateModeResponse, default initialized and not managed by a soap context
        virtual _ns1__GetClientCertificateModeResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetClientCertificateModeResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetClientCertificateModeResponse()
        {
          Enabled = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetClientCertificateModeResponse() { }
        /// Friend allocator used by soap_new__ns1__GetClientCertificateModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetClientCertificateModeResponse * SOAP_FMAC2 soap_instantiate__ns1__GetClientCertificateModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:673 */
#ifndef SOAP_TYPE__ns1__SetClientCertificateMode
#define SOAP_TYPE__ns1__SetClientCertificateMode (375)
/* complex XSD type 'ns1:SetClientCertificateMode': */
class SOAP_CMAC _ns1__SetClientCertificateMode {
      public:
        /// Required element 'ns1:Enabled' of XSD type 'xsd:boolean'
        bool Enabled;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetClientCertificateMode
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetClientCertificateMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetClientCertificateMode, default initialized and not managed by a soap context
        virtual _ns1__SetClientCertificateMode *soap_alloc(void) const { return SOAP_NEW(_ns1__SetClientCertificateMode); }
      public:
        /// Constructor with initializations
        _ns1__SetClientCertificateMode()
        {
          Enabled = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetClientCertificateMode() { }
        /// Friend allocator used by soap_new__ns1__SetClientCertificateMode(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetClientCertificateMode * SOAP_FMAC2 soap_instantiate__ns1__SetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:676 */
#ifndef SOAP_TYPE__ns1__SetClientCertificateModeResponse
#define SOAP_TYPE__ns1__SetClientCertificateModeResponse (376)
/* complex XSD type 'ns1:SetClientCertificateModeResponse': */
class SOAP_CMAC _ns1__SetClientCertificateModeResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetClientCertificateModeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetClientCertificateModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetClientCertificateModeResponse, default initialized and not managed by a soap context
        virtual _ns1__SetClientCertificateModeResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetClientCertificateModeResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetClientCertificateModeResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetClientCertificateModeResponse() { }
        /// Friend allocator used by soap_new__ns1__SetClientCertificateModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetClientCertificateModeResponse * SOAP_FMAC2 soap_instantiate__ns1__SetClientCertificateModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:679 */
#ifndef SOAP_TYPE__ns1__GetCACertificates
#define SOAP_TYPE__ns1__GetCACertificates (377)
/* complex XSD type 'ns1:GetCACertificates': */
class SOAP_CMAC _ns1__GetCACertificates {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCACertificates
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCACertificates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCACertificates, default initialized and not managed by a soap context
        virtual _ns1__GetCACertificates *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCACertificates); }
      public:
        /// Constructor with initializations
        _ns1__GetCACertificates()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCACertificates() { }
        /// Friend allocator used by soap_new__ns1__GetCACertificates(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCACertificates * SOAP_FMAC2 soap_instantiate__ns1__GetCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:682 */
#ifndef SOAP_TYPE__ns1__GetCACertificatesResponse
#define SOAP_TYPE__ns1__GetCACertificatesResponse (378)
/* complex XSD type 'ns1:GetCACertificatesResponse': */
class SOAP_CMAC _ns1__GetCACertificatesResponse {
      public:
        /// Optional element 'ns1:CACertificate' of XSD type 'ns2:Certificate'
        std::vector<ns2__Certificate *> CACertificate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCACertificatesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCACertificatesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCACertificatesResponse, default initialized and not managed by a soap context
        virtual _ns1__GetCACertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCACertificatesResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetCACertificatesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCACertificatesResponse() { }
        /// Friend allocator used by soap_new__ns1__GetCACertificatesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCACertificatesResponse * SOAP_FMAC2 soap_instantiate__ns1__GetCACertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:685 */
#ifndef SOAP_TYPE__ns1__LoadCertificateWithPrivateKey
#define SOAP_TYPE__ns1__LoadCertificateWithPrivateKey (379)
/* complex XSD type 'ns1:LoadCertificateWithPrivateKey': */
class SOAP_CMAC _ns1__LoadCertificateWithPrivateKey {
      public:
        /// Required element 'ns1:CertificateWithPrivateKey' of XSD type 'ns2:CertificateWithPrivateKey'
        std::vector<ns2__CertificateWithPrivateKey *> CertificateWithPrivateKey;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LoadCertificateWithPrivateKey
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LoadCertificateWithPrivateKey; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LoadCertificateWithPrivateKey, default initialized and not managed by a soap context
        virtual _ns1__LoadCertificateWithPrivateKey *soap_alloc(void) const { return SOAP_NEW(_ns1__LoadCertificateWithPrivateKey); }
      public:
        /// Constructor with initializations
        _ns1__LoadCertificateWithPrivateKey()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__LoadCertificateWithPrivateKey() { }
        /// Friend allocator used by soap_new__ns1__LoadCertificateWithPrivateKey(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LoadCertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate__ns1__LoadCertificateWithPrivateKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:688 */
#ifndef SOAP_TYPE__ns1__LoadCertificateWithPrivateKeyResponse
#define SOAP_TYPE__ns1__LoadCertificateWithPrivateKeyResponse (380)
/* complex XSD type 'ns1:LoadCertificateWithPrivateKeyResponse': */
class SOAP_CMAC _ns1__LoadCertificateWithPrivateKeyResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LoadCertificateWithPrivateKeyResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LoadCertificateWithPrivateKeyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LoadCertificateWithPrivateKeyResponse, default initialized and not managed by a soap context
        virtual _ns1__LoadCertificateWithPrivateKeyResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__LoadCertificateWithPrivateKeyResponse); }
      public:
        /// Constructor with initializations
        _ns1__LoadCertificateWithPrivateKeyResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__LoadCertificateWithPrivateKeyResponse() { }
        /// Friend allocator used by soap_new__ns1__LoadCertificateWithPrivateKeyResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC2 soap_instantiate__ns1__LoadCertificateWithPrivateKeyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:691 */
#ifndef SOAP_TYPE__ns1__GetCertificateInformation
#define SOAP_TYPE__ns1__GetCertificateInformation (381)
/* complex XSD type 'ns1:GetCertificateInformation': */
class SOAP_CMAC _ns1__GetCertificateInformation {
      public:
        /// Required element 'ns1:CertificateID' of XSD type 'xsd:token'
        std::string CertificateID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCertificateInformation
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCertificateInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCertificateInformation, default initialized and not managed by a soap context
        virtual _ns1__GetCertificateInformation *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCertificateInformation); }
      public:
        /// Constructor with initializations
        _ns1__GetCertificateInformation()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCertificateInformation() { }
        /// Friend allocator used by soap_new__ns1__GetCertificateInformation(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCertificateInformation * SOAP_FMAC2 soap_instantiate__ns1__GetCertificateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:694 */
#ifndef SOAP_TYPE__ns1__GetCertificateInformationResponse
#define SOAP_TYPE__ns1__GetCertificateInformationResponse (382)
/* complex XSD type 'ns1:GetCertificateInformationResponse': */
class SOAP_CMAC _ns1__GetCertificateInformationResponse {
      public:
        /// Required element 'ns1:CertificateInformation' of XSD type 'ns2:CertificateInformation'
        ns2__CertificateInformation *CertificateInformation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCertificateInformationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCertificateInformationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCertificateInformationResponse, default initialized and not managed by a soap context
        virtual _ns1__GetCertificateInformationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCertificateInformationResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetCertificateInformationResponse()
        {
          CertificateInformation = (ns2__CertificateInformation *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCertificateInformationResponse() { }
        /// Friend allocator used by soap_new__ns1__GetCertificateInformationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCertificateInformationResponse * SOAP_FMAC2 soap_instantiate__ns1__GetCertificateInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:697 */
#ifndef SOAP_TYPE__ns1__LoadCACertificates
#define SOAP_TYPE__ns1__LoadCACertificates (383)
/* complex XSD type 'ns1:LoadCACertificates': */
class SOAP_CMAC _ns1__LoadCACertificates {
      public:
        /// Required element 'ns1:CACertificate' of XSD type 'ns2:Certificate'
        std::vector<ns2__Certificate *> CACertificate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LoadCACertificates
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LoadCACertificates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LoadCACertificates, default initialized and not managed by a soap context
        virtual _ns1__LoadCACertificates *soap_alloc(void) const { return SOAP_NEW(_ns1__LoadCACertificates); }
      public:
        /// Constructor with initializations
        _ns1__LoadCACertificates()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__LoadCACertificates() { }
        /// Friend allocator used by soap_new__ns1__LoadCACertificates(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LoadCACertificates * SOAP_FMAC2 soap_instantiate__ns1__LoadCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:700 */
#ifndef SOAP_TYPE__ns1__LoadCACertificatesResponse
#define SOAP_TYPE__ns1__LoadCACertificatesResponse (384)
/* complex XSD type 'ns1:LoadCACertificatesResponse': */
class SOAP_CMAC _ns1__LoadCACertificatesResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LoadCACertificatesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LoadCACertificatesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LoadCACertificatesResponse, default initialized and not managed by a soap context
        virtual _ns1__LoadCACertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__LoadCACertificatesResponse); }
      public:
        /// Constructor with initializations
        _ns1__LoadCACertificatesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__LoadCACertificatesResponse() { }
        /// Friend allocator used by soap_new__ns1__LoadCACertificatesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LoadCACertificatesResponse * SOAP_FMAC2 soap_instantiate__ns1__LoadCACertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:703 */
#ifndef SOAP_TYPE__ns1__CreateDot1XConfiguration
#define SOAP_TYPE__ns1__CreateDot1XConfiguration (385)
/* complex XSD type 'ns1:CreateDot1XConfiguration': */
class SOAP_CMAC _ns1__CreateDot1XConfiguration {
      public:
        /// Required element 'ns1:Dot1XConfiguration' of XSD type 'ns2:Dot1XConfiguration'
        ns2__Dot1XConfiguration *Dot1XConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateDot1XConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateDot1XConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateDot1XConfiguration, default initialized and not managed by a soap context
        virtual _ns1__CreateDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateDot1XConfiguration); }
      public:
        /// Constructor with initializations
        _ns1__CreateDot1XConfiguration()
        {
          Dot1XConfiguration = (ns2__Dot1XConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateDot1XConfiguration() { }
        /// Friend allocator used by soap_new__ns1__CreateDot1XConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateDot1XConfiguration * SOAP_FMAC2 soap_instantiate__ns1__CreateDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:706 */
#ifndef SOAP_TYPE__ns1__CreateDot1XConfigurationResponse
#define SOAP_TYPE__ns1__CreateDot1XConfigurationResponse (386)
/* complex XSD type 'ns1:CreateDot1XConfigurationResponse': */
class SOAP_CMAC _ns1__CreateDot1XConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateDot1XConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateDot1XConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateDot1XConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns1__CreateDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateDot1XConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns1__CreateDot1XConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateDot1XConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns1__CreateDot1XConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns1__CreateDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:709 */
#ifndef SOAP_TYPE__ns1__SetDot1XConfiguration
#define SOAP_TYPE__ns1__SetDot1XConfiguration (387)
/* complex XSD type 'ns1:SetDot1XConfiguration': */
class SOAP_CMAC _ns1__SetDot1XConfiguration {
      public:
        /// Required element 'ns1:Dot1XConfiguration' of XSD type 'ns2:Dot1XConfiguration'
        ns2__Dot1XConfiguration *Dot1XConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetDot1XConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetDot1XConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetDot1XConfiguration, default initialized and not managed by a soap context
        virtual _ns1__SetDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns1__SetDot1XConfiguration); }
      public:
        /// Constructor with initializations
        _ns1__SetDot1XConfiguration()
        {
          Dot1XConfiguration = (ns2__Dot1XConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetDot1XConfiguration() { }
        /// Friend allocator used by soap_new__ns1__SetDot1XConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetDot1XConfiguration * SOAP_FMAC2 soap_instantiate__ns1__SetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:712 */
#ifndef SOAP_TYPE__ns1__SetDot1XConfigurationResponse
#define SOAP_TYPE__ns1__SetDot1XConfigurationResponse (388)
/* complex XSD type 'ns1:SetDot1XConfigurationResponse': */
class SOAP_CMAC _ns1__SetDot1XConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetDot1XConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetDot1XConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetDot1XConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns1__SetDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetDot1XConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetDot1XConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetDot1XConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns1__SetDot1XConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns1__SetDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:715 */
#ifndef SOAP_TYPE__ns1__GetDot1XConfiguration
#define SOAP_TYPE__ns1__GetDot1XConfiguration (389)
/* complex XSD type 'ns1:GetDot1XConfiguration': */
class SOAP_CMAC _ns1__GetDot1XConfiguration {
      public:
        /// Required element 'ns1:Dot1XConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string Dot1XConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetDot1XConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetDot1XConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetDot1XConfiguration, default initialized and not managed by a soap context
        virtual _ns1__GetDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns1__GetDot1XConfiguration); }
      public:
        /// Constructor with initializations
        _ns1__GetDot1XConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetDot1XConfiguration() { }
        /// Friend allocator used by soap_new__ns1__GetDot1XConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetDot1XConfiguration * SOAP_FMAC2 soap_instantiate__ns1__GetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:718 */
#ifndef SOAP_TYPE__ns1__GetDot1XConfigurationResponse
#define SOAP_TYPE__ns1__GetDot1XConfigurationResponse (390)
/* complex XSD type 'ns1:GetDot1XConfigurationResponse': */
class SOAP_CMAC _ns1__GetDot1XConfigurationResponse {
      public:
        /// Required element 'ns1:Dot1XConfiguration' of XSD type 'ns2:Dot1XConfiguration'
        ns2__Dot1XConfiguration *Dot1XConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetDot1XConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetDot1XConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetDot1XConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns1__GetDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetDot1XConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetDot1XConfigurationResponse()
        {
          Dot1XConfiguration = (ns2__Dot1XConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetDot1XConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns1__GetDot1XConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:721 */
#ifndef SOAP_TYPE__ns1__GetDot1XConfigurations
#define SOAP_TYPE__ns1__GetDot1XConfigurations (391)
/* complex XSD type 'ns1:GetDot1XConfigurations': */
class SOAP_CMAC _ns1__GetDot1XConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetDot1XConfigurations
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetDot1XConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetDot1XConfigurations, default initialized and not managed by a soap context
        virtual _ns1__GetDot1XConfigurations *soap_alloc(void) const { return SOAP_NEW(_ns1__GetDot1XConfigurations); }
      public:
        /// Constructor with initializations
        _ns1__GetDot1XConfigurations()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetDot1XConfigurations() { }
        /// Friend allocator used by soap_new__ns1__GetDot1XConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetDot1XConfigurations * SOAP_FMAC2 soap_instantiate__ns1__GetDot1XConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:724 */
#ifndef SOAP_TYPE__ns1__GetDot1XConfigurationsResponse
#define SOAP_TYPE__ns1__GetDot1XConfigurationsResponse (392)
/* complex XSD type 'ns1:GetDot1XConfigurationsResponse': */
class SOAP_CMAC _ns1__GetDot1XConfigurationsResponse {
      public:
        /// Optional element 'ns1:Dot1XConfiguration' of XSD type 'ns2:Dot1XConfiguration'
        std::vector<ns2__Dot1XConfiguration *> Dot1XConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetDot1XConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetDot1XConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetDot1XConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns1__GetDot1XConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetDot1XConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetDot1XConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetDot1XConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns1__GetDot1XConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetDot1XConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDot1XConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:727 */
#ifndef SOAP_TYPE__ns1__DeleteDot1XConfiguration
#define SOAP_TYPE__ns1__DeleteDot1XConfiguration (393)
/* complex XSD type 'ns1:DeleteDot1XConfiguration': */
class SOAP_CMAC _ns1__DeleteDot1XConfiguration {
      public:
        /// Optional element 'ns1:Dot1XConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::vector<std::string> Dot1XConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DeleteDot1XConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DeleteDot1XConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DeleteDot1XConfiguration, default initialized and not managed by a soap context
        virtual _ns1__DeleteDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns1__DeleteDot1XConfiguration); }
      public:
        /// Constructor with initializations
        _ns1__DeleteDot1XConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__DeleteDot1XConfiguration() { }
        /// Friend allocator used by soap_new__ns1__DeleteDot1XConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DeleteDot1XConfiguration * SOAP_FMAC2 soap_instantiate__ns1__DeleteDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:730 */
#ifndef SOAP_TYPE__ns1__DeleteDot1XConfigurationResponse
#define SOAP_TYPE__ns1__DeleteDot1XConfigurationResponse (394)
/* complex XSD type 'ns1:DeleteDot1XConfigurationResponse': */
class SOAP_CMAC _ns1__DeleteDot1XConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DeleteDot1XConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DeleteDot1XConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DeleteDot1XConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns1__DeleteDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__DeleteDot1XConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns1__DeleteDot1XConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__DeleteDot1XConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns1__DeleteDot1XConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DeleteDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns1__DeleteDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:733 */
#ifndef SOAP_TYPE__ns1__GetRelayOutputs
#define SOAP_TYPE__ns1__GetRelayOutputs (395)
/* complex XSD type 'ns1:GetRelayOutputs': */
class SOAP_CMAC _ns1__GetRelayOutputs {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetRelayOutputs
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetRelayOutputs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetRelayOutputs, default initialized and not managed by a soap context
        virtual _ns1__GetRelayOutputs *soap_alloc(void) const { return SOAP_NEW(_ns1__GetRelayOutputs); }
      public:
        /// Constructor with initializations
        _ns1__GetRelayOutputs()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetRelayOutputs() { }
        /// Friend allocator used by soap_new__ns1__GetRelayOutputs(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetRelayOutputs * SOAP_FMAC2 soap_instantiate__ns1__GetRelayOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:736 */
#ifndef SOAP_TYPE__ns1__GetRelayOutputsResponse
#define SOAP_TYPE__ns1__GetRelayOutputsResponse (396)
/* complex XSD type 'ns1:GetRelayOutputsResponse': */
class SOAP_CMAC _ns1__GetRelayOutputsResponse {
      public:
        /// Optional element 'ns1:RelayOutputs' of XSD type 'ns2:RelayOutput'
        std::vector<ns2__RelayOutput *> RelayOutputs;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetRelayOutputsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetRelayOutputsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetRelayOutputsResponse, default initialized and not managed by a soap context
        virtual _ns1__GetRelayOutputsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetRelayOutputsResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetRelayOutputsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetRelayOutputsResponse() { }
        /// Friend allocator used by soap_new__ns1__GetRelayOutputsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetRelayOutputsResponse * SOAP_FMAC2 soap_instantiate__ns1__GetRelayOutputsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:739 */
#ifndef SOAP_TYPE__ns1__SetRelayOutputSettings
#define SOAP_TYPE__ns1__SetRelayOutputSettings (397)
/* complex XSD type 'ns1:SetRelayOutputSettings': */
class SOAP_CMAC _ns1__SetRelayOutputSettings {
      public:
        /// Required element 'ns1:RelayOutputToken' of XSD type 'ns2:ReferenceToken'
        std::string RelayOutputToken;
        /// Required element 'ns1:Properties' of XSD type 'ns2:RelayOutputSettings'
        ns2__RelayOutputSettings *Properties;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetRelayOutputSettings
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetRelayOutputSettings; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetRelayOutputSettings, default initialized and not managed by a soap context
        virtual _ns1__SetRelayOutputSettings *soap_alloc(void) const { return SOAP_NEW(_ns1__SetRelayOutputSettings); }
      public:
        /// Constructor with initializations
        _ns1__SetRelayOutputSettings()
        {
          Properties = (ns2__RelayOutputSettings *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetRelayOutputSettings() { }
        /// Friend allocator used by soap_new__ns1__SetRelayOutputSettings(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate__ns1__SetRelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:742 */
#ifndef SOAP_TYPE__ns1__SetRelayOutputSettingsResponse
#define SOAP_TYPE__ns1__SetRelayOutputSettingsResponse (398)
/* complex XSD type 'ns1:SetRelayOutputSettingsResponse': */
class SOAP_CMAC _ns1__SetRelayOutputSettingsResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetRelayOutputSettingsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetRelayOutputSettingsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetRelayOutputSettingsResponse, default initialized and not managed by a soap context
        virtual _ns1__SetRelayOutputSettingsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetRelayOutputSettingsResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetRelayOutputSettingsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetRelayOutputSettingsResponse() { }
        /// Friend allocator used by soap_new__ns1__SetRelayOutputSettingsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetRelayOutputSettingsResponse * SOAP_FMAC2 soap_instantiate__ns1__SetRelayOutputSettingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:745 */
#ifndef SOAP_TYPE__ns1__SetRelayOutputState
#define SOAP_TYPE__ns1__SetRelayOutputState (399)
/* complex XSD type 'ns1:SetRelayOutputState': */
class SOAP_CMAC _ns1__SetRelayOutputState {
      public:
        /// Required element 'ns1:RelayOutputToken' of XSD type 'ns2:ReferenceToken'
        std::string RelayOutputToken;
        /// Required element 'ns1:LogicalState' of XSD type 'ns2:RelayLogicalState'
        ns2__RelayLogicalState LogicalState;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetRelayOutputState
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetRelayOutputState; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetRelayOutputState, default initialized and not managed by a soap context
        virtual _ns1__SetRelayOutputState *soap_alloc(void) const { return SOAP_NEW(_ns1__SetRelayOutputState); }
      public:
        /// Constructor with initializations
        _ns1__SetRelayOutputState()
        {
          LogicalState = (ns2__RelayLogicalState)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetRelayOutputState() { }
        /// Friend allocator used by soap_new__ns1__SetRelayOutputState(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetRelayOutputState * SOAP_FMAC2 soap_instantiate__ns1__SetRelayOutputState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:748 */
#ifndef SOAP_TYPE__ns1__SetRelayOutputStateResponse
#define SOAP_TYPE__ns1__SetRelayOutputStateResponse (400)
/* complex XSD type 'ns1:SetRelayOutputStateResponse': */
class SOAP_CMAC _ns1__SetRelayOutputStateResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetRelayOutputStateResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetRelayOutputStateResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetRelayOutputStateResponse, default initialized and not managed by a soap context
        virtual _ns1__SetRelayOutputStateResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetRelayOutputStateResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetRelayOutputStateResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetRelayOutputStateResponse() { }
        /// Friend allocator used by soap_new__ns1__SetRelayOutputStateResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetRelayOutputStateResponse * SOAP_FMAC2 soap_instantiate__ns1__SetRelayOutputStateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:751 */
#ifndef SOAP_TYPE__ns1__SendAuxiliaryCommand
#define SOAP_TYPE__ns1__SendAuxiliaryCommand (401)
/* complex XSD type 'ns1:SendAuxiliaryCommand': */
class SOAP_CMAC _ns1__SendAuxiliaryCommand {
      public:
        /// Required element 'ns1:AuxiliaryCommand' of XSD type 'ns2:AuxiliaryData'
        std::string AuxiliaryCommand;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SendAuxiliaryCommand
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SendAuxiliaryCommand; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SendAuxiliaryCommand, default initialized and not managed by a soap context
        virtual _ns1__SendAuxiliaryCommand *soap_alloc(void) const { return SOAP_NEW(_ns1__SendAuxiliaryCommand); }
      public:
        /// Constructor with initializations
        _ns1__SendAuxiliaryCommand()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SendAuxiliaryCommand() { }
        /// Friend allocator used by soap_new__ns1__SendAuxiliaryCommand(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate__ns1__SendAuxiliaryCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:754 */
#ifndef SOAP_TYPE__ns1__SendAuxiliaryCommandResponse
#define SOAP_TYPE__ns1__SendAuxiliaryCommandResponse (402)
/* complex XSD type 'ns1:SendAuxiliaryCommandResponse': */
class SOAP_CMAC _ns1__SendAuxiliaryCommandResponse {
      public:
        /// Optional element 'ns1:AuxiliaryCommandResponse' of XSD type 'ns2:AuxiliaryData'
        std::string *AuxiliaryCommandResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SendAuxiliaryCommandResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SendAuxiliaryCommandResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SendAuxiliaryCommandResponse, default initialized and not managed by a soap context
        virtual _ns1__SendAuxiliaryCommandResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SendAuxiliaryCommandResponse); }
      public:
        /// Constructor with initializations
        _ns1__SendAuxiliaryCommandResponse()
        {
          AuxiliaryCommandResponse = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SendAuxiliaryCommandResponse() { }
        /// Friend allocator used by soap_new__ns1__SendAuxiliaryCommandResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SendAuxiliaryCommandResponse * SOAP_FMAC2 soap_instantiate__ns1__SendAuxiliaryCommandResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:757 */
#ifndef SOAP_TYPE__ns1__GetDot11Capabilities
#define SOAP_TYPE__ns1__GetDot11Capabilities (403)
/* complex XSD type 'ns1:GetDot11Capabilities': */
class SOAP_CMAC _ns1__GetDot11Capabilities {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetDot11Capabilities
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetDot11Capabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetDot11Capabilities, default initialized and not managed by a soap context
        virtual _ns1__GetDot11Capabilities *soap_alloc(void) const { return SOAP_NEW(_ns1__GetDot11Capabilities); }
      public:
        /// Constructor with initializations
        _ns1__GetDot11Capabilities()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetDot11Capabilities() { }
        /// Friend allocator used by soap_new__ns1__GetDot11Capabilities(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetDot11Capabilities * SOAP_FMAC2 soap_instantiate__ns1__GetDot11Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:760 */
#ifndef SOAP_TYPE__ns1__GetDot11CapabilitiesResponse
#define SOAP_TYPE__ns1__GetDot11CapabilitiesResponse (404)
/* complex XSD type 'ns1:GetDot11CapabilitiesResponse': */
class SOAP_CMAC _ns1__GetDot11CapabilitiesResponse {
      public:
        /// Required element 'ns1:Capabilities' of XSD type 'ns2:Dot11Capabilities'
        ns2__Dot11Capabilities *Capabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetDot11CapabilitiesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetDot11CapabilitiesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetDot11CapabilitiesResponse, default initialized and not managed by a soap context
        virtual _ns1__GetDot11CapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetDot11CapabilitiesResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetDot11CapabilitiesResponse()
        {
          Capabilities = (ns2__Dot11Capabilities *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetDot11CapabilitiesResponse() { }
        /// Friend allocator used by soap_new__ns1__GetDot11CapabilitiesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetDot11CapabilitiesResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDot11CapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:763 */
#ifndef SOAP_TYPE__ns1__GetDot11Status
#define SOAP_TYPE__ns1__GetDot11Status (405)
/* complex XSD type 'ns1:GetDot11Status': */
class SOAP_CMAC _ns1__GetDot11Status {
      public:
        /// Required element 'ns1:InterfaceToken' of XSD type 'ns2:ReferenceToken'
        std::string InterfaceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetDot11Status
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetDot11Status; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetDot11Status, default initialized and not managed by a soap context
        virtual _ns1__GetDot11Status *soap_alloc(void) const { return SOAP_NEW(_ns1__GetDot11Status); }
      public:
        /// Constructor with initializations
        _ns1__GetDot11Status()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetDot11Status() { }
        /// Friend allocator used by soap_new__ns1__GetDot11Status(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetDot11Status * SOAP_FMAC2 soap_instantiate__ns1__GetDot11Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:766 */
#ifndef SOAP_TYPE__ns1__GetDot11StatusResponse
#define SOAP_TYPE__ns1__GetDot11StatusResponse (406)
/* complex XSD type 'ns1:GetDot11StatusResponse': */
class SOAP_CMAC _ns1__GetDot11StatusResponse {
      public:
        /// Required element 'ns1:Status' of XSD type 'ns2:Dot11Status'
        ns2__Dot11Status *Status;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetDot11StatusResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetDot11StatusResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetDot11StatusResponse, default initialized and not managed by a soap context
        virtual _ns1__GetDot11StatusResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetDot11StatusResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetDot11StatusResponse()
        {
          Status = (ns2__Dot11Status *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetDot11StatusResponse() { }
        /// Friend allocator used by soap_new__ns1__GetDot11StatusResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetDot11StatusResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDot11StatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:769 */
#ifndef SOAP_TYPE__ns1__ScanAvailableDot11Networks
#define SOAP_TYPE__ns1__ScanAvailableDot11Networks (407)
/* complex XSD type 'ns1:ScanAvailableDot11Networks': */
class SOAP_CMAC _ns1__ScanAvailableDot11Networks {
      public:
        /// Required element 'ns1:InterfaceToken' of XSD type 'ns2:ReferenceToken'
        std::string InterfaceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ScanAvailableDot11Networks
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ScanAvailableDot11Networks; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ScanAvailableDot11Networks, default initialized and not managed by a soap context
        virtual _ns1__ScanAvailableDot11Networks *soap_alloc(void) const { return SOAP_NEW(_ns1__ScanAvailableDot11Networks); }
      public:
        /// Constructor with initializations
        _ns1__ScanAvailableDot11Networks()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ScanAvailableDot11Networks() { }
        /// Friend allocator used by soap_new__ns1__ScanAvailableDot11Networks(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ScanAvailableDot11Networks * SOAP_FMAC2 soap_instantiate__ns1__ScanAvailableDot11Networks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:772 */
#ifndef SOAP_TYPE__ns1__ScanAvailableDot11NetworksResponse
#define SOAP_TYPE__ns1__ScanAvailableDot11NetworksResponse (408)
/* complex XSD type 'ns1:ScanAvailableDot11NetworksResponse': */
class SOAP_CMAC _ns1__ScanAvailableDot11NetworksResponse {
      public:
        /// Optional element 'ns1:Networks' of XSD type 'ns2:Dot11AvailableNetworks'
        std::vector<ns2__Dot11AvailableNetworks *> Networks;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ScanAvailableDot11NetworksResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ScanAvailableDot11NetworksResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ScanAvailableDot11NetworksResponse, default initialized and not managed by a soap context
        virtual _ns1__ScanAvailableDot11NetworksResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ScanAvailableDot11NetworksResponse); }
      public:
        /// Constructor with initializations
        _ns1__ScanAvailableDot11NetworksResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ScanAvailableDot11NetworksResponse() { }
        /// Friend allocator used by soap_new__ns1__ScanAvailableDot11NetworksResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ScanAvailableDot11NetworksResponse * SOAP_FMAC2 soap_instantiate__ns1__ScanAvailableDot11NetworksResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:775 */
#ifndef SOAP_TYPE__ns1__GetSystemUris
#define SOAP_TYPE__ns1__GetSystemUris (409)
/* complex XSD type 'ns1:GetSystemUris': */
class SOAP_CMAC _ns1__GetSystemUris {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSystemUris
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSystemUris; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSystemUris, default initialized and not managed by a soap context
        virtual _ns1__GetSystemUris *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSystemUris); }
      public:
        /// Constructor with initializations
        _ns1__GetSystemUris()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetSystemUris() { }
        /// Friend allocator used by soap_new__ns1__GetSystemUris(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSystemUris * SOAP_FMAC2 soap_instantiate__ns1__GetSystemUris(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:8994 */
#ifndef SOAP_TYPE__ns1__GetSystemUrisResponse_Extension
#define SOAP_TYPE__ns1__GetSystemUrisResponse_Extension (1554)
/* complex XSD type 'ns1:GetSystemUrisResponse-Extension': */
class SOAP_CMAC _ns1__GetSystemUrisResponse_Extension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSystemUrisResponse_Extension
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSystemUrisResponse_Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSystemUrisResponse_Extension, default initialized and not managed by a soap context
        virtual _ns1__GetSystemUrisResponse_Extension *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSystemUrisResponse_Extension); }
      public:
        /// Constructor with initializations
        _ns1__GetSystemUrisResponse_Extension()
        {
        }
        virtual ~_ns1__GetSystemUrisResponse_Extension() { }
        /// Friend allocator used by soap_new__ns1__GetSystemUrisResponse_Extension(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSystemUrisResponse_Extension * SOAP_FMAC2 soap_instantiate__ns1__GetSystemUrisResponse_Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:778 */
#ifndef SOAP_TYPE__ns1__GetSystemUrisResponse
#define SOAP_TYPE__ns1__GetSystemUrisResponse (410)
/* complex XSD type 'ns1:GetSystemUrisResponse': */
class SOAP_CMAC _ns1__GetSystemUrisResponse {
      public:
        /// Optional element 'ns1:SystemLogUris' of XSD type 'ns2:SystemLogUriList'
        ns2__SystemLogUriList *SystemLogUris;
        /// Optional element 'ns1:SupportInfoUri' of XSD type 'xsd:anyURI'
        std::string *SupportInfoUri;
        /// Optional element 'ns1:SystemBackupUri' of XSD type 'xsd:anyURI'
        std::string *SystemBackupUri;
        /// Optional element 'ns1:Extension' of XSD type 'ns1:GetSystemUrisResponse-Extension'
        _ns1__GetSystemUrisResponse_Extension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSystemUrisResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSystemUrisResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSystemUrisResponse, default initialized and not managed by a soap context
        virtual _ns1__GetSystemUrisResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSystemUrisResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetSystemUrisResponse()
        {
          SystemLogUris = (ns2__SystemLogUriList *)0;
          SupportInfoUri = (std::string *)0;
          SystemBackupUri = (std::string *)0;
          Extension = (_ns1__GetSystemUrisResponse_Extension *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetSystemUrisResponse() { }
        /// Friend allocator used by soap_new__ns1__GetSystemUrisResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSystemUrisResponse * SOAP_FMAC2 soap_instantiate__ns1__GetSystemUrisResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:781 */
#ifndef SOAP_TYPE__ns1__StartFirmwareUpgrade
#define SOAP_TYPE__ns1__StartFirmwareUpgrade (411)
/* complex XSD type 'ns1:StartFirmwareUpgrade': */
class SOAP_CMAC _ns1__StartFirmwareUpgrade {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__StartFirmwareUpgrade
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__StartFirmwareUpgrade; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__StartFirmwareUpgrade, default initialized and not managed by a soap context
        virtual _ns1__StartFirmwareUpgrade *soap_alloc(void) const { return SOAP_NEW(_ns1__StartFirmwareUpgrade); }
      public:
        /// Constructor with initializations
        _ns1__StartFirmwareUpgrade()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__StartFirmwareUpgrade() { }
        /// Friend allocator used by soap_new__ns1__StartFirmwareUpgrade(struct soap*, int)
        friend SOAP_FMAC1 _ns1__StartFirmwareUpgrade * SOAP_FMAC2 soap_instantiate__ns1__StartFirmwareUpgrade(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:784 */
#ifndef SOAP_TYPE__ns1__StartFirmwareUpgradeResponse
#define SOAP_TYPE__ns1__StartFirmwareUpgradeResponse (412)
/* complex XSD type 'ns1:StartFirmwareUpgradeResponse': */
class SOAP_CMAC _ns1__StartFirmwareUpgradeResponse {
      public:
        /// Required element 'ns1:UploadUri' of XSD type 'xsd:anyURI'
        std::string UploadUri;
        /// Required element 'ns1:UploadDelay' of XSD type 'xsd:duration'
        std::string UploadDelay;
        /// Required element 'ns1:ExpectedDownTime' of XSD type 'xsd:duration'
        std::string ExpectedDownTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__StartFirmwareUpgradeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__StartFirmwareUpgradeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__StartFirmwareUpgradeResponse, default initialized and not managed by a soap context
        virtual _ns1__StartFirmwareUpgradeResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__StartFirmwareUpgradeResponse); }
      public:
        /// Constructor with initializations
        _ns1__StartFirmwareUpgradeResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__StartFirmwareUpgradeResponse() { }
        /// Friend allocator used by soap_new__ns1__StartFirmwareUpgradeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__StartFirmwareUpgradeResponse * SOAP_FMAC2 soap_instantiate__ns1__StartFirmwareUpgradeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:787 */
#ifndef SOAP_TYPE__ns1__StartSystemRestore
#define SOAP_TYPE__ns1__StartSystemRestore (413)
/* complex XSD type 'ns1:StartSystemRestore': */
class SOAP_CMAC _ns1__StartSystemRestore {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__StartSystemRestore
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__StartSystemRestore; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__StartSystemRestore, default initialized and not managed by a soap context
        virtual _ns1__StartSystemRestore *soap_alloc(void) const { return SOAP_NEW(_ns1__StartSystemRestore); }
      public:
        /// Constructor with initializations
        _ns1__StartSystemRestore()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__StartSystemRestore() { }
        /// Friend allocator used by soap_new__ns1__StartSystemRestore(struct soap*, int)
        friend SOAP_FMAC1 _ns1__StartSystemRestore * SOAP_FMAC2 soap_instantiate__ns1__StartSystemRestore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:790 */
#ifndef SOAP_TYPE__ns1__StartSystemRestoreResponse
#define SOAP_TYPE__ns1__StartSystemRestoreResponse (414)
/* complex XSD type 'ns1:StartSystemRestoreResponse': */
class SOAP_CMAC _ns1__StartSystemRestoreResponse {
      public:
        /// Required element 'ns1:UploadUri' of XSD type 'xsd:anyURI'
        std::string UploadUri;
        /// Required element 'ns1:ExpectedDownTime' of XSD type 'xsd:duration'
        std::string ExpectedDownTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__StartSystemRestoreResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__StartSystemRestoreResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__StartSystemRestoreResponse, default initialized and not managed by a soap context
        virtual _ns1__StartSystemRestoreResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__StartSystemRestoreResponse); }
      public:
        /// Constructor with initializations
        _ns1__StartSystemRestoreResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__StartSystemRestoreResponse() { }
        /// Friend allocator used by soap_new__ns1__StartSystemRestoreResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__StartSystemRestoreResponse * SOAP_FMAC2 soap_instantiate__ns1__StartSystemRestoreResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:793 */
#ifndef SOAP_TYPE__ns1__GetStorageConfigurations
#define SOAP_TYPE__ns1__GetStorageConfigurations (415)
/* complex XSD type 'ns1:GetStorageConfigurations': */
class SOAP_CMAC _ns1__GetStorageConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetStorageConfigurations
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetStorageConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetStorageConfigurations, default initialized and not managed by a soap context
        virtual _ns1__GetStorageConfigurations *soap_alloc(void) const { return SOAP_NEW(_ns1__GetStorageConfigurations); }
      public:
        /// Constructor with initializations
        _ns1__GetStorageConfigurations()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetStorageConfigurations() { }
        /// Friend allocator used by soap_new__ns1__GetStorageConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetStorageConfigurations * SOAP_FMAC2 soap_instantiate__ns1__GetStorageConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:796 */
#ifndef SOAP_TYPE__ns1__GetStorageConfigurationsResponse
#define SOAP_TYPE__ns1__GetStorageConfigurationsResponse (416)
/* complex XSD type 'ns1:GetStorageConfigurationsResponse': */
class SOAP_CMAC _ns1__GetStorageConfigurationsResponse {
      public:
        /// Optional element 'ns1:StorageConfigurations' of XSD type 'ns1:StorageConfiguration'
        std::vector<ns1__StorageConfiguration *> StorageConfigurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetStorageConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetStorageConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetStorageConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns1__GetStorageConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetStorageConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetStorageConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetStorageConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns1__GetStorageConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetStorageConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns1__GetStorageConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:799 */
#ifndef SOAP_TYPE__ns1__CreateStorageConfiguration
#define SOAP_TYPE__ns1__CreateStorageConfiguration (417)
/* complex XSD type 'ns1:CreateStorageConfiguration': */
class SOAP_CMAC _ns1__CreateStorageConfiguration {
      public:
        /// Required element 'ns1:StorageConfiguration' of XSD type 'ns1:StorageConfigurationData'
        ns1__StorageConfigurationData *StorageConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateStorageConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateStorageConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateStorageConfiguration, default initialized and not managed by a soap context
        virtual _ns1__CreateStorageConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateStorageConfiguration); }
      public:
        /// Constructor with initializations
        _ns1__CreateStorageConfiguration()
        {
          StorageConfiguration = (ns1__StorageConfigurationData *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateStorageConfiguration() { }
        /// Friend allocator used by soap_new__ns1__CreateStorageConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateStorageConfiguration * SOAP_FMAC2 soap_instantiate__ns1__CreateStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:802 */
#ifndef SOAP_TYPE__ns1__CreateStorageConfigurationResponse
#define SOAP_TYPE__ns1__CreateStorageConfigurationResponse (418)
/* complex XSD type 'ns1:CreateStorageConfigurationResponse': */
class SOAP_CMAC _ns1__CreateStorageConfigurationResponse {
      public:
        /// Required element 'ns1:Token' of XSD type 'ns2:ReferenceToken'
        std::string Token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateStorageConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateStorageConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateStorageConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns1__CreateStorageConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateStorageConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns1__CreateStorageConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateStorageConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns1__CreateStorageConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns1__CreateStorageConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:805 */
#ifndef SOAP_TYPE__ns1__GetStorageConfiguration
#define SOAP_TYPE__ns1__GetStorageConfiguration (419)
/* complex XSD type 'ns1:GetStorageConfiguration': */
class SOAP_CMAC _ns1__GetStorageConfiguration {
      public:
        /// Required element 'ns1:Token' of XSD type 'ns2:ReferenceToken'
        std::string Token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetStorageConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetStorageConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetStorageConfiguration, default initialized and not managed by a soap context
        virtual _ns1__GetStorageConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns1__GetStorageConfiguration); }
      public:
        /// Constructor with initializations
        _ns1__GetStorageConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetStorageConfiguration() { }
        /// Friend allocator used by soap_new__ns1__GetStorageConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetStorageConfiguration * SOAP_FMAC2 soap_instantiate__ns1__GetStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:808 */
#ifndef SOAP_TYPE__ns1__GetStorageConfigurationResponse
#define SOAP_TYPE__ns1__GetStorageConfigurationResponse (420)
/* complex XSD type 'ns1:GetStorageConfigurationResponse': */
class SOAP_CMAC _ns1__GetStorageConfigurationResponse {
      public:
        /// Required element 'ns1:StorageConfiguration' of XSD type 'ns1:StorageConfiguration'
        ns1__StorageConfiguration *StorageConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetStorageConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetStorageConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetStorageConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns1__GetStorageConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetStorageConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetStorageConfigurationResponse()
        {
          StorageConfiguration = (ns1__StorageConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetStorageConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns1__GetStorageConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns1__GetStorageConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:811 */
#ifndef SOAP_TYPE__ns1__SetStorageConfiguration
#define SOAP_TYPE__ns1__SetStorageConfiguration (421)
/* complex XSD type 'ns1:SetStorageConfiguration': */
class SOAP_CMAC _ns1__SetStorageConfiguration {
      public:
        /// Required element 'ns1:StorageConfiguration' of XSD type 'ns1:StorageConfiguration'
        ns1__StorageConfiguration *StorageConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetStorageConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetStorageConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetStorageConfiguration, default initialized and not managed by a soap context
        virtual _ns1__SetStorageConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns1__SetStorageConfiguration); }
      public:
        /// Constructor with initializations
        _ns1__SetStorageConfiguration()
        {
          StorageConfiguration = (ns1__StorageConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetStorageConfiguration() { }
        /// Friend allocator used by soap_new__ns1__SetStorageConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetStorageConfiguration * SOAP_FMAC2 soap_instantiate__ns1__SetStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:814 */
#ifndef SOAP_TYPE__ns1__SetStorageConfigurationResponse
#define SOAP_TYPE__ns1__SetStorageConfigurationResponse (422)
/* complex XSD type 'ns1:SetStorageConfigurationResponse': */
class SOAP_CMAC _ns1__SetStorageConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetStorageConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetStorageConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetStorageConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns1__SetStorageConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetStorageConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetStorageConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetStorageConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns1__SetStorageConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns1__SetStorageConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:817 */
#ifndef SOAP_TYPE__ns1__DeleteStorageConfiguration
#define SOAP_TYPE__ns1__DeleteStorageConfiguration (423)
/* complex XSD type 'ns1:DeleteStorageConfiguration': */
class SOAP_CMAC _ns1__DeleteStorageConfiguration {
      public:
        /// Required element 'ns1:Token' of XSD type 'ns2:ReferenceToken'
        std::string Token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DeleteStorageConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DeleteStorageConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DeleteStorageConfiguration, default initialized and not managed by a soap context
        virtual _ns1__DeleteStorageConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns1__DeleteStorageConfiguration); }
      public:
        /// Constructor with initializations
        _ns1__DeleteStorageConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__DeleteStorageConfiguration() { }
        /// Friend allocator used by soap_new__ns1__DeleteStorageConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DeleteStorageConfiguration * SOAP_FMAC2 soap_instantiate__ns1__DeleteStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:820 */
#ifndef SOAP_TYPE__ns1__DeleteStorageConfigurationResponse
#define SOAP_TYPE__ns1__DeleteStorageConfigurationResponse (424)
/* complex XSD type 'ns1:DeleteStorageConfigurationResponse': */
class SOAP_CMAC _ns1__DeleteStorageConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DeleteStorageConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DeleteStorageConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DeleteStorageConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns1__DeleteStorageConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__DeleteStorageConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns1__DeleteStorageConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__DeleteStorageConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns1__DeleteStorageConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DeleteStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns1__DeleteStorageConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:823 */
#ifndef SOAP_TYPE_ns2__DeviceEntity
#define SOAP_TYPE_ns2__DeviceEntity (425)
/* Type ns2__DeviceEntity is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:DeviceEntity': */
class SOAP_CMAC ns2__DeviceEntity {
      public:
        /// required attribute 'token' of XSD type 'ns2:ReferenceToken'
        std::string token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DeviceEntity
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DeviceEntity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DeviceEntity, default initialized and not managed by a soap context
        virtual ns2__DeviceEntity *soap_alloc(void) const { return SOAP_NEW(ns2__DeviceEntity); }
      public:
        /// Constructor with initializations
        ns2__DeviceEntity()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__DeviceEntity() { }
        /// Friend allocator used by soap_new_ns2__DeviceEntity(struct soap*, int)
        friend SOAP_FMAC1 ns2__DeviceEntity * SOAP_FMAC2 soap_instantiate_ns2__DeviceEntity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:826 */
#ifndef SOAP_TYPE_ns2__IntRectangle
#define SOAP_TYPE_ns2__IntRectangle (426)
/* complex XSD type 'ns2:IntRectangle': */
class SOAP_CMAC ns2__IntRectangle {
      public:
        /// required attribute 'x' of XSD type 'xsd:int'
        int x;
        /// required attribute 'y' of XSD type 'xsd:int'
        int y;
        /// required attribute 'width' of XSD type 'xsd:int'
        int width;
        /// required attribute 'height' of XSD type 'xsd:int'
        int height;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__IntRectangle
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__IntRectangle; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__IntRectangle, default initialized and not managed by a soap context
        virtual ns2__IntRectangle *soap_alloc(void) const { return SOAP_NEW(ns2__IntRectangle); }
      public:
        /// Constructor with initializations
        ns2__IntRectangle()
        {
          x = (int)0;
          y = (int)0;
          width = (int)0;
          height = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__IntRectangle() { }
        /// Friend allocator used by soap_new_ns2__IntRectangle(struct soap*, int)
        friend SOAP_FMAC1 ns2__IntRectangle * SOAP_FMAC2 soap_instantiate_ns2__IntRectangle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:829 */
#ifndef SOAP_TYPE_ns2__IntRectangleRange
#define SOAP_TYPE_ns2__IntRectangleRange (427)
/* complex XSD type 'ns2:IntRectangleRange': */
class SOAP_CMAC ns2__IntRectangleRange {
      public:
        /// Required element 'ns2:XRange' of XSD type 'ns2:IntRange'
        ns2__IntRange *XRange;
        /// Required element 'ns2:YRange' of XSD type 'ns2:IntRange'
        ns2__IntRange *YRange;
        /// Required element 'ns2:WidthRange' of XSD type 'ns2:IntRange'
        ns2__IntRange *WidthRange;
        /// Required element 'ns2:HeightRange' of XSD type 'ns2:IntRange'
        ns2__IntRange *HeightRange;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__IntRectangleRange
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__IntRectangleRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__IntRectangleRange, default initialized and not managed by a soap context
        virtual ns2__IntRectangleRange *soap_alloc(void) const { return SOAP_NEW(ns2__IntRectangleRange); }
      public:
        /// Constructor with initializations
        ns2__IntRectangleRange()
        {
          XRange = (ns2__IntRange *)0;
          YRange = (ns2__IntRange *)0;
          WidthRange = (ns2__IntRange *)0;
          HeightRange = (ns2__IntRange *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__IntRectangleRange() { }
        /// Friend allocator used by soap_new_ns2__IntRectangleRange(struct soap*, int)
        friend SOAP_FMAC1 ns2__IntRectangleRange * SOAP_FMAC2 soap_instantiate_ns2__IntRectangleRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:832 */
#ifndef SOAP_TYPE_ns2__IntRange
#define SOAP_TYPE_ns2__IntRange (428)
/* complex XSD type 'ns2:IntRange': */
class SOAP_CMAC ns2__IntRange {
      public:
        /// Required element 'ns2:Min' of XSD type 'xsd:int'
        int Min;
        /// Required element 'ns2:Max' of XSD type 'xsd:int'
        int Max;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__IntRange
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__IntRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__IntRange, default initialized and not managed by a soap context
        virtual ns2__IntRange *soap_alloc(void) const { return SOAP_NEW(ns2__IntRange); }
      public:
        /// Constructor with initializations
        ns2__IntRange()
        {
          Min = (int)0;
          Max = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__IntRange() { }
        /// Friend allocator used by soap_new_ns2__IntRange(struct soap*, int)
        friend SOAP_FMAC1 ns2__IntRange * SOAP_FMAC2 soap_instantiate_ns2__IntRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:835 */
#ifndef SOAP_TYPE_ns2__FloatRange
#define SOAP_TYPE_ns2__FloatRange (429)
/* complex XSD type 'ns2:FloatRange': */
class SOAP_CMAC ns2__FloatRange {
      public:
        /// Required element 'ns2:Min' of XSD type 'xsd:float'
        float Min;
        /// Required element 'ns2:Max' of XSD type 'xsd:float'
        float Max;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FloatRange
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FloatRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FloatRange, default initialized and not managed by a soap context
        virtual ns2__FloatRange *soap_alloc(void) const { return SOAP_NEW(ns2__FloatRange); }
      public:
        /// Constructor with initializations
        ns2__FloatRange()
        {
          Min = (float)0;
          Max = (float)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__FloatRange() { }
        /// Friend allocator used by soap_new_ns2__FloatRange(struct soap*, int)
        friend SOAP_FMAC1 ns2__FloatRange * SOAP_FMAC2 soap_instantiate_ns2__FloatRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:838 */
#ifndef SOAP_TYPE_ns2__DurationRange
#define SOAP_TYPE_ns2__DurationRange (430)
/* complex XSD type 'ns2:DurationRange': */
class SOAP_CMAC ns2__DurationRange {
      public:
        /// Required element 'ns2:Min' of XSD type 'xsd:duration'
        std::string Min;
        /// Required element 'ns2:Max' of XSD type 'xsd:duration'
        std::string Max;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DurationRange
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DurationRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DurationRange, default initialized and not managed by a soap context
        virtual ns2__DurationRange *soap_alloc(void) const { return SOAP_NEW(ns2__DurationRange); }
      public:
        /// Constructor with initializations
        ns2__DurationRange()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__DurationRange() { }
        /// Friend allocator used by soap_new_ns2__DurationRange(struct soap*, int)
        friend SOAP_FMAC1 ns2__DurationRange * SOAP_FMAC2 soap_instantiate_ns2__DurationRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:841 */
#ifndef SOAP_TYPE_ns2__IntList
#define SOAP_TYPE_ns2__IntList (431)
/* complex XSD type 'ns2:IntList': */
class SOAP_CMAC ns2__IntList {
      public:
        /// Optional element 'ns2:Items' of XSD type 'xsd:int'
        std::vector<int> Items;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__IntList
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__IntList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__IntList, default initialized and not managed by a soap context
        virtual ns2__IntList *soap_alloc(void) const { return SOAP_NEW(ns2__IntList); }
      public:
        /// Constructor with initializations
        ns2__IntList()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__IntList() { }
        /// Friend allocator used by soap_new_ns2__IntList(struct soap*, int)
        friend SOAP_FMAC1 ns2__IntList * SOAP_FMAC2 soap_instantiate_ns2__IntList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:844 */
#ifndef SOAP_TYPE_ns2__FloatList
#define SOAP_TYPE_ns2__FloatList (432)
/* complex XSD type 'ns2:FloatList': */
class SOAP_CMAC ns2__FloatList {
      public:
        /// Optional element 'ns2:Items' of XSD type 'xsd:float'
        std::vector<float> Items;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FloatList
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FloatList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FloatList, default initialized and not managed by a soap context
        virtual ns2__FloatList *soap_alloc(void) const { return SOAP_NEW(ns2__FloatList); }
      public:
        /// Constructor with initializations
        ns2__FloatList()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__FloatList() { }
        /// Friend allocator used by soap_new_ns2__FloatList(struct soap*, int)
        friend SOAP_FMAC1 ns2__FloatList * SOAP_FMAC2 soap_instantiate_ns2__FloatList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:847 */
#ifndef SOAP_TYPE_ns2__AnyHolder
#define SOAP_TYPE_ns2__AnyHolder (433)
/* complex XSD type 'ns2:AnyHolder': */
class SOAP_CMAC ns2__AnyHolder {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AnyHolder
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AnyHolder; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AnyHolder, default initialized and not managed by a soap context
        virtual ns2__AnyHolder *soap_alloc(void) const { return SOAP_NEW(ns2__AnyHolder); }
      public:
        /// Constructor with initializations
        ns2__AnyHolder()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__AnyHolder() { }
        /// Friend allocator used by soap_new_ns2__AnyHolder(struct soap*, int)
        friend SOAP_FMAC1 ns2__AnyHolder * SOAP_FMAC2 soap_instantiate_ns2__AnyHolder(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:853 */
#ifndef SOAP_TYPE_ns2__VideoSourceExtension
#define SOAP_TYPE_ns2__VideoSourceExtension (435)
/* complex XSD type 'ns2:VideoSourceExtension': */
class SOAP_CMAC ns2__VideoSourceExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional element 'ns2:Imaging' of XSD type 'ns2:ImagingSettings20'
        ns2__ImagingSettings20 *Imaging;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:VideoSourceExtension2'
        ns2__VideoSourceExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoSourceExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoSourceExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoSourceExtension, default initialized and not managed by a soap context
        virtual ns2__VideoSourceExtension *soap_alloc(void) const { return SOAP_NEW(ns2__VideoSourceExtension); }
      public:
        /// Constructor with initializations
        ns2__VideoSourceExtension()
        {
          Imaging = (ns2__ImagingSettings20 *)0;
          Extension = (ns2__VideoSourceExtension2 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__VideoSourceExtension() { }
        /// Friend allocator used by soap_new_ns2__VideoSourceExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoSourceExtension * SOAP_FMAC2 soap_instantiate_ns2__VideoSourceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:856 */
#ifndef SOAP_TYPE_ns2__VideoSourceExtension2
#define SOAP_TYPE_ns2__VideoSourceExtension2 (436)
/* complex XSD type 'ns2:VideoSourceExtension2': */
class SOAP_CMAC ns2__VideoSourceExtension2 {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoSourceExtension2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoSourceExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoSourceExtension2, default initialized and not managed by a soap context
        virtual ns2__VideoSourceExtension2 *soap_alloc(void) const { return SOAP_NEW(ns2__VideoSourceExtension2); }
      public:
        /// Constructor with initializations
        ns2__VideoSourceExtension2()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__VideoSourceExtension2() { }
        /// Friend allocator used by soap_new_ns2__VideoSourceExtension2(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoSourceExtension2 * SOAP_FMAC2 soap_instantiate_ns2__VideoSourceExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:862 */
#ifndef SOAP_TYPE_ns2__Profile
#define SOAP_TYPE_ns2__Profile (438)
/* complex XSD type 'ns2:Profile': */
class SOAP_CMAC ns2__Profile {
      public:
        /// Required element 'ns2:Name' of XSD type 'ns2:Name'
        std::string Name;
        /// Optional element 'ns2:VideoSourceConfiguration' of XSD type 'ns2:VideoSourceConfiguration'
        ns2__VideoSourceConfiguration *VideoSourceConfiguration;
        /// Optional element 'ns2:AudioSourceConfiguration' of XSD type 'ns2:AudioSourceConfiguration'
        ns2__AudioSourceConfiguration *AudioSourceConfiguration;
        /// Optional element 'ns2:VideoEncoderConfiguration' of XSD type 'ns2:VideoEncoderConfiguration'
        ns2__VideoEncoderConfiguration *VideoEncoderConfiguration;
        /// Optional element 'ns2:AudioEncoderConfiguration' of XSD type 'ns2:AudioEncoderConfiguration'
        ns2__AudioEncoderConfiguration *AudioEncoderConfiguration;
        /// Optional element 'ns2:VideoAnalyticsConfiguration' of XSD type 'ns2:VideoAnalyticsConfiguration'
        ns2__VideoAnalyticsConfiguration *VideoAnalyticsConfiguration;
        /// Optional element 'ns2:PTZConfiguration' of XSD type 'ns2:PTZConfiguration'
        ns2__PTZConfiguration *PTZConfiguration;
        /// Optional element 'ns2:MetadataConfiguration' of XSD type 'ns2:MetadataConfiguration'
        ns2__MetadataConfiguration *MetadataConfiguration;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ProfileExtension'
        ns2__ProfileExtension *Extension;
        /// required attribute 'token' of XSD type 'ns2:ReferenceToken'
        std::string token;
        /// optional attribute 'fixed' of XSD type 'xsd:boolean'
        bool *fixed;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Profile
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Profile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Profile, default initialized and not managed by a soap context
        virtual ns2__Profile *soap_alloc(void) const { return SOAP_NEW(ns2__Profile); }
      public:
        /// Constructor with initializations
        ns2__Profile()
        {
          VideoSourceConfiguration = (ns2__VideoSourceConfiguration *)0;
          AudioSourceConfiguration = (ns2__AudioSourceConfiguration *)0;
          VideoEncoderConfiguration = (ns2__VideoEncoderConfiguration *)0;
          AudioEncoderConfiguration = (ns2__AudioEncoderConfiguration *)0;
          VideoAnalyticsConfiguration = (ns2__VideoAnalyticsConfiguration *)0;
          PTZConfiguration = (ns2__PTZConfiguration *)0;
          MetadataConfiguration = (ns2__MetadataConfiguration *)0;
          Extension = (ns2__ProfileExtension *)0;
          fixed = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Profile() { }
        /// Friend allocator used by soap_new_ns2__Profile(struct soap*, int)
        friend SOAP_FMAC1 ns2__Profile * SOAP_FMAC2 soap_instantiate_ns2__Profile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:865 */
#ifndef SOAP_TYPE_ns2__ProfileExtension
#define SOAP_TYPE_ns2__ProfileExtension (439)
/* complex XSD type 'ns2:ProfileExtension': */
class SOAP_CMAC ns2__ProfileExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional element 'ns2:AudioOutputConfiguration' of XSD type 'ns2:AudioOutputConfiguration'
        ns2__AudioOutputConfiguration *AudioOutputConfiguration;
        /// Optional element 'ns2:AudioDecoderConfiguration' of XSD type 'ns2:AudioDecoderConfiguration'
        ns2__AudioDecoderConfiguration *AudioDecoderConfiguration;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ProfileExtension2'
        ns2__ProfileExtension2 *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ProfileExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ProfileExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ProfileExtension, default initialized and not managed by a soap context
        virtual ns2__ProfileExtension *soap_alloc(void) const { return SOAP_NEW(ns2__ProfileExtension); }
      public:
        /// Constructor with initializations
        ns2__ProfileExtension()
        {
          AudioOutputConfiguration = (ns2__AudioOutputConfiguration *)0;
          AudioDecoderConfiguration = (ns2__AudioDecoderConfiguration *)0;
          Extension = (ns2__ProfileExtension2 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ProfileExtension() { }
        /// Friend allocator used by soap_new_ns2__ProfileExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__ProfileExtension * SOAP_FMAC2 soap_instantiate_ns2__ProfileExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:868 */
#ifndef SOAP_TYPE_ns2__ProfileExtension2
#define SOAP_TYPE_ns2__ProfileExtension2 (440)
/* complex XSD type 'ns2:ProfileExtension2': */
class SOAP_CMAC ns2__ProfileExtension2 {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ProfileExtension2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ProfileExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ProfileExtension2, default initialized and not managed by a soap context
        virtual ns2__ProfileExtension2 *soap_alloc(void) const { return SOAP_NEW(ns2__ProfileExtension2); }
      public:
        /// Constructor with initializations
        ns2__ProfileExtension2()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ProfileExtension2() { }
        /// Friend allocator used by soap_new_ns2__ProfileExtension2(struct soap*, int)
        friend SOAP_FMAC1 ns2__ProfileExtension2 * SOAP_FMAC2 soap_instantiate_ns2__ProfileExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:871 */
#ifndef SOAP_TYPE_ns2__ConfigurationEntity
#define SOAP_TYPE_ns2__ConfigurationEntity (441)
/* Type ns2__ConfigurationEntity is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:ConfigurationEntity': */
class SOAP_CMAC ns2__ConfigurationEntity {
      public:
        /// Required element 'ns2:Name' of XSD type 'ns2:Name'
        std::string Name;
        /// Required element 'ns2:UseCount' of XSD type 'xsd:int'
        int UseCount;
        /// required attribute 'token' of XSD type 'ns2:ReferenceToken'
        std::string token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ConfigurationEntity
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ConfigurationEntity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ConfigurationEntity, default initialized and not managed by a soap context
        virtual ns2__ConfigurationEntity *soap_alloc(void) const { return SOAP_NEW(ns2__ConfigurationEntity); }
      public:
        /// Constructor with initializations
        ns2__ConfigurationEntity()
        {
          UseCount = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ConfigurationEntity() { }
        /// Friend allocator used by soap_new_ns2__ConfigurationEntity(struct soap*, int)
        friend SOAP_FMAC1 ns2__ConfigurationEntity * SOAP_FMAC2 soap_instantiate_ns2__ConfigurationEntity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:877 */
#ifndef SOAP_TYPE_ns2__VideoSourceConfigurationExtension
#define SOAP_TYPE_ns2__VideoSourceConfigurationExtension (443)
/* complex XSD type 'ns2:VideoSourceConfigurationExtension': */
class SOAP_CMAC ns2__VideoSourceConfigurationExtension {
      public:
        /// Optional element 'ns2:Rotate' of XSD type 'ns2:Rotate'
        ns2__Rotate *Rotate;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:VideoSourceConfigurationExtension2'
        ns2__VideoSourceConfigurationExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoSourceConfigurationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoSourceConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoSourceConfigurationExtension, default initialized and not managed by a soap context
        virtual ns2__VideoSourceConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__VideoSourceConfigurationExtension); }
      public:
        /// Constructor with initializations
        ns2__VideoSourceConfigurationExtension()
        {
          Rotate = (ns2__Rotate *)0;
          Extension = (ns2__VideoSourceConfigurationExtension2 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__VideoSourceConfigurationExtension() { }
        /// Friend allocator used by soap_new_ns2__VideoSourceConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoSourceConfigurationExtension * SOAP_FMAC2 soap_instantiate_ns2__VideoSourceConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:880 */
#ifndef SOAP_TYPE_ns2__VideoSourceConfigurationExtension2
#define SOAP_TYPE_ns2__VideoSourceConfigurationExtension2 (444)
/* complex XSD type 'ns2:VideoSourceConfigurationExtension2': */
class SOAP_CMAC ns2__VideoSourceConfigurationExtension2 {
      public:
        /// Optional element 'ns2:LensDescription' of XSD type 'ns2:LensDescription'
        std::vector<ns2__LensDescription *> LensDescription;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoSourceConfigurationExtension2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoSourceConfigurationExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoSourceConfigurationExtension2, default initialized and not managed by a soap context
        virtual ns2__VideoSourceConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW(ns2__VideoSourceConfigurationExtension2); }
      public:
        /// Constructor with initializations
        ns2__VideoSourceConfigurationExtension2()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__VideoSourceConfigurationExtension2() { }
        /// Friend allocator used by soap_new_ns2__VideoSourceConfigurationExtension2(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoSourceConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_ns2__VideoSourceConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:883 */
#ifndef SOAP_TYPE_ns2__Rotate
#define SOAP_TYPE_ns2__Rotate (445)
/* complex XSD type 'ns2:Rotate': */
class SOAP_CMAC ns2__Rotate {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:RotateMode'
        ns2__RotateMode Mode;
        /// Optional element 'ns2:Degree' of XSD type 'xsd:int'
        int *Degree;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:RotateExtension'
        ns2__RotateExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Rotate
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Rotate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Rotate, default initialized and not managed by a soap context
        virtual ns2__Rotate *soap_alloc(void) const { return SOAP_NEW(ns2__Rotate); }
      public:
        /// Constructor with initializations
        ns2__Rotate()
        {
          Mode = (ns2__RotateMode)0;
          Degree = (int *)0;
          Extension = (ns2__RotateExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Rotate() { }
        /// Friend allocator used by soap_new_ns2__Rotate(struct soap*, int)
        friend SOAP_FMAC1 ns2__Rotate * SOAP_FMAC2 soap_instantiate_ns2__Rotate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:886 */
#ifndef SOAP_TYPE_ns2__RotateExtension
#define SOAP_TYPE_ns2__RotateExtension (446)
/* complex XSD type 'ns2:RotateExtension': */
class SOAP_CMAC ns2__RotateExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RotateExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RotateExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RotateExtension, default initialized and not managed by a soap context
        virtual ns2__RotateExtension *soap_alloc(void) const { return SOAP_NEW(ns2__RotateExtension); }
      public:
        /// Constructor with initializations
        ns2__RotateExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__RotateExtension() { }
        /// Friend allocator used by soap_new_ns2__RotateExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__RotateExtension * SOAP_FMAC2 soap_instantiate_ns2__RotateExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:889 */
#ifndef SOAP_TYPE_ns2__LensProjection
#define SOAP_TYPE_ns2__LensProjection (447)
/* complex XSD type 'ns2:LensProjection': */
class SOAP_CMAC ns2__LensProjection {
      public:
        /// Required element 'ns2:Angle' of XSD type 'xsd:float'
        float Angle;
        /// Required element 'ns2:Radius' of XSD type 'xsd:float'
        float Radius;
        /// Optional element 'ns2:Transmittance' of XSD type 'xsd:float'
        float *Transmittance;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__LensProjection
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__LensProjection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__LensProjection, default initialized and not managed by a soap context
        virtual ns2__LensProjection *soap_alloc(void) const { return SOAP_NEW(ns2__LensProjection); }
      public:
        /// Constructor with initializations
        ns2__LensProjection()
        {
          Angle = (float)0;
          Radius = (float)0;
          Transmittance = (float *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__LensProjection() { }
        /// Friend allocator used by soap_new_ns2__LensProjection(struct soap*, int)
        friend SOAP_FMAC1 ns2__LensProjection * SOAP_FMAC2 soap_instantiate_ns2__LensProjection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:892 */
#ifndef SOAP_TYPE_ns2__LensOffset
#define SOAP_TYPE_ns2__LensOffset (448)
/* complex XSD type 'ns2:LensOffset': */
class SOAP_CMAC ns2__LensOffset {
      public:
        /// optional attribute 'x' of XSD type 'xsd:float'
        float *x;
        /// optional attribute 'y' of XSD type 'xsd:float'
        float *y;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__LensOffset
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__LensOffset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__LensOffset, default initialized and not managed by a soap context
        virtual ns2__LensOffset *soap_alloc(void) const { return SOAP_NEW(ns2__LensOffset); }
      public:
        /// Constructor with initializations
        ns2__LensOffset()
        {
          x = (float *)0;
          y = (float *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__LensOffset() { }
        /// Friend allocator used by soap_new_ns2__LensOffset(struct soap*, int)
        friend SOAP_FMAC1 ns2__LensOffset * SOAP_FMAC2 soap_instantiate_ns2__LensOffset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:895 */
#ifndef SOAP_TYPE_ns2__LensDescription
#define SOAP_TYPE_ns2__LensDescription (449)
/* complex XSD type 'ns2:LensDescription': */
class SOAP_CMAC ns2__LensDescription {
      public:
        /// Required element 'ns2:Offset' of XSD type 'ns2:LensOffset'
        ns2__LensOffset *Offset;
        /// Required element 'ns2:Projection' of XSD type 'ns2:LensProjection'
        std::vector<ns2__LensProjection *> Projection;
        /// Required element 'ns2:XFactor' of XSD type 'xsd:float'
        float XFactor;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// optional attribute 'FocalLength' of XSD type 'xsd:float'
        float *FocalLength;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__LensDescription
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__LensDescription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__LensDescription, default initialized and not managed by a soap context
        virtual ns2__LensDescription *soap_alloc(void) const { return SOAP_NEW(ns2__LensDescription); }
      public:
        /// Constructor with initializations
        ns2__LensDescription()
        {
          Offset = (ns2__LensOffset *)0;
          XFactor = (float)0;
          FocalLength = (float *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__LensDescription() { }
        /// Friend allocator used by soap_new_ns2__LensDescription(struct soap*, int)
        friend SOAP_FMAC1 ns2__LensDescription * SOAP_FMAC2 soap_instantiate_ns2__LensDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:898 */
#ifndef SOAP_TYPE_ns2__VideoSourceConfigurationOptions
#define SOAP_TYPE_ns2__VideoSourceConfigurationOptions (450)
/* complex XSD type 'ns2:VideoSourceConfigurationOptions': */
class SOAP_CMAC ns2__VideoSourceConfigurationOptions {
      public:
        /// Required element 'ns2:BoundsRange' of XSD type 'ns2:IntRectangleRange'
        ns2__IntRectangleRange *BoundsRange;
        /// Required element 'ns2:VideoSourceTokensAvailable' of XSD type 'ns2:ReferenceToken'
        std::vector<std::string> VideoSourceTokensAvailable;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:VideoSourceConfigurationOptionsExtension'
        ns2__VideoSourceConfigurationOptionsExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoSourceConfigurationOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoSourceConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoSourceConfigurationOptions, default initialized and not managed by a soap context
        virtual ns2__VideoSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(ns2__VideoSourceConfigurationOptions); }
      public:
        /// Constructor with initializations
        ns2__VideoSourceConfigurationOptions()
        {
          BoundsRange = (ns2__IntRectangleRange *)0;
          Extension = (ns2__VideoSourceConfigurationOptionsExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__VideoSourceConfigurationOptions() { }
        /// Friend allocator used by soap_new_ns2__VideoSourceConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate_ns2__VideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:901 */
#ifndef SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension
#define SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension (451)
/* complex XSD type 'ns2:VideoSourceConfigurationOptionsExtension': */
class SOAP_CMAC ns2__VideoSourceConfigurationOptionsExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional element 'ns2:Rotate' of XSD type 'ns2:RotateOptions'
        ns2__RotateOptions *Rotate;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:VideoSourceConfigurationOptionsExtension2'
        ns2__VideoSourceConfigurationOptionsExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoSourceConfigurationOptionsExtension, default initialized and not managed by a soap context
        virtual ns2__VideoSourceConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(ns2__VideoSourceConfigurationOptionsExtension); }
      public:
        /// Constructor with initializations
        ns2__VideoSourceConfigurationOptionsExtension()
        {
          Rotate = (ns2__RotateOptions *)0;
          Extension = (ns2__VideoSourceConfigurationOptionsExtension2 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__VideoSourceConfigurationOptionsExtension() { }
        /// Friend allocator used by soap_new_ns2__VideoSourceConfigurationOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoSourceConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_ns2__VideoSourceConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:904 */
#ifndef SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension2
#define SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension2 (452)
/* complex XSD type 'ns2:VideoSourceConfigurationOptionsExtension2': */
class SOAP_CMAC ns2__VideoSourceConfigurationOptionsExtension2 {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoSourceConfigurationOptionsExtension2, default initialized and not managed by a soap context
        virtual ns2__VideoSourceConfigurationOptionsExtension2 *soap_alloc(void) const { return SOAP_NEW(ns2__VideoSourceConfigurationOptionsExtension2); }
      public:
        /// Constructor with initializations
        ns2__VideoSourceConfigurationOptionsExtension2()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__VideoSourceConfigurationOptionsExtension2() { }
        /// Friend allocator used by soap_new_ns2__VideoSourceConfigurationOptionsExtension2(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoSourceConfigurationOptionsExtension2 * SOAP_FMAC2 soap_instantiate_ns2__VideoSourceConfigurationOptionsExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:907 */
#ifndef SOAP_TYPE_ns2__RotateOptions
#define SOAP_TYPE_ns2__RotateOptions (453)
/* complex XSD type 'ns2:RotateOptions': */
class SOAP_CMAC ns2__RotateOptions {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:RotateMode'
        std::vector<ns2__RotateMode> Mode;
        /// Optional element 'ns2:DegreeList' of XSD type 'ns2:IntList'
        ns2__IntList *DegreeList;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:RotateOptionsExtension'
        ns2__RotateOptionsExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RotateOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RotateOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RotateOptions, default initialized and not managed by a soap context
        virtual ns2__RotateOptions *soap_alloc(void) const { return SOAP_NEW(ns2__RotateOptions); }
      public:
        /// Constructor with initializations
        ns2__RotateOptions()
        {
          DegreeList = (ns2__IntList *)0;
          Extension = (ns2__RotateOptionsExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__RotateOptions() { }
        /// Friend allocator used by soap_new_ns2__RotateOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__RotateOptions * SOAP_FMAC2 soap_instantiate_ns2__RotateOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:910 */
#ifndef SOAP_TYPE_ns2__RotateOptionsExtension
#define SOAP_TYPE_ns2__RotateOptionsExtension (454)
/* complex XSD type 'ns2:RotateOptionsExtension': */
class SOAP_CMAC ns2__RotateOptionsExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RotateOptionsExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RotateOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RotateOptionsExtension, default initialized and not managed by a soap context
        virtual ns2__RotateOptionsExtension *soap_alloc(void) const { return SOAP_NEW(ns2__RotateOptionsExtension); }
      public:
        /// Constructor with initializations
        ns2__RotateOptionsExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__RotateOptionsExtension() { }
        /// Friend allocator used by soap_new_ns2__RotateOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__RotateOptionsExtension * SOAP_FMAC2 soap_instantiate_ns2__RotateOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:916 */
#ifndef SOAP_TYPE_ns2__VideoResolution
#define SOAP_TYPE_ns2__VideoResolution (456)
/* complex XSD type 'ns2:VideoResolution': */
class SOAP_CMAC ns2__VideoResolution {
      public:
        /// Required element 'ns2:Width' of XSD type 'xsd:int'
        int Width;
        /// Required element 'ns2:Height' of XSD type 'xsd:int'
        int Height;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoResolution
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoResolution; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoResolution, default initialized and not managed by a soap context
        virtual ns2__VideoResolution *soap_alloc(void) const { return SOAP_NEW(ns2__VideoResolution); }
      public:
        /// Constructor with initializations
        ns2__VideoResolution()
        {
          Width = (int)0;
          Height = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__VideoResolution() { }
        /// Friend allocator used by soap_new_ns2__VideoResolution(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoResolution * SOAP_FMAC2 soap_instantiate_ns2__VideoResolution(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:919 */
#ifndef SOAP_TYPE_ns2__VideoRateControl
#define SOAP_TYPE_ns2__VideoRateControl (457)
/* complex XSD type 'ns2:VideoRateControl': */
class SOAP_CMAC ns2__VideoRateControl {
      public:
        /// Required element 'ns2:FrameRateLimit' of XSD type 'xsd:int'
        int FrameRateLimit;
        /// Required element 'ns2:EncodingInterval' of XSD type 'xsd:int'
        int EncodingInterval;
        /// Required element 'ns2:BitrateLimit' of XSD type 'xsd:int'
        int BitrateLimit;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoRateControl
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoRateControl; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoRateControl, default initialized and not managed by a soap context
        virtual ns2__VideoRateControl *soap_alloc(void) const { return SOAP_NEW(ns2__VideoRateControl); }
      public:
        /// Constructor with initializations
        ns2__VideoRateControl()
        {
          FrameRateLimit = (int)0;
          EncodingInterval = (int)0;
          BitrateLimit = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__VideoRateControl() { }
        /// Friend allocator used by soap_new_ns2__VideoRateControl(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoRateControl * SOAP_FMAC2 soap_instantiate_ns2__VideoRateControl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:922 */
#ifndef SOAP_TYPE_ns2__Mpeg4Configuration
#define SOAP_TYPE_ns2__Mpeg4Configuration (458)
/* complex XSD type 'ns2:Mpeg4Configuration': */
class SOAP_CMAC ns2__Mpeg4Configuration {
      public:
        /// Required element 'ns2:GovLength' of XSD type 'xsd:int'
        int GovLength;
        /// Required element 'ns2:Mpeg4Profile' of XSD type 'ns2:Mpeg4Profile'
        ns2__Mpeg4Profile Mpeg4Profile;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Mpeg4Configuration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Mpeg4Configuration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Mpeg4Configuration, default initialized and not managed by a soap context
        virtual ns2__Mpeg4Configuration *soap_alloc(void) const { return SOAP_NEW(ns2__Mpeg4Configuration); }
      public:
        /// Constructor with initializations
        ns2__Mpeg4Configuration()
        {
          GovLength = (int)0;
          Mpeg4Profile = (ns2__Mpeg4Profile)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Mpeg4Configuration() { }
        /// Friend allocator used by soap_new_ns2__Mpeg4Configuration(struct soap*, int)
        friend SOAP_FMAC1 ns2__Mpeg4Configuration * SOAP_FMAC2 soap_instantiate_ns2__Mpeg4Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:925 */
#ifndef SOAP_TYPE_ns2__H264Configuration
#define SOAP_TYPE_ns2__H264Configuration (459)
/* complex XSD type 'ns2:H264Configuration': */
class SOAP_CMAC ns2__H264Configuration {
      public:
        /// Required element 'ns2:GovLength' of XSD type 'xsd:int'
        int GovLength;
        /// Required element 'ns2:H264Profile' of XSD type 'ns2:H264Profile'
        ns2__H264Profile H264Profile;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__H264Configuration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__H264Configuration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__H264Configuration, default initialized and not managed by a soap context
        virtual ns2__H264Configuration *soap_alloc(void) const { return SOAP_NEW(ns2__H264Configuration); }
      public:
        /// Constructor with initializations
        ns2__H264Configuration()
        {
          GovLength = (int)0;
          H264Profile = (ns2__H264Profile)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__H264Configuration() { }
        /// Friend allocator used by soap_new_ns2__H264Configuration(struct soap*, int)
        friend SOAP_FMAC1 ns2__H264Configuration * SOAP_FMAC2 soap_instantiate_ns2__H264Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:928 */
#ifndef SOAP_TYPE_ns2__VideoEncoderConfigurationOptions
#define SOAP_TYPE_ns2__VideoEncoderConfigurationOptions (460)
/* complex XSD type 'ns2:VideoEncoderConfigurationOptions': */
class SOAP_CMAC ns2__VideoEncoderConfigurationOptions {
      public:
        /// Required element 'ns2:QualityRange' of XSD type 'ns2:IntRange'
        ns2__IntRange *QualityRange;
        /// Optional element 'ns2:JPEG' of XSD type 'ns2:JpegOptions'
        ns2__JpegOptions *JPEG;
        /// Optional element 'ns2:MPEG4' of XSD type 'ns2:Mpeg4Options'
        ns2__Mpeg4Options *MPEG4;
        /// Optional element 'ns2:H264' of XSD type 'ns2:H264Options'
        ns2__H264Options *H264;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:VideoEncoderOptionsExtension'
        ns2__VideoEncoderOptionsExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoEncoderConfigurationOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoEncoderConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoEncoderConfigurationOptions, default initialized and not managed by a soap context
        virtual ns2__VideoEncoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(ns2__VideoEncoderConfigurationOptions); }
      public:
        /// Constructor with initializations
        ns2__VideoEncoderConfigurationOptions()
        {
          QualityRange = (ns2__IntRange *)0;
          JPEG = (ns2__JpegOptions *)0;
          MPEG4 = (ns2__Mpeg4Options *)0;
          H264 = (ns2__H264Options *)0;
          Extension = (ns2__VideoEncoderOptionsExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__VideoEncoderConfigurationOptions() { }
        /// Friend allocator used by soap_new_ns2__VideoEncoderConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_ns2__VideoEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:931 */
#ifndef SOAP_TYPE_ns2__VideoEncoderOptionsExtension
#define SOAP_TYPE_ns2__VideoEncoderOptionsExtension (461)
/* complex XSD type 'ns2:VideoEncoderOptionsExtension': */
class SOAP_CMAC ns2__VideoEncoderOptionsExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional element 'ns2:JPEG' of XSD type 'ns2:JpegOptions2'
        ns2__JpegOptions2 *JPEG;
        /// Optional element 'ns2:MPEG4' of XSD type 'ns2:Mpeg4Options2'
        ns2__Mpeg4Options2 *MPEG4;
        /// Optional element 'ns2:H264' of XSD type 'ns2:H264Options2'
        ns2__H264Options2 *H264;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:VideoEncoderOptionsExtension2'
        ns2__VideoEncoderOptionsExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoEncoderOptionsExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoEncoderOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoEncoderOptionsExtension, default initialized and not managed by a soap context
        virtual ns2__VideoEncoderOptionsExtension *soap_alloc(void) const { return SOAP_NEW(ns2__VideoEncoderOptionsExtension); }
      public:
        /// Constructor with initializations
        ns2__VideoEncoderOptionsExtension()
        {
          JPEG = (ns2__JpegOptions2 *)0;
          MPEG4 = (ns2__Mpeg4Options2 *)0;
          H264 = (ns2__H264Options2 *)0;
          Extension = (ns2__VideoEncoderOptionsExtension2 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__VideoEncoderOptionsExtension() { }
        /// Friend allocator used by soap_new_ns2__VideoEncoderOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoEncoderOptionsExtension * SOAP_FMAC2 soap_instantiate_ns2__VideoEncoderOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:934 */
#ifndef SOAP_TYPE_ns2__VideoEncoderOptionsExtension2
#define SOAP_TYPE_ns2__VideoEncoderOptionsExtension2 (462)
/* complex XSD type 'ns2:VideoEncoderOptionsExtension2': */
class SOAP_CMAC ns2__VideoEncoderOptionsExtension2 {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoEncoderOptionsExtension2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoEncoderOptionsExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoEncoderOptionsExtension2, default initialized and not managed by a soap context
        virtual ns2__VideoEncoderOptionsExtension2 *soap_alloc(void) const { return SOAP_NEW(ns2__VideoEncoderOptionsExtension2); }
      public:
        /// Constructor with initializations
        ns2__VideoEncoderOptionsExtension2()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__VideoEncoderOptionsExtension2() { }
        /// Friend allocator used by soap_new_ns2__VideoEncoderOptionsExtension2(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoEncoderOptionsExtension2 * SOAP_FMAC2 soap_instantiate_ns2__VideoEncoderOptionsExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:937 */
#ifndef SOAP_TYPE_ns2__JpegOptions
#define SOAP_TYPE_ns2__JpegOptions (463)
/* Type ns2__JpegOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:JpegOptions': */
class SOAP_CMAC ns2__JpegOptions {
      public:
        /// Required element 'ns2:ResolutionsAvailable' of XSD type 'ns2:VideoResolution'
        std::vector<ns2__VideoResolution *> ResolutionsAvailable;
        /// Required element 'ns2:FrameRateRange' of XSD type 'ns2:IntRange'
        ns2__IntRange *FrameRateRange;
        /// Required element 'ns2:EncodingIntervalRange' of XSD type 'ns2:IntRange'
        ns2__IntRange *EncodingIntervalRange;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__JpegOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__JpegOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__JpegOptions, default initialized and not managed by a soap context
        virtual ns2__JpegOptions *soap_alloc(void) const { return SOAP_NEW(ns2__JpegOptions); }
      public:
        /// Constructor with initializations
        ns2__JpegOptions()
        {
          FrameRateRange = (ns2__IntRange *)0;
          EncodingIntervalRange = (ns2__IntRange *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__JpegOptions() { }
        /// Friend allocator used by soap_new_ns2__JpegOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__JpegOptions * SOAP_FMAC2 soap_instantiate_ns2__JpegOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:943 */
#ifndef SOAP_TYPE_ns2__Mpeg4Options
#define SOAP_TYPE_ns2__Mpeg4Options (465)
/* Type ns2__Mpeg4Options is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:Mpeg4Options': */
class SOAP_CMAC ns2__Mpeg4Options {
      public:
        /// Required element 'ns2:ResolutionsAvailable' of XSD type 'ns2:VideoResolution'
        std::vector<ns2__VideoResolution *> ResolutionsAvailable;
        /// Required element 'ns2:GovLengthRange' of XSD type 'ns2:IntRange'
        ns2__IntRange *GovLengthRange;
        /// Required element 'ns2:FrameRateRange' of XSD type 'ns2:IntRange'
        ns2__IntRange *FrameRateRange;
        /// Required element 'ns2:EncodingIntervalRange' of XSD type 'ns2:IntRange'
        ns2__IntRange *EncodingIntervalRange;
        /// Required element 'ns2:Mpeg4ProfilesSupported' of XSD type 'ns2:Mpeg4Profile'
        std::vector<ns2__Mpeg4Profile> Mpeg4ProfilesSupported;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Mpeg4Options
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Mpeg4Options; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Mpeg4Options, default initialized and not managed by a soap context
        virtual ns2__Mpeg4Options *soap_alloc(void) const { return SOAP_NEW(ns2__Mpeg4Options); }
      public:
        /// Constructor with initializations
        ns2__Mpeg4Options()
        {
          GovLengthRange = (ns2__IntRange *)0;
          FrameRateRange = (ns2__IntRange *)0;
          EncodingIntervalRange = (ns2__IntRange *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Mpeg4Options() { }
        /// Friend allocator used by soap_new_ns2__Mpeg4Options(struct soap*, int)
        friend SOAP_FMAC1 ns2__Mpeg4Options * SOAP_FMAC2 soap_instantiate_ns2__Mpeg4Options(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:949 */
#ifndef SOAP_TYPE_ns2__H264Options
#define SOAP_TYPE_ns2__H264Options (467)
/* Type ns2__H264Options is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:H264Options': */
class SOAP_CMAC ns2__H264Options {
      public:
        /// Required element 'ns2:ResolutionsAvailable' of XSD type 'ns2:VideoResolution'
        std::vector<ns2__VideoResolution *> ResolutionsAvailable;
        /// Required element 'ns2:GovLengthRange' of XSD type 'ns2:IntRange'
        ns2__IntRange *GovLengthRange;
        /// Required element 'ns2:FrameRateRange' of XSD type 'ns2:IntRange'
        ns2__IntRange *FrameRateRange;
        /// Required element 'ns2:EncodingIntervalRange' of XSD type 'ns2:IntRange'
        ns2__IntRange *EncodingIntervalRange;
        /// Required element 'ns2:H264ProfilesSupported' of XSD type 'ns2:H264Profile'
        std::vector<ns2__H264Profile> H264ProfilesSupported;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__H264Options
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__H264Options; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__H264Options, default initialized and not managed by a soap context
        virtual ns2__H264Options *soap_alloc(void) const { return SOAP_NEW(ns2__H264Options); }
      public:
        /// Constructor with initializations
        ns2__H264Options()
        {
          GovLengthRange = (ns2__IntRange *)0;
          FrameRateRange = (ns2__IntRange *)0;
          EncodingIntervalRange = (ns2__IntRange *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__H264Options() { }
        /// Friend allocator used by soap_new_ns2__H264Options(struct soap*, int)
        friend SOAP_FMAC1 ns2__H264Options * SOAP_FMAC2 soap_instantiate_ns2__H264Options(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:958 */
#ifndef SOAP_TYPE_ns2__VideoResolution2
#define SOAP_TYPE_ns2__VideoResolution2 (470)
/* complex XSD type 'ns2:VideoResolution2': */
class SOAP_CMAC ns2__VideoResolution2 {
      public:
        /// Required element 'ns2:Width' of XSD type 'xsd:int'
        int Width;
        /// Required element 'ns2:Height' of XSD type 'xsd:int'
        int Height;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoResolution2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoResolution2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoResolution2, default initialized and not managed by a soap context
        virtual ns2__VideoResolution2 *soap_alloc(void) const { return SOAP_NEW(ns2__VideoResolution2); }
      public:
        /// Constructor with initializations
        ns2__VideoResolution2()
        {
          Width = (int)0;
          Height = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__VideoResolution2() { }
        /// Friend allocator used by soap_new_ns2__VideoResolution2(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoResolution2 * SOAP_FMAC2 soap_instantiate_ns2__VideoResolution2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:961 */
#ifndef SOAP_TYPE_ns2__VideoRateControl2
#define SOAP_TYPE_ns2__VideoRateControl2 (471)
/* complex XSD type 'ns2:VideoRateControl2': */
class SOAP_CMAC ns2__VideoRateControl2 {
      public:
        /// Required element 'ns2:FrameRateLimit' of XSD type 'xsd:float'
        float FrameRateLimit;
        /// Required element 'ns2:BitrateLimit' of XSD type 'xsd:int'
        int BitrateLimit;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// optional attribute 'ConstantBitRate' of XSD type 'xsd:boolean'
        bool *ConstantBitRate;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoRateControl2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoRateControl2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoRateControl2, default initialized and not managed by a soap context
        virtual ns2__VideoRateControl2 *soap_alloc(void) const { return SOAP_NEW(ns2__VideoRateControl2); }
      public:
        /// Constructor with initializations
        ns2__VideoRateControl2()
        {
          FrameRateLimit = (float)0;
          BitrateLimit = (int)0;
          ConstantBitRate = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__VideoRateControl2() { }
        /// Friend allocator used by soap_new_ns2__VideoRateControl2(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoRateControl2 * SOAP_FMAC2 soap_instantiate_ns2__VideoRateControl2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:964 */
#ifndef SOAP_TYPE_ns2__VideoEncoder2ConfigurationOptions
#define SOAP_TYPE_ns2__VideoEncoder2ConfigurationOptions (472)
/* complex XSD type 'ns2:VideoEncoder2ConfigurationOptions': */
class SOAP_CMAC ns2__VideoEncoder2ConfigurationOptions {
      public:
        /// Required element 'ns2:Encoding' of XSD type 'xsd:string'
        std::string Encoding;
        /// Required element 'ns2:QualityRange' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *QualityRange;
        /// Required element 'ns2:ResolutionsAvailable' of XSD type 'ns2:VideoResolution2'
        std::vector<ns2__VideoResolution2 *> ResolutionsAvailable;
        /// Required element 'ns2:BitrateRange' of XSD type 'ns2:IntRange'
        ns2__IntRange *BitrateRange;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// optional attribute 'GovLengthRange' of XSD type 'ns2:IntAttrList'
        std::string *GovLengthRange;
        /// optional attribute 'FrameRatesSupported' of XSD type 'ns2:FloatAttrList'
        std::string *FrameRatesSupported;
        /// optional attribute 'ProfilesSupported' of XSD type 'ns2:StringAttrList'
        std::string *ProfilesSupported;
        /// optional attribute 'ConstantBitRateSupported' of XSD type 'xsd:boolean'
        bool *ConstantBitRateSupported;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoEncoder2ConfigurationOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoEncoder2ConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoEncoder2ConfigurationOptions, default initialized and not managed by a soap context
        virtual ns2__VideoEncoder2ConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(ns2__VideoEncoder2ConfigurationOptions); }
      public:
        /// Constructor with initializations
        ns2__VideoEncoder2ConfigurationOptions()
        {
          QualityRange = (ns2__FloatRange *)0;
          BitrateRange = (ns2__IntRange *)0;
          GovLengthRange = (std::string *)0;
          FrameRatesSupported = (std::string *)0;
          ProfilesSupported = (std::string *)0;
          ConstantBitRateSupported = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__VideoEncoder2ConfigurationOptions() { }
        /// Friend allocator used by soap_new_ns2__VideoEncoder2ConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoEncoder2ConfigurationOptions * SOAP_FMAC2 soap_instantiate_ns2__VideoEncoder2ConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:970 */
#ifndef SOAP_TYPE_ns2__AudioSourceConfigurationOptions
#define SOAP_TYPE_ns2__AudioSourceConfigurationOptions (474)
/* complex XSD type 'ns2:AudioSourceConfigurationOptions': */
class SOAP_CMAC ns2__AudioSourceConfigurationOptions {
      public:
        /// Required element 'ns2:InputTokensAvailable' of XSD type 'ns2:ReferenceToken'
        std::vector<std::string> InputTokensAvailable;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:AudioSourceOptionsExtension'
        ns2__AudioSourceOptionsExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AudioSourceConfigurationOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AudioSourceConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AudioSourceConfigurationOptions, default initialized and not managed by a soap context
        virtual ns2__AudioSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(ns2__AudioSourceConfigurationOptions); }
      public:
        /// Constructor with initializations
        ns2__AudioSourceConfigurationOptions()
        {
          Extension = (ns2__AudioSourceOptionsExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AudioSourceConfigurationOptions() { }
        /// Friend allocator used by soap_new_ns2__AudioSourceConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__AudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate_ns2__AudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:973 */
#ifndef SOAP_TYPE_ns2__AudioSourceOptionsExtension
#define SOAP_TYPE_ns2__AudioSourceOptionsExtension (475)
/* complex XSD type 'ns2:AudioSourceOptionsExtension': */
class SOAP_CMAC ns2__AudioSourceOptionsExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AudioSourceOptionsExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AudioSourceOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AudioSourceOptionsExtension, default initialized and not managed by a soap context
        virtual ns2__AudioSourceOptionsExtension *soap_alloc(void) const { return SOAP_NEW(ns2__AudioSourceOptionsExtension); }
      public:
        /// Constructor with initializations
        ns2__AudioSourceOptionsExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__AudioSourceOptionsExtension() { }
        /// Friend allocator used by soap_new_ns2__AudioSourceOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__AudioSourceOptionsExtension * SOAP_FMAC2 soap_instantiate_ns2__AudioSourceOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:979 */
#ifndef SOAP_TYPE_ns2__AudioEncoderConfigurationOptions
#define SOAP_TYPE_ns2__AudioEncoderConfigurationOptions (477)
/* complex XSD type 'ns2:AudioEncoderConfigurationOptions': */
class SOAP_CMAC ns2__AudioEncoderConfigurationOptions {
      public:
        /// Optional element 'ns2:Options' of XSD type 'ns2:AudioEncoderConfigurationOption'
        std::vector<ns2__AudioEncoderConfigurationOption *> Options;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AudioEncoderConfigurationOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AudioEncoderConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AudioEncoderConfigurationOptions, default initialized and not managed by a soap context
        virtual ns2__AudioEncoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(ns2__AudioEncoderConfigurationOptions); }
      public:
        /// Constructor with initializations
        ns2__AudioEncoderConfigurationOptions()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__AudioEncoderConfigurationOptions() { }
        /// Friend allocator used by soap_new_ns2__AudioEncoderConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__AudioEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_ns2__AudioEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:982 */
#ifndef SOAP_TYPE_ns2__AudioEncoderConfigurationOption
#define SOAP_TYPE_ns2__AudioEncoderConfigurationOption (478)
/* complex XSD type 'ns2:AudioEncoderConfigurationOption': */
class SOAP_CMAC ns2__AudioEncoderConfigurationOption {
      public:
        /// Required element 'ns2:Encoding' of XSD type 'ns2:AudioEncoding'
        ns2__AudioEncoding Encoding;
        /// Required element 'ns2:BitrateList' of XSD type 'ns2:IntList'
        ns2__IntList *BitrateList;
        /// Required element 'ns2:SampleRateList' of XSD type 'ns2:IntList'
        ns2__IntList *SampleRateList;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AudioEncoderConfigurationOption
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AudioEncoderConfigurationOption; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AudioEncoderConfigurationOption, default initialized and not managed by a soap context
        virtual ns2__AudioEncoderConfigurationOption *soap_alloc(void) const { return SOAP_NEW(ns2__AudioEncoderConfigurationOption); }
      public:
        /// Constructor with initializations
        ns2__AudioEncoderConfigurationOption()
        {
          Encoding = (ns2__AudioEncoding)0;
          BitrateList = (ns2__IntList *)0;
          SampleRateList = (ns2__IntList *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AudioEncoderConfigurationOption() { }
        /// Friend allocator used by soap_new_ns2__AudioEncoderConfigurationOption(struct soap*, int)
        friend SOAP_FMAC1 ns2__AudioEncoderConfigurationOption * SOAP_FMAC2 soap_instantiate_ns2__AudioEncoderConfigurationOption(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:988 */
#ifndef SOAP_TYPE_ns2__AudioEncoder2ConfigurationOptions
#define SOAP_TYPE_ns2__AudioEncoder2ConfigurationOptions (480)
/* complex XSD type 'ns2:AudioEncoder2ConfigurationOptions': */
class SOAP_CMAC ns2__AudioEncoder2ConfigurationOptions {
      public:
        /// Required element 'ns2:Encoding' of XSD type 'xsd:string'
        std::string Encoding;
        /// Required element 'ns2:BitrateList' of XSD type 'ns2:IntList'
        ns2__IntList *BitrateList;
        /// Required element 'ns2:SampleRateList' of XSD type 'ns2:IntList'
        ns2__IntList *SampleRateList;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AudioEncoder2ConfigurationOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AudioEncoder2ConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AudioEncoder2ConfigurationOptions, default initialized and not managed by a soap context
        virtual ns2__AudioEncoder2ConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(ns2__AudioEncoder2ConfigurationOptions); }
      public:
        /// Constructor with initializations
        ns2__AudioEncoder2ConfigurationOptions()
        {
          BitrateList = (ns2__IntList *)0;
          SampleRateList = (ns2__IntList *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AudioEncoder2ConfigurationOptions() { }
        /// Friend allocator used by soap_new_ns2__AudioEncoder2ConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__AudioEncoder2ConfigurationOptions * SOAP_FMAC2 soap_instantiate_ns2__AudioEncoder2ConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:997 */
#ifndef SOAP_TYPE_ns2__MetadataConfigurationExtension
#define SOAP_TYPE_ns2__MetadataConfigurationExtension (483)
/* complex XSD type 'ns2:MetadataConfigurationExtension': */
class SOAP_CMAC ns2__MetadataConfigurationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MetadataConfigurationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MetadataConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MetadataConfigurationExtension, default initialized and not managed by a soap context
        virtual ns2__MetadataConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__MetadataConfigurationExtension); }
      public:
        /// Constructor with initializations
        ns2__MetadataConfigurationExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__MetadataConfigurationExtension() { }
        /// Friend allocator used by soap_new_ns2__MetadataConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__MetadataConfigurationExtension * SOAP_FMAC2 soap_instantiate_ns2__MetadataConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1000 */
#ifndef SOAP_TYPE_ns2__PTZFilter
#define SOAP_TYPE_ns2__PTZFilter (484)
/* complex XSD type 'ns2:PTZFilter': */
class SOAP_CMAC ns2__PTZFilter {
      public:
        /// Required element 'ns2:Status' of XSD type 'xsd:boolean'
        bool Status;
        /// Required element 'ns2:Position' of XSD type 'xsd:boolean'
        bool Position;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZFilter
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZFilter, default initialized and not managed by a soap context
        virtual ns2__PTZFilter *soap_alloc(void) const { return SOAP_NEW(ns2__PTZFilter); }
      public:
        /// Constructor with initializations
        ns2__PTZFilter()
        {
          Status = (bool)0;
          Position = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZFilter() { }
        /// Friend allocator used by soap_new_ns2__PTZFilter(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZFilter * SOAP_FMAC2 soap_instantiate_ns2__PTZFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:10984 */
#ifndef SOAP_TYPE__ns2__EventSubscription_SubscriptionPolicy
#define SOAP_TYPE__ns2__EventSubscription_SubscriptionPolicy (1613)
/* complex XSD type 'ns2:EventSubscription-SubscriptionPolicy': */
class SOAP_CMAC _ns2__EventSubscription_SubscriptionPolicy {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
      public:
        /// Return unique type id SOAP_TYPE__ns2__EventSubscription_SubscriptionPolicy
        virtual int soap_type(void) const { return SOAP_TYPE__ns2__EventSubscription_SubscriptionPolicy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__EventSubscription_SubscriptionPolicy, default initialized and not managed by a soap context
        virtual _ns2__EventSubscription_SubscriptionPolicy *soap_alloc(void) const { return SOAP_NEW(_ns2__EventSubscription_SubscriptionPolicy); }
      public:
        /// Constructor with initializations
        _ns2__EventSubscription_SubscriptionPolicy()
        {
        }
        virtual ~_ns2__EventSubscription_SubscriptionPolicy() { }
        /// Friend allocator used by soap_new__ns2__EventSubscription_SubscriptionPolicy(struct soap*, int)
        friend SOAP_FMAC1 _ns2__EventSubscription_SubscriptionPolicy * SOAP_FMAC2 soap_instantiate__ns2__EventSubscription_SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1003 */
#ifndef SOAP_TYPE_ns2__EventSubscription
#define SOAP_TYPE_ns2__EventSubscription (485)
/* complex XSD type 'ns2:EventSubscription': */
class SOAP_CMAC ns2__EventSubscription {
      public:
        /// Optional element 'ns2:Filter' of XSD type 'ns3:FilterType'
        ns3__FilterType *Filter;
        /// Optional element 'ns2:SubscriptionPolicy' of XSD type 'ns2:EventSubscription-SubscriptionPolicy'
        _ns2__EventSubscription_SubscriptionPolicy *SubscriptionPolicy;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__EventSubscription
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__EventSubscription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__EventSubscription, default initialized and not managed by a soap context
        virtual ns2__EventSubscription *soap_alloc(void) const { return SOAP_NEW(ns2__EventSubscription); }
      public:
        /// Constructor with initializations
        ns2__EventSubscription()
        {
          Filter = (ns3__FilterType *)0;
          SubscriptionPolicy = (_ns2__EventSubscription_SubscriptionPolicy *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__EventSubscription() { }
        /// Friend allocator used by soap_new_ns2__EventSubscription(struct soap*, int)
        friend SOAP_FMAC1 ns2__EventSubscription * SOAP_FMAC2 soap_instantiate_ns2__EventSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1006 */
#ifndef SOAP_TYPE_ns2__MetadataConfigurationOptions
#define SOAP_TYPE_ns2__MetadataConfigurationOptions (486)
/* complex XSD type 'ns2:MetadataConfigurationOptions': */
class SOAP_CMAC ns2__MetadataConfigurationOptions {
      public:
        /// Required element 'ns2:PTZStatusFilterOptions' of XSD type 'ns2:PTZStatusFilterOptions'
        ns2__PTZStatusFilterOptions *PTZStatusFilterOptions;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:MetadataConfigurationOptionsExtension'
        ns2__MetadataConfigurationOptionsExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MetadataConfigurationOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MetadataConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MetadataConfigurationOptions, default initialized and not managed by a soap context
        virtual ns2__MetadataConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(ns2__MetadataConfigurationOptions); }
      public:
        /// Constructor with initializations
        ns2__MetadataConfigurationOptions()
        {
          PTZStatusFilterOptions = (ns2__PTZStatusFilterOptions *)0;
          Extension = (ns2__MetadataConfigurationOptionsExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__MetadataConfigurationOptions() { }
        /// Friend allocator used by soap_new_ns2__MetadataConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__MetadataConfigurationOptions * SOAP_FMAC2 soap_instantiate_ns2__MetadataConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1009 */
#ifndef SOAP_TYPE_ns2__MetadataConfigurationOptionsExtension
#define SOAP_TYPE_ns2__MetadataConfigurationOptionsExtension (487)
/* complex XSD type 'ns2:MetadataConfigurationOptionsExtension': */
class SOAP_CMAC ns2__MetadataConfigurationOptionsExtension {
      public:
        /// Optional element 'ns2:CompressionType' of XSD type 'xsd:string'
        std::vector<std::string> CompressionType;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:MetadataConfigurationOptionsExtension2'
        ns2__MetadataConfigurationOptionsExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MetadataConfigurationOptionsExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MetadataConfigurationOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MetadataConfigurationOptionsExtension, default initialized and not managed by a soap context
        virtual ns2__MetadataConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(ns2__MetadataConfigurationOptionsExtension); }
      public:
        /// Constructor with initializations
        ns2__MetadataConfigurationOptionsExtension()
        {
          Extension = (ns2__MetadataConfigurationOptionsExtension2 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__MetadataConfigurationOptionsExtension() { }
        /// Friend allocator used by soap_new_ns2__MetadataConfigurationOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__MetadataConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_ns2__MetadataConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1012 */
#ifndef SOAP_TYPE_ns2__MetadataConfigurationOptionsExtension2
#define SOAP_TYPE_ns2__MetadataConfigurationOptionsExtension2 (488)
/* complex XSD type 'ns2:MetadataConfigurationOptionsExtension2': */
class SOAP_CMAC ns2__MetadataConfigurationOptionsExtension2 {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MetadataConfigurationOptionsExtension2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MetadataConfigurationOptionsExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MetadataConfigurationOptionsExtension2, default initialized and not managed by a soap context
        virtual ns2__MetadataConfigurationOptionsExtension2 *soap_alloc(void) const { return SOAP_NEW(ns2__MetadataConfigurationOptionsExtension2); }
      public:
        /// Constructor with initializations
        ns2__MetadataConfigurationOptionsExtension2()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__MetadataConfigurationOptionsExtension2() { }
        /// Friend allocator used by soap_new_ns2__MetadataConfigurationOptionsExtension2(struct soap*, int)
        friend SOAP_FMAC1 ns2__MetadataConfigurationOptionsExtension2 * SOAP_FMAC2 soap_instantiate_ns2__MetadataConfigurationOptionsExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1015 */
#ifndef SOAP_TYPE_ns2__PTZStatusFilterOptions
#define SOAP_TYPE_ns2__PTZStatusFilterOptions (489)
/* complex XSD type 'ns2:PTZStatusFilterOptions': */
class SOAP_CMAC ns2__PTZStatusFilterOptions {
      public:
        /// Required element 'ns2:PanTiltStatusSupported' of XSD type 'xsd:boolean'
        bool PanTiltStatusSupported;
        /// Required element 'ns2:ZoomStatusSupported' of XSD type 'xsd:boolean'
        bool ZoomStatusSupported;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional element 'ns2:PanTiltPositionSupported' of XSD type 'xsd:boolean'
        bool *PanTiltPositionSupported;
        /// Optional element 'ns2:ZoomPositionSupported' of XSD type 'xsd:boolean'
        bool *ZoomPositionSupported;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:PTZStatusFilterOptionsExtension'
        ns2__PTZStatusFilterOptionsExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZStatusFilterOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZStatusFilterOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZStatusFilterOptions, default initialized and not managed by a soap context
        virtual ns2__PTZStatusFilterOptions *soap_alloc(void) const { return SOAP_NEW(ns2__PTZStatusFilterOptions); }
      public:
        /// Constructor with initializations
        ns2__PTZStatusFilterOptions()
        {
          PanTiltStatusSupported = (bool)0;
          ZoomStatusSupported = (bool)0;
          PanTiltPositionSupported = (bool *)0;
          ZoomPositionSupported = (bool *)0;
          Extension = (ns2__PTZStatusFilterOptionsExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZStatusFilterOptions() { }
        /// Friend allocator used by soap_new_ns2__PTZStatusFilterOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZStatusFilterOptions * SOAP_FMAC2 soap_instantiate_ns2__PTZStatusFilterOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1018 */
#ifndef SOAP_TYPE_ns2__PTZStatusFilterOptionsExtension
#define SOAP_TYPE_ns2__PTZStatusFilterOptionsExtension (490)
/* complex XSD type 'ns2:PTZStatusFilterOptionsExtension': */
class SOAP_CMAC ns2__PTZStatusFilterOptionsExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZStatusFilterOptionsExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZStatusFilterOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZStatusFilterOptionsExtension, default initialized and not managed by a soap context
        virtual ns2__PTZStatusFilterOptionsExtension *soap_alloc(void) const { return SOAP_NEW(ns2__PTZStatusFilterOptionsExtension); }
      public:
        /// Constructor with initializations
        ns2__PTZStatusFilterOptionsExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZStatusFilterOptionsExtension() { }
        /// Friend allocator used by soap_new_ns2__PTZStatusFilterOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZStatusFilterOptionsExtension * SOAP_FMAC2 soap_instantiate_ns2__PTZStatusFilterOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1024 */
#ifndef SOAP_TYPE_ns2__VideoOutputExtension
#define SOAP_TYPE_ns2__VideoOutputExtension (492)
/* complex XSD type 'ns2:VideoOutputExtension': */
class SOAP_CMAC ns2__VideoOutputExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoOutputExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoOutputExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoOutputExtension, default initialized and not managed by a soap context
        virtual ns2__VideoOutputExtension *soap_alloc(void) const { return SOAP_NEW(ns2__VideoOutputExtension); }
      public:
        /// Constructor with initializations
        ns2__VideoOutputExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__VideoOutputExtension() { }
        /// Friend allocator used by soap_new_ns2__VideoOutputExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoOutputExtension * SOAP_FMAC2 soap_instantiate_ns2__VideoOutputExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1030 */
#ifndef SOAP_TYPE_ns2__VideoOutputConfigurationOptions
#define SOAP_TYPE_ns2__VideoOutputConfigurationOptions (494)
/* complex XSD type 'ns2:VideoOutputConfigurationOptions': */
class SOAP_CMAC ns2__VideoOutputConfigurationOptions {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoOutputConfigurationOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoOutputConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoOutputConfigurationOptions, default initialized and not managed by a soap context
        virtual ns2__VideoOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(ns2__VideoOutputConfigurationOptions); }
      public:
        /// Constructor with initializations
        ns2__VideoOutputConfigurationOptions()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__VideoOutputConfigurationOptions() { }
        /// Friend allocator used by soap_new_ns2__VideoOutputConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate_ns2__VideoOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1033 */
#ifndef SOAP_TYPE_ns2__VideoDecoderConfigurationOptions
#define SOAP_TYPE_ns2__VideoDecoderConfigurationOptions (495)
/* complex XSD type 'ns2:VideoDecoderConfigurationOptions': */
class SOAP_CMAC ns2__VideoDecoderConfigurationOptions {
      public:
        /// Optional element 'ns2:JpegDecOptions' of XSD type 'ns2:JpegDecOptions'
        ns2__JpegDecOptions *JpegDecOptions;
        /// Optional element 'ns2:H264DecOptions' of XSD type 'ns2:H264DecOptions'
        ns2__H264DecOptions *H264DecOptions;
        /// Optional element 'ns2:Mpeg4DecOptions' of XSD type 'ns2:Mpeg4DecOptions'
        ns2__Mpeg4DecOptions *Mpeg4DecOptions;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:VideoDecoderConfigurationOptionsExtension'
        ns2__VideoDecoderConfigurationOptionsExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoDecoderConfigurationOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoDecoderConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoDecoderConfigurationOptions, default initialized and not managed by a soap context
        virtual ns2__VideoDecoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(ns2__VideoDecoderConfigurationOptions); }
      public:
        /// Constructor with initializations
        ns2__VideoDecoderConfigurationOptions()
        {
          JpegDecOptions = (ns2__JpegDecOptions *)0;
          H264DecOptions = (ns2__H264DecOptions *)0;
          Mpeg4DecOptions = (ns2__Mpeg4DecOptions *)0;
          Extension = (ns2__VideoDecoderConfigurationOptionsExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__VideoDecoderConfigurationOptions() { }
        /// Friend allocator used by soap_new_ns2__VideoDecoderConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoDecoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_ns2__VideoDecoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1036 */
#ifndef SOAP_TYPE_ns2__H264DecOptions
#define SOAP_TYPE_ns2__H264DecOptions (496)
/* complex XSD type 'ns2:H264DecOptions': */
class SOAP_CMAC ns2__H264DecOptions {
      public:
        /// Required element 'ns2:ResolutionsAvailable' of XSD type 'ns2:VideoResolution'
        std::vector<ns2__VideoResolution *> ResolutionsAvailable;
        /// Required element 'ns2:SupportedH264Profiles' of XSD type 'ns2:H264Profile'
        std::vector<ns2__H264Profile> SupportedH264Profiles;
        /// Required element 'ns2:SupportedInputBitrate' of XSD type 'ns2:IntRange'
        ns2__IntRange *SupportedInputBitrate;
        /// Required element 'ns2:SupportedFrameRate' of XSD type 'ns2:IntRange'
        ns2__IntRange *SupportedFrameRate;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__H264DecOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__H264DecOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__H264DecOptions, default initialized and not managed by a soap context
        virtual ns2__H264DecOptions *soap_alloc(void) const { return SOAP_NEW(ns2__H264DecOptions); }
      public:
        /// Constructor with initializations
        ns2__H264DecOptions()
        {
          SupportedInputBitrate = (ns2__IntRange *)0;
          SupportedFrameRate = (ns2__IntRange *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__H264DecOptions() { }
        /// Friend allocator used by soap_new_ns2__H264DecOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__H264DecOptions * SOAP_FMAC2 soap_instantiate_ns2__H264DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1039 */
#ifndef SOAP_TYPE_ns2__JpegDecOptions
#define SOAP_TYPE_ns2__JpegDecOptions (497)
/* complex XSD type 'ns2:JpegDecOptions': */
class SOAP_CMAC ns2__JpegDecOptions {
      public:
        /// Required element 'ns2:ResolutionsAvailable' of XSD type 'ns2:VideoResolution'
        std::vector<ns2__VideoResolution *> ResolutionsAvailable;
        /// Required element 'ns2:SupportedInputBitrate' of XSD type 'ns2:IntRange'
        ns2__IntRange *SupportedInputBitrate;
        /// Required element 'ns2:SupportedFrameRate' of XSD type 'ns2:IntRange'
        ns2__IntRange *SupportedFrameRate;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__JpegDecOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__JpegDecOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__JpegDecOptions, default initialized and not managed by a soap context
        virtual ns2__JpegDecOptions *soap_alloc(void) const { return SOAP_NEW(ns2__JpegDecOptions); }
      public:
        /// Constructor with initializations
        ns2__JpegDecOptions()
        {
          SupportedInputBitrate = (ns2__IntRange *)0;
          SupportedFrameRate = (ns2__IntRange *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__JpegDecOptions() { }
        /// Friend allocator used by soap_new_ns2__JpegDecOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__JpegDecOptions * SOAP_FMAC2 soap_instantiate_ns2__JpegDecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1042 */
#ifndef SOAP_TYPE_ns2__Mpeg4DecOptions
#define SOAP_TYPE_ns2__Mpeg4DecOptions (498)
/* complex XSD type 'ns2:Mpeg4DecOptions': */
class SOAP_CMAC ns2__Mpeg4DecOptions {
      public:
        /// Required element 'ns2:ResolutionsAvailable' of XSD type 'ns2:VideoResolution'
        std::vector<ns2__VideoResolution *> ResolutionsAvailable;
        /// Required element 'ns2:SupportedMpeg4Profiles' of XSD type 'ns2:Mpeg4Profile'
        std::vector<ns2__Mpeg4Profile> SupportedMpeg4Profiles;
        /// Required element 'ns2:SupportedInputBitrate' of XSD type 'ns2:IntRange'
        ns2__IntRange *SupportedInputBitrate;
        /// Required element 'ns2:SupportedFrameRate' of XSD type 'ns2:IntRange'
        ns2__IntRange *SupportedFrameRate;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Mpeg4DecOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Mpeg4DecOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Mpeg4DecOptions, default initialized and not managed by a soap context
        virtual ns2__Mpeg4DecOptions *soap_alloc(void) const { return SOAP_NEW(ns2__Mpeg4DecOptions); }
      public:
        /// Constructor with initializations
        ns2__Mpeg4DecOptions()
        {
          SupportedInputBitrate = (ns2__IntRange *)0;
          SupportedFrameRate = (ns2__IntRange *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Mpeg4DecOptions() { }
        /// Friend allocator used by soap_new_ns2__Mpeg4DecOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__Mpeg4DecOptions * SOAP_FMAC2 soap_instantiate_ns2__Mpeg4DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1045 */
#ifndef SOAP_TYPE_ns2__VideoDecoderConfigurationOptionsExtension
#define SOAP_TYPE_ns2__VideoDecoderConfigurationOptionsExtension (499)
/* complex XSD type 'ns2:VideoDecoderConfigurationOptionsExtension': */
class SOAP_CMAC ns2__VideoDecoderConfigurationOptionsExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoDecoderConfigurationOptionsExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoDecoderConfigurationOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoDecoderConfigurationOptionsExtension, default initialized and not managed by a soap context
        virtual ns2__VideoDecoderConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(ns2__VideoDecoderConfigurationOptionsExtension); }
      public:
        /// Constructor with initializations
        ns2__VideoDecoderConfigurationOptionsExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__VideoDecoderConfigurationOptionsExtension() { }
        /// Friend allocator used by soap_new_ns2__VideoDecoderConfigurationOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoDecoderConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_ns2__VideoDecoderConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1054 */
#ifndef SOAP_TYPE_ns2__AudioOutputConfigurationOptions
#define SOAP_TYPE_ns2__AudioOutputConfigurationOptions (502)
/* complex XSD type 'ns2:AudioOutputConfigurationOptions': */
class SOAP_CMAC ns2__AudioOutputConfigurationOptions {
      public:
        /// Required element 'ns2:OutputTokensAvailable' of XSD type 'ns2:ReferenceToken'
        std::vector<std::string> OutputTokensAvailable;
        /// Optional element 'ns2:SendPrimacyOptions' of XSD type 'xsd:anyURI'
        std::vector<std::string> SendPrimacyOptions;
        /// Required element 'ns2:OutputLevelRange' of XSD type 'ns2:IntRange'
        ns2__IntRange *OutputLevelRange;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AudioOutputConfigurationOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AudioOutputConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AudioOutputConfigurationOptions, default initialized and not managed by a soap context
        virtual ns2__AudioOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(ns2__AudioOutputConfigurationOptions); }
      public:
        /// Constructor with initializations
        ns2__AudioOutputConfigurationOptions()
        {
          OutputLevelRange = (ns2__IntRange *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AudioOutputConfigurationOptions() { }
        /// Friend allocator used by soap_new_ns2__AudioOutputConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__AudioOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate_ns2__AudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1060 */
#ifndef SOAP_TYPE_ns2__AudioDecoderConfigurationOptions
#define SOAP_TYPE_ns2__AudioDecoderConfigurationOptions (504)
/* complex XSD type 'ns2:AudioDecoderConfigurationOptions': */
class SOAP_CMAC ns2__AudioDecoderConfigurationOptions {
      public:
        /// Optional element 'ns2:AACDecOptions' of XSD type 'ns2:AACDecOptions'
        ns2__AACDecOptions *AACDecOptions;
        /// Optional element 'ns2:G711DecOptions' of XSD type 'ns2:G711DecOptions'
        ns2__G711DecOptions *G711DecOptions;
        /// Optional element 'ns2:G726DecOptions' of XSD type 'ns2:G726DecOptions'
        ns2__G726DecOptions *G726DecOptions;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:AudioDecoderConfigurationOptionsExtension'
        ns2__AudioDecoderConfigurationOptionsExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AudioDecoderConfigurationOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AudioDecoderConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AudioDecoderConfigurationOptions, default initialized and not managed by a soap context
        virtual ns2__AudioDecoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(ns2__AudioDecoderConfigurationOptions); }
      public:
        /// Constructor with initializations
        ns2__AudioDecoderConfigurationOptions()
        {
          AACDecOptions = (ns2__AACDecOptions *)0;
          G711DecOptions = (ns2__G711DecOptions *)0;
          G726DecOptions = (ns2__G726DecOptions *)0;
          Extension = (ns2__AudioDecoderConfigurationOptionsExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AudioDecoderConfigurationOptions() { }
        /// Friend allocator used by soap_new_ns2__AudioDecoderConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__AudioDecoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_ns2__AudioDecoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1063 */
#ifndef SOAP_TYPE_ns2__G711DecOptions
#define SOAP_TYPE_ns2__G711DecOptions (505)
/* complex XSD type 'ns2:G711DecOptions': */
class SOAP_CMAC ns2__G711DecOptions {
      public:
        /// Required element 'ns2:Bitrate' of XSD type 'ns2:IntList'
        ns2__IntList *Bitrate;
        /// Required element 'ns2:SampleRateRange' of XSD type 'ns2:IntList'
        ns2__IntList *SampleRateRange;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__G711DecOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__G711DecOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__G711DecOptions, default initialized and not managed by a soap context
        virtual ns2__G711DecOptions *soap_alloc(void) const { return SOAP_NEW(ns2__G711DecOptions); }
      public:
        /// Constructor with initializations
        ns2__G711DecOptions()
        {
          Bitrate = (ns2__IntList *)0;
          SampleRateRange = (ns2__IntList *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__G711DecOptions() { }
        /// Friend allocator used by soap_new_ns2__G711DecOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__G711DecOptions * SOAP_FMAC2 soap_instantiate_ns2__G711DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1066 */
#ifndef SOAP_TYPE_ns2__AACDecOptions
#define SOAP_TYPE_ns2__AACDecOptions (506)
/* complex XSD type 'ns2:AACDecOptions': */
class SOAP_CMAC ns2__AACDecOptions {
      public:
        /// Required element 'ns2:Bitrate' of XSD type 'ns2:IntList'
        ns2__IntList *Bitrate;
        /// Required element 'ns2:SampleRateRange' of XSD type 'ns2:IntList'
        ns2__IntList *SampleRateRange;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AACDecOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AACDecOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AACDecOptions, default initialized and not managed by a soap context
        virtual ns2__AACDecOptions *soap_alloc(void) const { return SOAP_NEW(ns2__AACDecOptions); }
      public:
        /// Constructor with initializations
        ns2__AACDecOptions()
        {
          Bitrate = (ns2__IntList *)0;
          SampleRateRange = (ns2__IntList *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AACDecOptions() { }
        /// Friend allocator used by soap_new_ns2__AACDecOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__AACDecOptions * SOAP_FMAC2 soap_instantiate_ns2__AACDecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1069 */
#ifndef SOAP_TYPE_ns2__G726DecOptions
#define SOAP_TYPE_ns2__G726DecOptions (507)
/* complex XSD type 'ns2:G726DecOptions': */
class SOAP_CMAC ns2__G726DecOptions {
      public:
        /// Required element 'ns2:Bitrate' of XSD type 'ns2:IntList'
        ns2__IntList *Bitrate;
        /// Required element 'ns2:SampleRateRange' of XSD type 'ns2:IntList'
        ns2__IntList *SampleRateRange;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__G726DecOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__G726DecOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__G726DecOptions, default initialized and not managed by a soap context
        virtual ns2__G726DecOptions *soap_alloc(void) const { return SOAP_NEW(ns2__G726DecOptions); }
      public:
        /// Constructor with initializations
        ns2__G726DecOptions()
        {
          Bitrate = (ns2__IntList *)0;
          SampleRateRange = (ns2__IntList *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__G726DecOptions() { }
        /// Friend allocator used by soap_new_ns2__G726DecOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__G726DecOptions * SOAP_FMAC2 soap_instantiate_ns2__G726DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1072 */
#ifndef SOAP_TYPE_ns2__AudioDecoderConfigurationOptionsExtension
#define SOAP_TYPE_ns2__AudioDecoderConfigurationOptionsExtension (508)
/* complex XSD type 'ns2:AudioDecoderConfigurationOptionsExtension': */
class SOAP_CMAC ns2__AudioDecoderConfigurationOptionsExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AudioDecoderConfigurationOptionsExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AudioDecoderConfigurationOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AudioDecoderConfigurationOptionsExtension, default initialized and not managed by a soap context
        virtual ns2__AudioDecoderConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(ns2__AudioDecoderConfigurationOptionsExtension); }
      public:
        /// Constructor with initializations
        ns2__AudioDecoderConfigurationOptionsExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__AudioDecoderConfigurationOptionsExtension() { }
        /// Friend allocator used by soap_new_ns2__AudioDecoderConfigurationOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__AudioDecoderConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_ns2__AudioDecoderConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1075 */
#ifndef SOAP_TYPE_ns2__MulticastConfiguration
#define SOAP_TYPE_ns2__MulticastConfiguration (509)
/* complex XSD type 'ns2:MulticastConfiguration': */
class SOAP_CMAC ns2__MulticastConfiguration {
      public:
        /// Required element 'ns2:Address' of XSD type 'ns2:IPAddress'
        ns2__IPAddress *Address;
        /// Required element 'ns2:Port' of XSD type 'xsd:int'
        int Port;
        /// Required element 'ns2:TTL' of XSD type 'xsd:int'
        int TTL;
        /// Required element 'ns2:AutoStart' of XSD type 'xsd:boolean'
        bool AutoStart;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MulticastConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MulticastConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MulticastConfiguration, default initialized and not managed by a soap context
        virtual ns2__MulticastConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__MulticastConfiguration); }
      public:
        /// Constructor with initializations
        ns2__MulticastConfiguration()
        {
          Address = (ns2__IPAddress *)0;
          Port = (int)0;
          TTL = (int)0;
          AutoStart = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__MulticastConfiguration() { }
        /// Friend allocator used by soap_new_ns2__MulticastConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__MulticastConfiguration * SOAP_FMAC2 soap_instantiate_ns2__MulticastConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1078 */
#ifndef SOAP_TYPE_ns2__StreamSetup
#define SOAP_TYPE_ns2__StreamSetup (510)
/* complex XSD type 'ns2:StreamSetup': */
class SOAP_CMAC ns2__StreamSetup {
      public:
        /// Required element 'ns2:Stream' of XSD type 'ns2:StreamType'
        ns2__StreamType Stream;
        /// Required element 'ns2:Transport' of XSD type 'ns2:Transport'
        ns2__Transport *Transport;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__StreamSetup
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__StreamSetup; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__StreamSetup, default initialized and not managed by a soap context
        virtual ns2__StreamSetup *soap_alloc(void) const { return SOAP_NEW(ns2__StreamSetup); }
      public:
        /// Constructor with initializations
        ns2__StreamSetup()
        {
          Stream = (ns2__StreamType)0;
          Transport = (ns2__Transport *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__StreamSetup() { }
        /// Friend allocator used by soap_new_ns2__StreamSetup(struct soap*, int)
        friend SOAP_FMAC1 ns2__StreamSetup * SOAP_FMAC2 soap_instantiate_ns2__StreamSetup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1081 */
#ifndef SOAP_TYPE_ns2__Transport
#define SOAP_TYPE_ns2__Transport (511)
/* Type ns2__Transport is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:Transport': */
class SOAP_CMAC ns2__Transport {
      public:
        /// Required element 'ns2:Protocol' of XSD type 'ns2:TransportProtocol'
        ns2__TransportProtocol Protocol;
        /// Optional element 'ns2:Tunnel' of XSD type 'ns2:Transport'
        ns2__Transport *Tunnel;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Transport
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Transport; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Transport, default initialized and not managed by a soap context
        virtual ns2__Transport *soap_alloc(void) const { return SOAP_NEW(ns2__Transport); }
      public:
        /// Constructor with initializations
        ns2__Transport()
        {
          Protocol = (ns2__TransportProtocol)0;
          Tunnel = (ns2__Transport *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Transport() { }
        /// Friend allocator used by soap_new_ns2__Transport(struct soap*, int)
        friend SOAP_FMAC1 ns2__Transport * SOAP_FMAC2 soap_instantiate_ns2__Transport(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1084 */
#ifndef SOAP_TYPE_ns2__MediaUri
#define SOAP_TYPE_ns2__MediaUri (512)
/* complex XSD type 'ns2:MediaUri': */
class SOAP_CMAC ns2__MediaUri {
      public:
        /// Required element 'ns2:Uri' of XSD type 'xsd:anyURI'
        std::string Uri;
        /// Required element 'ns2:InvalidAfterConnect' of XSD type 'xsd:boolean'
        bool InvalidAfterConnect;
        /// Required element 'ns2:InvalidAfterReboot' of XSD type 'xsd:boolean'
        bool InvalidAfterReboot;
        /// Required element 'ns2:Timeout' of XSD type 'xsd:duration'
        std::string Timeout;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MediaUri
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MediaUri; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MediaUri, default initialized and not managed by a soap context
        virtual ns2__MediaUri *soap_alloc(void) const { return SOAP_NEW(ns2__MediaUri); }
      public:
        /// Constructor with initializations
        ns2__MediaUri()
        {
          InvalidAfterConnect = (bool)0;
          InvalidAfterReboot = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__MediaUri() { }
        /// Friend allocator used by soap_new_ns2__MediaUri(struct soap*, int)
        friend SOAP_FMAC1 ns2__MediaUri * SOAP_FMAC2 soap_instantiate_ns2__MediaUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1087 */
#ifndef SOAP_TYPE_ns2__Scope
#define SOAP_TYPE_ns2__Scope (513)
/* complex XSD type 'ns2:Scope': */
class SOAP_CMAC ns2__Scope {
      public:
        /// Required element 'ns2:ScopeDef' of XSD type 'ns2:ScopeDefinition'
        ns2__ScopeDefinition ScopeDef;
        /// Required element 'ns2:ScopeItem' of XSD type 'xsd:anyURI'
        std::string ScopeItem;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Scope
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Scope; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Scope, default initialized and not managed by a soap context
        virtual ns2__Scope *soap_alloc(void) const { return SOAP_NEW(ns2__Scope); }
      public:
        /// Constructor with initializations
        ns2__Scope()
        {
          ScopeDef = (ns2__ScopeDefinition)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Scope() { }
        /// Friend allocator used by soap_new_ns2__Scope(struct soap*, int)
        friend SOAP_FMAC1 ns2__Scope * SOAP_FMAC2 soap_instantiate_ns2__Scope(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1093 */
#ifndef SOAP_TYPE_ns2__NetworkInterfaceExtension
#define SOAP_TYPE_ns2__NetworkInterfaceExtension (515)
/* complex XSD type 'ns2:NetworkInterfaceExtension': */
class SOAP_CMAC ns2__NetworkInterfaceExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Required element 'ns2:InterfaceType' of XSD type 'ns2:IANA-IfTypes'
        int InterfaceType;
        /// Optional element 'ns2:Dot3' of XSD type 'ns2:Dot3Configuration'
        std::vector<ns2__Dot3Configuration *> Dot3;
        /// Optional element 'ns2:Dot11' of XSD type 'ns2:Dot11Configuration'
        std::vector<ns2__Dot11Configuration *> Dot11;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:NetworkInterfaceExtension2'
        ns2__NetworkInterfaceExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NetworkInterfaceExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NetworkInterfaceExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NetworkInterfaceExtension, default initialized and not managed by a soap context
        virtual ns2__NetworkInterfaceExtension *soap_alloc(void) const { return SOAP_NEW(ns2__NetworkInterfaceExtension); }
      public:
        /// Constructor with initializations
        ns2__NetworkInterfaceExtension()
        {
          InterfaceType = (int)0;
          Extension = (ns2__NetworkInterfaceExtension2 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__NetworkInterfaceExtension() { }
        /// Friend allocator used by soap_new_ns2__NetworkInterfaceExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__NetworkInterfaceExtension * SOAP_FMAC2 soap_instantiate_ns2__NetworkInterfaceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1096 */
#ifndef SOAP_TYPE_ns2__Dot3Configuration
#define SOAP_TYPE_ns2__Dot3Configuration (516)
/* complex XSD type 'ns2:Dot3Configuration': */
class SOAP_CMAC ns2__Dot3Configuration {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Dot3Configuration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Dot3Configuration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Dot3Configuration, default initialized and not managed by a soap context
        virtual ns2__Dot3Configuration *soap_alloc(void) const { return SOAP_NEW(ns2__Dot3Configuration); }
      public:
        /// Constructor with initializations
        ns2__Dot3Configuration()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__Dot3Configuration() { }
        /// Friend allocator used by soap_new_ns2__Dot3Configuration(struct soap*, int)
        friend SOAP_FMAC1 ns2__Dot3Configuration * SOAP_FMAC2 soap_instantiate_ns2__Dot3Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1099 */
#ifndef SOAP_TYPE_ns2__NetworkInterfaceExtension2
#define SOAP_TYPE_ns2__NetworkInterfaceExtension2 (517)
/* complex XSD type 'ns2:NetworkInterfaceExtension2': */
class SOAP_CMAC ns2__NetworkInterfaceExtension2 {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NetworkInterfaceExtension2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NetworkInterfaceExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NetworkInterfaceExtension2, default initialized and not managed by a soap context
        virtual ns2__NetworkInterfaceExtension2 *soap_alloc(void) const { return SOAP_NEW(ns2__NetworkInterfaceExtension2); }
      public:
        /// Constructor with initializations
        ns2__NetworkInterfaceExtension2()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__NetworkInterfaceExtension2() { }
        /// Friend allocator used by soap_new_ns2__NetworkInterfaceExtension2(struct soap*, int)
        friend SOAP_FMAC1 ns2__NetworkInterfaceExtension2 * SOAP_FMAC2 soap_instantiate_ns2__NetworkInterfaceExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1102 */
#ifndef SOAP_TYPE_ns2__NetworkInterfaceLink
#define SOAP_TYPE_ns2__NetworkInterfaceLink (518)
/* complex XSD type 'ns2:NetworkInterfaceLink': */
class SOAP_CMAC ns2__NetworkInterfaceLink {
      public:
        /// Required element 'ns2:AdminSettings' of XSD type 'ns2:NetworkInterfaceConnectionSetting'
        ns2__NetworkInterfaceConnectionSetting *AdminSettings;
        /// Required element 'ns2:OperSettings' of XSD type 'ns2:NetworkInterfaceConnectionSetting'
        ns2__NetworkInterfaceConnectionSetting *OperSettings;
        /// Required element 'ns2:InterfaceType' of XSD type 'ns2:IANA-IfTypes'
        int InterfaceType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NetworkInterfaceLink
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NetworkInterfaceLink; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NetworkInterfaceLink, default initialized and not managed by a soap context
        virtual ns2__NetworkInterfaceLink *soap_alloc(void) const { return SOAP_NEW(ns2__NetworkInterfaceLink); }
      public:
        /// Constructor with initializations
        ns2__NetworkInterfaceLink()
        {
          AdminSettings = (ns2__NetworkInterfaceConnectionSetting *)0;
          OperSettings = (ns2__NetworkInterfaceConnectionSetting *)0;
          InterfaceType = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__NetworkInterfaceLink() { }
        /// Friend allocator used by soap_new_ns2__NetworkInterfaceLink(struct soap*, int)
        friend SOAP_FMAC1 ns2__NetworkInterfaceLink * SOAP_FMAC2 soap_instantiate_ns2__NetworkInterfaceLink(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1105 */
#ifndef SOAP_TYPE_ns2__NetworkInterfaceConnectionSetting
#define SOAP_TYPE_ns2__NetworkInterfaceConnectionSetting (519)
/* complex XSD type 'ns2:NetworkInterfaceConnectionSetting': */
class SOAP_CMAC ns2__NetworkInterfaceConnectionSetting {
      public:
        /// Required element 'ns2:AutoNegotiation' of XSD type 'xsd:boolean'
        bool AutoNegotiation;
        /// Required element 'ns2:Speed' of XSD type 'xsd:int'
        int Speed;
        /// Required element 'ns2:Duplex' of XSD type 'ns2:Duplex'
        ns2__Duplex Duplex;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NetworkInterfaceConnectionSetting
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NetworkInterfaceConnectionSetting; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NetworkInterfaceConnectionSetting, default initialized and not managed by a soap context
        virtual ns2__NetworkInterfaceConnectionSetting *soap_alloc(void) const { return SOAP_NEW(ns2__NetworkInterfaceConnectionSetting); }
      public:
        /// Constructor with initializations
        ns2__NetworkInterfaceConnectionSetting()
        {
          AutoNegotiation = (bool)0;
          Speed = (int)0;
          Duplex = (ns2__Duplex)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__NetworkInterfaceConnectionSetting() { }
        /// Friend allocator used by soap_new_ns2__NetworkInterfaceConnectionSetting(struct soap*, int)
        friend SOAP_FMAC1 ns2__NetworkInterfaceConnectionSetting * SOAP_FMAC2 soap_instantiate_ns2__NetworkInterfaceConnectionSetting(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1108 */
#ifndef SOAP_TYPE_ns2__NetworkInterfaceInfo
#define SOAP_TYPE_ns2__NetworkInterfaceInfo (520)
/* complex XSD type 'ns2:NetworkInterfaceInfo': */
class SOAP_CMAC ns2__NetworkInterfaceInfo {
      public:
        /// Optional element 'ns2:Name' of XSD type 'xsd:string'
        std::string *Name;
        /// Required element 'ns2:HwAddress' of XSD type 'ns2:HwAddress'
        std::string HwAddress;
        /// Optional element 'ns2:MTU' of XSD type 'xsd:int'
        int *MTU;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NetworkInterfaceInfo
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NetworkInterfaceInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NetworkInterfaceInfo, default initialized and not managed by a soap context
        virtual ns2__NetworkInterfaceInfo *soap_alloc(void) const { return SOAP_NEW(ns2__NetworkInterfaceInfo); }
      public:
        /// Constructor with initializations
        ns2__NetworkInterfaceInfo()
        {
          Name = (std::string *)0;
          MTU = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__NetworkInterfaceInfo() { }
        /// Friend allocator used by soap_new_ns2__NetworkInterfaceInfo(struct soap*, int)
        friend SOAP_FMAC1 ns2__NetworkInterfaceInfo * SOAP_FMAC2 soap_instantiate_ns2__NetworkInterfaceInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1111 */
#ifndef SOAP_TYPE_ns2__IPv6NetworkInterface
#define SOAP_TYPE_ns2__IPv6NetworkInterface (521)
/* complex XSD type 'ns2:IPv6NetworkInterface': */
class SOAP_CMAC ns2__IPv6NetworkInterface {
      public:
        /// Required element 'ns2:Enabled' of XSD type 'xsd:boolean'
        bool Enabled;
        /// Optional element 'ns2:Config' of XSD type 'ns2:IPv6Configuration'
        ns2__IPv6Configuration *Config;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__IPv6NetworkInterface
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__IPv6NetworkInterface; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__IPv6NetworkInterface, default initialized and not managed by a soap context
        virtual ns2__IPv6NetworkInterface *soap_alloc(void) const { return SOAP_NEW(ns2__IPv6NetworkInterface); }
      public:
        /// Constructor with initializations
        ns2__IPv6NetworkInterface()
        {
          Enabled = (bool)0;
          Config = (ns2__IPv6Configuration *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__IPv6NetworkInterface() { }
        /// Friend allocator used by soap_new_ns2__IPv6NetworkInterface(struct soap*, int)
        friend SOAP_FMAC1 ns2__IPv6NetworkInterface * SOAP_FMAC2 soap_instantiate_ns2__IPv6NetworkInterface(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1114 */
#ifndef SOAP_TYPE_ns2__IPv4NetworkInterface
#define SOAP_TYPE_ns2__IPv4NetworkInterface (522)
/* complex XSD type 'ns2:IPv4NetworkInterface': */
class SOAP_CMAC ns2__IPv4NetworkInterface {
      public:
        /// Required element 'ns2:Enabled' of XSD type 'xsd:boolean'
        bool Enabled;
        /// Required element 'ns2:Config' of XSD type 'ns2:IPv4Configuration'
        ns2__IPv4Configuration *Config;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__IPv4NetworkInterface
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__IPv4NetworkInterface; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__IPv4NetworkInterface, default initialized and not managed by a soap context
        virtual ns2__IPv4NetworkInterface *soap_alloc(void) const { return SOAP_NEW(ns2__IPv4NetworkInterface); }
      public:
        /// Constructor with initializations
        ns2__IPv4NetworkInterface()
        {
          Enabled = (bool)0;
          Config = (ns2__IPv4Configuration *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__IPv4NetworkInterface() { }
        /// Friend allocator used by soap_new_ns2__IPv4NetworkInterface(struct soap*, int)
        friend SOAP_FMAC1 ns2__IPv4NetworkInterface * SOAP_FMAC2 soap_instantiate_ns2__IPv4NetworkInterface(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1117 */
#ifndef SOAP_TYPE_ns2__IPv4Configuration
#define SOAP_TYPE_ns2__IPv4Configuration (523)
/* complex XSD type 'ns2:IPv4Configuration': */
class SOAP_CMAC ns2__IPv4Configuration {
      public:
        /// Optional element 'ns2:Manual' of XSD type 'ns2:PrefixedIPv4Address'
        std::vector<ns2__PrefixedIPv4Address *> Manual;
        /// Optional element 'ns2:LinkLocal' of XSD type 'ns2:PrefixedIPv4Address'
        ns2__PrefixedIPv4Address *LinkLocal;
        /// Optional element 'ns2:FromDHCP' of XSD type 'ns2:PrefixedIPv4Address'
        ns2__PrefixedIPv4Address *FromDHCP;
        /// Required element 'ns2:DHCP' of XSD type 'xsd:boolean'
        bool DHCP;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__IPv4Configuration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__IPv4Configuration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__IPv4Configuration, default initialized and not managed by a soap context
        virtual ns2__IPv4Configuration *soap_alloc(void) const { return SOAP_NEW(ns2__IPv4Configuration); }
      public:
        /// Constructor with initializations
        ns2__IPv4Configuration()
        {
          LinkLocal = (ns2__PrefixedIPv4Address *)0;
          FromDHCP = (ns2__PrefixedIPv4Address *)0;
          DHCP = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__IPv4Configuration() { }
        /// Friend allocator used by soap_new_ns2__IPv4Configuration(struct soap*, int)
        friend SOAP_FMAC1 ns2__IPv4Configuration * SOAP_FMAC2 soap_instantiate_ns2__IPv4Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1120 */
#ifndef SOAP_TYPE_ns2__IPv6Configuration
#define SOAP_TYPE_ns2__IPv6Configuration (524)
/* complex XSD type 'ns2:IPv6Configuration': */
class SOAP_CMAC ns2__IPv6Configuration {
      public:
        /// Optional element 'ns2:AcceptRouterAdvert' of XSD type 'xsd:boolean'
        bool *AcceptRouterAdvert;
        /// Required element 'ns2:DHCP' of XSD type 'ns2:IPv6DHCPConfiguration'
        ns2__IPv6DHCPConfiguration DHCP;
        /// Optional element 'ns2:Manual' of XSD type 'ns2:PrefixedIPv6Address'
        std::vector<ns2__PrefixedIPv6Address *> Manual;
        /// Optional element 'ns2:LinkLocal' of XSD type 'ns2:PrefixedIPv6Address'
        std::vector<ns2__PrefixedIPv6Address *> LinkLocal;
        /// Optional element 'ns2:FromDHCP' of XSD type 'ns2:PrefixedIPv6Address'
        std::vector<ns2__PrefixedIPv6Address *> FromDHCP;
        /// Optional element 'ns2:FromRA' of XSD type 'ns2:PrefixedIPv6Address'
        std::vector<ns2__PrefixedIPv6Address *> FromRA;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:IPv6ConfigurationExtension'
        ns2__IPv6ConfigurationExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__IPv6Configuration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__IPv6Configuration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__IPv6Configuration, default initialized and not managed by a soap context
        virtual ns2__IPv6Configuration *soap_alloc(void) const { return SOAP_NEW(ns2__IPv6Configuration); }
      public:
        /// Constructor with initializations
        ns2__IPv6Configuration()
        {
          AcceptRouterAdvert = (bool *)0;
          DHCP = (ns2__IPv6DHCPConfiguration)0;
          Extension = (ns2__IPv6ConfigurationExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__IPv6Configuration() { }
        /// Friend allocator used by soap_new_ns2__IPv6Configuration(struct soap*, int)
        friend SOAP_FMAC1 ns2__IPv6Configuration * SOAP_FMAC2 soap_instantiate_ns2__IPv6Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1123 */
#ifndef SOAP_TYPE_ns2__IPv6ConfigurationExtension
#define SOAP_TYPE_ns2__IPv6ConfigurationExtension (525)
/* complex XSD type 'ns2:IPv6ConfigurationExtension': */
class SOAP_CMAC ns2__IPv6ConfigurationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__IPv6ConfigurationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__IPv6ConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__IPv6ConfigurationExtension, default initialized and not managed by a soap context
        virtual ns2__IPv6ConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__IPv6ConfigurationExtension); }
      public:
        /// Constructor with initializations
        ns2__IPv6ConfigurationExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__IPv6ConfigurationExtension() { }
        /// Friend allocator used by soap_new_ns2__IPv6ConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__IPv6ConfigurationExtension * SOAP_FMAC2 soap_instantiate_ns2__IPv6ConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1126 */
#ifndef SOAP_TYPE_ns2__NetworkProtocol
#define SOAP_TYPE_ns2__NetworkProtocol (526)
/* complex XSD type 'ns2:NetworkProtocol': */
class SOAP_CMAC ns2__NetworkProtocol {
      public:
        /// Required element 'ns2:Name' of XSD type 'ns2:NetworkProtocolType'
        ns2__NetworkProtocolType Name;
        /// Required element 'ns2:Enabled' of XSD type 'xsd:boolean'
        bool Enabled;
        /// Required element 'ns2:Port' of XSD type 'xsd:int'
        std::vector<int> Port;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:NetworkProtocolExtension'
        ns2__NetworkProtocolExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NetworkProtocol
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NetworkProtocol; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NetworkProtocol, default initialized and not managed by a soap context
        virtual ns2__NetworkProtocol *soap_alloc(void) const { return SOAP_NEW(ns2__NetworkProtocol); }
      public:
        /// Constructor with initializations
        ns2__NetworkProtocol()
        {
          Name = (ns2__NetworkProtocolType)0;
          Enabled = (bool)0;
          Extension = (ns2__NetworkProtocolExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__NetworkProtocol() { }
        /// Friend allocator used by soap_new_ns2__NetworkProtocol(struct soap*, int)
        friend SOAP_FMAC1 ns2__NetworkProtocol * SOAP_FMAC2 soap_instantiate_ns2__NetworkProtocol(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1129 */
#ifndef SOAP_TYPE_ns2__NetworkProtocolExtension
#define SOAP_TYPE_ns2__NetworkProtocolExtension (527)
/* complex XSD type 'ns2:NetworkProtocolExtension': */
class SOAP_CMAC ns2__NetworkProtocolExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NetworkProtocolExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NetworkProtocolExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NetworkProtocolExtension, default initialized and not managed by a soap context
        virtual ns2__NetworkProtocolExtension *soap_alloc(void) const { return SOAP_NEW(ns2__NetworkProtocolExtension); }
      public:
        /// Constructor with initializations
        ns2__NetworkProtocolExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__NetworkProtocolExtension() { }
        /// Friend allocator used by soap_new_ns2__NetworkProtocolExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__NetworkProtocolExtension * SOAP_FMAC2 soap_instantiate_ns2__NetworkProtocolExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1132 */
#ifndef SOAP_TYPE_ns2__NetworkHost
#define SOAP_TYPE_ns2__NetworkHost (528)
/* complex XSD type 'ns2:NetworkHost': */
class SOAP_CMAC ns2__NetworkHost {
      public:
        /// Required element 'ns2:Type' of XSD type 'ns2:NetworkHostType'
        ns2__NetworkHostType Type;
        /// Optional element 'ns2:IPv4Address' of XSD type 'ns2:IPv4Address'
        std::string *IPv4Address;
        /// Optional element 'ns2:IPv6Address' of XSD type 'ns2:IPv6Address'
        std::string *IPv6Address;
        /// Optional element 'ns2:DNSname' of XSD type 'ns2:DNSName'
        std::string *DNSname;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:NetworkHostExtension'
        ns2__NetworkHostExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NetworkHost
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NetworkHost; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NetworkHost, default initialized and not managed by a soap context
        virtual ns2__NetworkHost *soap_alloc(void) const { return SOAP_NEW(ns2__NetworkHost); }
      public:
        /// Constructor with initializations
        ns2__NetworkHost()
        {
          Type = (ns2__NetworkHostType)0;
          IPv4Address = (std::string *)0;
          IPv6Address = (std::string *)0;
          DNSname = (std::string *)0;
          Extension = (ns2__NetworkHostExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__NetworkHost() { }
        /// Friend allocator used by soap_new_ns2__NetworkHost(struct soap*, int)
        friend SOAP_FMAC1 ns2__NetworkHost * SOAP_FMAC2 soap_instantiate_ns2__NetworkHost(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1135 */
#ifndef SOAP_TYPE_ns2__NetworkHostExtension
#define SOAP_TYPE_ns2__NetworkHostExtension (529)
/* complex XSD type 'ns2:NetworkHostExtension': */
class SOAP_CMAC ns2__NetworkHostExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NetworkHostExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NetworkHostExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NetworkHostExtension, default initialized and not managed by a soap context
        virtual ns2__NetworkHostExtension *soap_alloc(void) const { return SOAP_NEW(ns2__NetworkHostExtension); }
      public:
        /// Constructor with initializations
        ns2__NetworkHostExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__NetworkHostExtension() { }
        /// Friend allocator used by soap_new_ns2__NetworkHostExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__NetworkHostExtension * SOAP_FMAC2 soap_instantiate_ns2__NetworkHostExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1138 */
#ifndef SOAP_TYPE_ns2__IPAddress
#define SOAP_TYPE_ns2__IPAddress (530)
/* complex XSD type 'ns2:IPAddress': */
class SOAP_CMAC ns2__IPAddress {
      public:
        /// Required element 'ns2:Type' of XSD type 'ns2:IPType'
        ns2__IPType Type;
        /// Optional element 'ns2:IPv4Address' of XSD type 'ns2:IPv4Address'
        std::string *IPv4Address;
        /// Optional element 'ns2:IPv6Address' of XSD type 'ns2:IPv6Address'
        std::string *IPv6Address;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__IPAddress
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__IPAddress; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__IPAddress, default initialized and not managed by a soap context
        virtual ns2__IPAddress *soap_alloc(void) const { return SOAP_NEW(ns2__IPAddress); }
      public:
        /// Constructor with initializations
        ns2__IPAddress()
        {
          Type = (ns2__IPType)0;
          IPv4Address = (std::string *)0;
          IPv6Address = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__IPAddress() { }
        /// Friend allocator used by soap_new_ns2__IPAddress(struct soap*, int)
        friend SOAP_FMAC1 ns2__IPAddress * SOAP_FMAC2 soap_instantiate_ns2__IPAddress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1141 */
#ifndef SOAP_TYPE_ns2__PrefixedIPv4Address
#define SOAP_TYPE_ns2__PrefixedIPv4Address (531)
/* complex XSD type 'ns2:PrefixedIPv4Address': */
class SOAP_CMAC ns2__PrefixedIPv4Address {
      public:
        /// Required element 'ns2:Address' of XSD type 'ns2:IPv4Address'
        std::string Address;
        /// Required element 'ns2:PrefixLength' of XSD type 'xsd:int'
        int PrefixLength;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PrefixedIPv4Address
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PrefixedIPv4Address; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PrefixedIPv4Address, default initialized and not managed by a soap context
        virtual ns2__PrefixedIPv4Address *soap_alloc(void) const { return SOAP_NEW(ns2__PrefixedIPv4Address); }
      public:
        /// Constructor with initializations
        ns2__PrefixedIPv4Address()
        {
          PrefixLength = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PrefixedIPv4Address() { }
        /// Friend allocator used by soap_new_ns2__PrefixedIPv4Address(struct soap*, int)
        friend SOAP_FMAC1 ns2__PrefixedIPv4Address * SOAP_FMAC2 soap_instantiate_ns2__PrefixedIPv4Address(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1144 */
#ifndef SOAP_TYPE_ns2__PrefixedIPv6Address
#define SOAP_TYPE_ns2__PrefixedIPv6Address (532)
/* complex XSD type 'ns2:PrefixedIPv6Address': */
class SOAP_CMAC ns2__PrefixedIPv6Address {
      public:
        /// Required element 'ns2:Address' of XSD type 'ns2:IPv6Address'
        std::string Address;
        /// Required element 'ns2:PrefixLength' of XSD type 'xsd:int'
        int PrefixLength;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PrefixedIPv6Address
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PrefixedIPv6Address; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PrefixedIPv6Address, default initialized and not managed by a soap context
        virtual ns2__PrefixedIPv6Address *soap_alloc(void) const { return SOAP_NEW(ns2__PrefixedIPv6Address); }
      public:
        /// Constructor with initializations
        ns2__PrefixedIPv6Address()
        {
          PrefixLength = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PrefixedIPv6Address() { }
        /// Friend allocator used by soap_new_ns2__PrefixedIPv6Address(struct soap*, int)
        friend SOAP_FMAC1 ns2__PrefixedIPv6Address * SOAP_FMAC2 soap_instantiate_ns2__PrefixedIPv6Address(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1147 */
#ifndef SOAP_TYPE_ns2__HostnameInformation
#define SOAP_TYPE_ns2__HostnameInformation (533)
/* complex XSD type 'ns2:HostnameInformation': */
class SOAP_CMAC ns2__HostnameInformation {
      public:
        /// Required element 'ns2:FromDHCP' of XSD type 'xsd:boolean'
        bool FromDHCP;
        /// Optional element 'ns2:Name' of XSD type 'xsd:token'
        std::string *Name;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:HostnameInformationExtension'
        ns2__HostnameInformationExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__HostnameInformation
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__HostnameInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__HostnameInformation, default initialized and not managed by a soap context
        virtual ns2__HostnameInformation *soap_alloc(void) const { return SOAP_NEW(ns2__HostnameInformation); }
      public:
        /// Constructor with initializations
        ns2__HostnameInformation()
        {
          FromDHCP = (bool)0;
          Name = (std::string *)0;
          Extension = (ns2__HostnameInformationExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__HostnameInformation() { }
        /// Friend allocator used by soap_new_ns2__HostnameInformation(struct soap*, int)
        friend SOAP_FMAC1 ns2__HostnameInformation * SOAP_FMAC2 soap_instantiate_ns2__HostnameInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1150 */
#ifndef SOAP_TYPE_ns2__HostnameInformationExtension
#define SOAP_TYPE_ns2__HostnameInformationExtension (534)
/* complex XSD type 'ns2:HostnameInformationExtension': */
class SOAP_CMAC ns2__HostnameInformationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__HostnameInformationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__HostnameInformationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__HostnameInformationExtension, default initialized and not managed by a soap context
        virtual ns2__HostnameInformationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__HostnameInformationExtension); }
      public:
        /// Constructor with initializations
        ns2__HostnameInformationExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__HostnameInformationExtension() { }
        /// Friend allocator used by soap_new_ns2__HostnameInformationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__HostnameInformationExtension * SOAP_FMAC2 soap_instantiate_ns2__HostnameInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1153 */
#ifndef SOAP_TYPE_ns2__DNSInformation
#define SOAP_TYPE_ns2__DNSInformation (535)
/* complex XSD type 'ns2:DNSInformation': */
class SOAP_CMAC ns2__DNSInformation {
      public:
        /// Required element 'ns2:FromDHCP' of XSD type 'xsd:boolean'
        bool FromDHCP;
        /// Optional element 'ns2:SearchDomain' of XSD type 'xsd:token'
        std::vector<std::string> SearchDomain;
        /// Optional element 'ns2:DNSFromDHCP' of XSD type 'ns2:IPAddress'
        std::vector<ns2__IPAddress *> DNSFromDHCP;
        /// Optional element 'ns2:DNSManual' of XSD type 'ns2:IPAddress'
        std::vector<ns2__IPAddress *> DNSManual;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:DNSInformationExtension'
        ns2__DNSInformationExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DNSInformation
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DNSInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DNSInformation, default initialized and not managed by a soap context
        virtual ns2__DNSInformation *soap_alloc(void) const { return SOAP_NEW(ns2__DNSInformation); }
      public:
        /// Constructor with initializations
        ns2__DNSInformation()
        {
          FromDHCP = (bool)0;
          Extension = (ns2__DNSInformationExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DNSInformation() { }
        /// Friend allocator used by soap_new_ns2__DNSInformation(struct soap*, int)
        friend SOAP_FMAC1 ns2__DNSInformation * SOAP_FMAC2 soap_instantiate_ns2__DNSInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1156 */
#ifndef SOAP_TYPE_ns2__DNSInformationExtension
#define SOAP_TYPE_ns2__DNSInformationExtension (536)
/* complex XSD type 'ns2:DNSInformationExtension': */
class SOAP_CMAC ns2__DNSInformationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DNSInformationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DNSInformationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DNSInformationExtension, default initialized and not managed by a soap context
        virtual ns2__DNSInformationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__DNSInformationExtension); }
      public:
        /// Constructor with initializations
        ns2__DNSInformationExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__DNSInformationExtension() { }
        /// Friend allocator used by soap_new_ns2__DNSInformationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__DNSInformationExtension * SOAP_FMAC2 soap_instantiate_ns2__DNSInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1159 */
#ifndef SOAP_TYPE_ns2__NTPInformation
#define SOAP_TYPE_ns2__NTPInformation (537)
/* complex XSD type 'ns2:NTPInformation': */
class SOAP_CMAC ns2__NTPInformation {
      public:
        /// Required element 'ns2:FromDHCP' of XSD type 'xsd:boolean'
        bool FromDHCP;
        /// Optional element 'ns2:NTPFromDHCP' of XSD type 'ns2:NetworkHost'
        std::vector<ns2__NetworkHost *> NTPFromDHCP;
        /// Optional element 'ns2:NTPManual' of XSD type 'ns2:NetworkHost'
        std::vector<ns2__NetworkHost *> NTPManual;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:NTPInformationExtension'
        ns2__NTPInformationExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NTPInformation
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NTPInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NTPInformation, default initialized and not managed by a soap context
        virtual ns2__NTPInformation *soap_alloc(void) const { return SOAP_NEW(ns2__NTPInformation); }
      public:
        /// Constructor with initializations
        ns2__NTPInformation()
        {
          FromDHCP = (bool)0;
          Extension = (ns2__NTPInformationExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__NTPInformation() { }
        /// Friend allocator used by soap_new_ns2__NTPInformation(struct soap*, int)
        friend SOAP_FMAC1 ns2__NTPInformation * SOAP_FMAC2 soap_instantiate_ns2__NTPInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1162 */
#ifndef SOAP_TYPE_ns2__NTPInformationExtension
#define SOAP_TYPE_ns2__NTPInformationExtension (538)
/* complex XSD type 'ns2:NTPInformationExtension': */
class SOAP_CMAC ns2__NTPInformationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NTPInformationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NTPInformationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NTPInformationExtension, default initialized and not managed by a soap context
        virtual ns2__NTPInformationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__NTPInformationExtension); }
      public:
        /// Constructor with initializations
        ns2__NTPInformationExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__NTPInformationExtension() { }
        /// Friend allocator used by soap_new_ns2__NTPInformationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__NTPInformationExtension * SOAP_FMAC2 soap_instantiate_ns2__NTPInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1165 */
#ifndef SOAP_TYPE_ns2__DynamicDNSInformation
#define SOAP_TYPE_ns2__DynamicDNSInformation (539)
/* complex XSD type 'ns2:DynamicDNSInformation': */
class SOAP_CMAC ns2__DynamicDNSInformation {
      public:
        /// Required element 'ns2:Type' of XSD type 'ns2:DynamicDNSType'
        ns2__DynamicDNSType Type;
        /// Optional element 'ns2:Name' of XSD type 'ns2:DNSName'
        std::string *Name;
        /// Optional element 'ns2:TTL' of XSD type 'xsd:duration'
        std::string *TTL;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:DynamicDNSInformationExtension'
        ns2__DynamicDNSInformationExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DynamicDNSInformation
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DynamicDNSInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DynamicDNSInformation, default initialized and not managed by a soap context
        virtual ns2__DynamicDNSInformation *soap_alloc(void) const { return SOAP_NEW(ns2__DynamicDNSInformation); }
      public:
        /// Constructor with initializations
        ns2__DynamicDNSInformation()
        {
          Type = (ns2__DynamicDNSType)0;
          Name = (std::string *)0;
          TTL = (std::string *)0;
          Extension = (ns2__DynamicDNSInformationExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DynamicDNSInformation() { }
        /// Friend allocator used by soap_new_ns2__DynamicDNSInformation(struct soap*, int)
        friend SOAP_FMAC1 ns2__DynamicDNSInformation * SOAP_FMAC2 soap_instantiate_ns2__DynamicDNSInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1168 */
#ifndef SOAP_TYPE_ns2__DynamicDNSInformationExtension
#define SOAP_TYPE_ns2__DynamicDNSInformationExtension (540)
/* complex XSD type 'ns2:DynamicDNSInformationExtension': */
class SOAP_CMAC ns2__DynamicDNSInformationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DynamicDNSInformationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DynamicDNSInformationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DynamicDNSInformationExtension, default initialized and not managed by a soap context
        virtual ns2__DynamicDNSInformationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__DynamicDNSInformationExtension); }
      public:
        /// Constructor with initializations
        ns2__DynamicDNSInformationExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__DynamicDNSInformationExtension() { }
        /// Friend allocator used by soap_new_ns2__DynamicDNSInformationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__DynamicDNSInformationExtension * SOAP_FMAC2 soap_instantiate_ns2__DynamicDNSInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1171 */
#ifndef SOAP_TYPE_ns2__NetworkInterfaceSetConfiguration
#define SOAP_TYPE_ns2__NetworkInterfaceSetConfiguration (541)
/* complex XSD type 'ns2:NetworkInterfaceSetConfiguration': */
class SOAP_CMAC ns2__NetworkInterfaceSetConfiguration {
      public:
        /// Optional element 'ns2:Enabled' of XSD type 'xsd:boolean'
        bool *Enabled;
        /// Optional element 'ns2:Link' of XSD type 'ns2:NetworkInterfaceConnectionSetting'
        ns2__NetworkInterfaceConnectionSetting *Link;
        /// Optional element 'ns2:MTU' of XSD type 'xsd:int'
        int *MTU;
        /// Optional element 'ns2:IPv4' of XSD type 'ns2:IPv4NetworkInterfaceSetConfiguration'
        ns2__IPv4NetworkInterfaceSetConfiguration *IPv4;
        /// Optional element 'ns2:IPv6' of XSD type 'ns2:IPv6NetworkInterfaceSetConfiguration'
        ns2__IPv6NetworkInterfaceSetConfiguration *IPv6;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:NetworkInterfaceSetConfigurationExtension'
        ns2__NetworkInterfaceSetConfigurationExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NetworkInterfaceSetConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NetworkInterfaceSetConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NetworkInterfaceSetConfiguration, default initialized and not managed by a soap context
        virtual ns2__NetworkInterfaceSetConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__NetworkInterfaceSetConfiguration); }
      public:
        /// Constructor with initializations
        ns2__NetworkInterfaceSetConfiguration()
        {
          Enabled = (bool *)0;
          Link = (ns2__NetworkInterfaceConnectionSetting *)0;
          MTU = (int *)0;
          IPv4 = (ns2__IPv4NetworkInterfaceSetConfiguration *)0;
          IPv6 = (ns2__IPv6NetworkInterfaceSetConfiguration *)0;
          Extension = (ns2__NetworkInterfaceSetConfigurationExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__NetworkInterfaceSetConfiguration() { }
        /// Friend allocator used by soap_new_ns2__NetworkInterfaceSetConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_ns2__NetworkInterfaceSetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1174 */
#ifndef SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension
#define SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension (542)
/* complex XSD type 'ns2:NetworkInterfaceSetConfigurationExtension': */
class SOAP_CMAC ns2__NetworkInterfaceSetConfigurationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional element 'ns2:Dot3' of XSD type 'ns2:Dot3Configuration'
        std::vector<ns2__Dot3Configuration *> Dot3;
        /// Optional element 'ns2:Dot11' of XSD type 'ns2:Dot11Configuration'
        std::vector<ns2__Dot11Configuration *> Dot11;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:NetworkInterfaceSetConfigurationExtension2'
        ns2__NetworkInterfaceSetConfigurationExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NetworkInterfaceSetConfigurationExtension, default initialized and not managed by a soap context
        virtual ns2__NetworkInterfaceSetConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__NetworkInterfaceSetConfigurationExtension); }
      public:
        /// Constructor with initializations
        ns2__NetworkInterfaceSetConfigurationExtension()
        {
          Extension = (ns2__NetworkInterfaceSetConfigurationExtension2 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__NetworkInterfaceSetConfigurationExtension() { }
        /// Friend allocator used by soap_new_ns2__NetworkInterfaceSetConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC2 soap_instantiate_ns2__NetworkInterfaceSetConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1177 */
#ifndef SOAP_TYPE_ns2__IPv6NetworkInterfaceSetConfiguration
#define SOAP_TYPE_ns2__IPv6NetworkInterfaceSetConfiguration (543)
/* complex XSD type 'ns2:IPv6NetworkInterfaceSetConfiguration': */
class SOAP_CMAC ns2__IPv6NetworkInterfaceSetConfiguration {
      public:
        /// Optional element 'ns2:Enabled' of XSD type 'xsd:boolean'
        bool *Enabled;
        /// Optional element 'ns2:AcceptRouterAdvert' of XSD type 'xsd:boolean'
        bool *AcceptRouterAdvert;
        /// Optional element 'ns2:Manual' of XSD type 'ns2:PrefixedIPv6Address'
        std::vector<ns2__PrefixedIPv6Address *> Manual;
        /// Optional element 'ns2:DHCP' of XSD type 'ns2:IPv6DHCPConfiguration'
        ns2__IPv6DHCPConfiguration *DHCP;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__IPv6NetworkInterfaceSetConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__IPv6NetworkInterfaceSetConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__IPv6NetworkInterfaceSetConfiguration, default initialized and not managed by a soap context
        virtual ns2__IPv6NetworkInterfaceSetConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__IPv6NetworkInterfaceSetConfiguration); }
      public:
        /// Constructor with initializations
        ns2__IPv6NetworkInterfaceSetConfiguration()
        {
          Enabled = (bool *)0;
          AcceptRouterAdvert = (bool *)0;
          DHCP = (ns2__IPv6DHCPConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__IPv6NetworkInterfaceSetConfiguration() { }
        /// Friend allocator used by soap_new_ns2__IPv6NetworkInterfaceSetConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_ns2__IPv6NetworkInterfaceSetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1180 */
#ifndef SOAP_TYPE_ns2__IPv4NetworkInterfaceSetConfiguration
#define SOAP_TYPE_ns2__IPv4NetworkInterfaceSetConfiguration (544)
/* complex XSD type 'ns2:IPv4NetworkInterfaceSetConfiguration': */
class SOAP_CMAC ns2__IPv4NetworkInterfaceSetConfiguration {
      public:
        /// Optional element 'ns2:Enabled' of XSD type 'xsd:boolean'
        bool *Enabled;
        /// Optional element 'ns2:Manual' of XSD type 'ns2:PrefixedIPv4Address'
        std::vector<ns2__PrefixedIPv4Address *> Manual;
        /// Optional element 'ns2:DHCP' of XSD type 'xsd:boolean'
        bool *DHCP;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__IPv4NetworkInterfaceSetConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__IPv4NetworkInterfaceSetConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__IPv4NetworkInterfaceSetConfiguration, default initialized and not managed by a soap context
        virtual ns2__IPv4NetworkInterfaceSetConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__IPv4NetworkInterfaceSetConfiguration); }
      public:
        /// Constructor with initializations
        ns2__IPv4NetworkInterfaceSetConfiguration()
        {
          Enabled = (bool *)0;
          DHCP = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__IPv4NetworkInterfaceSetConfiguration() { }
        /// Friend allocator used by soap_new_ns2__IPv4NetworkInterfaceSetConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_ns2__IPv4NetworkInterfaceSetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1183 */
#ifndef SOAP_TYPE_ns2__NetworkGateway
#define SOAP_TYPE_ns2__NetworkGateway (545)
/* complex XSD type 'ns2:NetworkGateway': */
class SOAP_CMAC ns2__NetworkGateway {
      public:
        /// Optional element 'ns2:IPv4Address' of XSD type 'ns2:IPv4Address'
        std::vector<std::string> IPv4Address;
        /// Optional element 'ns2:IPv6Address' of XSD type 'ns2:IPv6Address'
        std::vector<std::string> IPv6Address;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NetworkGateway
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NetworkGateway; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NetworkGateway, default initialized and not managed by a soap context
        virtual ns2__NetworkGateway *soap_alloc(void) const { return SOAP_NEW(ns2__NetworkGateway); }
      public:
        /// Constructor with initializations
        ns2__NetworkGateway()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__NetworkGateway() { }
        /// Friend allocator used by soap_new_ns2__NetworkGateway(struct soap*, int)
        friend SOAP_FMAC1 ns2__NetworkGateway * SOAP_FMAC2 soap_instantiate_ns2__NetworkGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1186 */
#ifndef SOAP_TYPE_ns2__NetworkZeroConfiguration
#define SOAP_TYPE_ns2__NetworkZeroConfiguration (546)
/* complex XSD type 'ns2:NetworkZeroConfiguration': */
class SOAP_CMAC ns2__NetworkZeroConfiguration {
      public:
        /// Required element 'ns2:InterfaceToken' of XSD type 'ns2:ReferenceToken'
        std::string InterfaceToken;
        /// Required element 'ns2:Enabled' of XSD type 'xsd:boolean'
        bool Enabled;
        /// Optional element 'ns2:Addresses' of XSD type 'ns2:IPv4Address'
        std::vector<std::string> Addresses;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:NetworkZeroConfigurationExtension'
        ns2__NetworkZeroConfigurationExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NetworkZeroConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NetworkZeroConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NetworkZeroConfiguration, default initialized and not managed by a soap context
        virtual ns2__NetworkZeroConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__NetworkZeroConfiguration); }
      public:
        /// Constructor with initializations
        ns2__NetworkZeroConfiguration()
        {
          Enabled = (bool)0;
          Extension = (ns2__NetworkZeroConfigurationExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__NetworkZeroConfiguration() { }
        /// Friend allocator used by soap_new_ns2__NetworkZeroConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__NetworkZeroConfiguration * SOAP_FMAC2 soap_instantiate_ns2__NetworkZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1189 */
#ifndef SOAP_TYPE_ns2__NetworkZeroConfigurationExtension
#define SOAP_TYPE_ns2__NetworkZeroConfigurationExtension (547)
/* Type ns2__NetworkZeroConfigurationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:NetworkZeroConfigurationExtension': */
class SOAP_CMAC ns2__NetworkZeroConfigurationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional element 'ns2:Additional' of XSD type 'ns2:NetworkZeroConfiguration'
        std::vector<ns2__NetworkZeroConfiguration *> Additional;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:NetworkZeroConfigurationExtension2'
        ns2__NetworkZeroConfigurationExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NetworkZeroConfigurationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NetworkZeroConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NetworkZeroConfigurationExtension, default initialized and not managed by a soap context
        virtual ns2__NetworkZeroConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__NetworkZeroConfigurationExtension); }
      public:
        /// Constructor with initializations
        ns2__NetworkZeroConfigurationExtension()
        {
          Extension = (ns2__NetworkZeroConfigurationExtension2 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__NetworkZeroConfigurationExtension() { }
        /// Friend allocator used by soap_new_ns2__NetworkZeroConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__NetworkZeroConfigurationExtension * SOAP_FMAC2 soap_instantiate_ns2__NetworkZeroConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1192 */
#ifndef SOAP_TYPE_ns2__NetworkZeroConfigurationExtension2
#define SOAP_TYPE_ns2__NetworkZeroConfigurationExtension2 (548)
/* complex XSD type 'ns2:NetworkZeroConfigurationExtension2': */
class SOAP_CMAC ns2__NetworkZeroConfigurationExtension2 {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NetworkZeroConfigurationExtension2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NetworkZeroConfigurationExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NetworkZeroConfigurationExtension2, default initialized and not managed by a soap context
        virtual ns2__NetworkZeroConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW(ns2__NetworkZeroConfigurationExtension2); }
      public:
        /// Constructor with initializations
        ns2__NetworkZeroConfigurationExtension2()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__NetworkZeroConfigurationExtension2() { }
        /// Friend allocator used by soap_new_ns2__NetworkZeroConfigurationExtension2(struct soap*, int)
        friend SOAP_FMAC1 ns2__NetworkZeroConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_ns2__NetworkZeroConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1195 */
#ifndef SOAP_TYPE_ns2__IPAddressFilter
#define SOAP_TYPE_ns2__IPAddressFilter (549)
/* complex XSD type 'ns2:IPAddressFilter': */
class SOAP_CMAC ns2__IPAddressFilter {
      public:
        /// Required element 'ns2:Type' of XSD type 'ns2:IPAddressFilterType'
        ns2__IPAddressFilterType Type;
        /// Optional element 'ns2:IPv4Address' of XSD type 'ns2:PrefixedIPv4Address'
        std::vector<ns2__PrefixedIPv4Address *> IPv4Address;
        /// Optional element 'ns2:IPv6Address' of XSD type 'ns2:PrefixedIPv6Address'
        std::vector<ns2__PrefixedIPv6Address *> IPv6Address;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:IPAddressFilterExtension'
        ns2__IPAddressFilterExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__IPAddressFilter
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__IPAddressFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__IPAddressFilter, default initialized and not managed by a soap context
        virtual ns2__IPAddressFilter *soap_alloc(void) const { return SOAP_NEW(ns2__IPAddressFilter); }
      public:
        /// Constructor with initializations
        ns2__IPAddressFilter()
        {
          Type = (ns2__IPAddressFilterType)0;
          Extension = (ns2__IPAddressFilterExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__IPAddressFilter() { }
        /// Friend allocator used by soap_new_ns2__IPAddressFilter(struct soap*, int)
        friend SOAP_FMAC1 ns2__IPAddressFilter * SOAP_FMAC2 soap_instantiate_ns2__IPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1198 */
#ifndef SOAP_TYPE_ns2__IPAddressFilterExtension
#define SOAP_TYPE_ns2__IPAddressFilterExtension (550)
/* complex XSD type 'ns2:IPAddressFilterExtension': */
class SOAP_CMAC ns2__IPAddressFilterExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__IPAddressFilterExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__IPAddressFilterExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__IPAddressFilterExtension, default initialized and not managed by a soap context
        virtual ns2__IPAddressFilterExtension *soap_alloc(void) const { return SOAP_NEW(ns2__IPAddressFilterExtension); }
      public:
        /// Constructor with initializations
        ns2__IPAddressFilterExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__IPAddressFilterExtension() { }
        /// Friend allocator used by soap_new_ns2__IPAddressFilterExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__IPAddressFilterExtension * SOAP_FMAC2 soap_instantiate_ns2__IPAddressFilterExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1201 */
#ifndef SOAP_TYPE_ns2__Dot11Configuration
#define SOAP_TYPE_ns2__Dot11Configuration (551)
/* complex XSD type 'ns2:Dot11Configuration': */
class SOAP_CMAC ns2__Dot11Configuration {
      public:
        /// Required element 'ns2:SSID' of XSD type 'ns2:Dot11SSIDType'
        xsd__hexBinary SSID;
        /// Required element 'ns2:Mode' of XSD type 'ns2:Dot11StationMode'
        ns2__Dot11StationMode Mode;
        /// Required element 'ns2:Alias' of XSD type 'ns2:Name'
        std::string Alias;
        /// Required element 'ns2:Priority' of XSD type 'ns2:NetworkInterfaceConfigPriority'
        std::string Priority;
        /// Required element 'ns2:Security' of XSD type 'ns2:Dot11SecurityConfiguration'
        ns2__Dot11SecurityConfiguration *Security;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Dot11Configuration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Dot11Configuration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Dot11Configuration, default initialized and not managed by a soap context
        virtual ns2__Dot11Configuration *soap_alloc(void) const { return SOAP_NEW(ns2__Dot11Configuration); }
      public:
        /// Constructor with initializations
        ns2__Dot11Configuration()
        {
          Mode = (ns2__Dot11StationMode)0;
          Security = (ns2__Dot11SecurityConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Dot11Configuration() { }
        /// Friend allocator used by soap_new_ns2__Dot11Configuration(struct soap*, int)
        friend SOAP_FMAC1 ns2__Dot11Configuration * SOAP_FMAC2 soap_instantiate_ns2__Dot11Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1204 */
#ifndef SOAP_TYPE_ns2__Dot11SecurityConfiguration
#define SOAP_TYPE_ns2__Dot11SecurityConfiguration (552)
/* complex XSD type 'ns2:Dot11SecurityConfiguration': */
class SOAP_CMAC ns2__Dot11SecurityConfiguration {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:Dot11SecurityMode'
        ns2__Dot11SecurityMode Mode;
        /// Optional element 'ns2:Algorithm' of XSD type 'ns2:Dot11Cipher'
        ns2__Dot11Cipher *Algorithm;
        /// Optional element 'ns2:PSK' of XSD type 'ns2:Dot11PSKSet'
        ns2__Dot11PSKSet *PSK;
        /// Optional element 'ns2:Dot1X' of XSD type 'ns2:ReferenceToken'
        std::string *Dot1X;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:Dot11SecurityConfigurationExtension'
        ns2__Dot11SecurityConfigurationExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Dot11SecurityConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Dot11SecurityConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Dot11SecurityConfiguration, default initialized and not managed by a soap context
        virtual ns2__Dot11SecurityConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__Dot11SecurityConfiguration); }
      public:
        /// Constructor with initializations
        ns2__Dot11SecurityConfiguration()
        {
          Mode = (ns2__Dot11SecurityMode)0;
          Algorithm = (ns2__Dot11Cipher *)0;
          PSK = (ns2__Dot11PSKSet *)0;
          Dot1X = (std::string *)0;
          Extension = (ns2__Dot11SecurityConfigurationExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Dot11SecurityConfiguration() { }
        /// Friend allocator used by soap_new_ns2__Dot11SecurityConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__Dot11SecurityConfiguration * SOAP_FMAC2 soap_instantiate_ns2__Dot11SecurityConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1207 */
#ifndef SOAP_TYPE_ns2__Dot11SecurityConfigurationExtension
#define SOAP_TYPE_ns2__Dot11SecurityConfigurationExtension (553)
/* complex XSD type 'ns2:Dot11SecurityConfigurationExtension': */
class SOAP_CMAC ns2__Dot11SecurityConfigurationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Dot11SecurityConfigurationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Dot11SecurityConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Dot11SecurityConfigurationExtension, default initialized and not managed by a soap context
        virtual ns2__Dot11SecurityConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__Dot11SecurityConfigurationExtension); }
      public:
        /// Constructor with initializations
        ns2__Dot11SecurityConfigurationExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__Dot11SecurityConfigurationExtension() { }
        /// Friend allocator used by soap_new_ns2__Dot11SecurityConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__Dot11SecurityConfigurationExtension * SOAP_FMAC2 soap_instantiate_ns2__Dot11SecurityConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1210 */
#ifndef SOAP_TYPE_ns2__Dot11PSKSet
#define SOAP_TYPE_ns2__Dot11PSKSet (554)
/* complex XSD type 'ns2:Dot11PSKSet': */
class SOAP_CMAC ns2__Dot11PSKSet {
      public:
        /// Optional element 'ns2:Key' of XSD type 'ns2:Dot11PSK'
        xsd__hexBinary *Key;
        /// Optional element 'ns2:Passphrase' of XSD type 'ns2:Dot11PSKPassphrase'
        std::string *Passphrase;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:Dot11PSKSetExtension'
        ns2__Dot11PSKSetExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Dot11PSKSet
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Dot11PSKSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Dot11PSKSet, default initialized and not managed by a soap context
        virtual ns2__Dot11PSKSet *soap_alloc(void) const { return SOAP_NEW(ns2__Dot11PSKSet); }
      public:
        /// Constructor with initializations
        ns2__Dot11PSKSet()
        {
          Key = (xsd__hexBinary *)0;
          Passphrase = (std::string *)0;
          Extension = (ns2__Dot11PSKSetExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Dot11PSKSet() { }
        /// Friend allocator used by soap_new_ns2__Dot11PSKSet(struct soap*, int)
        friend SOAP_FMAC1 ns2__Dot11PSKSet * SOAP_FMAC2 soap_instantiate_ns2__Dot11PSKSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1213 */
#ifndef SOAP_TYPE_ns2__Dot11PSKSetExtension
#define SOAP_TYPE_ns2__Dot11PSKSetExtension (555)
/* complex XSD type 'ns2:Dot11PSKSetExtension': */
class SOAP_CMAC ns2__Dot11PSKSetExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Dot11PSKSetExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Dot11PSKSetExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Dot11PSKSetExtension, default initialized and not managed by a soap context
        virtual ns2__Dot11PSKSetExtension *soap_alloc(void) const { return SOAP_NEW(ns2__Dot11PSKSetExtension); }
      public:
        /// Constructor with initializations
        ns2__Dot11PSKSetExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__Dot11PSKSetExtension() { }
        /// Friend allocator used by soap_new_ns2__Dot11PSKSetExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__Dot11PSKSetExtension * SOAP_FMAC2 soap_instantiate_ns2__Dot11PSKSetExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1216 */
#ifndef SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension2
#define SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension2 (556)
/* complex XSD type 'ns2:NetworkInterfaceSetConfigurationExtension2': */
class SOAP_CMAC ns2__NetworkInterfaceSetConfigurationExtension2 {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NetworkInterfaceSetConfigurationExtension2, default initialized and not managed by a soap context
        virtual ns2__NetworkInterfaceSetConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW(ns2__NetworkInterfaceSetConfigurationExtension2); }
      public:
        /// Constructor with initializations
        ns2__NetworkInterfaceSetConfigurationExtension2()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__NetworkInterfaceSetConfigurationExtension2() { }
        /// Friend allocator used by soap_new_ns2__NetworkInterfaceSetConfigurationExtension2(struct soap*, int)
        friend SOAP_FMAC1 ns2__NetworkInterfaceSetConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_ns2__NetworkInterfaceSetConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1219 */
#ifndef SOAP_TYPE_ns2__Dot11Capabilities
#define SOAP_TYPE_ns2__Dot11Capabilities (557)
/* complex XSD type 'ns2:Dot11Capabilities': */
class SOAP_CMAC ns2__Dot11Capabilities {
      public:
        /// Required element 'ns2:TKIP' of XSD type 'xsd:boolean'
        bool TKIP;
        /// Required element 'ns2:ScanAvailableNetworks' of XSD type 'xsd:boolean'
        bool ScanAvailableNetworks;
        /// Required element 'ns2:MultipleConfiguration' of XSD type 'xsd:boolean'
        bool MultipleConfiguration;
        /// Required element 'ns2:AdHocStationMode' of XSD type 'xsd:boolean'
        bool AdHocStationMode;
        /// Required element 'ns2:WEP' of XSD type 'xsd:boolean'
        bool WEP;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Dot11Capabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Dot11Capabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Dot11Capabilities, default initialized and not managed by a soap context
        virtual ns2__Dot11Capabilities *soap_alloc(void) const { return SOAP_NEW(ns2__Dot11Capabilities); }
      public:
        /// Constructor with initializations
        ns2__Dot11Capabilities()
        {
          TKIP = (bool)0;
          ScanAvailableNetworks = (bool)0;
          MultipleConfiguration = (bool)0;
          AdHocStationMode = (bool)0;
          WEP = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Dot11Capabilities() { }
        /// Friend allocator used by soap_new_ns2__Dot11Capabilities(struct soap*, int)
        friend SOAP_FMAC1 ns2__Dot11Capabilities * SOAP_FMAC2 soap_instantiate_ns2__Dot11Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1222 */
#ifndef SOAP_TYPE_ns2__Dot11Status
#define SOAP_TYPE_ns2__Dot11Status (558)
/* complex XSD type 'ns2:Dot11Status': */
class SOAP_CMAC ns2__Dot11Status {
      public:
        /// Required element 'ns2:SSID' of XSD type 'ns2:Dot11SSIDType'
        xsd__hexBinary SSID;
        /// Optional element 'ns2:BSSID' of XSD type 'xsd:string'
        std::string *BSSID;
        /// Optional element 'ns2:PairCipher' of XSD type 'ns2:Dot11Cipher'
        ns2__Dot11Cipher *PairCipher;
        /// Optional element 'ns2:GroupCipher' of XSD type 'ns2:Dot11Cipher'
        ns2__Dot11Cipher *GroupCipher;
        /// Optional element 'ns2:SignalStrength' of XSD type 'ns2:Dot11SignalStrength'
        ns2__Dot11SignalStrength *SignalStrength;
        /// Required element 'ns2:ActiveConfigAlias' of XSD type 'ns2:ReferenceToken'
        std::string ActiveConfigAlias;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Dot11Status
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Dot11Status; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Dot11Status, default initialized and not managed by a soap context
        virtual ns2__Dot11Status *soap_alloc(void) const { return SOAP_NEW(ns2__Dot11Status); }
      public:
        /// Constructor with initializations
        ns2__Dot11Status()
        {
          BSSID = (std::string *)0;
          PairCipher = (ns2__Dot11Cipher *)0;
          GroupCipher = (ns2__Dot11Cipher *)0;
          SignalStrength = (ns2__Dot11SignalStrength *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Dot11Status() { }
        /// Friend allocator used by soap_new_ns2__Dot11Status(struct soap*, int)
        friend SOAP_FMAC1 ns2__Dot11Status * SOAP_FMAC2 soap_instantiate_ns2__Dot11Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1225 */
#ifndef SOAP_TYPE_ns2__Dot11AvailableNetworks
#define SOAP_TYPE_ns2__Dot11AvailableNetworks (559)
/* complex XSD type 'ns2:Dot11AvailableNetworks': */
class SOAP_CMAC ns2__Dot11AvailableNetworks {
      public:
        /// Required element 'ns2:SSID' of XSD type 'ns2:Dot11SSIDType'
        xsd__hexBinary SSID;
        /// Optional element 'ns2:BSSID' of XSD type 'xsd:string'
        std::string *BSSID;
        /// Optional element 'ns2:AuthAndMangementSuite' of XSD type 'ns2:Dot11AuthAndMangementSuite'
        std::vector<ns2__Dot11AuthAndMangementSuite> AuthAndMangementSuite;
        /// Optional element 'ns2:PairCipher' of XSD type 'ns2:Dot11Cipher'
        std::vector<ns2__Dot11Cipher> PairCipher;
        /// Optional element 'ns2:GroupCipher' of XSD type 'ns2:Dot11Cipher'
        std::vector<ns2__Dot11Cipher> GroupCipher;
        /// Optional element 'ns2:SignalStrength' of XSD type 'ns2:Dot11SignalStrength'
        ns2__Dot11SignalStrength *SignalStrength;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:Dot11AvailableNetworksExtension'
        ns2__Dot11AvailableNetworksExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Dot11AvailableNetworks
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Dot11AvailableNetworks; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Dot11AvailableNetworks, default initialized and not managed by a soap context
        virtual ns2__Dot11AvailableNetworks *soap_alloc(void) const { return SOAP_NEW(ns2__Dot11AvailableNetworks); }
      public:
        /// Constructor with initializations
        ns2__Dot11AvailableNetworks()
        {
          BSSID = (std::string *)0;
          SignalStrength = (ns2__Dot11SignalStrength *)0;
          Extension = (ns2__Dot11AvailableNetworksExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Dot11AvailableNetworks() { }
        /// Friend allocator used by soap_new_ns2__Dot11AvailableNetworks(struct soap*, int)
        friend SOAP_FMAC1 ns2__Dot11AvailableNetworks * SOAP_FMAC2 soap_instantiate_ns2__Dot11AvailableNetworks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1228 */
#ifndef SOAP_TYPE_ns2__Dot11AvailableNetworksExtension
#define SOAP_TYPE_ns2__Dot11AvailableNetworksExtension (560)
/* complex XSD type 'ns2:Dot11AvailableNetworksExtension': */
class SOAP_CMAC ns2__Dot11AvailableNetworksExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Dot11AvailableNetworksExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Dot11AvailableNetworksExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Dot11AvailableNetworksExtension, default initialized and not managed by a soap context
        virtual ns2__Dot11AvailableNetworksExtension *soap_alloc(void) const { return SOAP_NEW(ns2__Dot11AvailableNetworksExtension); }
      public:
        /// Constructor with initializations
        ns2__Dot11AvailableNetworksExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__Dot11AvailableNetworksExtension() { }
        /// Friend allocator used by soap_new_ns2__Dot11AvailableNetworksExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__Dot11AvailableNetworksExtension * SOAP_FMAC2 soap_instantiate_ns2__Dot11AvailableNetworksExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1231 */
#ifndef SOAP_TYPE_ns2__Capabilities
#define SOAP_TYPE_ns2__Capabilities (561)
/* complex XSD type 'ns2:Capabilities': */
class SOAP_CMAC ns2__Capabilities {
      public:
        /// Optional element 'ns2:Analytics' of XSD type 'ns2:AnalyticsCapabilities'
        ns2__AnalyticsCapabilities *Analytics;
        /// Optional element 'ns2:Device' of XSD type 'ns2:DeviceCapabilities'
        ns2__DeviceCapabilities *Device;
        /// Optional element 'ns2:Events' of XSD type 'ns2:EventCapabilities'
        ns2__EventCapabilities *Events;
        /// Optional element 'ns2:Imaging' of XSD type 'ns2:ImagingCapabilities'
        ns2__ImagingCapabilities *Imaging;
        /// Optional element 'ns2:Media' of XSD type 'ns2:MediaCapabilities'
        ns2__MediaCapabilities *Media;
        /// Optional element 'ns2:PTZ' of XSD type 'ns2:PTZCapabilities'
        ns2__PTZCapabilities *PTZ;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:CapabilitiesExtension'
        ns2__CapabilitiesExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Capabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Capabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Capabilities, default initialized and not managed by a soap context
        virtual ns2__Capabilities *soap_alloc(void) const { return SOAP_NEW(ns2__Capabilities); }
      public:
        /// Constructor with initializations
        ns2__Capabilities()
        {
          Analytics = (ns2__AnalyticsCapabilities *)0;
          Device = (ns2__DeviceCapabilities *)0;
          Events = (ns2__EventCapabilities *)0;
          Imaging = (ns2__ImagingCapabilities *)0;
          Media = (ns2__MediaCapabilities *)0;
          PTZ = (ns2__PTZCapabilities *)0;
          Extension = (ns2__CapabilitiesExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Capabilities() { }
        /// Friend allocator used by soap_new_ns2__Capabilities(struct soap*, int)
        friend SOAP_FMAC1 ns2__Capabilities * SOAP_FMAC2 soap_instantiate_ns2__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1234 */
#ifndef SOAP_TYPE_ns2__CapabilitiesExtension
#define SOAP_TYPE_ns2__CapabilitiesExtension (562)
/* complex XSD type 'ns2:CapabilitiesExtension': */
class SOAP_CMAC ns2__CapabilitiesExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional element 'ns2:DeviceIO' of XSD type 'ns2:DeviceIOCapabilities'
        ns2__DeviceIOCapabilities *DeviceIO;
        /// Optional element 'ns2:Display' of XSD type 'ns2:DisplayCapabilities'
        ns2__DisplayCapabilities *Display;
        /// Optional element 'ns2:Recording' of XSD type 'ns2:RecordingCapabilities'
        ns2__RecordingCapabilities *Recording;
        /// Optional element 'ns2:Search' of XSD type 'ns2:SearchCapabilities'
        ns2__SearchCapabilities *Search;
        /// Optional element 'ns2:Replay' of XSD type 'ns2:ReplayCapabilities'
        ns2__ReplayCapabilities *Replay;
        /// Optional element 'ns2:Receiver' of XSD type 'ns2:ReceiverCapabilities'
        ns2__ReceiverCapabilities *Receiver;
        /// Optional element 'ns2:AnalyticsDevice' of XSD type 'ns2:AnalyticsDeviceCapabilities'
        ns2__AnalyticsDeviceCapabilities *AnalyticsDevice;
        /// Optional element 'ns2:Extensions' of XSD type 'ns2:CapabilitiesExtension2'
        ns2__CapabilitiesExtension2 *Extensions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CapabilitiesExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CapabilitiesExtension, default initialized and not managed by a soap context
        virtual ns2__CapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(ns2__CapabilitiesExtension); }
      public:
        /// Constructor with initializations
        ns2__CapabilitiesExtension()
        {
          DeviceIO = (ns2__DeviceIOCapabilities *)0;
          Display = (ns2__DisplayCapabilities *)0;
          Recording = (ns2__RecordingCapabilities *)0;
          Search = (ns2__SearchCapabilities *)0;
          Replay = (ns2__ReplayCapabilities *)0;
          Receiver = (ns2__ReceiverCapabilities *)0;
          AnalyticsDevice = (ns2__AnalyticsDeviceCapabilities *)0;
          Extensions = (ns2__CapabilitiesExtension2 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CapabilitiesExtension() { }
        /// Friend allocator used by soap_new_ns2__CapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__CapabilitiesExtension * SOAP_FMAC2 soap_instantiate_ns2__CapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1237 */
#ifndef SOAP_TYPE_ns2__CapabilitiesExtension2
#define SOAP_TYPE_ns2__CapabilitiesExtension2 (563)
/* complex XSD type 'ns2:CapabilitiesExtension2': */
class SOAP_CMAC ns2__CapabilitiesExtension2 {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CapabilitiesExtension2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CapabilitiesExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CapabilitiesExtension2, default initialized and not managed by a soap context
        virtual ns2__CapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(ns2__CapabilitiesExtension2); }
      public:
        /// Constructor with initializations
        ns2__CapabilitiesExtension2()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__CapabilitiesExtension2() { }
        /// Friend allocator used by soap_new_ns2__CapabilitiesExtension2(struct soap*, int)
        friend SOAP_FMAC1 ns2__CapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_ns2__CapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1240 */
#ifndef SOAP_TYPE_ns2__AnalyticsCapabilities
#define SOAP_TYPE_ns2__AnalyticsCapabilities (564)
/* complex XSD type 'ns2:AnalyticsCapabilities': */
class SOAP_CMAC ns2__AnalyticsCapabilities {
      public:
        /// Required element 'ns2:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Required element 'ns2:RuleSupport' of XSD type 'xsd:boolean'
        bool RuleSupport;
        /// Required element 'ns2:AnalyticsModuleSupport' of XSD type 'xsd:boolean'
        bool AnalyticsModuleSupport;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AnalyticsCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AnalyticsCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AnalyticsCapabilities, default initialized and not managed by a soap context
        virtual ns2__AnalyticsCapabilities *soap_alloc(void) const { return SOAP_NEW(ns2__AnalyticsCapabilities); }
      public:
        /// Constructor with initializations
        ns2__AnalyticsCapabilities()
        {
          RuleSupport = (bool)0;
          AnalyticsModuleSupport = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AnalyticsCapabilities() { }
        /// Friend allocator used by soap_new_ns2__AnalyticsCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns2__AnalyticsCapabilities * SOAP_FMAC2 soap_instantiate_ns2__AnalyticsCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1243 */
#ifndef SOAP_TYPE_ns2__DeviceCapabilities
#define SOAP_TYPE_ns2__DeviceCapabilities (565)
/* complex XSD type 'ns2:DeviceCapabilities': */
class SOAP_CMAC ns2__DeviceCapabilities {
      public:
        /// Required element 'ns2:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Optional element 'ns2:Network' of XSD type 'ns2:NetworkCapabilities'
        ns2__NetworkCapabilities *Network;
        /// Optional element 'ns2:System' of XSD type 'ns2:SystemCapabilities'
        ns2__SystemCapabilities *System;
        /// Optional element 'ns2:IO' of XSD type 'ns2:IOCapabilities'
        ns2__IOCapabilities *IO;
        /// Optional element 'ns2:Security' of XSD type 'ns2:SecurityCapabilities'
        ns2__SecurityCapabilities *Security;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:DeviceCapabilitiesExtension'
        ns2__DeviceCapabilitiesExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DeviceCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DeviceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DeviceCapabilities, default initialized and not managed by a soap context
        virtual ns2__DeviceCapabilities *soap_alloc(void) const { return SOAP_NEW(ns2__DeviceCapabilities); }
      public:
        /// Constructor with initializations
        ns2__DeviceCapabilities()
        {
          Network = (ns2__NetworkCapabilities *)0;
          System = (ns2__SystemCapabilities *)0;
          IO = (ns2__IOCapabilities *)0;
          Security = (ns2__SecurityCapabilities *)0;
          Extension = (ns2__DeviceCapabilitiesExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DeviceCapabilities() { }
        /// Friend allocator used by soap_new_ns2__DeviceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns2__DeviceCapabilities * SOAP_FMAC2 soap_instantiate_ns2__DeviceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1246 */
#ifndef SOAP_TYPE_ns2__DeviceCapabilitiesExtension
#define SOAP_TYPE_ns2__DeviceCapabilitiesExtension (566)
/* complex XSD type 'ns2:DeviceCapabilitiesExtension': */
class SOAP_CMAC ns2__DeviceCapabilitiesExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DeviceCapabilitiesExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DeviceCapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DeviceCapabilitiesExtension, default initialized and not managed by a soap context
        virtual ns2__DeviceCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(ns2__DeviceCapabilitiesExtension); }
      public:
        /// Constructor with initializations
        ns2__DeviceCapabilitiesExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__DeviceCapabilitiesExtension() { }
        /// Friend allocator used by soap_new_ns2__DeviceCapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__DeviceCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_ns2__DeviceCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1249 */
#ifndef SOAP_TYPE_ns2__EventCapabilities
#define SOAP_TYPE_ns2__EventCapabilities (567)
/* complex XSD type 'ns2:EventCapabilities': */
class SOAP_CMAC ns2__EventCapabilities {
      public:
        /// Required element 'ns2:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Required element 'ns2:WSSubscriptionPolicySupport' of XSD type 'xsd:boolean'
        bool WSSubscriptionPolicySupport;
        /// Required element 'ns2:WSPullPointSupport' of XSD type 'xsd:boolean'
        bool WSPullPointSupport;
        /// Required element 'ns2:WSPausableSubscriptionManagerInterfaceSupport' of XSD type 'xsd:boolean'
        bool WSPausableSubscriptionManagerInterfaceSupport;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__EventCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__EventCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__EventCapabilities, default initialized and not managed by a soap context
        virtual ns2__EventCapabilities *soap_alloc(void) const { return SOAP_NEW(ns2__EventCapabilities); }
      public:
        /// Constructor with initializations
        ns2__EventCapabilities()
        {
          WSSubscriptionPolicySupport = (bool)0;
          WSPullPointSupport = (bool)0;
          WSPausableSubscriptionManagerInterfaceSupport = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__EventCapabilities() { }
        /// Friend allocator used by soap_new_ns2__EventCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns2__EventCapabilities * SOAP_FMAC2 soap_instantiate_ns2__EventCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1252 */
#ifndef SOAP_TYPE_ns2__IOCapabilities
#define SOAP_TYPE_ns2__IOCapabilities (568)
/* complex XSD type 'ns2:IOCapabilities': */
class SOAP_CMAC ns2__IOCapabilities {
      public:
        /// Optional element 'ns2:InputConnectors' of XSD type 'xsd:int'
        int *InputConnectors;
        /// Optional element 'ns2:RelayOutputs' of XSD type 'xsd:int'
        int *RelayOutputs;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:IOCapabilitiesExtension'
        ns2__IOCapabilitiesExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__IOCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__IOCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__IOCapabilities, default initialized and not managed by a soap context
        virtual ns2__IOCapabilities *soap_alloc(void) const { return SOAP_NEW(ns2__IOCapabilities); }
      public:
        /// Constructor with initializations
        ns2__IOCapabilities()
        {
          InputConnectors = (int *)0;
          RelayOutputs = (int *)0;
          Extension = (ns2__IOCapabilitiesExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__IOCapabilities() { }
        /// Friend allocator used by soap_new_ns2__IOCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns2__IOCapabilities * SOAP_FMAC2 soap_instantiate_ns2__IOCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1255 */
#ifndef SOAP_TYPE_ns2__IOCapabilitiesExtension
#define SOAP_TYPE_ns2__IOCapabilitiesExtension (569)
/* complex XSD type 'ns2:IOCapabilitiesExtension': */
class SOAP_CMAC ns2__IOCapabilitiesExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional element 'ns2:Auxiliary' of XSD type 'xsd:boolean'
        bool *Auxiliary;
        /// Optional element 'ns2:AuxiliaryCommands' of XSD type 'ns2:AuxiliaryData'
        std::vector<std::string> AuxiliaryCommands;
        /// Required element 'ns2:Extension' of XSD type 'ns2:IOCapabilitiesExtension2'
        ns2__IOCapabilitiesExtension2 *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__IOCapabilitiesExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__IOCapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__IOCapabilitiesExtension, default initialized and not managed by a soap context
        virtual ns2__IOCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(ns2__IOCapabilitiesExtension); }
      public:
        /// Constructor with initializations
        ns2__IOCapabilitiesExtension()
        {
          Auxiliary = (bool *)0;
          Extension = (ns2__IOCapabilitiesExtension2 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__IOCapabilitiesExtension() { }
        /// Friend allocator used by soap_new_ns2__IOCapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__IOCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_ns2__IOCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1258 */
#ifndef SOAP_TYPE_ns2__IOCapabilitiesExtension2
#define SOAP_TYPE_ns2__IOCapabilitiesExtension2 (570)
/* complex XSD type 'ns2:IOCapabilitiesExtension2': */
class SOAP_CMAC ns2__IOCapabilitiesExtension2 {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__IOCapabilitiesExtension2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__IOCapabilitiesExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__IOCapabilitiesExtension2, default initialized and not managed by a soap context
        virtual ns2__IOCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(ns2__IOCapabilitiesExtension2); }
      public:
        /// Constructor with initializations
        ns2__IOCapabilitiesExtension2()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__IOCapabilitiesExtension2() { }
        /// Friend allocator used by soap_new_ns2__IOCapabilitiesExtension2(struct soap*, int)
        friend SOAP_FMAC1 ns2__IOCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_ns2__IOCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1261 */
#ifndef SOAP_TYPE_ns2__MediaCapabilities
#define SOAP_TYPE_ns2__MediaCapabilities (571)
/* complex XSD type 'ns2:MediaCapabilities': */
class SOAP_CMAC ns2__MediaCapabilities {
      public:
        /// Required element 'ns2:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Required element 'ns2:StreamingCapabilities' of XSD type 'ns2:RealTimeStreamingCapabilities'
        ns2__RealTimeStreamingCapabilities *StreamingCapabilities;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:MediaCapabilitiesExtension'
        ns2__MediaCapabilitiesExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MediaCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MediaCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MediaCapabilities, default initialized and not managed by a soap context
        virtual ns2__MediaCapabilities *soap_alloc(void) const { return SOAP_NEW(ns2__MediaCapabilities); }
      public:
        /// Constructor with initializations
        ns2__MediaCapabilities()
        {
          StreamingCapabilities = (ns2__RealTimeStreamingCapabilities *)0;
          Extension = (ns2__MediaCapabilitiesExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__MediaCapabilities() { }
        /// Friend allocator used by soap_new_ns2__MediaCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns2__MediaCapabilities * SOAP_FMAC2 soap_instantiate_ns2__MediaCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1264 */
#ifndef SOAP_TYPE_ns2__MediaCapabilitiesExtension
#define SOAP_TYPE_ns2__MediaCapabilitiesExtension (572)
/* complex XSD type 'ns2:MediaCapabilitiesExtension': */
class SOAP_CMAC ns2__MediaCapabilitiesExtension {
      public:
        /// Required element 'ns2:ProfileCapabilities' of XSD type 'ns2:ProfileCapabilities'
        ns2__ProfileCapabilities *ProfileCapabilities;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MediaCapabilitiesExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MediaCapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MediaCapabilitiesExtension, default initialized and not managed by a soap context
        virtual ns2__MediaCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(ns2__MediaCapabilitiesExtension); }
      public:
        /// Constructor with initializations
        ns2__MediaCapabilitiesExtension()
        {
          ProfileCapabilities = (ns2__ProfileCapabilities *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__MediaCapabilitiesExtension() { }
        /// Friend allocator used by soap_new_ns2__MediaCapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__MediaCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_ns2__MediaCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1267 */
#ifndef SOAP_TYPE_ns2__RealTimeStreamingCapabilities
#define SOAP_TYPE_ns2__RealTimeStreamingCapabilities (573)
/* complex XSD type 'ns2:RealTimeStreamingCapabilities': */
class SOAP_CMAC ns2__RealTimeStreamingCapabilities {
      public:
        /// Optional element 'ns2:RTPMulticast' of XSD type 'xsd:boolean'
        bool *RTPMulticast;
        /// Optional element 'ns2:RTP_TCP' of XSD type 'xsd:boolean'
        bool *RTP_USCORETCP;
        /// Optional element 'ns2:RTP_RTSP_TCP' of XSD type 'xsd:boolean'
        bool *RTP_USCORERTSP_USCORETCP;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:RealTimeStreamingCapabilitiesExtension'
        ns2__RealTimeStreamingCapabilitiesExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RealTimeStreamingCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RealTimeStreamingCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RealTimeStreamingCapabilities, default initialized and not managed by a soap context
        virtual ns2__RealTimeStreamingCapabilities *soap_alloc(void) const { return SOAP_NEW(ns2__RealTimeStreamingCapabilities); }
      public:
        /// Constructor with initializations
        ns2__RealTimeStreamingCapabilities()
        {
          RTPMulticast = (bool *)0;
          RTP_USCORETCP = (bool *)0;
          RTP_USCORERTSP_USCORETCP = (bool *)0;
          Extension = (ns2__RealTimeStreamingCapabilitiesExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__RealTimeStreamingCapabilities() { }
        /// Friend allocator used by soap_new_ns2__RealTimeStreamingCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns2__RealTimeStreamingCapabilities * SOAP_FMAC2 soap_instantiate_ns2__RealTimeStreamingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1270 */
#ifndef SOAP_TYPE_ns2__RealTimeStreamingCapabilitiesExtension
#define SOAP_TYPE_ns2__RealTimeStreamingCapabilitiesExtension (574)
/* complex XSD type 'ns2:RealTimeStreamingCapabilitiesExtension': */
class SOAP_CMAC ns2__RealTimeStreamingCapabilitiesExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RealTimeStreamingCapabilitiesExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RealTimeStreamingCapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RealTimeStreamingCapabilitiesExtension, default initialized and not managed by a soap context
        virtual ns2__RealTimeStreamingCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(ns2__RealTimeStreamingCapabilitiesExtension); }
      public:
        /// Constructor with initializations
        ns2__RealTimeStreamingCapabilitiesExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__RealTimeStreamingCapabilitiesExtension() { }
        /// Friend allocator used by soap_new_ns2__RealTimeStreamingCapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_ns2__RealTimeStreamingCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1273 */
#ifndef SOAP_TYPE_ns2__ProfileCapabilities
#define SOAP_TYPE_ns2__ProfileCapabilities (575)
/* complex XSD type 'ns2:ProfileCapabilities': */
class SOAP_CMAC ns2__ProfileCapabilities {
      public:
        /// Required element 'ns2:MaximumNumberOfProfiles' of XSD type 'xsd:int'
        int MaximumNumberOfProfiles;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ProfileCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ProfileCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ProfileCapabilities, default initialized and not managed by a soap context
        virtual ns2__ProfileCapabilities *soap_alloc(void) const { return SOAP_NEW(ns2__ProfileCapabilities); }
      public:
        /// Constructor with initializations
        ns2__ProfileCapabilities()
        {
          MaximumNumberOfProfiles = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ProfileCapabilities() { }
        /// Friend allocator used by soap_new_ns2__ProfileCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns2__ProfileCapabilities * SOAP_FMAC2 soap_instantiate_ns2__ProfileCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1276 */
#ifndef SOAP_TYPE_ns2__NetworkCapabilities
#define SOAP_TYPE_ns2__NetworkCapabilities (576)
/* complex XSD type 'ns2:NetworkCapabilities': */
class SOAP_CMAC ns2__NetworkCapabilities {
      public:
        /// Optional element 'ns2:IPFilter' of XSD type 'xsd:boolean'
        bool *IPFilter;
        /// Optional element 'ns2:ZeroConfiguration' of XSD type 'xsd:boolean'
        bool *ZeroConfiguration;
        /// Optional element 'ns2:IPVersion6' of XSD type 'xsd:boolean'
        bool *IPVersion6;
        /// Optional element 'ns2:DynDNS' of XSD type 'xsd:boolean'
        bool *DynDNS;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:NetworkCapabilitiesExtension'
        ns2__NetworkCapabilitiesExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NetworkCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NetworkCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NetworkCapabilities, default initialized and not managed by a soap context
        virtual ns2__NetworkCapabilities *soap_alloc(void) const { return SOAP_NEW(ns2__NetworkCapabilities); }
      public:
        /// Constructor with initializations
        ns2__NetworkCapabilities()
        {
          IPFilter = (bool *)0;
          ZeroConfiguration = (bool *)0;
          IPVersion6 = (bool *)0;
          DynDNS = (bool *)0;
          Extension = (ns2__NetworkCapabilitiesExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__NetworkCapabilities() { }
        /// Friend allocator used by soap_new_ns2__NetworkCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns2__NetworkCapabilities * SOAP_FMAC2 soap_instantiate_ns2__NetworkCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1279 */
#ifndef SOAP_TYPE_ns2__NetworkCapabilitiesExtension
#define SOAP_TYPE_ns2__NetworkCapabilitiesExtension (577)
/* complex XSD type 'ns2:NetworkCapabilitiesExtension': */
class SOAP_CMAC ns2__NetworkCapabilitiesExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional element 'ns2:Dot11Configuration' of XSD type 'xsd:boolean'
        bool *Dot11Configuration;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:NetworkCapabilitiesExtension2'
        ns2__NetworkCapabilitiesExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NetworkCapabilitiesExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NetworkCapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NetworkCapabilitiesExtension, default initialized and not managed by a soap context
        virtual ns2__NetworkCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(ns2__NetworkCapabilitiesExtension); }
      public:
        /// Constructor with initializations
        ns2__NetworkCapabilitiesExtension()
        {
          Dot11Configuration = (bool *)0;
          Extension = (ns2__NetworkCapabilitiesExtension2 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__NetworkCapabilitiesExtension() { }
        /// Friend allocator used by soap_new_ns2__NetworkCapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__NetworkCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_ns2__NetworkCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1282 */
#ifndef SOAP_TYPE_ns2__NetworkCapabilitiesExtension2
#define SOAP_TYPE_ns2__NetworkCapabilitiesExtension2 (578)
/* complex XSD type 'ns2:NetworkCapabilitiesExtension2': */
class SOAP_CMAC ns2__NetworkCapabilitiesExtension2 {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NetworkCapabilitiesExtension2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NetworkCapabilitiesExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NetworkCapabilitiesExtension2, default initialized and not managed by a soap context
        virtual ns2__NetworkCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(ns2__NetworkCapabilitiesExtension2); }
      public:
        /// Constructor with initializations
        ns2__NetworkCapabilitiesExtension2()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__NetworkCapabilitiesExtension2() { }
        /// Friend allocator used by soap_new_ns2__NetworkCapabilitiesExtension2(struct soap*, int)
        friend SOAP_FMAC1 ns2__NetworkCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_ns2__NetworkCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1285 */
#ifndef SOAP_TYPE_ns2__SecurityCapabilities
#define SOAP_TYPE_ns2__SecurityCapabilities (579)
/* complex XSD type 'ns2:SecurityCapabilities': */
class SOAP_CMAC ns2__SecurityCapabilities {
      public:
        /// Required element 'ns2:TLS1.1' of XSD type 'xsd:boolean'
        bool TLS1_x002e1;
        /// Required element 'ns2:TLS1.2' of XSD type 'xsd:boolean'
        bool TLS1_x002e2;
        /// Required element 'ns2:OnboardKeyGeneration' of XSD type 'xsd:boolean'
        bool OnboardKeyGeneration;
        /// Required element 'ns2:AccessPolicyConfig' of XSD type 'xsd:boolean'
        bool AccessPolicyConfig;
        /// Required element 'ns2:X.509Token' of XSD type 'xsd:boolean'
        bool X_x002e509Token;
        /// Required element 'ns2:SAMLToken' of XSD type 'xsd:boolean'
        bool SAMLToken;
        /// Required element 'ns2:KerberosToken' of XSD type 'xsd:boolean'
        bool KerberosToken;
        /// Required element 'ns2:RELToken' of XSD type 'xsd:boolean'
        bool RELToken;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:SecurityCapabilitiesExtension'
        ns2__SecurityCapabilitiesExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SecurityCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SecurityCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SecurityCapabilities, default initialized and not managed by a soap context
        virtual ns2__SecurityCapabilities *soap_alloc(void) const { return SOAP_NEW(ns2__SecurityCapabilities); }
      public:
        /// Constructor with initializations
        ns2__SecurityCapabilities()
        {
          TLS1_x002e1 = (bool)0;
          TLS1_x002e2 = (bool)0;
          OnboardKeyGeneration = (bool)0;
          AccessPolicyConfig = (bool)0;
          X_x002e509Token = (bool)0;
          SAMLToken = (bool)0;
          KerberosToken = (bool)0;
          RELToken = (bool)0;
          Extension = (ns2__SecurityCapabilitiesExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__SecurityCapabilities() { }
        /// Friend allocator used by soap_new_ns2__SecurityCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns2__SecurityCapabilities * SOAP_FMAC2 soap_instantiate_ns2__SecurityCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1288 */
#ifndef SOAP_TYPE_ns2__SecurityCapabilitiesExtension
#define SOAP_TYPE_ns2__SecurityCapabilitiesExtension (580)
/* complex XSD type 'ns2:SecurityCapabilitiesExtension': */
class SOAP_CMAC ns2__SecurityCapabilitiesExtension {
      public:
        /// Required element 'ns2:TLS1.0' of XSD type 'xsd:boolean'
        bool TLS1_x002e0;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:SecurityCapabilitiesExtension2'
        ns2__SecurityCapabilitiesExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SecurityCapabilitiesExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SecurityCapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SecurityCapabilitiesExtension, default initialized and not managed by a soap context
        virtual ns2__SecurityCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(ns2__SecurityCapabilitiesExtension); }
      public:
        /// Constructor with initializations
        ns2__SecurityCapabilitiesExtension()
        {
          TLS1_x002e0 = (bool)0;
          Extension = (ns2__SecurityCapabilitiesExtension2 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__SecurityCapabilitiesExtension() { }
        /// Friend allocator used by soap_new_ns2__SecurityCapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__SecurityCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_ns2__SecurityCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1291 */
#ifndef SOAP_TYPE_ns2__SecurityCapabilitiesExtension2
#define SOAP_TYPE_ns2__SecurityCapabilitiesExtension2 (581)
/* complex XSD type 'ns2:SecurityCapabilitiesExtension2': */
class SOAP_CMAC ns2__SecurityCapabilitiesExtension2 {
      public:
        /// Required element 'ns2:Dot1X' of XSD type 'xsd:boolean'
        bool Dot1X;
        /// Optional element 'ns2:SupportedEAPMethod' of XSD type 'xsd:int'
        std::vector<int> SupportedEAPMethod;
        /// Required element 'ns2:RemoteUserHandling' of XSD type 'xsd:boolean'
        bool RemoteUserHandling;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SecurityCapabilitiesExtension2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SecurityCapabilitiesExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SecurityCapabilitiesExtension2, default initialized and not managed by a soap context
        virtual ns2__SecurityCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(ns2__SecurityCapabilitiesExtension2); }
      public:
        /// Constructor with initializations
        ns2__SecurityCapabilitiesExtension2()
        {
          Dot1X = (bool)0;
          RemoteUserHandling = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__SecurityCapabilitiesExtension2() { }
        /// Friend allocator used by soap_new_ns2__SecurityCapabilitiesExtension2(struct soap*, int)
        friend SOAP_FMAC1 ns2__SecurityCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_ns2__SecurityCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1294 */
#ifndef SOAP_TYPE_ns2__SystemCapabilities
#define SOAP_TYPE_ns2__SystemCapabilities (582)
/* complex XSD type 'ns2:SystemCapabilities': */
class SOAP_CMAC ns2__SystemCapabilities {
      public:
        /// Required element 'ns2:DiscoveryResolve' of XSD type 'xsd:boolean'
        bool DiscoveryResolve;
        /// Required element 'ns2:DiscoveryBye' of XSD type 'xsd:boolean'
        bool DiscoveryBye;
        /// Required element 'ns2:RemoteDiscovery' of XSD type 'xsd:boolean'
        bool RemoteDiscovery;
        /// Required element 'ns2:SystemBackup' of XSD type 'xsd:boolean'
        bool SystemBackup;
        /// Required element 'ns2:SystemLogging' of XSD type 'xsd:boolean'
        bool SystemLogging;
        /// Required element 'ns2:FirmwareUpgrade' of XSD type 'xsd:boolean'
        bool FirmwareUpgrade;
        /// Required element 'ns2:SupportedVersions' of XSD type 'ns2:OnvifVersion'
        std::vector<ns2__OnvifVersion *> SupportedVersions;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:SystemCapabilitiesExtension'
        ns2__SystemCapabilitiesExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SystemCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SystemCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SystemCapabilities, default initialized and not managed by a soap context
        virtual ns2__SystemCapabilities *soap_alloc(void) const { return SOAP_NEW(ns2__SystemCapabilities); }
      public:
        /// Constructor with initializations
        ns2__SystemCapabilities()
        {
          DiscoveryResolve = (bool)0;
          DiscoveryBye = (bool)0;
          RemoteDiscovery = (bool)0;
          SystemBackup = (bool)0;
          SystemLogging = (bool)0;
          FirmwareUpgrade = (bool)0;
          Extension = (ns2__SystemCapabilitiesExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__SystemCapabilities() { }
        /// Friend allocator used by soap_new_ns2__SystemCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns2__SystemCapabilities * SOAP_FMAC2 soap_instantiate_ns2__SystemCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1297 */
#ifndef SOAP_TYPE_ns2__SystemCapabilitiesExtension
#define SOAP_TYPE_ns2__SystemCapabilitiesExtension (583)
/* complex XSD type 'ns2:SystemCapabilitiesExtension': */
class SOAP_CMAC ns2__SystemCapabilitiesExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional element 'ns2:HttpFirmwareUpgrade' of XSD type 'xsd:boolean'
        bool *HttpFirmwareUpgrade;
        /// Optional element 'ns2:HttpSystemBackup' of XSD type 'xsd:boolean'
        bool *HttpSystemBackup;
        /// Optional element 'ns2:HttpSystemLogging' of XSD type 'xsd:boolean'
        bool *HttpSystemLogging;
        /// Optional element 'ns2:HttpSupportInformation' of XSD type 'xsd:boolean'
        bool *HttpSupportInformation;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:SystemCapabilitiesExtension2'
        ns2__SystemCapabilitiesExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SystemCapabilitiesExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SystemCapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SystemCapabilitiesExtension, default initialized and not managed by a soap context
        virtual ns2__SystemCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(ns2__SystemCapabilitiesExtension); }
      public:
        /// Constructor with initializations
        ns2__SystemCapabilitiesExtension()
        {
          HttpFirmwareUpgrade = (bool *)0;
          HttpSystemBackup = (bool *)0;
          HttpSystemLogging = (bool *)0;
          HttpSupportInformation = (bool *)0;
          Extension = (ns2__SystemCapabilitiesExtension2 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__SystemCapabilitiesExtension() { }
        /// Friend allocator used by soap_new_ns2__SystemCapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__SystemCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_ns2__SystemCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1300 */
#ifndef SOAP_TYPE_ns2__SystemCapabilitiesExtension2
#define SOAP_TYPE_ns2__SystemCapabilitiesExtension2 (584)
/* complex XSD type 'ns2:SystemCapabilitiesExtension2': */
class SOAP_CMAC ns2__SystemCapabilitiesExtension2 {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SystemCapabilitiesExtension2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SystemCapabilitiesExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SystemCapabilitiesExtension2, default initialized and not managed by a soap context
        virtual ns2__SystemCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(ns2__SystemCapabilitiesExtension2); }
      public:
        /// Constructor with initializations
        ns2__SystemCapabilitiesExtension2()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__SystemCapabilitiesExtension2() { }
        /// Friend allocator used by soap_new_ns2__SystemCapabilitiesExtension2(struct soap*, int)
        friend SOAP_FMAC1 ns2__SystemCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_ns2__SystemCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1303 */
#ifndef SOAP_TYPE_ns2__OnvifVersion
#define SOAP_TYPE_ns2__OnvifVersion (585)
/* complex XSD type 'ns2:OnvifVersion': */
class SOAP_CMAC ns2__OnvifVersion {
      public:
        /// Required element 'ns2:Major' of XSD type 'xsd:int'
        int Major;
        /// Required element 'ns2:Minor' of XSD type 'xsd:int'
        int Minor;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OnvifVersion
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__OnvifVersion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OnvifVersion, default initialized and not managed by a soap context
        virtual ns2__OnvifVersion *soap_alloc(void) const { return SOAP_NEW(ns2__OnvifVersion); }
      public:
        /// Constructor with initializations
        ns2__OnvifVersion()
        {
          Major = (int)0;
          Minor = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__OnvifVersion() { }
        /// Friend allocator used by soap_new_ns2__OnvifVersion(struct soap*, int)
        friend SOAP_FMAC1 ns2__OnvifVersion * SOAP_FMAC2 soap_instantiate_ns2__OnvifVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1306 */
#ifndef SOAP_TYPE_ns2__ImagingCapabilities
#define SOAP_TYPE_ns2__ImagingCapabilities (586)
/* complex XSD type 'ns2:ImagingCapabilities': */
class SOAP_CMAC ns2__ImagingCapabilities {
      public:
        /// Required element 'ns2:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ImagingCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ImagingCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ImagingCapabilities, default initialized and not managed by a soap context
        virtual ns2__ImagingCapabilities *soap_alloc(void) const { return SOAP_NEW(ns2__ImagingCapabilities); }
      public:
        /// Constructor with initializations
        ns2__ImagingCapabilities()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ImagingCapabilities() { }
        /// Friend allocator used by soap_new_ns2__ImagingCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns2__ImagingCapabilities * SOAP_FMAC2 soap_instantiate_ns2__ImagingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1309 */
#ifndef SOAP_TYPE_ns2__PTZCapabilities
#define SOAP_TYPE_ns2__PTZCapabilities (587)
/* complex XSD type 'ns2:PTZCapabilities': */
class SOAP_CMAC ns2__PTZCapabilities {
      public:
        /// Required element 'ns2:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZCapabilities, default initialized and not managed by a soap context
        virtual ns2__PTZCapabilities *soap_alloc(void) const { return SOAP_NEW(ns2__PTZCapabilities); }
      public:
        /// Constructor with initializations
        ns2__PTZCapabilities()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZCapabilities() { }
        /// Friend allocator used by soap_new_ns2__PTZCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZCapabilities * SOAP_FMAC2 soap_instantiate_ns2__PTZCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1312 */
#ifndef SOAP_TYPE_ns2__DeviceIOCapabilities
#define SOAP_TYPE_ns2__DeviceIOCapabilities (588)
/* complex XSD type 'ns2:DeviceIOCapabilities': */
class SOAP_CMAC ns2__DeviceIOCapabilities {
      public:
        /// Required element 'ns2:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Required element 'ns2:VideoSources' of XSD type 'xsd:int'
        int VideoSources;
        /// Required element 'ns2:VideoOutputs' of XSD type 'xsd:int'
        int VideoOutputs;
        /// Required element 'ns2:AudioSources' of XSD type 'xsd:int'
        int AudioSources;
        /// Required element 'ns2:AudioOutputs' of XSD type 'xsd:int'
        int AudioOutputs;
        /// Required element 'ns2:RelayOutputs' of XSD type 'xsd:int'
        int RelayOutputs;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DeviceIOCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DeviceIOCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DeviceIOCapabilities, default initialized and not managed by a soap context
        virtual ns2__DeviceIOCapabilities *soap_alloc(void) const { return SOAP_NEW(ns2__DeviceIOCapabilities); }
      public:
        /// Constructor with initializations
        ns2__DeviceIOCapabilities()
        {
          VideoSources = (int)0;
          VideoOutputs = (int)0;
          AudioSources = (int)0;
          AudioOutputs = (int)0;
          RelayOutputs = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DeviceIOCapabilities() { }
        /// Friend allocator used by soap_new_ns2__DeviceIOCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns2__DeviceIOCapabilities * SOAP_FMAC2 soap_instantiate_ns2__DeviceIOCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1315 */
#ifndef SOAP_TYPE_ns2__DisplayCapabilities
#define SOAP_TYPE_ns2__DisplayCapabilities (589)
/* complex XSD type 'ns2:DisplayCapabilities': */
class SOAP_CMAC ns2__DisplayCapabilities {
      public:
        /// Required element 'ns2:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Required element 'ns2:FixedLayout' of XSD type 'xsd:boolean'
        bool FixedLayout;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DisplayCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DisplayCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DisplayCapabilities, default initialized and not managed by a soap context
        virtual ns2__DisplayCapabilities *soap_alloc(void) const { return SOAP_NEW(ns2__DisplayCapabilities); }
      public:
        /// Constructor with initializations
        ns2__DisplayCapabilities()
        {
          FixedLayout = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DisplayCapabilities() { }
        /// Friend allocator used by soap_new_ns2__DisplayCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns2__DisplayCapabilities * SOAP_FMAC2 soap_instantiate_ns2__DisplayCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1318 */
#ifndef SOAP_TYPE_ns2__RecordingCapabilities
#define SOAP_TYPE_ns2__RecordingCapabilities (590)
/* complex XSD type 'ns2:RecordingCapabilities': */
class SOAP_CMAC ns2__RecordingCapabilities {
      public:
        /// Required element 'ns2:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Required element 'ns2:ReceiverSource' of XSD type 'xsd:boolean'
        bool ReceiverSource;
        /// Required element 'ns2:MediaProfileSource' of XSD type 'xsd:boolean'
        bool MediaProfileSource;
        /// Required element 'ns2:DynamicRecordings' of XSD type 'xsd:boolean'
        bool DynamicRecordings;
        /// Required element 'ns2:DynamicTracks' of XSD type 'xsd:boolean'
        bool DynamicTracks;
        /// Required element 'ns2:MaxStringLength' of XSD type 'xsd:int'
        int MaxStringLength;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RecordingCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RecordingCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RecordingCapabilities, default initialized and not managed by a soap context
        virtual ns2__RecordingCapabilities *soap_alloc(void) const { return SOAP_NEW(ns2__RecordingCapabilities); }
      public:
        /// Constructor with initializations
        ns2__RecordingCapabilities()
        {
          ReceiverSource = (bool)0;
          MediaProfileSource = (bool)0;
          DynamicRecordings = (bool)0;
          DynamicTracks = (bool)0;
          MaxStringLength = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__RecordingCapabilities() { }
        /// Friend allocator used by soap_new_ns2__RecordingCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns2__RecordingCapabilities * SOAP_FMAC2 soap_instantiate_ns2__RecordingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1321 */
#ifndef SOAP_TYPE_ns2__SearchCapabilities
#define SOAP_TYPE_ns2__SearchCapabilities (591)
/* complex XSD type 'ns2:SearchCapabilities': */
class SOAP_CMAC ns2__SearchCapabilities {
      public:
        /// Required element 'ns2:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Required element 'ns2:MetadataSearch' of XSD type 'xsd:boolean'
        bool MetadataSearch;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SearchCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SearchCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SearchCapabilities, default initialized and not managed by a soap context
        virtual ns2__SearchCapabilities *soap_alloc(void) const { return SOAP_NEW(ns2__SearchCapabilities); }
      public:
        /// Constructor with initializations
        ns2__SearchCapabilities()
        {
          MetadataSearch = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__SearchCapabilities() { }
        /// Friend allocator used by soap_new_ns2__SearchCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns2__SearchCapabilities * SOAP_FMAC2 soap_instantiate_ns2__SearchCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1324 */
#ifndef SOAP_TYPE_ns2__ReplayCapabilities
#define SOAP_TYPE_ns2__ReplayCapabilities (592)
/* complex XSD type 'ns2:ReplayCapabilities': */
class SOAP_CMAC ns2__ReplayCapabilities {
      public:
        /// Required element 'ns2:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ReplayCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ReplayCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ReplayCapabilities, default initialized and not managed by a soap context
        virtual ns2__ReplayCapabilities *soap_alloc(void) const { return SOAP_NEW(ns2__ReplayCapabilities); }
      public:
        /// Constructor with initializations
        ns2__ReplayCapabilities()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ReplayCapabilities() { }
        /// Friend allocator used by soap_new_ns2__ReplayCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns2__ReplayCapabilities * SOAP_FMAC2 soap_instantiate_ns2__ReplayCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1327 */
#ifndef SOAP_TYPE_ns2__ReceiverCapabilities
#define SOAP_TYPE_ns2__ReceiverCapabilities (593)
/* complex XSD type 'ns2:ReceiverCapabilities': */
class SOAP_CMAC ns2__ReceiverCapabilities {
      public:
        /// Required element 'ns2:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Required element 'ns2:RTP_Multicast' of XSD type 'xsd:boolean'
        bool RTP_USCOREMulticast;
        /// Required element 'ns2:RTP_TCP' of XSD type 'xsd:boolean'
        bool RTP_USCORETCP;
        /// Required element 'ns2:RTP_RTSP_TCP' of XSD type 'xsd:boolean'
        bool RTP_USCORERTSP_USCORETCP;
        /// Required element 'ns2:SupportedReceivers' of XSD type 'xsd:int'
        int SupportedReceivers;
        /// Required element 'ns2:MaximumRTSPURILength' of XSD type 'xsd:int'
        int MaximumRTSPURILength;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ReceiverCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ReceiverCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ReceiverCapabilities, default initialized and not managed by a soap context
        virtual ns2__ReceiverCapabilities *soap_alloc(void) const { return SOAP_NEW(ns2__ReceiverCapabilities); }
      public:
        /// Constructor with initializations
        ns2__ReceiverCapabilities()
        {
          RTP_USCOREMulticast = (bool)0;
          RTP_USCORETCP = (bool)0;
          RTP_USCORERTSP_USCORETCP = (bool)0;
          SupportedReceivers = (int)0;
          MaximumRTSPURILength = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ReceiverCapabilities() { }
        /// Friend allocator used by soap_new_ns2__ReceiverCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns2__ReceiverCapabilities * SOAP_FMAC2 soap_instantiate_ns2__ReceiverCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1330 */
#ifndef SOAP_TYPE_ns2__AnalyticsDeviceCapabilities
#define SOAP_TYPE_ns2__AnalyticsDeviceCapabilities (594)
/* complex XSD type 'ns2:AnalyticsDeviceCapabilities': */
class SOAP_CMAC ns2__AnalyticsDeviceCapabilities {
      public:
        /// Required element 'ns2:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Optional element 'ns2:RuleSupport' of XSD type 'xsd:boolean'
        bool *RuleSupport;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:AnalyticsDeviceExtension'
        ns2__AnalyticsDeviceExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AnalyticsDeviceCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AnalyticsDeviceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AnalyticsDeviceCapabilities, default initialized and not managed by a soap context
        virtual ns2__AnalyticsDeviceCapabilities *soap_alloc(void) const { return SOAP_NEW(ns2__AnalyticsDeviceCapabilities); }
      public:
        /// Constructor with initializations
        ns2__AnalyticsDeviceCapabilities()
        {
          RuleSupport = (bool *)0;
          Extension = (ns2__AnalyticsDeviceExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AnalyticsDeviceCapabilities() { }
        /// Friend allocator used by soap_new_ns2__AnalyticsDeviceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns2__AnalyticsDeviceCapabilities * SOAP_FMAC2 soap_instantiate_ns2__AnalyticsDeviceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1333 */
#ifndef SOAP_TYPE_ns2__AnalyticsDeviceExtension
#define SOAP_TYPE_ns2__AnalyticsDeviceExtension (595)
/* complex XSD type 'ns2:AnalyticsDeviceExtension': */
class SOAP_CMAC ns2__AnalyticsDeviceExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AnalyticsDeviceExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AnalyticsDeviceExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AnalyticsDeviceExtension, default initialized and not managed by a soap context
        virtual ns2__AnalyticsDeviceExtension *soap_alloc(void) const { return SOAP_NEW(ns2__AnalyticsDeviceExtension); }
      public:
        /// Constructor with initializations
        ns2__AnalyticsDeviceExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__AnalyticsDeviceExtension() { }
        /// Friend allocator used by soap_new_ns2__AnalyticsDeviceExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__AnalyticsDeviceExtension * SOAP_FMAC2 soap_instantiate_ns2__AnalyticsDeviceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1336 */
#ifndef SOAP_TYPE_ns2__SystemLog
#define SOAP_TYPE_ns2__SystemLog (596)
/* complex XSD type 'ns2:SystemLog': */
class SOAP_CMAC ns2__SystemLog {
      public:
        /// Optional element 'ns2:Binary' of XSD type 'ns2:AttachmentData'
        ns2__AttachmentData *Binary;
        /// Optional element 'ns2:String' of XSD type 'xsd:string'
        std::string *String;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SystemLog
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SystemLog; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SystemLog, default initialized and not managed by a soap context
        virtual ns2__SystemLog *soap_alloc(void) const { return SOAP_NEW(ns2__SystemLog); }
      public:
        /// Constructor with initializations
        ns2__SystemLog()
        {
          Binary = (ns2__AttachmentData *)0;
          String = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__SystemLog() { }
        /// Friend allocator used by soap_new_ns2__SystemLog(struct soap*, int)
        friend SOAP_FMAC1 ns2__SystemLog * SOAP_FMAC2 soap_instantiate_ns2__SystemLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1339 */
#ifndef SOAP_TYPE_ns2__SupportInformation
#define SOAP_TYPE_ns2__SupportInformation (597)
/* complex XSD type 'ns2:SupportInformation': */
class SOAP_CMAC ns2__SupportInformation {
      public:
        /// Optional element 'ns2:Binary' of XSD type 'ns2:AttachmentData'
        ns2__AttachmentData *Binary;
        /// Optional element 'ns2:String' of XSD type 'xsd:string'
        std::string *String;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SupportInformation
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SupportInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SupportInformation, default initialized and not managed by a soap context
        virtual ns2__SupportInformation *soap_alloc(void) const { return SOAP_NEW(ns2__SupportInformation); }
      public:
        /// Constructor with initializations
        ns2__SupportInformation()
        {
          Binary = (ns2__AttachmentData *)0;
          String = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__SupportInformation() { }
        /// Friend allocator used by soap_new_ns2__SupportInformation(struct soap*, int)
        friend SOAP_FMAC1 ns2__SupportInformation * SOAP_FMAC2 soap_instantiate_ns2__SupportInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1342 */
#ifndef SOAP_TYPE_ns2__BinaryData
#define SOAP_TYPE_ns2__BinaryData (598)
/* complex XSD type 'ns2:BinaryData': */
class SOAP_CMAC ns2__BinaryData {
      public:
        /// Required element 'ns2:Data' of XSD type 'xsd:base64Binary'
        xsd__base64Binary Data;
        /// optional attribute 'xmime:contentType' of XSD type 'xmime:contentType'
        std::string *xmime__contentType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BinaryData
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__BinaryData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BinaryData, default initialized and not managed by a soap context
        virtual ns2__BinaryData *soap_alloc(void) const { return SOAP_NEW(ns2__BinaryData); }
      public:
        /// Constructor with initializations
        ns2__BinaryData()
        {
          xmime__contentType = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__BinaryData() { }
        /// Friend allocator used by soap_new_ns2__BinaryData(struct soap*, int)
        friend SOAP_FMAC1 ns2__BinaryData * SOAP_FMAC2 soap_instantiate_ns2__BinaryData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1345 */
#ifndef SOAP_TYPE_ns2__AttachmentData
#define SOAP_TYPE_ns2__AttachmentData (599)
/* complex XSD type 'ns2:AttachmentData': */
class SOAP_CMAC ns2__AttachmentData {
      public:
        /// Required element 'ns4:Include' of XSD type 'ns4:Include'
        ns4__Include *ns4__Include_;
        /// optional attribute 'xmime:contentType' of XSD type 'xmime:contentType'
        std::string *xmime__contentType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AttachmentData
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AttachmentData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AttachmentData, default initialized and not managed by a soap context
        virtual ns2__AttachmentData *soap_alloc(void) const { return SOAP_NEW(ns2__AttachmentData); }
      public:
        /// Constructor with initializations
        ns2__AttachmentData()
        {
          ns4__Include_ = (ns4__Include *)0;
          xmime__contentType = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AttachmentData() { }
        /// Friend allocator used by soap_new_ns2__AttachmentData(struct soap*, int)
        friend SOAP_FMAC1 ns2__AttachmentData * SOAP_FMAC2 soap_instantiate_ns2__AttachmentData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1348 */
#ifndef SOAP_TYPE_ns2__BackupFile
#define SOAP_TYPE_ns2__BackupFile (600)
/* complex XSD type 'ns2:BackupFile': */
class SOAP_CMAC ns2__BackupFile {
      public:
        /// Required element 'ns2:Name' of XSD type 'xsd:string'
        std::string Name;
        /// Required element 'ns2:Data' of XSD type 'ns2:AttachmentData'
        ns2__AttachmentData *Data;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BackupFile
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__BackupFile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BackupFile, default initialized and not managed by a soap context
        virtual ns2__BackupFile *soap_alloc(void) const { return SOAP_NEW(ns2__BackupFile); }
      public:
        /// Constructor with initializations
        ns2__BackupFile()
        {
          Data = (ns2__AttachmentData *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__BackupFile() { }
        /// Friend allocator used by soap_new_ns2__BackupFile(struct soap*, int)
        friend SOAP_FMAC1 ns2__BackupFile * SOAP_FMAC2 soap_instantiate_ns2__BackupFile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1351 */
#ifndef SOAP_TYPE_ns2__SystemLogUriList
#define SOAP_TYPE_ns2__SystemLogUriList (601)
/* complex XSD type 'ns2:SystemLogUriList': */
class SOAP_CMAC ns2__SystemLogUriList {
      public:
        /// Optional element 'ns2:SystemLog' of XSD type 'ns2:SystemLogUri'
        std::vector<ns2__SystemLogUri *> SystemLog;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SystemLogUriList
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SystemLogUriList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SystemLogUriList, default initialized and not managed by a soap context
        virtual ns2__SystemLogUriList *soap_alloc(void) const { return SOAP_NEW(ns2__SystemLogUriList); }
      public:
        /// Constructor with initializations
        ns2__SystemLogUriList()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__SystemLogUriList() { }
        /// Friend allocator used by soap_new_ns2__SystemLogUriList(struct soap*, int)
        friend SOAP_FMAC1 ns2__SystemLogUriList * SOAP_FMAC2 soap_instantiate_ns2__SystemLogUriList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1354 */
#ifndef SOAP_TYPE_ns2__SystemLogUri
#define SOAP_TYPE_ns2__SystemLogUri (602)
/* complex XSD type 'ns2:SystemLogUri': */
class SOAP_CMAC ns2__SystemLogUri {
      public:
        /// Required element 'ns2:Type' of XSD type 'ns2:SystemLogType'
        ns2__SystemLogType Type;
        /// Required element 'ns2:Uri' of XSD type 'xsd:anyURI'
        std::string Uri;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SystemLogUri
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SystemLogUri; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SystemLogUri, default initialized and not managed by a soap context
        virtual ns2__SystemLogUri *soap_alloc(void) const { return SOAP_NEW(ns2__SystemLogUri); }
      public:
        /// Constructor with initializations
        ns2__SystemLogUri()
        {
          Type = (ns2__SystemLogType)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__SystemLogUri() { }
        /// Friend allocator used by soap_new_ns2__SystemLogUri(struct soap*, int)
        friend SOAP_FMAC1 ns2__SystemLogUri * SOAP_FMAC2 soap_instantiate_ns2__SystemLogUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1357 */
#ifndef SOAP_TYPE_ns2__SystemDateTime
#define SOAP_TYPE_ns2__SystemDateTime (603)
/* complex XSD type 'ns2:SystemDateTime': */
class SOAP_CMAC ns2__SystemDateTime {
      public:
        /// Required element 'ns2:DateTimeType' of XSD type 'ns2:SetDateTimeType'
        ns2__SetDateTimeType DateTimeType;
        /// Required element 'ns2:DaylightSavings' of XSD type 'xsd:boolean'
        bool DaylightSavings;
        /// Optional element 'ns2:TimeZone' of XSD type 'ns2:TimeZone'
        ns2__TimeZone *TimeZone;
        /// Optional element 'ns2:UTCDateTime' of XSD type 'ns2:DateTime'
        ns2__DateTime *UTCDateTime;
        /// Optional element 'ns2:LocalDateTime' of XSD type 'ns2:DateTime'
        ns2__DateTime *LocalDateTime;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:SystemDateTimeExtension'
        ns2__SystemDateTimeExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SystemDateTime
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SystemDateTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SystemDateTime, default initialized and not managed by a soap context
        virtual ns2__SystemDateTime *soap_alloc(void) const { return SOAP_NEW(ns2__SystemDateTime); }
      public:
        /// Constructor with initializations
        ns2__SystemDateTime()
        {
          DateTimeType = (ns2__SetDateTimeType)0;
          DaylightSavings = (bool)0;
          TimeZone = (ns2__TimeZone *)0;
          UTCDateTime = (ns2__DateTime *)0;
          LocalDateTime = (ns2__DateTime *)0;
          Extension = (ns2__SystemDateTimeExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__SystemDateTime() { }
        /// Friend allocator used by soap_new_ns2__SystemDateTime(struct soap*, int)
        friend SOAP_FMAC1 ns2__SystemDateTime * SOAP_FMAC2 soap_instantiate_ns2__SystemDateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1360 */
#ifndef SOAP_TYPE_ns2__SystemDateTimeExtension
#define SOAP_TYPE_ns2__SystemDateTimeExtension (604)
/* complex XSD type 'ns2:SystemDateTimeExtension': */
class SOAP_CMAC ns2__SystemDateTimeExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SystemDateTimeExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SystemDateTimeExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SystemDateTimeExtension, default initialized and not managed by a soap context
        virtual ns2__SystemDateTimeExtension *soap_alloc(void) const { return SOAP_NEW(ns2__SystemDateTimeExtension); }
      public:
        /// Constructor with initializations
        ns2__SystemDateTimeExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__SystemDateTimeExtension() { }
        /// Friend allocator used by soap_new_ns2__SystemDateTimeExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__SystemDateTimeExtension * SOAP_FMAC2 soap_instantiate_ns2__SystemDateTimeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1363 */
#ifndef SOAP_TYPE_ns2__DateTime
#define SOAP_TYPE_ns2__DateTime (605)
/* complex XSD type 'ns2:DateTime': */
class SOAP_CMAC ns2__DateTime {
      public:
        /// Required element 'ns2:Time' of XSD type 'ns2:Time'
        ns2__Time *Time;
        /// Required element 'ns2:Date' of XSD type 'ns2:Date'
        ns2__Date *Date;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DateTime
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DateTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DateTime, default initialized and not managed by a soap context
        virtual ns2__DateTime *soap_alloc(void) const { return SOAP_NEW(ns2__DateTime); }
      public:
        /// Constructor with initializations
        ns2__DateTime()
        {
          Time = (ns2__Time *)0;
          Date = (ns2__Date *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DateTime() { }
        /// Friend allocator used by soap_new_ns2__DateTime(struct soap*, int)
        friend SOAP_FMAC1 ns2__DateTime * SOAP_FMAC2 soap_instantiate_ns2__DateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1366 */
#ifndef SOAP_TYPE_ns2__Date
#define SOAP_TYPE_ns2__Date (606)
/* complex XSD type 'ns2:Date': */
class SOAP_CMAC ns2__Date {
      public:
        /// Required element 'ns2:Year' of XSD type 'xsd:int'
        int Year;
        /// Required element 'ns2:Month' of XSD type 'xsd:int'
        int Month;
        /// Required element 'ns2:Day' of XSD type 'xsd:int'
        int Day;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Date
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Date; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Date, default initialized and not managed by a soap context
        virtual ns2__Date *soap_alloc(void) const { return SOAP_NEW(ns2__Date); }
      public:
        /// Constructor with initializations
        ns2__Date()
        {
          Year = (int)0;
          Month = (int)0;
          Day = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Date() { }
        /// Friend allocator used by soap_new_ns2__Date(struct soap*, int)
        friend SOAP_FMAC1 ns2__Date * SOAP_FMAC2 soap_instantiate_ns2__Date(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1369 */
#ifndef SOAP_TYPE_ns2__Time
#define SOAP_TYPE_ns2__Time (607)
/* complex XSD type 'ns2:Time': */
class SOAP_CMAC ns2__Time {
      public:
        /// Required element 'ns2:Hour' of XSD type 'xsd:int'
        int Hour;
        /// Required element 'ns2:Minute' of XSD type 'xsd:int'
        int Minute;
        /// Required element 'ns2:Second' of XSD type 'xsd:int'
        int Second;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Time
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Time; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Time, default initialized and not managed by a soap context
        virtual ns2__Time *soap_alloc(void) const { return SOAP_NEW(ns2__Time); }
      public:
        /// Constructor with initializations
        ns2__Time()
        {
          Hour = (int)0;
          Minute = (int)0;
          Second = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Time() { }
        /// Friend allocator used by soap_new_ns2__Time(struct soap*, int)
        friend SOAP_FMAC1 ns2__Time * SOAP_FMAC2 soap_instantiate_ns2__Time(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1372 */
#ifndef SOAP_TYPE_ns2__TimeZone
#define SOAP_TYPE_ns2__TimeZone (608)
/* complex XSD type 'ns2:TimeZone': */
class SOAP_CMAC ns2__TimeZone {
      public:
        /// Required element 'ns2:TZ' of XSD type 'xsd:token'
        std::string TZ;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__TimeZone
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__TimeZone; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__TimeZone, default initialized and not managed by a soap context
        virtual ns2__TimeZone *soap_alloc(void) const { return SOAP_NEW(ns2__TimeZone); }
      public:
        /// Constructor with initializations
        ns2__TimeZone()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__TimeZone() { }
        /// Friend allocator used by soap_new_ns2__TimeZone(struct soap*, int)
        friend SOAP_FMAC1 ns2__TimeZone * SOAP_FMAC2 soap_instantiate_ns2__TimeZone(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1375 */
#ifndef SOAP_TYPE_ns2__RemoteUser
#define SOAP_TYPE_ns2__RemoteUser (609)
/* complex XSD type 'ns2:RemoteUser': */
class SOAP_CMAC ns2__RemoteUser {
      public:
        /// Required element 'ns2:Username' of XSD type 'xsd:string'
        std::string Username;
        /// Optional element 'ns2:Password' of XSD type 'xsd:string'
        std::string *Password;
        /// Required element 'ns2:UseDerivedPassword' of XSD type 'xsd:boolean'
        bool UseDerivedPassword;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RemoteUser
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RemoteUser; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RemoteUser, default initialized and not managed by a soap context
        virtual ns2__RemoteUser *soap_alloc(void) const { return SOAP_NEW(ns2__RemoteUser); }
      public:
        /// Constructor with initializations
        ns2__RemoteUser()
        {
          Password = (std::string *)0;
          UseDerivedPassword = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__RemoteUser() { }
        /// Friend allocator used by soap_new_ns2__RemoteUser(struct soap*, int)
        friend SOAP_FMAC1 ns2__RemoteUser * SOAP_FMAC2 soap_instantiate_ns2__RemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1378 */
#ifndef SOAP_TYPE_ns2__User
#define SOAP_TYPE_ns2__User (610)
/* complex XSD type 'ns2:User': */
class SOAP_CMAC ns2__User {
      public:
        /// Required element 'ns2:Username' of XSD type 'xsd:string'
        std::string Username;
        /// Optional element 'ns2:Password' of XSD type 'xsd:string'
        std::string *Password;
        /// Required element 'ns2:UserLevel' of XSD type 'ns2:UserLevel'
        ns2__UserLevel UserLevel;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:UserExtension'
        ns2__UserExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__User
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__User; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__User, default initialized and not managed by a soap context
        virtual ns2__User *soap_alloc(void) const { return SOAP_NEW(ns2__User); }
      public:
        /// Constructor with initializations
        ns2__User()
        {
          Password = (std::string *)0;
          UserLevel = (ns2__UserLevel)0;
          Extension = (ns2__UserExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__User() { }
        /// Friend allocator used by soap_new_ns2__User(struct soap*, int)
        friend SOAP_FMAC1 ns2__User * SOAP_FMAC2 soap_instantiate_ns2__User(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1381 */
#ifndef SOAP_TYPE_ns2__UserExtension
#define SOAP_TYPE_ns2__UserExtension (611)
/* complex XSD type 'ns2:UserExtension': */
class SOAP_CMAC ns2__UserExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__UserExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__UserExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__UserExtension, default initialized and not managed by a soap context
        virtual ns2__UserExtension *soap_alloc(void) const { return SOAP_NEW(ns2__UserExtension); }
      public:
        /// Constructor with initializations
        ns2__UserExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__UserExtension() { }
        /// Friend allocator used by soap_new_ns2__UserExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__UserExtension * SOAP_FMAC2 soap_instantiate_ns2__UserExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1384 */
#ifndef SOAP_TYPE_ns2__CertificateGenerationParameters
#define SOAP_TYPE_ns2__CertificateGenerationParameters (612)
/* complex XSD type 'ns2:CertificateGenerationParameters': */
class SOAP_CMAC ns2__CertificateGenerationParameters {
      public:
        /// Optional element 'ns2:CertificateID' of XSD type 'xsd:token'
        std::string *CertificateID;
        /// Optional element 'ns2:Subject' of XSD type 'xsd:string'
        std::string *Subject;
        /// Optional element 'ns2:ValidNotBefore' of XSD type 'xsd:token'
        std::string *ValidNotBefore;
        /// Optional element 'ns2:ValidNotAfter' of XSD type 'xsd:token'
        std::string *ValidNotAfter;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:CertificateGenerationParametersExtension'
        ns2__CertificateGenerationParametersExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CertificateGenerationParameters
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CertificateGenerationParameters; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CertificateGenerationParameters, default initialized and not managed by a soap context
        virtual ns2__CertificateGenerationParameters *soap_alloc(void) const { return SOAP_NEW(ns2__CertificateGenerationParameters); }
      public:
        /// Constructor with initializations
        ns2__CertificateGenerationParameters()
        {
          CertificateID = (std::string *)0;
          Subject = (std::string *)0;
          ValidNotBefore = (std::string *)0;
          ValidNotAfter = (std::string *)0;
          Extension = (ns2__CertificateGenerationParametersExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CertificateGenerationParameters() { }
        /// Friend allocator used by soap_new_ns2__CertificateGenerationParameters(struct soap*, int)
        friend SOAP_FMAC1 ns2__CertificateGenerationParameters * SOAP_FMAC2 soap_instantiate_ns2__CertificateGenerationParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1387 */
#ifndef SOAP_TYPE_ns2__CertificateGenerationParametersExtension
#define SOAP_TYPE_ns2__CertificateGenerationParametersExtension (613)
/* complex XSD type 'ns2:CertificateGenerationParametersExtension': */
class SOAP_CMAC ns2__CertificateGenerationParametersExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CertificateGenerationParametersExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CertificateGenerationParametersExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CertificateGenerationParametersExtension, default initialized and not managed by a soap context
        virtual ns2__CertificateGenerationParametersExtension *soap_alloc(void) const { return SOAP_NEW(ns2__CertificateGenerationParametersExtension); }
      public:
        /// Constructor with initializations
        ns2__CertificateGenerationParametersExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__CertificateGenerationParametersExtension() { }
        /// Friend allocator used by soap_new_ns2__CertificateGenerationParametersExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__CertificateGenerationParametersExtension * SOAP_FMAC2 soap_instantiate_ns2__CertificateGenerationParametersExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1390 */
#ifndef SOAP_TYPE_ns2__Certificate
#define SOAP_TYPE_ns2__Certificate (614)
/* complex XSD type 'ns2:Certificate': */
class SOAP_CMAC ns2__Certificate {
      public:
        /// Required element 'ns2:CertificateID' of XSD type 'xsd:token'
        std::string CertificateID;
        /// Required element 'ns2:Certificate' of XSD type 'ns2:BinaryData'
        ns2__BinaryData *Certificate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Certificate
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Certificate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Certificate, default initialized and not managed by a soap context
        virtual ns2__Certificate *soap_alloc(void) const { return SOAP_NEW(ns2__Certificate); }
      public:
        /// Constructor with initializations
        ns2__Certificate()
        {
          Certificate = (ns2__BinaryData *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Certificate() { }
        /// Friend allocator used by soap_new_ns2__Certificate(struct soap*, int)
        friend SOAP_FMAC1 ns2__Certificate * SOAP_FMAC2 soap_instantiate_ns2__Certificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1393 */
#ifndef SOAP_TYPE_ns2__CertificateStatus
#define SOAP_TYPE_ns2__CertificateStatus (615)
/* complex XSD type 'ns2:CertificateStatus': */
class SOAP_CMAC ns2__CertificateStatus {
      public:
        /// Required element 'ns2:CertificateID' of XSD type 'xsd:token'
        std::string CertificateID;
        /// Required element 'ns2:Status' of XSD type 'xsd:boolean'
        bool Status;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CertificateStatus
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CertificateStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CertificateStatus, default initialized and not managed by a soap context
        virtual ns2__CertificateStatus *soap_alloc(void) const { return SOAP_NEW(ns2__CertificateStatus); }
      public:
        /// Constructor with initializations
        ns2__CertificateStatus()
        {
          Status = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CertificateStatus() { }
        /// Friend allocator used by soap_new_ns2__CertificateStatus(struct soap*, int)
        friend SOAP_FMAC1 ns2__CertificateStatus * SOAP_FMAC2 soap_instantiate_ns2__CertificateStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1396 */
#ifndef SOAP_TYPE_ns2__CertificateWithPrivateKey
#define SOAP_TYPE_ns2__CertificateWithPrivateKey (616)
/* complex XSD type 'ns2:CertificateWithPrivateKey': */
class SOAP_CMAC ns2__CertificateWithPrivateKey {
      public:
        /// Optional element 'ns2:CertificateID' of XSD type 'xsd:token'
        std::string *CertificateID;
        /// Required element 'ns2:Certificate' of XSD type 'ns2:BinaryData'
        ns2__BinaryData *Certificate;
        /// Required element 'ns2:PrivateKey' of XSD type 'ns2:BinaryData'
        ns2__BinaryData *PrivateKey;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CertificateWithPrivateKey
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CertificateWithPrivateKey; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CertificateWithPrivateKey, default initialized and not managed by a soap context
        virtual ns2__CertificateWithPrivateKey *soap_alloc(void) const { return SOAP_NEW(ns2__CertificateWithPrivateKey); }
      public:
        /// Constructor with initializations
        ns2__CertificateWithPrivateKey()
        {
          CertificateID = (std::string *)0;
          Certificate = (ns2__BinaryData *)0;
          PrivateKey = (ns2__BinaryData *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CertificateWithPrivateKey() { }
        /// Friend allocator used by soap_new_ns2__CertificateWithPrivateKey(struct soap*, int)
        friend SOAP_FMAC1 ns2__CertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate_ns2__CertificateWithPrivateKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1399 */
#ifndef SOAP_TYPE_ns2__CertificateInformation
#define SOAP_TYPE_ns2__CertificateInformation (617)
/* complex XSD type 'ns2:CertificateInformation': */
class SOAP_CMAC ns2__CertificateInformation {
      public:
        /// Required element 'ns2:CertificateID' of XSD type 'xsd:token'
        std::string CertificateID;
        /// Optional element 'ns2:IssuerDN' of XSD type 'xsd:string'
        std::string *IssuerDN;
        /// Optional element 'ns2:SubjectDN' of XSD type 'xsd:string'
        std::string *SubjectDN;
        /// Optional element 'ns2:KeyUsage' of XSD type 'ns2:CertificateUsage'
        ns2__CertificateUsage *KeyUsage;
        /// Optional element 'ns2:ExtendedKeyUsage' of XSD type 'ns2:CertificateUsage'
        ns2__CertificateUsage *ExtendedKeyUsage;
        /// Optional element 'ns2:KeyLength' of XSD type 'xsd:int'
        int *KeyLength;
        /// Optional element 'ns2:Version' of XSD type 'xsd:string'
        std::string *Version;
        /// Optional element 'ns2:SerialNum' of XSD type 'xsd:string'
        std::string *SerialNum;
        /// Optional element 'ns2:SignatureAlgorithm' of XSD type 'xsd:string'
        std::string *SignatureAlgorithm;
        /// Optional element 'ns2:Validity' of XSD type 'ns2:DateTimeRange'
        ns2__DateTimeRange *Validity;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:CertificateInformationExtension'
        ns2__CertificateInformationExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CertificateInformation
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CertificateInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CertificateInformation, default initialized and not managed by a soap context
        virtual ns2__CertificateInformation *soap_alloc(void) const { return SOAP_NEW(ns2__CertificateInformation); }
      public:
        /// Constructor with initializations
        ns2__CertificateInformation()
        {
          IssuerDN = (std::string *)0;
          SubjectDN = (std::string *)0;
          KeyUsage = (ns2__CertificateUsage *)0;
          ExtendedKeyUsage = (ns2__CertificateUsage *)0;
          KeyLength = (int *)0;
          Version = (std::string *)0;
          SerialNum = (std::string *)0;
          SignatureAlgorithm = (std::string *)0;
          Validity = (ns2__DateTimeRange *)0;
          Extension = (ns2__CertificateInformationExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CertificateInformation() { }
        /// Friend allocator used by soap_new_ns2__CertificateInformation(struct soap*, int)
        friend SOAP_FMAC1 ns2__CertificateInformation * SOAP_FMAC2 soap_instantiate_ns2__CertificateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1405 */
#ifndef SOAP_TYPE_ns2__CertificateInformationExtension
#define SOAP_TYPE_ns2__CertificateInformationExtension (619)
/* complex XSD type 'ns2:CertificateInformationExtension': */
class SOAP_CMAC ns2__CertificateInformationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CertificateInformationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CertificateInformationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CertificateInformationExtension, default initialized and not managed by a soap context
        virtual ns2__CertificateInformationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__CertificateInformationExtension); }
      public:
        /// Constructor with initializations
        ns2__CertificateInformationExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__CertificateInformationExtension() { }
        /// Friend allocator used by soap_new_ns2__CertificateInformationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__CertificateInformationExtension * SOAP_FMAC2 soap_instantiate_ns2__CertificateInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1408 */
#ifndef SOAP_TYPE_ns2__Dot1XConfiguration
#define SOAP_TYPE_ns2__Dot1XConfiguration (620)
/* complex XSD type 'ns2:Dot1XConfiguration': */
class SOAP_CMAC ns2__Dot1XConfiguration {
      public:
        /// Required element 'ns2:Dot1XConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string Dot1XConfigurationToken;
        /// Required element 'ns2:Identity' of XSD type 'xsd:string'
        std::string Identity;
        /// Optional element 'ns2:AnonymousID' of XSD type 'xsd:string'
        std::string *AnonymousID;
        /// Required element 'ns2:EAPMethod' of XSD type 'xsd:int'
        int EAPMethod;
        /// Optional element 'ns2:CACertificateID' of XSD type 'xsd:token'
        std::vector<std::string> CACertificateID;
        /// Optional element 'ns2:EAPMethodConfiguration' of XSD type 'ns2:EAPMethodConfiguration'
        ns2__EAPMethodConfiguration *EAPMethodConfiguration;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:Dot1XConfigurationExtension'
        ns2__Dot1XConfigurationExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Dot1XConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Dot1XConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Dot1XConfiguration, default initialized and not managed by a soap context
        virtual ns2__Dot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__Dot1XConfiguration); }
      public:
        /// Constructor with initializations
        ns2__Dot1XConfiguration()
        {
          AnonymousID = (std::string *)0;
          EAPMethod = (int)0;
          EAPMethodConfiguration = (ns2__EAPMethodConfiguration *)0;
          Extension = (ns2__Dot1XConfigurationExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Dot1XConfiguration() { }
        /// Friend allocator used by soap_new_ns2__Dot1XConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__Dot1XConfiguration * SOAP_FMAC2 soap_instantiate_ns2__Dot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1411 */
#ifndef SOAP_TYPE_ns2__Dot1XConfigurationExtension
#define SOAP_TYPE_ns2__Dot1XConfigurationExtension (621)
/* complex XSD type 'ns2:Dot1XConfigurationExtension': */
class SOAP_CMAC ns2__Dot1XConfigurationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Dot1XConfigurationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Dot1XConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Dot1XConfigurationExtension, default initialized and not managed by a soap context
        virtual ns2__Dot1XConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__Dot1XConfigurationExtension); }
      public:
        /// Constructor with initializations
        ns2__Dot1XConfigurationExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__Dot1XConfigurationExtension() { }
        /// Friend allocator used by soap_new_ns2__Dot1XConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__Dot1XConfigurationExtension * SOAP_FMAC2 soap_instantiate_ns2__Dot1XConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1414 */
#ifndef SOAP_TYPE_ns2__EAPMethodConfiguration
#define SOAP_TYPE_ns2__EAPMethodConfiguration (622)
/* complex XSD type 'ns2:EAPMethodConfiguration': */
class SOAP_CMAC ns2__EAPMethodConfiguration {
      public:
        /// Optional element 'ns2:TLSConfiguration' of XSD type 'ns2:TLSConfiguration'
        ns2__TLSConfiguration *TLSConfiguration;
        /// Optional element 'ns2:Password' of XSD type 'xsd:string'
        std::string *Password;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:EapMethodExtension'
        ns2__EapMethodExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__EAPMethodConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__EAPMethodConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__EAPMethodConfiguration, default initialized and not managed by a soap context
        virtual ns2__EAPMethodConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__EAPMethodConfiguration); }
      public:
        /// Constructor with initializations
        ns2__EAPMethodConfiguration()
        {
          TLSConfiguration = (ns2__TLSConfiguration *)0;
          Password = (std::string *)0;
          Extension = (ns2__EapMethodExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__EAPMethodConfiguration() { }
        /// Friend allocator used by soap_new_ns2__EAPMethodConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__EAPMethodConfiguration * SOAP_FMAC2 soap_instantiate_ns2__EAPMethodConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1417 */
#ifndef SOAP_TYPE_ns2__EapMethodExtension
#define SOAP_TYPE_ns2__EapMethodExtension (623)
/* complex XSD type 'ns2:EapMethodExtension': */
class SOAP_CMAC ns2__EapMethodExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__EapMethodExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__EapMethodExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__EapMethodExtension, default initialized and not managed by a soap context
        virtual ns2__EapMethodExtension *soap_alloc(void) const { return SOAP_NEW(ns2__EapMethodExtension); }
      public:
        /// Constructor with initializations
        ns2__EapMethodExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__EapMethodExtension() { }
        /// Friend allocator used by soap_new_ns2__EapMethodExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__EapMethodExtension * SOAP_FMAC2 soap_instantiate_ns2__EapMethodExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1420 */
#ifndef SOAP_TYPE_ns2__TLSConfiguration
#define SOAP_TYPE_ns2__TLSConfiguration (624)
/* complex XSD type 'ns2:TLSConfiguration': */
class SOAP_CMAC ns2__TLSConfiguration {
      public:
        /// Required element 'ns2:CertificateID' of XSD type 'xsd:token'
        std::string CertificateID;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__TLSConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__TLSConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__TLSConfiguration, default initialized and not managed by a soap context
        virtual ns2__TLSConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__TLSConfiguration); }
      public:
        /// Constructor with initializations
        ns2__TLSConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__TLSConfiguration() { }
        /// Friend allocator used by soap_new_ns2__TLSConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__TLSConfiguration * SOAP_FMAC2 soap_instantiate_ns2__TLSConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1423 */
#ifndef SOAP_TYPE_ns2__GenericEapPwdConfigurationExtension
#define SOAP_TYPE_ns2__GenericEapPwdConfigurationExtension (625)
/* complex XSD type 'ns2:GenericEapPwdConfigurationExtension': */
class SOAP_CMAC ns2__GenericEapPwdConfigurationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GenericEapPwdConfigurationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__GenericEapPwdConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GenericEapPwdConfigurationExtension, default initialized and not managed by a soap context
        virtual ns2__GenericEapPwdConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__GenericEapPwdConfigurationExtension); }
      public:
        /// Constructor with initializations
        ns2__GenericEapPwdConfigurationExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__GenericEapPwdConfigurationExtension() { }
        /// Friend allocator used by soap_new_ns2__GenericEapPwdConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__GenericEapPwdConfigurationExtension * SOAP_FMAC2 soap_instantiate_ns2__GenericEapPwdConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1426 */
#ifndef SOAP_TYPE_ns2__RelayOutputSettings
#define SOAP_TYPE_ns2__RelayOutputSettings (626)
/* complex XSD type 'ns2:RelayOutputSettings': */
class SOAP_CMAC ns2__RelayOutputSettings {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:RelayMode'
        ns2__RelayMode Mode;
        /// Required element 'ns2:DelayTime' of XSD type 'xsd:duration'
        std::string DelayTime;
        /// Required element 'ns2:IdleState' of XSD type 'ns2:RelayIdleState'
        ns2__RelayIdleState IdleState;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RelayOutputSettings
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RelayOutputSettings; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RelayOutputSettings, default initialized and not managed by a soap context
        virtual ns2__RelayOutputSettings *soap_alloc(void) const { return SOAP_NEW(ns2__RelayOutputSettings); }
      public:
        /// Constructor with initializations
        ns2__RelayOutputSettings()
        {
          Mode = (ns2__RelayMode)0;
          IdleState = (ns2__RelayIdleState)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__RelayOutputSettings() { }
        /// Friend allocator used by soap_new_ns2__RelayOutputSettings(struct soap*, int)
        friend SOAP_FMAC1 ns2__RelayOutputSettings * SOAP_FMAC2 soap_instantiate_ns2__RelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1438 */
#ifndef SOAP_TYPE_ns2__PTZNodeExtension
#define SOAP_TYPE_ns2__PTZNodeExtension (630)
/* complex XSD type 'ns2:PTZNodeExtension': */
class SOAP_CMAC ns2__PTZNodeExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional element 'ns2:SupportedPresetTour' of XSD type 'ns2:PTZPresetTourSupported'
        ns2__PTZPresetTourSupported *SupportedPresetTour;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:PTZNodeExtension2'
        ns2__PTZNodeExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZNodeExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZNodeExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZNodeExtension, default initialized and not managed by a soap context
        virtual ns2__PTZNodeExtension *soap_alloc(void) const { return SOAP_NEW(ns2__PTZNodeExtension); }
      public:
        /// Constructor with initializations
        ns2__PTZNodeExtension()
        {
          SupportedPresetTour = (ns2__PTZPresetTourSupported *)0;
          Extension = (ns2__PTZNodeExtension2 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZNodeExtension() { }
        /// Friend allocator used by soap_new_ns2__PTZNodeExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZNodeExtension * SOAP_FMAC2 soap_instantiate_ns2__PTZNodeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1441 */
#ifndef SOAP_TYPE_ns2__PTZNodeExtension2
#define SOAP_TYPE_ns2__PTZNodeExtension2 (631)
/* complex XSD type 'ns2:PTZNodeExtension2': */
class SOAP_CMAC ns2__PTZNodeExtension2 {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZNodeExtension2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZNodeExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZNodeExtension2, default initialized and not managed by a soap context
        virtual ns2__PTZNodeExtension2 *soap_alloc(void) const { return SOAP_NEW(ns2__PTZNodeExtension2); }
      public:
        /// Constructor with initializations
        ns2__PTZNodeExtension2()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZNodeExtension2() { }
        /// Friend allocator used by soap_new_ns2__PTZNodeExtension2(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZNodeExtension2 * SOAP_FMAC2 soap_instantiate_ns2__PTZNodeExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1444 */
#ifndef SOAP_TYPE_ns2__PTZPresetTourSupported
#define SOAP_TYPE_ns2__PTZPresetTourSupported (632)
/* complex XSD type 'ns2:PTZPresetTourSupported': */
class SOAP_CMAC ns2__PTZPresetTourSupported {
      public:
        /// Required element 'ns2:MaximumNumberOfPresetTours' of XSD type 'xsd:int'
        int MaximumNumberOfPresetTours;
        /// Optional element 'ns2:PTZPresetTourOperation' of XSD type 'ns2:PTZPresetTourOperation'
        std::vector<ns2__PTZPresetTourOperation> PTZPresetTourOperation;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:PTZPresetTourSupportedExtension'
        ns2__PTZPresetTourSupportedExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZPresetTourSupported
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZPresetTourSupported; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZPresetTourSupported, default initialized and not managed by a soap context
        virtual ns2__PTZPresetTourSupported *soap_alloc(void) const { return SOAP_NEW(ns2__PTZPresetTourSupported); }
      public:
        /// Constructor with initializations
        ns2__PTZPresetTourSupported()
        {
          MaximumNumberOfPresetTours = (int)0;
          Extension = (ns2__PTZPresetTourSupportedExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZPresetTourSupported() { }
        /// Friend allocator used by soap_new_ns2__PTZPresetTourSupported(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZPresetTourSupported * SOAP_FMAC2 soap_instantiate_ns2__PTZPresetTourSupported(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1447 */
#ifndef SOAP_TYPE_ns2__PTZPresetTourSupportedExtension
#define SOAP_TYPE_ns2__PTZPresetTourSupportedExtension (633)
/* complex XSD type 'ns2:PTZPresetTourSupportedExtension': */
class SOAP_CMAC ns2__PTZPresetTourSupportedExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZPresetTourSupportedExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZPresetTourSupportedExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZPresetTourSupportedExtension, default initialized and not managed by a soap context
        virtual ns2__PTZPresetTourSupportedExtension *soap_alloc(void) const { return SOAP_NEW(ns2__PTZPresetTourSupportedExtension); }
      public:
        /// Constructor with initializations
        ns2__PTZPresetTourSupportedExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZPresetTourSupportedExtension() { }
        /// Friend allocator used by soap_new_ns2__PTZPresetTourSupportedExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZPresetTourSupportedExtension * SOAP_FMAC2 soap_instantiate_ns2__PTZPresetTourSupportedExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1453 */
#ifndef SOAP_TYPE_ns2__PTZConfigurationExtension
#define SOAP_TYPE_ns2__PTZConfigurationExtension (635)
/* complex XSD type 'ns2:PTZConfigurationExtension': */
class SOAP_CMAC ns2__PTZConfigurationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional element 'ns2:PTControlDirection' of XSD type 'ns2:PTControlDirection'
        ns2__PTControlDirection *PTControlDirection;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:PTZConfigurationExtension2'
        ns2__PTZConfigurationExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZConfigurationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZConfigurationExtension, default initialized and not managed by a soap context
        virtual ns2__PTZConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__PTZConfigurationExtension); }
      public:
        /// Constructor with initializations
        ns2__PTZConfigurationExtension()
        {
          PTControlDirection = (ns2__PTControlDirection *)0;
          Extension = (ns2__PTZConfigurationExtension2 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZConfigurationExtension() { }
        /// Friend allocator used by soap_new_ns2__PTZConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZConfigurationExtension * SOAP_FMAC2 soap_instantiate_ns2__PTZConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1456 */
#ifndef SOAP_TYPE_ns2__PTZConfigurationExtension2
#define SOAP_TYPE_ns2__PTZConfigurationExtension2 (636)
/* complex XSD type 'ns2:PTZConfigurationExtension2': */
class SOAP_CMAC ns2__PTZConfigurationExtension2 {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZConfigurationExtension2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZConfigurationExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZConfigurationExtension2, default initialized and not managed by a soap context
        virtual ns2__PTZConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW(ns2__PTZConfigurationExtension2); }
      public:
        /// Constructor with initializations
        ns2__PTZConfigurationExtension2()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZConfigurationExtension2() { }
        /// Friend allocator used by soap_new_ns2__PTZConfigurationExtension2(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_ns2__PTZConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1459 */
#ifndef SOAP_TYPE_ns2__PTControlDirection
#define SOAP_TYPE_ns2__PTControlDirection (637)
/* complex XSD type 'ns2:PTControlDirection': */
class SOAP_CMAC ns2__PTControlDirection {
      public:
        /// Optional element 'ns2:EFlip' of XSD type 'ns2:EFlip'
        ns2__EFlip *EFlip;
        /// Optional element 'ns2:Reverse' of XSD type 'ns2:Reverse'
        ns2__Reverse *Reverse;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:PTControlDirectionExtension'
        ns2__PTControlDirectionExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTControlDirection
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTControlDirection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTControlDirection, default initialized and not managed by a soap context
        virtual ns2__PTControlDirection *soap_alloc(void) const { return SOAP_NEW(ns2__PTControlDirection); }
      public:
        /// Constructor with initializations
        ns2__PTControlDirection()
        {
          EFlip = (ns2__EFlip *)0;
          Reverse = (ns2__Reverse *)0;
          Extension = (ns2__PTControlDirectionExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTControlDirection() { }
        /// Friend allocator used by soap_new_ns2__PTControlDirection(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTControlDirection * SOAP_FMAC2 soap_instantiate_ns2__PTControlDirection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1462 */
#ifndef SOAP_TYPE_ns2__PTControlDirectionExtension
#define SOAP_TYPE_ns2__PTControlDirectionExtension (638)
/* complex XSD type 'ns2:PTControlDirectionExtension': */
class SOAP_CMAC ns2__PTControlDirectionExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTControlDirectionExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTControlDirectionExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTControlDirectionExtension, default initialized and not managed by a soap context
        virtual ns2__PTControlDirectionExtension *soap_alloc(void) const { return SOAP_NEW(ns2__PTControlDirectionExtension); }
      public:
        /// Constructor with initializations
        ns2__PTControlDirectionExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTControlDirectionExtension() { }
        /// Friend allocator used by soap_new_ns2__PTControlDirectionExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTControlDirectionExtension * SOAP_FMAC2 soap_instantiate_ns2__PTControlDirectionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1465 */
#ifndef SOAP_TYPE_ns2__EFlip
#define SOAP_TYPE_ns2__EFlip (639)
/* complex XSD type 'ns2:EFlip': */
class SOAP_CMAC ns2__EFlip {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:EFlipMode'
        ns2__EFlipMode Mode;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__EFlip
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__EFlip; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__EFlip, default initialized and not managed by a soap context
        virtual ns2__EFlip *soap_alloc(void) const { return SOAP_NEW(ns2__EFlip); }
      public:
        /// Constructor with initializations
        ns2__EFlip()
        {
          Mode = (ns2__EFlipMode)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__EFlip() { }
        /// Friend allocator used by soap_new_ns2__EFlip(struct soap*, int)
        friend SOAP_FMAC1 ns2__EFlip * SOAP_FMAC2 soap_instantiate_ns2__EFlip(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1468 */
#ifndef SOAP_TYPE_ns2__Reverse
#define SOAP_TYPE_ns2__Reverse (640)
/* complex XSD type 'ns2:Reverse': */
class SOAP_CMAC ns2__Reverse {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:ReverseMode'
        ns2__ReverseMode Mode;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Reverse
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Reverse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Reverse, default initialized and not managed by a soap context
        virtual ns2__Reverse *soap_alloc(void) const { return SOAP_NEW(ns2__Reverse); }
      public:
        /// Constructor with initializations
        ns2__Reverse()
        {
          Mode = (ns2__ReverseMode)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Reverse() { }
        /// Friend allocator used by soap_new_ns2__Reverse(struct soap*, int)
        friend SOAP_FMAC1 ns2__Reverse * SOAP_FMAC2 soap_instantiate_ns2__Reverse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1471 */
#ifndef SOAP_TYPE_ns2__PTZConfigurationOptions
#define SOAP_TYPE_ns2__PTZConfigurationOptions (641)
/* complex XSD type 'ns2:PTZConfigurationOptions': */
class SOAP_CMAC ns2__PTZConfigurationOptions {
      public:
        /// Required element 'ns2:Spaces' of XSD type 'ns2:PTZSpaces'
        ns2__PTZSpaces *Spaces;
        /// Required element 'ns2:PTZTimeout' of XSD type 'ns2:DurationRange'
        ns2__DurationRange *PTZTimeout;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional element 'ns2:PTControlDirection' of XSD type 'ns2:PTControlDirectionOptions'
        ns2__PTControlDirectionOptions *PTControlDirection;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:PTZConfigurationOptions2'
        ns2__PTZConfigurationOptions2 *Extension;
        /// optional attribute 'PTZRamps' of XSD type 'ns2:IntAttrList'
        std::string *PTZRamps;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZConfigurationOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZConfigurationOptions, default initialized and not managed by a soap context
        virtual ns2__PTZConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(ns2__PTZConfigurationOptions); }
      public:
        /// Constructor with initializations
        ns2__PTZConfigurationOptions()
        {
          Spaces = (ns2__PTZSpaces *)0;
          PTZTimeout = (ns2__DurationRange *)0;
          PTControlDirection = (ns2__PTControlDirectionOptions *)0;
          Extension = (ns2__PTZConfigurationOptions2 *)0;
          PTZRamps = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZConfigurationOptions() { }
        /// Friend allocator used by soap_new_ns2__PTZConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZConfigurationOptions * SOAP_FMAC2 soap_instantiate_ns2__PTZConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1474 */
#ifndef SOAP_TYPE_ns2__PTZConfigurationOptions2
#define SOAP_TYPE_ns2__PTZConfigurationOptions2 (642)
/* complex XSD type 'ns2:PTZConfigurationOptions2': */
class SOAP_CMAC ns2__PTZConfigurationOptions2 {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZConfigurationOptions2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZConfigurationOptions2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZConfigurationOptions2, default initialized and not managed by a soap context
        virtual ns2__PTZConfigurationOptions2 *soap_alloc(void) const { return SOAP_NEW(ns2__PTZConfigurationOptions2); }
      public:
        /// Constructor with initializations
        ns2__PTZConfigurationOptions2()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZConfigurationOptions2() { }
        /// Friend allocator used by soap_new_ns2__PTZConfigurationOptions2(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZConfigurationOptions2 * SOAP_FMAC2 soap_instantiate_ns2__PTZConfigurationOptions2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1477 */
#ifndef SOAP_TYPE_ns2__PTControlDirectionOptions
#define SOAP_TYPE_ns2__PTControlDirectionOptions (643)
/* complex XSD type 'ns2:PTControlDirectionOptions': */
class SOAP_CMAC ns2__PTControlDirectionOptions {
      public:
        /// Optional element 'ns2:EFlip' of XSD type 'ns2:EFlipOptions'
        ns2__EFlipOptions *EFlip;
        /// Optional element 'ns2:Reverse' of XSD type 'ns2:ReverseOptions'
        ns2__ReverseOptions *Reverse;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:PTControlDirectionOptionsExtension'
        ns2__PTControlDirectionOptionsExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTControlDirectionOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTControlDirectionOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTControlDirectionOptions, default initialized and not managed by a soap context
        virtual ns2__PTControlDirectionOptions *soap_alloc(void) const { return SOAP_NEW(ns2__PTControlDirectionOptions); }
      public:
        /// Constructor with initializations
        ns2__PTControlDirectionOptions()
        {
          EFlip = (ns2__EFlipOptions *)0;
          Reverse = (ns2__ReverseOptions *)0;
          Extension = (ns2__PTControlDirectionOptionsExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTControlDirectionOptions() { }
        /// Friend allocator used by soap_new_ns2__PTControlDirectionOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTControlDirectionOptions * SOAP_FMAC2 soap_instantiate_ns2__PTControlDirectionOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1480 */
#ifndef SOAP_TYPE_ns2__PTControlDirectionOptionsExtension
#define SOAP_TYPE_ns2__PTControlDirectionOptionsExtension (644)
/* complex XSD type 'ns2:PTControlDirectionOptionsExtension': */
class SOAP_CMAC ns2__PTControlDirectionOptionsExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTControlDirectionOptionsExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTControlDirectionOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTControlDirectionOptionsExtension, default initialized and not managed by a soap context
        virtual ns2__PTControlDirectionOptionsExtension *soap_alloc(void) const { return SOAP_NEW(ns2__PTControlDirectionOptionsExtension); }
      public:
        /// Constructor with initializations
        ns2__PTControlDirectionOptionsExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTControlDirectionOptionsExtension() { }
        /// Friend allocator used by soap_new_ns2__PTControlDirectionOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTControlDirectionOptionsExtension * SOAP_FMAC2 soap_instantiate_ns2__PTControlDirectionOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1483 */
#ifndef SOAP_TYPE_ns2__EFlipOptions
#define SOAP_TYPE_ns2__EFlipOptions (645)
/* complex XSD type 'ns2:EFlipOptions': */
class SOAP_CMAC ns2__EFlipOptions {
      public:
        /// Optional element 'ns2:Mode' of XSD type 'ns2:EFlipMode'
        std::vector<ns2__EFlipMode> Mode;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:EFlipOptionsExtension'
        ns2__EFlipOptionsExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__EFlipOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__EFlipOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__EFlipOptions, default initialized and not managed by a soap context
        virtual ns2__EFlipOptions *soap_alloc(void) const { return SOAP_NEW(ns2__EFlipOptions); }
      public:
        /// Constructor with initializations
        ns2__EFlipOptions()
        {
          Extension = (ns2__EFlipOptionsExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__EFlipOptions() { }
        /// Friend allocator used by soap_new_ns2__EFlipOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__EFlipOptions * SOAP_FMAC2 soap_instantiate_ns2__EFlipOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1486 */
#ifndef SOAP_TYPE_ns2__EFlipOptionsExtension
#define SOAP_TYPE_ns2__EFlipOptionsExtension (646)
/* complex XSD type 'ns2:EFlipOptionsExtension': */
class SOAP_CMAC ns2__EFlipOptionsExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__EFlipOptionsExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__EFlipOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__EFlipOptionsExtension, default initialized and not managed by a soap context
        virtual ns2__EFlipOptionsExtension *soap_alloc(void) const { return SOAP_NEW(ns2__EFlipOptionsExtension); }
      public:
        /// Constructor with initializations
        ns2__EFlipOptionsExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__EFlipOptionsExtension() { }
        /// Friend allocator used by soap_new_ns2__EFlipOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__EFlipOptionsExtension * SOAP_FMAC2 soap_instantiate_ns2__EFlipOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1489 */
#ifndef SOAP_TYPE_ns2__ReverseOptions
#define SOAP_TYPE_ns2__ReverseOptions (647)
/* complex XSD type 'ns2:ReverseOptions': */
class SOAP_CMAC ns2__ReverseOptions {
      public:
        /// Optional element 'ns2:Mode' of XSD type 'ns2:ReverseMode'
        std::vector<ns2__ReverseMode> Mode;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ReverseOptionsExtension'
        ns2__ReverseOptionsExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ReverseOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ReverseOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ReverseOptions, default initialized and not managed by a soap context
        virtual ns2__ReverseOptions *soap_alloc(void) const { return SOAP_NEW(ns2__ReverseOptions); }
      public:
        /// Constructor with initializations
        ns2__ReverseOptions()
        {
          Extension = (ns2__ReverseOptionsExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ReverseOptions() { }
        /// Friend allocator used by soap_new_ns2__ReverseOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__ReverseOptions * SOAP_FMAC2 soap_instantiate_ns2__ReverseOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1492 */
#ifndef SOAP_TYPE_ns2__ReverseOptionsExtension
#define SOAP_TYPE_ns2__ReverseOptionsExtension (648)
/* complex XSD type 'ns2:ReverseOptionsExtension': */
class SOAP_CMAC ns2__ReverseOptionsExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ReverseOptionsExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ReverseOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ReverseOptionsExtension, default initialized and not managed by a soap context
        virtual ns2__ReverseOptionsExtension *soap_alloc(void) const { return SOAP_NEW(ns2__ReverseOptionsExtension); }
      public:
        /// Constructor with initializations
        ns2__ReverseOptionsExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ReverseOptionsExtension() { }
        /// Friend allocator used by soap_new_ns2__ReverseOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__ReverseOptionsExtension * SOAP_FMAC2 soap_instantiate_ns2__ReverseOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1495 */
#ifndef SOAP_TYPE_ns2__PanTiltLimits
#define SOAP_TYPE_ns2__PanTiltLimits (649)
/* complex XSD type 'ns2:PanTiltLimits': */
class SOAP_CMAC ns2__PanTiltLimits {
      public:
        /// Required element 'ns2:Range' of XSD type 'ns2:Space2DDescription'
        ns2__Space2DDescription *Range;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PanTiltLimits
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PanTiltLimits; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PanTiltLimits, default initialized and not managed by a soap context
        virtual ns2__PanTiltLimits *soap_alloc(void) const { return SOAP_NEW(ns2__PanTiltLimits); }
      public:
        /// Constructor with initializations
        ns2__PanTiltLimits()
        {
          Range = (ns2__Space2DDescription *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PanTiltLimits() { }
        /// Friend allocator used by soap_new_ns2__PanTiltLimits(struct soap*, int)
        friend SOAP_FMAC1 ns2__PanTiltLimits * SOAP_FMAC2 soap_instantiate_ns2__PanTiltLimits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1498 */
#ifndef SOAP_TYPE_ns2__ZoomLimits
#define SOAP_TYPE_ns2__ZoomLimits (650)
/* complex XSD type 'ns2:ZoomLimits': */
class SOAP_CMAC ns2__ZoomLimits {
      public:
        /// Required element 'ns2:Range' of XSD type 'ns2:Space1DDescription'
        ns2__Space1DDescription *Range;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ZoomLimits
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ZoomLimits; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ZoomLimits, default initialized and not managed by a soap context
        virtual ns2__ZoomLimits *soap_alloc(void) const { return SOAP_NEW(ns2__ZoomLimits); }
      public:
        /// Constructor with initializations
        ns2__ZoomLimits()
        {
          Range = (ns2__Space1DDescription *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ZoomLimits() { }
        /// Friend allocator used by soap_new_ns2__ZoomLimits(struct soap*, int)
        friend SOAP_FMAC1 ns2__ZoomLimits * SOAP_FMAC2 soap_instantiate_ns2__ZoomLimits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1501 */
#ifndef SOAP_TYPE_ns2__PTZSpaces
#define SOAP_TYPE_ns2__PTZSpaces (651)
/* complex XSD type 'ns2:PTZSpaces': */
class SOAP_CMAC ns2__PTZSpaces {
      public:
        /// Optional element 'ns2:AbsolutePanTiltPositionSpace' of XSD type 'ns2:Space2DDescription'
        std::vector<ns2__Space2DDescription *> AbsolutePanTiltPositionSpace;
        /// Optional element 'ns2:AbsoluteZoomPositionSpace' of XSD type 'ns2:Space1DDescription'
        std::vector<ns2__Space1DDescription *> AbsoluteZoomPositionSpace;
        /// Optional element 'ns2:RelativePanTiltTranslationSpace' of XSD type 'ns2:Space2DDescription'
        std::vector<ns2__Space2DDescription *> RelativePanTiltTranslationSpace;
        /// Optional element 'ns2:RelativeZoomTranslationSpace' of XSD type 'ns2:Space1DDescription'
        std::vector<ns2__Space1DDescription *> RelativeZoomTranslationSpace;
        /// Optional element 'ns2:ContinuousPanTiltVelocitySpace' of XSD type 'ns2:Space2DDescription'
        std::vector<ns2__Space2DDescription *> ContinuousPanTiltVelocitySpace;
        /// Optional element 'ns2:ContinuousZoomVelocitySpace' of XSD type 'ns2:Space1DDescription'
        std::vector<ns2__Space1DDescription *> ContinuousZoomVelocitySpace;
        /// Optional element 'ns2:PanTiltSpeedSpace' of XSD type 'ns2:Space1DDescription'
        std::vector<ns2__Space1DDescription *> PanTiltSpeedSpace;
        /// Optional element 'ns2:ZoomSpeedSpace' of XSD type 'ns2:Space1DDescription'
        std::vector<ns2__Space1DDescription *> ZoomSpeedSpace;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:PTZSpacesExtension'
        ns2__PTZSpacesExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZSpaces
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZSpaces; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZSpaces, default initialized and not managed by a soap context
        virtual ns2__PTZSpaces *soap_alloc(void) const { return SOAP_NEW(ns2__PTZSpaces); }
      public:
        /// Constructor with initializations
        ns2__PTZSpaces()
        {
          Extension = (ns2__PTZSpacesExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZSpaces() { }
        /// Friend allocator used by soap_new_ns2__PTZSpaces(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZSpaces * SOAP_FMAC2 soap_instantiate_ns2__PTZSpaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1504 */
#ifndef SOAP_TYPE_ns2__PTZSpacesExtension
#define SOAP_TYPE_ns2__PTZSpacesExtension (652)
/* complex XSD type 'ns2:PTZSpacesExtension': */
class SOAP_CMAC ns2__PTZSpacesExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZSpacesExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZSpacesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZSpacesExtension, default initialized and not managed by a soap context
        virtual ns2__PTZSpacesExtension *soap_alloc(void) const { return SOAP_NEW(ns2__PTZSpacesExtension); }
      public:
        /// Constructor with initializations
        ns2__PTZSpacesExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZSpacesExtension() { }
        /// Friend allocator used by soap_new_ns2__PTZSpacesExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZSpacesExtension * SOAP_FMAC2 soap_instantiate_ns2__PTZSpacesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1507 */
#ifndef SOAP_TYPE_ns2__Space2DDescription
#define SOAP_TYPE_ns2__Space2DDescription (653)
/* complex XSD type 'ns2:Space2DDescription': */
class SOAP_CMAC ns2__Space2DDescription {
      public:
        /// Required element 'ns2:URI' of XSD type 'xsd:anyURI'
        std::string URI;
        /// Required element 'ns2:XRange' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *XRange;
        /// Required element 'ns2:YRange' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *YRange;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Space2DDescription
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Space2DDescription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Space2DDescription, default initialized and not managed by a soap context
        virtual ns2__Space2DDescription *soap_alloc(void) const { return SOAP_NEW(ns2__Space2DDescription); }
      public:
        /// Constructor with initializations
        ns2__Space2DDescription()
        {
          XRange = (ns2__FloatRange *)0;
          YRange = (ns2__FloatRange *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Space2DDescription() { }
        /// Friend allocator used by soap_new_ns2__Space2DDescription(struct soap*, int)
        friend SOAP_FMAC1 ns2__Space2DDescription * SOAP_FMAC2 soap_instantiate_ns2__Space2DDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1510 */
#ifndef SOAP_TYPE_ns2__Space1DDescription
#define SOAP_TYPE_ns2__Space1DDescription (654)
/* complex XSD type 'ns2:Space1DDescription': */
class SOAP_CMAC ns2__Space1DDescription {
      public:
        /// Required element 'ns2:URI' of XSD type 'xsd:anyURI'
        std::string URI;
        /// Required element 'ns2:XRange' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *XRange;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Space1DDescription
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Space1DDescription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Space1DDescription, default initialized and not managed by a soap context
        virtual ns2__Space1DDescription *soap_alloc(void) const { return SOAP_NEW(ns2__Space1DDescription); }
      public:
        /// Constructor with initializations
        ns2__Space1DDescription()
        {
          XRange = (ns2__FloatRange *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Space1DDescription() { }
        /// Friend allocator used by soap_new_ns2__Space1DDescription(struct soap*, int)
        friend SOAP_FMAC1 ns2__Space1DDescription * SOAP_FMAC2 soap_instantiate_ns2__Space1DDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1513 */
#ifndef SOAP_TYPE_ns2__Vector2D
#define SOAP_TYPE_ns2__Vector2D (655)
/* complex XSD type 'ns2:Vector2D': */
class SOAP_CMAC ns2__Vector2D {
      public:
        /// required attribute 'x' of XSD type 'xsd:float'
        float x;
        /// required attribute 'y' of XSD type 'xsd:float'
        float y;
        /// optional attribute 'space' of XSD type 'xsd:anyURI'
        std::string *space;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Vector2D
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Vector2D; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Vector2D, default initialized and not managed by a soap context
        virtual ns2__Vector2D *soap_alloc(void) const { return SOAP_NEW(ns2__Vector2D); }
      public:
        /// Constructor with initializations
        ns2__Vector2D()
        {
          x = (float)0;
          y = (float)0;
          space = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Vector2D() { }
        /// Friend allocator used by soap_new_ns2__Vector2D(struct soap*, int)
        friend SOAP_FMAC1 ns2__Vector2D * SOAP_FMAC2 soap_instantiate_ns2__Vector2D(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1516 */
#ifndef SOAP_TYPE_ns2__Vector1D
#define SOAP_TYPE_ns2__Vector1D (656)
/* complex XSD type 'ns2:Vector1D': */
class SOAP_CMAC ns2__Vector1D {
      public:
        /// required attribute 'x' of XSD type 'xsd:float'
        float x;
        /// optional attribute 'space' of XSD type 'xsd:anyURI'
        std::string *space;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Vector1D
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Vector1D; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Vector1D, default initialized and not managed by a soap context
        virtual ns2__Vector1D *soap_alloc(void) const { return SOAP_NEW(ns2__Vector1D); }
      public:
        /// Constructor with initializations
        ns2__Vector1D()
        {
          x = (float)0;
          space = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Vector1D() { }
        /// Friend allocator used by soap_new_ns2__Vector1D(struct soap*, int)
        friend SOAP_FMAC1 ns2__Vector1D * SOAP_FMAC2 soap_instantiate_ns2__Vector1D(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1519 */
#ifndef SOAP_TYPE_ns2__PTZVector
#define SOAP_TYPE_ns2__PTZVector (657)
/* complex XSD type 'ns2:PTZVector': */
class SOAP_CMAC ns2__PTZVector {
      public:
        /// Optional element 'ns2:PanTilt' of XSD type 'ns2:Vector2D'
        ns2__Vector2D *PanTilt;
        /// Optional element 'ns2:Zoom' of XSD type 'ns2:Vector1D'
        ns2__Vector1D *Zoom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZVector
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZVector; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZVector, default initialized and not managed by a soap context
        virtual ns2__PTZVector *soap_alloc(void) const { return SOAP_NEW(ns2__PTZVector); }
      public:
        /// Constructor with initializations
        ns2__PTZVector()
        {
          PanTilt = (ns2__Vector2D *)0;
          Zoom = (ns2__Vector1D *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZVector() { }
        /// Friend allocator used by soap_new_ns2__PTZVector(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZVector * SOAP_FMAC2 soap_instantiate_ns2__PTZVector(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1522 */
#ifndef SOAP_TYPE_ns2__PTZSpeed
#define SOAP_TYPE_ns2__PTZSpeed (658)
/* complex XSD type 'ns2:PTZSpeed': */
class SOAP_CMAC ns2__PTZSpeed {
      public:
        /// Optional element 'ns2:PanTilt' of XSD type 'ns2:Vector2D'
        ns2__Vector2D *PanTilt;
        /// Optional element 'ns2:Zoom' of XSD type 'ns2:Vector1D'
        ns2__Vector1D *Zoom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZSpeed
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZSpeed; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZSpeed, default initialized and not managed by a soap context
        virtual ns2__PTZSpeed *soap_alloc(void) const { return SOAP_NEW(ns2__PTZSpeed); }
      public:
        /// Constructor with initializations
        ns2__PTZSpeed()
        {
          PanTilt = (ns2__Vector2D *)0;
          Zoom = (ns2__Vector1D *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZSpeed() { }
        /// Friend allocator used by soap_new_ns2__PTZSpeed(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZSpeed * SOAP_FMAC2 soap_instantiate_ns2__PTZSpeed(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1525 */
#ifndef SOAP_TYPE_ns2__PTZStatus
#define SOAP_TYPE_ns2__PTZStatus (659)
/* complex XSD type 'ns2:PTZStatus': */
class SOAP_CMAC ns2__PTZStatus {
      public:
        /// Optional element 'ns2:Position' of XSD type 'ns2:PTZVector'
        ns2__PTZVector *Position;
        /// Optional element 'ns2:MoveStatus' of XSD type 'ns2:PTZMoveStatus'
        ns2__PTZMoveStatus *MoveStatus;
        /// Optional element 'ns2:Error' of XSD type 'xsd:string'
        std::string *Error;
        /// Required element 'ns2:UtcTime' of XSD type 'xsd:dateTime'
        time_t UtcTime;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZStatus
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZStatus, default initialized and not managed by a soap context
        virtual ns2__PTZStatus *soap_alloc(void) const { return SOAP_NEW(ns2__PTZStatus); }
      public:
        /// Constructor with initializations
        ns2__PTZStatus()
        {
          Position = (ns2__PTZVector *)0;
          MoveStatus = (ns2__PTZMoveStatus *)0;
          Error = (std::string *)0;
          UtcTime = (time_t)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZStatus() { }
        /// Friend allocator used by soap_new_ns2__PTZStatus(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZStatus * SOAP_FMAC2 soap_instantiate_ns2__PTZStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1528 */
#ifndef SOAP_TYPE_ns2__PTZPreset
#define SOAP_TYPE_ns2__PTZPreset (660)
/* complex XSD type 'ns2:PTZPreset': */
class SOAP_CMAC ns2__PTZPreset {
      public:
        /// Optional element 'ns2:Name' of XSD type 'ns2:Name'
        std::string *Name;
        /// Optional element 'ns2:PTZPosition' of XSD type 'ns2:PTZVector'
        ns2__PTZVector *PTZPosition;
        /// optional attribute 'token' of XSD type 'ns2:ReferenceToken'
        std::string *token;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZPreset
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZPreset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZPreset, default initialized and not managed by a soap context
        virtual ns2__PTZPreset *soap_alloc(void) const { return SOAP_NEW(ns2__PTZPreset); }
      public:
        /// Constructor with initializations
        ns2__PTZPreset()
        {
          Name = (std::string *)0;
          PTZPosition = (ns2__PTZVector *)0;
          token = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZPreset() { }
        /// Friend allocator used by soap_new_ns2__PTZPreset(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZPreset * SOAP_FMAC2 soap_instantiate_ns2__PTZPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1531 */
#ifndef SOAP_TYPE_ns2__PTZMoveStatus
#define SOAP_TYPE_ns2__PTZMoveStatus (661)
/* complex XSD type 'ns2:PTZMoveStatus': */
class SOAP_CMAC ns2__PTZMoveStatus {
      public:
        /// Optional element 'ns2:PanTilt' of XSD type 'ns2:MoveStatus'
        ns2__MoveStatus *PanTilt;
        /// Optional element 'ns2:Zoom' of XSD type 'ns2:MoveStatus'
        ns2__MoveStatus *Zoom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZMoveStatus
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZMoveStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZMoveStatus, default initialized and not managed by a soap context
        virtual ns2__PTZMoveStatus *soap_alloc(void) const { return SOAP_NEW(ns2__PTZMoveStatus); }
      public:
        /// Constructor with initializations
        ns2__PTZMoveStatus()
        {
          PanTilt = (ns2__MoveStatus *)0;
          Zoom = (ns2__MoveStatus *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZMoveStatus() { }
        /// Friend allocator used by soap_new_ns2__PTZMoveStatus(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZMoveStatus * SOAP_FMAC2 soap_instantiate_ns2__PTZMoveStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1534 */
#ifndef SOAP_TYPE_ns2__PresetTour
#define SOAP_TYPE_ns2__PresetTour (662)
/* complex XSD type 'ns2:PresetTour': */
class SOAP_CMAC ns2__PresetTour {
      public:
        /// Optional element 'ns2:Name' of XSD type 'ns2:Name'
        std::string *Name;
        /// Required element 'ns2:Status' of XSD type 'ns2:PTZPresetTourStatus'
        ns2__PTZPresetTourStatus *Status;
        /// Required element 'ns2:AutoStart' of XSD type 'xsd:boolean'
        bool AutoStart;
        /// Required element 'ns2:StartingCondition' of XSD type 'ns2:PTZPresetTourStartingCondition'
        ns2__PTZPresetTourStartingCondition *StartingCondition;
        /// Optional element 'ns2:TourSpot' of XSD type 'ns2:PTZPresetTourSpot'
        std::vector<ns2__PTZPresetTourSpot *> TourSpot;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:PTZPresetTourExtension'
        ns2__PTZPresetTourExtension *Extension;
        /// optional attribute 'token' of XSD type 'ns2:ReferenceToken'
        std::string *token;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PresetTour
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PresetTour; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PresetTour, default initialized and not managed by a soap context
        virtual ns2__PresetTour *soap_alloc(void) const { return SOAP_NEW(ns2__PresetTour); }
      public:
        /// Constructor with initializations
        ns2__PresetTour()
        {
          Name = (std::string *)0;
          Status = (ns2__PTZPresetTourStatus *)0;
          AutoStart = (bool)0;
          StartingCondition = (ns2__PTZPresetTourStartingCondition *)0;
          Extension = (ns2__PTZPresetTourExtension *)0;
          token = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PresetTour() { }
        /// Friend allocator used by soap_new_ns2__PresetTour(struct soap*, int)
        friend SOAP_FMAC1 ns2__PresetTour * SOAP_FMAC2 soap_instantiate_ns2__PresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1537 */
#ifndef SOAP_TYPE_ns2__PTZPresetTourExtension
#define SOAP_TYPE_ns2__PTZPresetTourExtension (663)
/* complex XSD type 'ns2:PTZPresetTourExtension': */
class SOAP_CMAC ns2__PTZPresetTourExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZPresetTourExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZPresetTourExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZPresetTourExtension, default initialized and not managed by a soap context
        virtual ns2__PTZPresetTourExtension *soap_alloc(void) const { return SOAP_NEW(ns2__PTZPresetTourExtension); }
      public:
        /// Constructor with initializations
        ns2__PTZPresetTourExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZPresetTourExtension() { }
        /// Friend allocator used by soap_new_ns2__PTZPresetTourExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZPresetTourExtension * SOAP_FMAC2 soap_instantiate_ns2__PTZPresetTourExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1540 */
#ifndef SOAP_TYPE_ns2__PTZPresetTourSpot
#define SOAP_TYPE_ns2__PTZPresetTourSpot (664)
/* complex XSD type 'ns2:PTZPresetTourSpot': */
class SOAP_CMAC ns2__PTZPresetTourSpot {
      public:
        /// Required element 'ns2:PresetDetail' of XSD type 'ns2:PTZPresetTourPresetDetail'
        ns2__PTZPresetTourPresetDetail *PresetDetail;
        /// Optional element 'ns2:Speed' of XSD type 'ns2:PTZSpeed'
        ns2__PTZSpeed *Speed;
        /// Optional element 'ns2:StayTime' of XSD type 'xsd:duration'
        std::string *StayTime;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:PTZPresetTourSpotExtension'
        ns2__PTZPresetTourSpotExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZPresetTourSpot
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZPresetTourSpot; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZPresetTourSpot, default initialized and not managed by a soap context
        virtual ns2__PTZPresetTourSpot *soap_alloc(void) const { return SOAP_NEW(ns2__PTZPresetTourSpot); }
      public:
        /// Constructor with initializations
        ns2__PTZPresetTourSpot()
        {
          PresetDetail = (ns2__PTZPresetTourPresetDetail *)0;
          Speed = (ns2__PTZSpeed *)0;
          StayTime = (std::string *)0;
          Extension = (ns2__PTZPresetTourSpotExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZPresetTourSpot() { }
        /// Friend allocator used by soap_new_ns2__PTZPresetTourSpot(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZPresetTourSpot * SOAP_FMAC2 soap_instantiate_ns2__PTZPresetTourSpot(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1543 */
#ifndef SOAP_TYPE_ns2__PTZPresetTourSpotExtension
#define SOAP_TYPE_ns2__PTZPresetTourSpotExtension (665)
/* complex XSD type 'ns2:PTZPresetTourSpotExtension': */
class SOAP_CMAC ns2__PTZPresetTourSpotExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZPresetTourSpotExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZPresetTourSpotExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZPresetTourSpotExtension, default initialized and not managed by a soap context
        virtual ns2__PTZPresetTourSpotExtension *soap_alloc(void) const { return SOAP_NEW(ns2__PTZPresetTourSpotExtension); }
      public:
        /// Constructor with initializations
        ns2__PTZPresetTourSpotExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZPresetTourSpotExtension() { }
        /// Friend allocator used by soap_new_ns2__PTZPresetTourSpotExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZPresetTourSpotExtension * SOAP_FMAC2 soap_instantiate_ns2__PTZPresetTourSpotExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:16992 */
#ifndef SOAP_TYPE__ns2__union_PTZPresetTourPresetDetail
#define SOAP_TYPE__ns2__union_PTZPresetTourPresetDetail (1761)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns2__union_PTZPresetTourPresetDetail
{
        #define SOAP_UNION__ns2__union_PTZPresetTourPresetDetail_PresetToken	(1)	/**< union variant selector value for member PresetToken */
        std::string *PresetToken;
        #define SOAP_UNION__ns2__union_PTZPresetTourPresetDetail_Home	(2)	/**< union variant selector value for member Home */
        bool Home;
        #define SOAP_UNION__ns2__union_PTZPresetTourPresetDetail_PTZPosition	(3)	/**< union variant selector value for member PTZPosition */
        ns2__PTZVector *PTZPosition;
        #define SOAP_UNION__ns2__union_PTZPresetTourPresetDetail_TypeExtension	(4)	/**< union variant selector value for member TypeExtension */
        ns2__PTZPresetTourTypeExtension *TypeExtension;
};
#endif

/* onvifgen/onvif.h:1546 */
#ifndef SOAP_TYPE_ns2__PTZPresetTourPresetDetail
#define SOAP_TYPE_ns2__PTZPresetTourPresetDetail (666)
/* complex XSD type 'ns2:PTZPresetTourPresetDetail': */
class SOAP_CMAC ns2__PTZPresetTourPresetDetail {
      public:
        /// Union with union _ns2__union_PTZPresetTourPresetDetail variant selector __union_PTZPresetTourPresetDetail set to one of: SOAP_UNION__ns2__union_PTZPresetTourPresetDetail_PresetToken SOAP_UNION__ns2__union_PTZPresetTourPresetDetail_Home SOAP_UNION__ns2__union_PTZPresetTourPresetDetail_PTZPosition SOAP_UNION__ns2__union_PTZPresetTourPresetDetail_TypeExtension
        int __union_PTZPresetTourPresetDetail;
        union _ns2__union_PTZPresetTourPresetDetail union_PTZPresetTourPresetDetail;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZPresetTourPresetDetail
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZPresetTourPresetDetail; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZPresetTourPresetDetail, default initialized and not managed by a soap context
        virtual ns2__PTZPresetTourPresetDetail *soap_alloc(void) const { return SOAP_NEW(ns2__PTZPresetTourPresetDetail); }
      public:
        /// Constructor with initializations
        ns2__PTZPresetTourPresetDetail()
        {
          __union_PTZPresetTourPresetDetail = -1;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZPresetTourPresetDetail() { }
        /// Friend allocator used by soap_new_ns2__PTZPresetTourPresetDetail(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZPresetTourPresetDetail * SOAP_FMAC2 soap_instantiate_ns2__PTZPresetTourPresetDetail(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1549 */
#ifndef SOAP_TYPE_ns2__PTZPresetTourTypeExtension
#define SOAP_TYPE_ns2__PTZPresetTourTypeExtension (667)
/* complex XSD type 'ns2:PTZPresetTourTypeExtension': */
class SOAP_CMAC ns2__PTZPresetTourTypeExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZPresetTourTypeExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZPresetTourTypeExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZPresetTourTypeExtension, default initialized and not managed by a soap context
        virtual ns2__PTZPresetTourTypeExtension *soap_alloc(void) const { return SOAP_NEW(ns2__PTZPresetTourTypeExtension); }
      public:
        /// Constructor with initializations
        ns2__PTZPresetTourTypeExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZPresetTourTypeExtension() { }
        /// Friend allocator used by soap_new_ns2__PTZPresetTourTypeExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZPresetTourTypeExtension * SOAP_FMAC2 soap_instantiate_ns2__PTZPresetTourTypeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1552 */
#ifndef SOAP_TYPE_ns2__PTZPresetTourStatus
#define SOAP_TYPE_ns2__PTZPresetTourStatus (668)
/* complex XSD type 'ns2:PTZPresetTourStatus': */
class SOAP_CMAC ns2__PTZPresetTourStatus {
      public:
        /// Required element 'ns2:State' of XSD type 'ns2:PTZPresetTourState'
        ns2__PTZPresetTourState State;
        /// Optional element 'ns2:CurrentTourSpot' of XSD type 'ns2:PTZPresetTourSpot'
        ns2__PTZPresetTourSpot *CurrentTourSpot;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:PTZPresetTourStatusExtension'
        ns2__PTZPresetTourStatusExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZPresetTourStatus
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZPresetTourStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZPresetTourStatus, default initialized and not managed by a soap context
        virtual ns2__PTZPresetTourStatus *soap_alloc(void) const { return SOAP_NEW(ns2__PTZPresetTourStatus); }
      public:
        /// Constructor with initializations
        ns2__PTZPresetTourStatus()
        {
          State = (ns2__PTZPresetTourState)0;
          CurrentTourSpot = (ns2__PTZPresetTourSpot *)0;
          Extension = (ns2__PTZPresetTourStatusExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZPresetTourStatus() { }
        /// Friend allocator used by soap_new_ns2__PTZPresetTourStatus(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZPresetTourStatus * SOAP_FMAC2 soap_instantiate_ns2__PTZPresetTourStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1555 */
#ifndef SOAP_TYPE_ns2__PTZPresetTourStatusExtension
#define SOAP_TYPE_ns2__PTZPresetTourStatusExtension (669)
/* complex XSD type 'ns2:PTZPresetTourStatusExtension': */
class SOAP_CMAC ns2__PTZPresetTourStatusExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZPresetTourStatusExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZPresetTourStatusExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZPresetTourStatusExtension, default initialized and not managed by a soap context
        virtual ns2__PTZPresetTourStatusExtension *soap_alloc(void) const { return SOAP_NEW(ns2__PTZPresetTourStatusExtension); }
      public:
        /// Constructor with initializations
        ns2__PTZPresetTourStatusExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZPresetTourStatusExtension() { }
        /// Friend allocator used by soap_new_ns2__PTZPresetTourStatusExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZPresetTourStatusExtension * SOAP_FMAC2 soap_instantiate_ns2__PTZPresetTourStatusExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1558 */
#ifndef SOAP_TYPE_ns2__PTZPresetTourStartingCondition
#define SOAP_TYPE_ns2__PTZPresetTourStartingCondition (670)
/* complex XSD type 'ns2:PTZPresetTourStartingCondition': */
class SOAP_CMAC ns2__PTZPresetTourStartingCondition {
      public:
        /// Optional element 'ns2:RecurringTime' of XSD type 'xsd:int'
        int *RecurringTime;
        /// Optional element 'ns2:RecurringDuration' of XSD type 'xsd:duration'
        std::string *RecurringDuration;
        /// Optional element 'ns2:Direction' of XSD type 'ns2:PTZPresetTourDirection'
        ns2__PTZPresetTourDirection *Direction;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:PTZPresetTourStartingConditionExtension'
        ns2__PTZPresetTourStartingConditionExtension *Extension;
        /// optional attribute 'RandomPresetOrder' of XSD type 'xsd:boolean'
        bool *RandomPresetOrder;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZPresetTourStartingCondition
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZPresetTourStartingCondition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZPresetTourStartingCondition, default initialized and not managed by a soap context
        virtual ns2__PTZPresetTourStartingCondition *soap_alloc(void) const { return SOAP_NEW(ns2__PTZPresetTourStartingCondition); }
      public:
        /// Constructor with initializations
        ns2__PTZPresetTourStartingCondition()
        {
          RecurringTime = (int *)0;
          RecurringDuration = (std::string *)0;
          Direction = (ns2__PTZPresetTourDirection *)0;
          Extension = (ns2__PTZPresetTourStartingConditionExtension *)0;
          RandomPresetOrder = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZPresetTourStartingCondition() { }
        /// Friend allocator used by soap_new_ns2__PTZPresetTourStartingCondition(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZPresetTourStartingCondition * SOAP_FMAC2 soap_instantiate_ns2__PTZPresetTourStartingCondition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1561 */
#ifndef SOAP_TYPE_ns2__PTZPresetTourStartingConditionExtension
#define SOAP_TYPE_ns2__PTZPresetTourStartingConditionExtension (671)
/* complex XSD type 'ns2:PTZPresetTourStartingConditionExtension': */
class SOAP_CMAC ns2__PTZPresetTourStartingConditionExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZPresetTourStartingConditionExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZPresetTourStartingConditionExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZPresetTourStartingConditionExtension, default initialized and not managed by a soap context
        virtual ns2__PTZPresetTourStartingConditionExtension *soap_alloc(void) const { return SOAP_NEW(ns2__PTZPresetTourStartingConditionExtension); }
      public:
        /// Constructor with initializations
        ns2__PTZPresetTourStartingConditionExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZPresetTourStartingConditionExtension() { }
        /// Friend allocator used by soap_new_ns2__PTZPresetTourStartingConditionExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZPresetTourStartingConditionExtension * SOAP_FMAC2 soap_instantiate_ns2__PTZPresetTourStartingConditionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1564 */
#ifndef SOAP_TYPE_ns2__PTZPresetTourOptions
#define SOAP_TYPE_ns2__PTZPresetTourOptions (672)
/* complex XSD type 'ns2:PTZPresetTourOptions': */
class SOAP_CMAC ns2__PTZPresetTourOptions {
      public:
        /// Required element 'ns2:AutoStart' of XSD type 'xsd:boolean'
        bool AutoStart;
        /// Required element 'ns2:StartingCondition' of XSD type 'ns2:PTZPresetTourStartingConditionOptions'
        ns2__PTZPresetTourStartingConditionOptions *StartingCondition;
        /// Required element 'ns2:TourSpot' of XSD type 'ns2:PTZPresetTourSpotOptions'
        ns2__PTZPresetTourSpotOptions *TourSpot;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZPresetTourOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZPresetTourOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZPresetTourOptions, default initialized and not managed by a soap context
        virtual ns2__PTZPresetTourOptions *soap_alloc(void) const { return SOAP_NEW(ns2__PTZPresetTourOptions); }
      public:
        /// Constructor with initializations
        ns2__PTZPresetTourOptions()
        {
          AutoStart = (bool)0;
          StartingCondition = (ns2__PTZPresetTourStartingConditionOptions *)0;
          TourSpot = (ns2__PTZPresetTourSpotOptions *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZPresetTourOptions() { }
        /// Friend allocator used by soap_new_ns2__PTZPresetTourOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZPresetTourOptions * SOAP_FMAC2 soap_instantiate_ns2__PTZPresetTourOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1567 */
#ifndef SOAP_TYPE_ns2__PTZPresetTourSpotOptions
#define SOAP_TYPE_ns2__PTZPresetTourSpotOptions (673)
/* complex XSD type 'ns2:PTZPresetTourSpotOptions': */
class SOAP_CMAC ns2__PTZPresetTourSpotOptions {
      public:
        /// Required element 'ns2:PresetDetail' of XSD type 'ns2:PTZPresetTourPresetDetailOptions'
        ns2__PTZPresetTourPresetDetailOptions *PresetDetail;
        /// Required element 'ns2:StayTime' of XSD type 'ns2:DurationRange'
        ns2__DurationRange *StayTime;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZPresetTourSpotOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZPresetTourSpotOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZPresetTourSpotOptions, default initialized and not managed by a soap context
        virtual ns2__PTZPresetTourSpotOptions *soap_alloc(void) const { return SOAP_NEW(ns2__PTZPresetTourSpotOptions); }
      public:
        /// Constructor with initializations
        ns2__PTZPresetTourSpotOptions()
        {
          PresetDetail = (ns2__PTZPresetTourPresetDetailOptions *)0;
          StayTime = (ns2__DurationRange *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZPresetTourSpotOptions() { }
        /// Friend allocator used by soap_new_ns2__PTZPresetTourSpotOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZPresetTourSpotOptions * SOAP_FMAC2 soap_instantiate_ns2__PTZPresetTourSpotOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1570 */
#ifndef SOAP_TYPE_ns2__PTZPresetTourPresetDetailOptions
#define SOAP_TYPE_ns2__PTZPresetTourPresetDetailOptions (674)
/* complex XSD type 'ns2:PTZPresetTourPresetDetailOptions': */
class SOAP_CMAC ns2__PTZPresetTourPresetDetailOptions {
      public:
        /// Optional element 'ns2:PresetToken' of XSD type 'ns2:ReferenceToken'
        std::vector<std::string> PresetToken;
        /// Optional element 'ns2:Home' of XSD type 'xsd:boolean'
        bool *Home;
        /// Optional element 'ns2:PanTiltPositionSpace' of XSD type 'ns2:Space2DDescription'
        ns2__Space2DDescription *PanTiltPositionSpace;
        /// Optional element 'ns2:ZoomPositionSpace' of XSD type 'ns2:Space1DDescription'
        ns2__Space1DDescription *ZoomPositionSpace;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:PTZPresetTourPresetDetailOptionsExtension'
        ns2__PTZPresetTourPresetDetailOptionsExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZPresetTourPresetDetailOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZPresetTourPresetDetailOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZPresetTourPresetDetailOptions, default initialized and not managed by a soap context
        virtual ns2__PTZPresetTourPresetDetailOptions *soap_alloc(void) const { return SOAP_NEW(ns2__PTZPresetTourPresetDetailOptions); }
      public:
        /// Constructor with initializations
        ns2__PTZPresetTourPresetDetailOptions()
        {
          Home = (bool *)0;
          PanTiltPositionSpace = (ns2__Space2DDescription *)0;
          ZoomPositionSpace = (ns2__Space1DDescription *)0;
          Extension = (ns2__PTZPresetTourPresetDetailOptionsExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZPresetTourPresetDetailOptions() { }
        /// Friend allocator used by soap_new_ns2__PTZPresetTourPresetDetailOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZPresetTourPresetDetailOptions * SOAP_FMAC2 soap_instantiate_ns2__PTZPresetTourPresetDetailOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1573 */
#ifndef SOAP_TYPE_ns2__PTZPresetTourPresetDetailOptionsExtension
#define SOAP_TYPE_ns2__PTZPresetTourPresetDetailOptionsExtension (675)
/* complex XSD type 'ns2:PTZPresetTourPresetDetailOptionsExtension': */
class SOAP_CMAC ns2__PTZPresetTourPresetDetailOptionsExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZPresetTourPresetDetailOptionsExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZPresetTourPresetDetailOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZPresetTourPresetDetailOptionsExtension, default initialized and not managed by a soap context
        virtual ns2__PTZPresetTourPresetDetailOptionsExtension *soap_alloc(void) const { return SOAP_NEW(ns2__PTZPresetTourPresetDetailOptionsExtension); }
      public:
        /// Constructor with initializations
        ns2__PTZPresetTourPresetDetailOptionsExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZPresetTourPresetDetailOptionsExtension() { }
        /// Friend allocator used by soap_new_ns2__PTZPresetTourPresetDetailOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZPresetTourPresetDetailOptionsExtension * SOAP_FMAC2 soap_instantiate_ns2__PTZPresetTourPresetDetailOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1576 */
#ifndef SOAP_TYPE_ns2__PTZPresetTourStartingConditionOptions
#define SOAP_TYPE_ns2__PTZPresetTourStartingConditionOptions (676)
/* complex XSD type 'ns2:PTZPresetTourStartingConditionOptions': */
class SOAP_CMAC ns2__PTZPresetTourStartingConditionOptions {
      public:
        /// Optional element 'ns2:RecurringTime' of XSD type 'ns2:IntRange'
        ns2__IntRange *RecurringTime;
        /// Optional element 'ns2:RecurringDuration' of XSD type 'ns2:DurationRange'
        ns2__DurationRange *RecurringDuration;
        /// Optional element 'ns2:Direction' of XSD type 'ns2:PTZPresetTourDirection'
        std::vector<ns2__PTZPresetTourDirection> Direction;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:PTZPresetTourStartingConditionOptionsExtension'
        ns2__PTZPresetTourStartingConditionOptionsExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZPresetTourStartingConditionOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZPresetTourStartingConditionOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZPresetTourStartingConditionOptions, default initialized and not managed by a soap context
        virtual ns2__PTZPresetTourStartingConditionOptions *soap_alloc(void) const { return SOAP_NEW(ns2__PTZPresetTourStartingConditionOptions); }
      public:
        /// Constructor with initializations
        ns2__PTZPresetTourStartingConditionOptions()
        {
          RecurringTime = (ns2__IntRange *)0;
          RecurringDuration = (ns2__DurationRange *)0;
          Extension = (ns2__PTZPresetTourStartingConditionOptionsExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZPresetTourStartingConditionOptions() { }
        /// Friend allocator used by soap_new_ns2__PTZPresetTourStartingConditionOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZPresetTourStartingConditionOptions * SOAP_FMAC2 soap_instantiate_ns2__PTZPresetTourStartingConditionOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1579 */
#ifndef SOAP_TYPE_ns2__PTZPresetTourStartingConditionOptionsExtension
#define SOAP_TYPE_ns2__PTZPresetTourStartingConditionOptionsExtension (677)
/* complex XSD type 'ns2:PTZPresetTourStartingConditionOptionsExtension': */
class SOAP_CMAC ns2__PTZPresetTourStartingConditionOptionsExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZPresetTourStartingConditionOptionsExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZPresetTourStartingConditionOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZPresetTourStartingConditionOptionsExtension, default initialized and not managed by a soap context
        virtual ns2__PTZPresetTourStartingConditionOptionsExtension *soap_alloc(void) const { return SOAP_NEW(ns2__PTZPresetTourStartingConditionOptionsExtension); }
      public:
        /// Constructor with initializations
        ns2__PTZPresetTourStartingConditionOptionsExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZPresetTourStartingConditionOptionsExtension() { }
        /// Friend allocator used by soap_new_ns2__PTZPresetTourStartingConditionOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZPresetTourStartingConditionOptionsExtension * SOAP_FMAC2 soap_instantiate_ns2__PTZPresetTourStartingConditionOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1582 */
#ifndef SOAP_TYPE_ns2__ImagingStatus
#define SOAP_TYPE_ns2__ImagingStatus (678)
/* complex XSD type 'ns2:ImagingStatus': */
class SOAP_CMAC ns2__ImagingStatus {
      public:
        /// Required element 'ns2:FocusStatus' of XSD type 'ns2:FocusStatus'
        ns2__FocusStatus *FocusStatus;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ImagingStatus
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ImagingStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ImagingStatus, default initialized and not managed by a soap context
        virtual ns2__ImagingStatus *soap_alloc(void) const { return SOAP_NEW(ns2__ImagingStatus); }
      public:
        /// Constructor with initializations
        ns2__ImagingStatus()
        {
          FocusStatus = (ns2__FocusStatus *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ImagingStatus() { }
        /// Friend allocator used by soap_new_ns2__ImagingStatus(struct soap*, int)
        friend SOAP_FMAC1 ns2__ImagingStatus * SOAP_FMAC2 soap_instantiate_ns2__ImagingStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1585 */
#ifndef SOAP_TYPE_ns2__FocusStatus
#define SOAP_TYPE_ns2__FocusStatus (679)
/* complex XSD type 'ns2:FocusStatus': */
class SOAP_CMAC ns2__FocusStatus {
      public:
        /// Required element 'ns2:Position' of XSD type 'xsd:float'
        float Position;
        /// Required element 'ns2:MoveStatus' of XSD type 'ns2:MoveStatus'
        ns2__MoveStatus MoveStatus;
        /// Required element 'ns2:Error' of XSD type 'xsd:string'
        std::string Error;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FocusStatus
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FocusStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FocusStatus, default initialized and not managed by a soap context
        virtual ns2__FocusStatus *soap_alloc(void) const { return SOAP_NEW(ns2__FocusStatus); }
      public:
        /// Constructor with initializations
        ns2__FocusStatus()
        {
          Position = (float)0;
          MoveStatus = (ns2__MoveStatus)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__FocusStatus() { }
        /// Friend allocator used by soap_new_ns2__FocusStatus(struct soap*, int)
        friend SOAP_FMAC1 ns2__FocusStatus * SOAP_FMAC2 soap_instantiate_ns2__FocusStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1588 */
#ifndef SOAP_TYPE_ns2__FocusConfiguration
#define SOAP_TYPE_ns2__FocusConfiguration (680)
/* complex XSD type 'ns2:FocusConfiguration': */
class SOAP_CMAC ns2__FocusConfiguration {
      public:
        /// Required element 'ns2:AutoFocusMode' of XSD type 'ns2:AutoFocusMode'
        ns2__AutoFocusMode AutoFocusMode;
        /// Required element 'ns2:DefaultSpeed' of XSD type 'xsd:float'
        float DefaultSpeed;
        /// Required element 'ns2:NearLimit' of XSD type 'xsd:float'
        float NearLimit;
        /// Required element 'ns2:FarLimit' of XSD type 'xsd:float'
        float FarLimit;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FocusConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FocusConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FocusConfiguration, default initialized and not managed by a soap context
        virtual ns2__FocusConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__FocusConfiguration); }
      public:
        /// Constructor with initializations
        ns2__FocusConfiguration()
        {
          AutoFocusMode = (ns2__AutoFocusMode)0;
          DefaultSpeed = (float)0;
          NearLimit = (float)0;
          FarLimit = (float)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__FocusConfiguration() { }
        /// Friend allocator used by soap_new_ns2__FocusConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__FocusConfiguration * SOAP_FMAC2 soap_instantiate_ns2__FocusConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1591 */
#ifndef SOAP_TYPE_ns2__ImagingSettings
#define SOAP_TYPE_ns2__ImagingSettings (681)
/* complex XSD type 'ns2:ImagingSettings': */
class SOAP_CMAC ns2__ImagingSettings {
      public:
        /// Optional element 'ns2:BacklightCompensation' of XSD type 'ns2:BacklightCompensation'
        ns2__BacklightCompensation *BacklightCompensation;
        /// Optional element 'ns2:Brightness' of XSD type 'xsd:float'
        float *Brightness;
        /// Optional element 'ns2:ColorSaturation' of XSD type 'xsd:float'
        float *ColorSaturation;
        /// Optional element 'ns2:Contrast' of XSD type 'xsd:float'
        float *Contrast;
        /// Optional element 'ns2:Exposure' of XSD type 'ns2:Exposure'
        ns2__Exposure *Exposure;
        /// Optional element 'ns2:Focus' of XSD type 'ns2:FocusConfiguration'
        ns2__FocusConfiguration *Focus;
        /// Optional element 'ns2:IrCutFilter' of XSD type 'ns2:IrCutFilterMode'
        ns2__IrCutFilterMode *IrCutFilter;
        /// Optional element 'ns2:Sharpness' of XSD type 'xsd:float'
        float *Sharpness;
        /// Optional element 'ns2:WideDynamicRange' of XSD type 'ns2:WideDynamicRange'
        ns2__WideDynamicRange *WideDynamicRange;
        /// Optional element 'ns2:WhiteBalance' of XSD type 'ns2:WhiteBalance'
        ns2__WhiteBalance *WhiteBalance;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ImagingSettingsExtension'
        ns2__ImagingSettingsExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ImagingSettings
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ImagingSettings; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ImagingSettings, default initialized and not managed by a soap context
        virtual ns2__ImagingSettings *soap_alloc(void) const { return SOAP_NEW(ns2__ImagingSettings); }
      public:
        /// Constructor with initializations
        ns2__ImagingSettings()
        {
          BacklightCompensation = (ns2__BacklightCompensation *)0;
          Brightness = (float *)0;
          ColorSaturation = (float *)0;
          Contrast = (float *)0;
          Exposure = (ns2__Exposure *)0;
          Focus = (ns2__FocusConfiguration *)0;
          IrCutFilter = (ns2__IrCutFilterMode *)0;
          Sharpness = (float *)0;
          WideDynamicRange = (ns2__WideDynamicRange *)0;
          WhiteBalance = (ns2__WhiteBalance *)0;
          Extension = (ns2__ImagingSettingsExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ImagingSettings() { }
        /// Friend allocator used by soap_new_ns2__ImagingSettings(struct soap*, int)
        friend SOAP_FMAC1 ns2__ImagingSettings * SOAP_FMAC2 soap_instantiate_ns2__ImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1594 */
#ifndef SOAP_TYPE_ns2__ImagingSettingsExtension
#define SOAP_TYPE_ns2__ImagingSettingsExtension (682)
/* complex XSD type 'ns2:ImagingSettingsExtension': */
class SOAP_CMAC ns2__ImagingSettingsExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ImagingSettingsExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ImagingSettingsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ImagingSettingsExtension, default initialized and not managed by a soap context
        virtual ns2__ImagingSettingsExtension *soap_alloc(void) const { return SOAP_NEW(ns2__ImagingSettingsExtension); }
      public:
        /// Constructor with initializations
        ns2__ImagingSettingsExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ImagingSettingsExtension() { }
        /// Friend allocator used by soap_new_ns2__ImagingSettingsExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__ImagingSettingsExtension * SOAP_FMAC2 soap_instantiate_ns2__ImagingSettingsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1597 */
#ifndef SOAP_TYPE_ns2__Exposure
#define SOAP_TYPE_ns2__Exposure (683)
/* complex XSD type 'ns2:Exposure': */
class SOAP_CMAC ns2__Exposure {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:ExposureMode'
        ns2__ExposureMode Mode;
        /// Required element 'ns2:Priority' of XSD type 'ns2:ExposurePriority'
        ns2__ExposurePriority Priority;
        /// Required element 'ns2:Window' of XSD type 'ns2:Rectangle'
        ns2__Rectangle *Window;
        /// Required element 'ns2:MinExposureTime' of XSD type 'xsd:float'
        float MinExposureTime;
        /// Required element 'ns2:MaxExposureTime' of XSD type 'xsd:float'
        float MaxExposureTime;
        /// Required element 'ns2:MinGain' of XSD type 'xsd:float'
        float MinGain;
        /// Required element 'ns2:MaxGain' of XSD type 'xsd:float'
        float MaxGain;
        /// Required element 'ns2:MinIris' of XSD type 'xsd:float'
        float MinIris;
        /// Required element 'ns2:MaxIris' of XSD type 'xsd:float'
        float MaxIris;
        /// Required element 'ns2:ExposureTime' of XSD type 'xsd:float'
        float ExposureTime;
        /// Required element 'ns2:Gain' of XSD type 'xsd:float'
        float Gain;
        /// Required element 'ns2:Iris' of XSD type 'xsd:float'
        float Iris;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Exposure
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Exposure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Exposure, default initialized and not managed by a soap context
        virtual ns2__Exposure *soap_alloc(void) const { return SOAP_NEW(ns2__Exposure); }
      public:
        /// Constructor with initializations
        ns2__Exposure()
        {
          Mode = (ns2__ExposureMode)0;
          Priority = (ns2__ExposurePriority)0;
          Window = (ns2__Rectangle *)0;
          MinExposureTime = (float)0;
          MaxExposureTime = (float)0;
          MinGain = (float)0;
          MaxGain = (float)0;
          MinIris = (float)0;
          MaxIris = (float)0;
          ExposureTime = (float)0;
          Gain = (float)0;
          Iris = (float)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Exposure() { }
        /// Friend allocator used by soap_new_ns2__Exposure(struct soap*, int)
        friend SOAP_FMAC1 ns2__Exposure * SOAP_FMAC2 soap_instantiate_ns2__Exposure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1600 */
#ifndef SOAP_TYPE_ns2__WideDynamicRange
#define SOAP_TYPE_ns2__WideDynamicRange (684)
/* complex XSD type 'ns2:WideDynamicRange': */
class SOAP_CMAC ns2__WideDynamicRange {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:WideDynamicMode'
        ns2__WideDynamicMode Mode;
        /// Required element 'ns2:Level' of XSD type 'xsd:float'
        float Level;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__WideDynamicRange
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__WideDynamicRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__WideDynamicRange, default initialized and not managed by a soap context
        virtual ns2__WideDynamicRange *soap_alloc(void) const { return SOAP_NEW(ns2__WideDynamicRange); }
      public:
        /// Constructor with initializations
        ns2__WideDynamicRange()
        {
          Mode = (ns2__WideDynamicMode)0;
          Level = (float)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__WideDynamicRange() { }
        /// Friend allocator used by soap_new_ns2__WideDynamicRange(struct soap*, int)
        friend SOAP_FMAC1 ns2__WideDynamicRange * SOAP_FMAC2 soap_instantiate_ns2__WideDynamicRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1603 */
#ifndef SOAP_TYPE_ns2__BacklightCompensation
#define SOAP_TYPE_ns2__BacklightCompensation (685)
/* complex XSD type 'ns2:BacklightCompensation': */
class SOAP_CMAC ns2__BacklightCompensation {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:BacklightCompensationMode'
        ns2__BacklightCompensationMode Mode;
        /// Required element 'ns2:Level' of XSD type 'xsd:float'
        float Level;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BacklightCompensation
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__BacklightCompensation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BacklightCompensation, default initialized and not managed by a soap context
        virtual ns2__BacklightCompensation *soap_alloc(void) const { return SOAP_NEW(ns2__BacklightCompensation); }
      public:
        /// Constructor with initializations
        ns2__BacklightCompensation()
        {
          Mode = (ns2__BacklightCompensationMode)0;
          Level = (float)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__BacklightCompensation() { }
        /// Friend allocator used by soap_new_ns2__BacklightCompensation(struct soap*, int)
        friend SOAP_FMAC1 ns2__BacklightCompensation * SOAP_FMAC2 soap_instantiate_ns2__BacklightCompensation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1606 */
#ifndef SOAP_TYPE_ns2__ImagingOptions
#define SOAP_TYPE_ns2__ImagingOptions (686)
/* complex XSD type 'ns2:ImagingOptions': */
class SOAP_CMAC ns2__ImagingOptions {
      public:
        /// Required element 'ns2:BacklightCompensation' of XSD type 'ns2:BacklightCompensationOptions'
        ns2__BacklightCompensationOptions *BacklightCompensation;
        /// Required element 'ns2:Brightness' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *Brightness;
        /// Required element 'ns2:ColorSaturation' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *ColorSaturation;
        /// Required element 'ns2:Contrast' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *Contrast;
        /// Required element 'ns2:Exposure' of XSD type 'ns2:ExposureOptions'
        ns2__ExposureOptions *Exposure;
        /// Required element 'ns2:Focus' of XSD type 'ns2:FocusOptions'
        ns2__FocusOptions *Focus;
        /// Required element 'ns2:IrCutFilterModes' of XSD type 'ns2:IrCutFilterMode'
        std::vector<ns2__IrCutFilterMode> IrCutFilterModes;
        /// Required element 'ns2:Sharpness' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *Sharpness;
        /// Required element 'ns2:WideDynamicRange' of XSD type 'ns2:WideDynamicRangeOptions'
        ns2__WideDynamicRangeOptions *WideDynamicRange;
        /// Required element 'ns2:WhiteBalance' of XSD type 'ns2:WhiteBalanceOptions'
        ns2__WhiteBalanceOptions *WhiteBalance;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ImagingOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ImagingOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ImagingOptions, default initialized and not managed by a soap context
        virtual ns2__ImagingOptions *soap_alloc(void) const { return SOAP_NEW(ns2__ImagingOptions); }
      public:
        /// Constructor with initializations
        ns2__ImagingOptions()
        {
          BacklightCompensation = (ns2__BacklightCompensationOptions *)0;
          Brightness = (ns2__FloatRange *)0;
          ColorSaturation = (ns2__FloatRange *)0;
          Contrast = (ns2__FloatRange *)0;
          Exposure = (ns2__ExposureOptions *)0;
          Focus = (ns2__FocusOptions *)0;
          Sharpness = (ns2__FloatRange *)0;
          WideDynamicRange = (ns2__WideDynamicRangeOptions *)0;
          WhiteBalance = (ns2__WhiteBalanceOptions *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ImagingOptions() { }
        /// Friend allocator used by soap_new_ns2__ImagingOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__ImagingOptions * SOAP_FMAC2 soap_instantiate_ns2__ImagingOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1609 */
#ifndef SOAP_TYPE_ns2__WideDynamicRangeOptions
#define SOAP_TYPE_ns2__WideDynamicRangeOptions (687)
/* complex XSD type 'ns2:WideDynamicRangeOptions': */
class SOAP_CMAC ns2__WideDynamicRangeOptions {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:WideDynamicMode'
        std::vector<ns2__WideDynamicMode> Mode;
        /// Required element 'ns2:Level' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *Level;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__WideDynamicRangeOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__WideDynamicRangeOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__WideDynamicRangeOptions, default initialized and not managed by a soap context
        virtual ns2__WideDynamicRangeOptions *soap_alloc(void) const { return SOAP_NEW(ns2__WideDynamicRangeOptions); }
      public:
        /// Constructor with initializations
        ns2__WideDynamicRangeOptions()
        {
          Level = (ns2__FloatRange *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__WideDynamicRangeOptions() { }
        /// Friend allocator used by soap_new_ns2__WideDynamicRangeOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__WideDynamicRangeOptions * SOAP_FMAC2 soap_instantiate_ns2__WideDynamicRangeOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1612 */
#ifndef SOAP_TYPE_ns2__BacklightCompensationOptions
#define SOAP_TYPE_ns2__BacklightCompensationOptions (688)
/* complex XSD type 'ns2:BacklightCompensationOptions': */
class SOAP_CMAC ns2__BacklightCompensationOptions {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:WideDynamicMode'
        std::vector<ns2__WideDynamicMode> Mode;
        /// Required element 'ns2:Level' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *Level;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BacklightCompensationOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__BacklightCompensationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BacklightCompensationOptions, default initialized and not managed by a soap context
        virtual ns2__BacklightCompensationOptions *soap_alloc(void) const { return SOAP_NEW(ns2__BacklightCompensationOptions); }
      public:
        /// Constructor with initializations
        ns2__BacklightCompensationOptions()
        {
          Level = (ns2__FloatRange *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__BacklightCompensationOptions() { }
        /// Friend allocator used by soap_new_ns2__BacklightCompensationOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__BacklightCompensationOptions * SOAP_FMAC2 soap_instantiate_ns2__BacklightCompensationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1615 */
#ifndef SOAP_TYPE_ns2__FocusOptions
#define SOAP_TYPE_ns2__FocusOptions (689)
/* complex XSD type 'ns2:FocusOptions': */
class SOAP_CMAC ns2__FocusOptions {
      public:
        /// Optional element 'ns2:AutoFocusModes' of XSD type 'ns2:AutoFocusMode'
        std::vector<ns2__AutoFocusMode> AutoFocusModes;
        /// Required element 'ns2:DefaultSpeed' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *DefaultSpeed;
        /// Required element 'ns2:NearLimit' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *NearLimit;
        /// Required element 'ns2:FarLimit' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *FarLimit;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FocusOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FocusOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FocusOptions, default initialized and not managed by a soap context
        virtual ns2__FocusOptions *soap_alloc(void) const { return SOAP_NEW(ns2__FocusOptions); }
      public:
        /// Constructor with initializations
        ns2__FocusOptions()
        {
          DefaultSpeed = (ns2__FloatRange *)0;
          NearLimit = (ns2__FloatRange *)0;
          FarLimit = (ns2__FloatRange *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__FocusOptions() { }
        /// Friend allocator used by soap_new_ns2__FocusOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__FocusOptions * SOAP_FMAC2 soap_instantiate_ns2__FocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1618 */
#ifndef SOAP_TYPE_ns2__ExposureOptions
#define SOAP_TYPE_ns2__ExposureOptions (690)
/* complex XSD type 'ns2:ExposureOptions': */
class SOAP_CMAC ns2__ExposureOptions {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:ExposureMode'
        std::vector<ns2__ExposureMode> Mode;
        /// Required element 'ns2:Priority' of XSD type 'ns2:ExposurePriority'
        std::vector<ns2__ExposurePriority> Priority;
        /// Required element 'ns2:MinExposureTime' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *MinExposureTime;
        /// Required element 'ns2:MaxExposureTime' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *MaxExposureTime;
        /// Required element 'ns2:MinGain' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *MinGain;
        /// Required element 'ns2:MaxGain' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *MaxGain;
        /// Required element 'ns2:MinIris' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *MinIris;
        /// Required element 'ns2:MaxIris' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *MaxIris;
        /// Required element 'ns2:ExposureTime' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *ExposureTime;
        /// Required element 'ns2:Gain' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *Gain;
        /// Required element 'ns2:Iris' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *Iris;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ExposureOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ExposureOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ExposureOptions, default initialized and not managed by a soap context
        virtual ns2__ExposureOptions *soap_alloc(void) const { return SOAP_NEW(ns2__ExposureOptions); }
      public:
        /// Constructor with initializations
        ns2__ExposureOptions()
        {
          MinExposureTime = (ns2__FloatRange *)0;
          MaxExposureTime = (ns2__FloatRange *)0;
          MinGain = (ns2__FloatRange *)0;
          MaxGain = (ns2__FloatRange *)0;
          MinIris = (ns2__FloatRange *)0;
          MaxIris = (ns2__FloatRange *)0;
          ExposureTime = (ns2__FloatRange *)0;
          Gain = (ns2__FloatRange *)0;
          Iris = (ns2__FloatRange *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ExposureOptions() { }
        /// Friend allocator used by soap_new_ns2__ExposureOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__ExposureOptions * SOAP_FMAC2 soap_instantiate_ns2__ExposureOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1621 */
#ifndef SOAP_TYPE_ns2__WhiteBalanceOptions
#define SOAP_TYPE_ns2__WhiteBalanceOptions (691)
/* complex XSD type 'ns2:WhiteBalanceOptions': */
class SOAP_CMAC ns2__WhiteBalanceOptions {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:WhiteBalanceMode'
        std::vector<ns2__WhiteBalanceMode> Mode;
        /// Required element 'ns2:YrGain' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *YrGain;
        /// Required element 'ns2:YbGain' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *YbGain;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__WhiteBalanceOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__WhiteBalanceOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__WhiteBalanceOptions, default initialized and not managed by a soap context
        virtual ns2__WhiteBalanceOptions *soap_alloc(void) const { return SOAP_NEW(ns2__WhiteBalanceOptions); }
      public:
        /// Constructor with initializations
        ns2__WhiteBalanceOptions()
        {
          YrGain = (ns2__FloatRange *)0;
          YbGain = (ns2__FloatRange *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__WhiteBalanceOptions() { }
        /// Friend allocator used by soap_new_ns2__WhiteBalanceOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__WhiteBalanceOptions * SOAP_FMAC2 soap_instantiate_ns2__WhiteBalanceOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1624 */
#ifndef SOAP_TYPE_ns2__FocusMove
#define SOAP_TYPE_ns2__FocusMove (692)
/* complex XSD type 'ns2:FocusMove': */
class SOAP_CMAC ns2__FocusMove {
      public:
        /// Optional element 'ns2:Absolute' of XSD type 'ns2:AbsoluteFocus'
        ns2__AbsoluteFocus *Absolute;
        /// Optional element 'ns2:Relative' of XSD type 'ns2:RelativeFocus'
        ns2__RelativeFocus *Relative;
        /// Optional element 'ns2:Continuous' of XSD type 'ns2:ContinuousFocus'
        ns2__ContinuousFocus *Continuous;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FocusMove
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FocusMove; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FocusMove, default initialized and not managed by a soap context
        virtual ns2__FocusMove *soap_alloc(void) const { return SOAP_NEW(ns2__FocusMove); }
      public:
        /// Constructor with initializations
        ns2__FocusMove()
        {
          Absolute = (ns2__AbsoluteFocus *)0;
          Relative = (ns2__RelativeFocus *)0;
          Continuous = (ns2__ContinuousFocus *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__FocusMove() { }
        /// Friend allocator used by soap_new_ns2__FocusMove(struct soap*, int)
        friend SOAP_FMAC1 ns2__FocusMove * SOAP_FMAC2 soap_instantiate_ns2__FocusMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1627 */
#ifndef SOAP_TYPE_ns2__AbsoluteFocus
#define SOAP_TYPE_ns2__AbsoluteFocus (693)
/* complex XSD type 'ns2:AbsoluteFocus': */
class SOAP_CMAC ns2__AbsoluteFocus {
      public:
        /// Required element 'ns2:Position' of XSD type 'xsd:float'
        float Position;
        /// Optional element 'ns2:Speed' of XSD type 'xsd:float'
        float *Speed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AbsoluteFocus
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AbsoluteFocus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AbsoluteFocus, default initialized and not managed by a soap context
        virtual ns2__AbsoluteFocus *soap_alloc(void) const { return SOAP_NEW(ns2__AbsoluteFocus); }
      public:
        /// Constructor with initializations
        ns2__AbsoluteFocus()
        {
          Position = (float)0;
          Speed = (float *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AbsoluteFocus() { }
        /// Friend allocator used by soap_new_ns2__AbsoluteFocus(struct soap*, int)
        friend SOAP_FMAC1 ns2__AbsoluteFocus * SOAP_FMAC2 soap_instantiate_ns2__AbsoluteFocus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1630 */
#ifndef SOAP_TYPE_ns2__RelativeFocus
#define SOAP_TYPE_ns2__RelativeFocus (694)
/* complex XSD type 'ns2:RelativeFocus': */
class SOAP_CMAC ns2__RelativeFocus {
      public:
        /// Required element 'ns2:Distance' of XSD type 'xsd:float'
        float Distance;
        /// Optional element 'ns2:Speed' of XSD type 'xsd:float'
        float *Speed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RelativeFocus
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RelativeFocus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RelativeFocus, default initialized and not managed by a soap context
        virtual ns2__RelativeFocus *soap_alloc(void) const { return SOAP_NEW(ns2__RelativeFocus); }
      public:
        /// Constructor with initializations
        ns2__RelativeFocus()
        {
          Distance = (float)0;
          Speed = (float *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__RelativeFocus() { }
        /// Friend allocator used by soap_new_ns2__RelativeFocus(struct soap*, int)
        friend SOAP_FMAC1 ns2__RelativeFocus * SOAP_FMAC2 soap_instantiate_ns2__RelativeFocus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1633 */
#ifndef SOAP_TYPE_ns2__ContinuousFocus
#define SOAP_TYPE_ns2__ContinuousFocus (695)
/* complex XSD type 'ns2:ContinuousFocus': */
class SOAP_CMAC ns2__ContinuousFocus {
      public:
        /// Required element 'ns2:Speed' of XSD type 'xsd:float'
        float Speed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ContinuousFocus
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ContinuousFocus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ContinuousFocus, default initialized and not managed by a soap context
        virtual ns2__ContinuousFocus *soap_alloc(void) const { return SOAP_NEW(ns2__ContinuousFocus); }
      public:
        /// Constructor with initializations
        ns2__ContinuousFocus()
        {
          Speed = (float)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ContinuousFocus() { }
        /// Friend allocator used by soap_new_ns2__ContinuousFocus(struct soap*, int)
        friend SOAP_FMAC1 ns2__ContinuousFocus * SOAP_FMAC2 soap_instantiate_ns2__ContinuousFocus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1636 */
#ifndef SOAP_TYPE_ns2__MoveOptions
#define SOAP_TYPE_ns2__MoveOptions (696)
/* complex XSD type 'ns2:MoveOptions': */
class SOAP_CMAC ns2__MoveOptions {
      public:
        /// Optional element 'ns2:Absolute' of XSD type 'ns2:AbsoluteFocusOptions'
        ns2__AbsoluteFocusOptions *Absolute;
        /// Optional element 'ns2:Relative' of XSD type 'ns2:RelativeFocusOptions'
        ns2__RelativeFocusOptions *Relative;
        /// Optional element 'ns2:Continuous' of XSD type 'ns2:ContinuousFocusOptions'
        ns2__ContinuousFocusOptions *Continuous;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MoveOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MoveOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MoveOptions, default initialized and not managed by a soap context
        virtual ns2__MoveOptions *soap_alloc(void) const { return SOAP_NEW(ns2__MoveOptions); }
      public:
        /// Constructor with initializations
        ns2__MoveOptions()
        {
          Absolute = (ns2__AbsoluteFocusOptions *)0;
          Relative = (ns2__RelativeFocusOptions *)0;
          Continuous = (ns2__ContinuousFocusOptions *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__MoveOptions() { }
        /// Friend allocator used by soap_new_ns2__MoveOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__MoveOptions * SOAP_FMAC2 soap_instantiate_ns2__MoveOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1639 */
#ifndef SOAP_TYPE_ns2__AbsoluteFocusOptions
#define SOAP_TYPE_ns2__AbsoluteFocusOptions (697)
/* complex XSD type 'ns2:AbsoluteFocusOptions': */
class SOAP_CMAC ns2__AbsoluteFocusOptions {
      public:
        /// Required element 'ns2:Position' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *Position;
        /// Optional element 'ns2:Speed' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *Speed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AbsoluteFocusOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AbsoluteFocusOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AbsoluteFocusOptions, default initialized and not managed by a soap context
        virtual ns2__AbsoluteFocusOptions *soap_alloc(void) const { return SOAP_NEW(ns2__AbsoluteFocusOptions); }
      public:
        /// Constructor with initializations
        ns2__AbsoluteFocusOptions()
        {
          Position = (ns2__FloatRange *)0;
          Speed = (ns2__FloatRange *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AbsoluteFocusOptions() { }
        /// Friend allocator used by soap_new_ns2__AbsoluteFocusOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__AbsoluteFocusOptions * SOAP_FMAC2 soap_instantiate_ns2__AbsoluteFocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1642 */
#ifndef SOAP_TYPE_ns2__RelativeFocusOptions
#define SOAP_TYPE_ns2__RelativeFocusOptions (698)
/* complex XSD type 'ns2:RelativeFocusOptions': */
class SOAP_CMAC ns2__RelativeFocusOptions {
      public:
        /// Required element 'ns2:Distance' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *Distance;
        /// Required element 'ns2:Speed' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *Speed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RelativeFocusOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RelativeFocusOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RelativeFocusOptions, default initialized and not managed by a soap context
        virtual ns2__RelativeFocusOptions *soap_alloc(void) const { return SOAP_NEW(ns2__RelativeFocusOptions); }
      public:
        /// Constructor with initializations
        ns2__RelativeFocusOptions()
        {
          Distance = (ns2__FloatRange *)0;
          Speed = (ns2__FloatRange *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__RelativeFocusOptions() { }
        /// Friend allocator used by soap_new_ns2__RelativeFocusOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__RelativeFocusOptions * SOAP_FMAC2 soap_instantiate_ns2__RelativeFocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1645 */
#ifndef SOAP_TYPE_ns2__ContinuousFocusOptions
#define SOAP_TYPE_ns2__ContinuousFocusOptions (699)
/* complex XSD type 'ns2:ContinuousFocusOptions': */
class SOAP_CMAC ns2__ContinuousFocusOptions {
      public:
        /// Required element 'ns2:Speed' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *Speed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ContinuousFocusOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ContinuousFocusOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ContinuousFocusOptions, default initialized and not managed by a soap context
        virtual ns2__ContinuousFocusOptions *soap_alloc(void) const { return SOAP_NEW(ns2__ContinuousFocusOptions); }
      public:
        /// Constructor with initializations
        ns2__ContinuousFocusOptions()
        {
          Speed = (ns2__FloatRange *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ContinuousFocusOptions() { }
        /// Friend allocator used by soap_new_ns2__ContinuousFocusOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__ContinuousFocusOptions * SOAP_FMAC2 soap_instantiate_ns2__ContinuousFocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1648 */
#ifndef SOAP_TYPE_ns2__WhiteBalance
#define SOAP_TYPE_ns2__WhiteBalance (700)
/* complex XSD type 'ns2:WhiteBalance': */
class SOAP_CMAC ns2__WhiteBalance {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:WhiteBalanceMode'
        ns2__WhiteBalanceMode Mode;
        /// Required element 'ns2:CrGain' of XSD type 'xsd:float'
        float CrGain;
        /// Required element 'ns2:CbGain' of XSD type 'xsd:float'
        float CbGain;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__WhiteBalance
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__WhiteBalance; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__WhiteBalance, default initialized and not managed by a soap context
        virtual ns2__WhiteBalance *soap_alloc(void) const { return SOAP_NEW(ns2__WhiteBalance); }
      public:
        /// Constructor with initializations
        ns2__WhiteBalance()
        {
          Mode = (ns2__WhiteBalanceMode)0;
          CrGain = (float)0;
          CbGain = (float)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__WhiteBalance() { }
        /// Friend allocator used by soap_new_ns2__WhiteBalance(struct soap*, int)
        friend SOAP_FMAC1 ns2__WhiteBalance * SOAP_FMAC2 soap_instantiate_ns2__WhiteBalance(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1651 */
#ifndef SOAP_TYPE_ns2__ImagingStatus20
#define SOAP_TYPE_ns2__ImagingStatus20 (701)
/* complex XSD type 'ns2:ImagingStatus20': */
class SOAP_CMAC ns2__ImagingStatus20 {
      public:
        /// Optional element 'ns2:FocusStatus20' of XSD type 'ns2:FocusStatus20'
        ns2__FocusStatus20 *FocusStatus20;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ImagingStatus20Extension'
        ns2__ImagingStatus20Extension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ImagingStatus20
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ImagingStatus20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ImagingStatus20, default initialized and not managed by a soap context
        virtual ns2__ImagingStatus20 *soap_alloc(void) const { return SOAP_NEW(ns2__ImagingStatus20); }
      public:
        /// Constructor with initializations
        ns2__ImagingStatus20()
        {
          FocusStatus20 = (ns2__FocusStatus20 *)0;
          Extension = (ns2__ImagingStatus20Extension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ImagingStatus20() { }
        /// Friend allocator used by soap_new_ns2__ImagingStatus20(struct soap*, int)
        friend SOAP_FMAC1 ns2__ImagingStatus20 * SOAP_FMAC2 soap_instantiate_ns2__ImagingStatus20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1654 */
#ifndef SOAP_TYPE_ns2__ImagingStatus20Extension
#define SOAP_TYPE_ns2__ImagingStatus20Extension (702)
/* complex XSD type 'ns2:ImagingStatus20Extension': */
class SOAP_CMAC ns2__ImagingStatus20Extension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ImagingStatus20Extension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ImagingStatus20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ImagingStatus20Extension, default initialized and not managed by a soap context
        virtual ns2__ImagingStatus20Extension *soap_alloc(void) const { return SOAP_NEW(ns2__ImagingStatus20Extension); }
      public:
        /// Constructor with initializations
        ns2__ImagingStatus20Extension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ImagingStatus20Extension() { }
        /// Friend allocator used by soap_new_ns2__ImagingStatus20Extension(struct soap*, int)
        friend SOAP_FMAC1 ns2__ImagingStatus20Extension * SOAP_FMAC2 soap_instantiate_ns2__ImagingStatus20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1657 */
#ifndef SOAP_TYPE_ns2__FocusStatus20
#define SOAP_TYPE_ns2__FocusStatus20 (703)
/* complex XSD type 'ns2:FocusStatus20': */
class SOAP_CMAC ns2__FocusStatus20 {
      public:
        /// Required element 'ns2:Position' of XSD type 'xsd:float'
        float Position;
        /// Required element 'ns2:MoveStatus' of XSD type 'ns2:MoveStatus'
        ns2__MoveStatus MoveStatus;
        /// Optional element 'ns2:Error' of XSD type 'xsd:string'
        std::string *Error;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:FocusStatus20Extension'
        ns2__FocusStatus20Extension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FocusStatus20
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FocusStatus20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FocusStatus20, default initialized and not managed by a soap context
        virtual ns2__FocusStatus20 *soap_alloc(void) const { return SOAP_NEW(ns2__FocusStatus20); }
      public:
        /// Constructor with initializations
        ns2__FocusStatus20()
        {
          Position = (float)0;
          MoveStatus = (ns2__MoveStatus)0;
          Error = (std::string *)0;
          Extension = (ns2__FocusStatus20Extension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__FocusStatus20() { }
        /// Friend allocator used by soap_new_ns2__FocusStatus20(struct soap*, int)
        friend SOAP_FMAC1 ns2__FocusStatus20 * SOAP_FMAC2 soap_instantiate_ns2__FocusStatus20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1660 */
#ifndef SOAP_TYPE_ns2__FocusStatus20Extension
#define SOAP_TYPE_ns2__FocusStatus20Extension (704)
/* complex XSD type 'ns2:FocusStatus20Extension': */
class SOAP_CMAC ns2__FocusStatus20Extension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FocusStatus20Extension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FocusStatus20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FocusStatus20Extension, default initialized and not managed by a soap context
        virtual ns2__FocusStatus20Extension *soap_alloc(void) const { return SOAP_NEW(ns2__FocusStatus20Extension); }
      public:
        /// Constructor with initializations
        ns2__FocusStatus20Extension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__FocusStatus20Extension() { }
        /// Friend allocator used by soap_new_ns2__FocusStatus20Extension(struct soap*, int)
        friend SOAP_FMAC1 ns2__FocusStatus20Extension * SOAP_FMAC2 soap_instantiate_ns2__FocusStatus20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1663 */
#ifndef SOAP_TYPE_ns2__ImagingSettings20
#define SOAP_TYPE_ns2__ImagingSettings20 (705)
/* complex XSD type 'ns2:ImagingSettings20': */
class SOAP_CMAC ns2__ImagingSettings20 {
      public:
        /// Optional element 'ns2:BacklightCompensation' of XSD type 'ns2:BacklightCompensation20'
        ns2__BacklightCompensation20 *BacklightCompensation;
        /// Optional element 'ns2:Brightness' of XSD type 'xsd:float'
        float *Brightness;
        /// Optional element 'ns2:ColorSaturation' of XSD type 'xsd:float'
        float *ColorSaturation;
        /// Optional element 'ns2:Contrast' of XSD type 'xsd:float'
        float *Contrast;
        /// Optional element 'ns2:Exposure' of XSD type 'ns2:Exposure20'
        ns2__Exposure20 *Exposure;
        /// Optional element 'ns2:Focus' of XSD type 'ns2:FocusConfiguration20'
        ns2__FocusConfiguration20 *Focus;
        /// Optional element 'ns2:IrCutFilter' of XSD type 'ns2:IrCutFilterMode'
        ns2__IrCutFilterMode *IrCutFilter;
        /// Optional element 'ns2:Sharpness' of XSD type 'xsd:float'
        float *Sharpness;
        /// Optional element 'ns2:WideDynamicRange' of XSD type 'ns2:WideDynamicRange20'
        ns2__WideDynamicRange20 *WideDynamicRange;
        /// Optional element 'ns2:WhiteBalance' of XSD type 'ns2:WhiteBalance20'
        ns2__WhiteBalance20 *WhiteBalance;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ImagingSettingsExtension20'
        ns2__ImagingSettingsExtension20 *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ImagingSettings20
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ImagingSettings20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ImagingSettings20, default initialized and not managed by a soap context
        virtual ns2__ImagingSettings20 *soap_alloc(void) const { return SOAP_NEW(ns2__ImagingSettings20); }
      public:
        /// Constructor with initializations
        ns2__ImagingSettings20()
        {
          BacklightCompensation = (ns2__BacklightCompensation20 *)0;
          Brightness = (float *)0;
          ColorSaturation = (float *)0;
          Contrast = (float *)0;
          Exposure = (ns2__Exposure20 *)0;
          Focus = (ns2__FocusConfiguration20 *)0;
          IrCutFilter = (ns2__IrCutFilterMode *)0;
          Sharpness = (float *)0;
          WideDynamicRange = (ns2__WideDynamicRange20 *)0;
          WhiteBalance = (ns2__WhiteBalance20 *)0;
          Extension = (ns2__ImagingSettingsExtension20 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ImagingSettings20() { }
        /// Friend allocator used by soap_new_ns2__ImagingSettings20(struct soap*, int)
        friend SOAP_FMAC1 ns2__ImagingSettings20 * SOAP_FMAC2 soap_instantiate_ns2__ImagingSettings20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1666 */
#ifndef SOAP_TYPE_ns2__ImagingSettingsExtension20
#define SOAP_TYPE_ns2__ImagingSettingsExtension20 (706)
/* complex XSD type 'ns2:ImagingSettingsExtension20': */
class SOAP_CMAC ns2__ImagingSettingsExtension20 {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional element 'ns2:ImageStabilization' of XSD type 'ns2:ImageStabilization'
        ns2__ImageStabilization *ImageStabilization;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ImagingSettingsExtension202'
        ns2__ImagingSettingsExtension202 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ImagingSettingsExtension20
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ImagingSettingsExtension20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ImagingSettingsExtension20, default initialized and not managed by a soap context
        virtual ns2__ImagingSettingsExtension20 *soap_alloc(void) const { return SOAP_NEW(ns2__ImagingSettingsExtension20); }
      public:
        /// Constructor with initializations
        ns2__ImagingSettingsExtension20()
        {
          ImageStabilization = (ns2__ImageStabilization *)0;
          Extension = (ns2__ImagingSettingsExtension202 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ImagingSettingsExtension20() { }
        /// Friend allocator used by soap_new_ns2__ImagingSettingsExtension20(struct soap*, int)
        friend SOAP_FMAC1 ns2__ImagingSettingsExtension20 * SOAP_FMAC2 soap_instantiate_ns2__ImagingSettingsExtension20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1669 */
#ifndef SOAP_TYPE_ns2__ImagingSettingsExtension202
#define SOAP_TYPE_ns2__ImagingSettingsExtension202 (707)
/* complex XSD type 'ns2:ImagingSettingsExtension202': */
class SOAP_CMAC ns2__ImagingSettingsExtension202 {
      public:
        /// Optional element 'ns2:IrCutFilterAutoAdjustment' of XSD type 'ns2:IrCutFilterAutoAdjustment'
        std::vector<ns2__IrCutFilterAutoAdjustment *> IrCutFilterAutoAdjustment;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ImagingSettingsExtension203'
        ns2__ImagingSettingsExtension203 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ImagingSettingsExtension202
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ImagingSettingsExtension202; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ImagingSettingsExtension202, default initialized and not managed by a soap context
        virtual ns2__ImagingSettingsExtension202 *soap_alloc(void) const { return SOAP_NEW(ns2__ImagingSettingsExtension202); }
      public:
        /// Constructor with initializations
        ns2__ImagingSettingsExtension202()
        {
          Extension = (ns2__ImagingSettingsExtension203 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ImagingSettingsExtension202() { }
        /// Friend allocator used by soap_new_ns2__ImagingSettingsExtension202(struct soap*, int)
        friend SOAP_FMAC1 ns2__ImagingSettingsExtension202 * SOAP_FMAC2 soap_instantiate_ns2__ImagingSettingsExtension202(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1672 */
#ifndef SOAP_TYPE_ns2__ImagingSettingsExtension203
#define SOAP_TYPE_ns2__ImagingSettingsExtension203 (708)
/* complex XSD type 'ns2:ImagingSettingsExtension203': */
class SOAP_CMAC ns2__ImagingSettingsExtension203 {
      public:
        /// Optional element 'ns2:ToneCompensation' of XSD type 'ns2:ToneCompensation'
        ns2__ToneCompensation *ToneCompensation;
        /// Optional element 'ns2:Defogging' of XSD type 'ns2:Defogging'
        ns2__Defogging *Defogging;
        /// Optional element 'ns2:NoiseReduction' of XSD type 'ns2:NoiseReduction'
        ns2__NoiseReduction *NoiseReduction;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ImagingSettingsExtension204'
        ns2__ImagingSettingsExtension204 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ImagingSettingsExtension203
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ImagingSettingsExtension203; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ImagingSettingsExtension203, default initialized and not managed by a soap context
        virtual ns2__ImagingSettingsExtension203 *soap_alloc(void) const { return SOAP_NEW(ns2__ImagingSettingsExtension203); }
      public:
        /// Constructor with initializations
        ns2__ImagingSettingsExtension203()
        {
          ToneCompensation = (ns2__ToneCompensation *)0;
          Defogging = (ns2__Defogging *)0;
          NoiseReduction = (ns2__NoiseReduction *)0;
          Extension = (ns2__ImagingSettingsExtension204 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ImagingSettingsExtension203() { }
        /// Friend allocator used by soap_new_ns2__ImagingSettingsExtension203(struct soap*, int)
        friend SOAP_FMAC1 ns2__ImagingSettingsExtension203 * SOAP_FMAC2 soap_instantiate_ns2__ImagingSettingsExtension203(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1675 */
#ifndef SOAP_TYPE_ns2__ImagingSettingsExtension204
#define SOAP_TYPE_ns2__ImagingSettingsExtension204 (709)
/* complex XSD type 'ns2:ImagingSettingsExtension204': */
class SOAP_CMAC ns2__ImagingSettingsExtension204 {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ImagingSettingsExtension204
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ImagingSettingsExtension204; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ImagingSettingsExtension204, default initialized and not managed by a soap context
        virtual ns2__ImagingSettingsExtension204 *soap_alloc(void) const { return SOAP_NEW(ns2__ImagingSettingsExtension204); }
      public:
        /// Constructor with initializations
        ns2__ImagingSettingsExtension204()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ImagingSettingsExtension204() { }
        /// Friend allocator used by soap_new_ns2__ImagingSettingsExtension204(struct soap*, int)
        friend SOAP_FMAC1 ns2__ImagingSettingsExtension204 * SOAP_FMAC2 soap_instantiate_ns2__ImagingSettingsExtension204(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1678 */
#ifndef SOAP_TYPE_ns2__ImageStabilization
#define SOAP_TYPE_ns2__ImageStabilization (710)
/* complex XSD type 'ns2:ImageStabilization': */
class SOAP_CMAC ns2__ImageStabilization {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:ImageStabilizationMode'
        ns2__ImageStabilizationMode Mode;
        /// Optional element 'ns2:Level' of XSD type 'xsd:float'
        float *Level;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ImageStabilizationExtension'
        ns2__ImageStabilizationExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ImageStabilization
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ImageStabilization; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ImageStabilization, default initialized and not managed by a soap context
        virtual ns2__ImageStabilization *soap_alloc(void) const { return SOAP_NEW(ns2__ImageStabilization); }
      public:
        /// Constructor with initializations
        ns2__ImageStabilization()
        {
          Mode = (ns2__ImageStabilizationMode)0;
          Level = (float *)0;
          Extension = (ns2__ImageStabilizationExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ImageStabilization() { }
        /// Friend allocator used by soap_new_ns2__ImageStabilization(struct soap*, int)
        friend SOAP_FMAC1 ns2__ImageStabilization * SOAP_FMAC2 soap_instantiate_ns2__ImageStabilization(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1681 */
#ifndef SOAP_TYPE_ns2__ImageStabilizationExtension
#define SOAP_TYPE_ns2__ImageStabilizationExtension (711)
/* complex XSD type 'ns2:ImageStabilizationExtension': */
class SOAP_CMAC ns2__ImageStabilizationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ImageStabilizationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ImageStabilizationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ImageStabilizationExtension, default initialized and not managed by a soap context
        virtual ns2__ImageStabilizationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__ImageStabilizationExtension); }
      public:
        /// Constructor with initializations
        ns2__ImageStabilizationExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ImageStabilizationExtension() { }
        /// Friend allocator used by soap_new_ns2__ImageStabilizationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__ImageStabilizationExtension * SOAP_FMAC2 soap_instantiate_ns2__ImageStabilizationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1684 */
#ifndef SOAP_TYPE_ns2__IrCutFilterAutoAdjustment
#define SOAP_TYPE_ns2__IrCutFilterAutoAdjustment (712)
/* complex XSD type 'ns2:IrCutFilterAutoAdjustment': */
class SOAP_CMAC ns2__IrCutFilterAutoAdjustment {
      public:
        /// Required element 'ns2:BoundaryType' of XSD type 'xsd:string'
        std::string BoundaryType;
        /// Optional element 'ns2:BoundaryOffset' of XSD type 'xsd:float'
        float *BoundaryOffset;
        /// Optional element 'ns2:ResponseTime' of XSD type 'xsd:duration'
        std::string *ResponseTime;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:IrCutFilterAutoAdjustmentExtension'
        ns2__IrCutFilterAutoAdjustmentExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__IrCutFilterAutoAdjustment
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__IrCutFilterAutoAdjustment; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__IrCutFilterAutoAdjustment, default initialized and not managed by a soap context
        virtual ns2__IrCutFilterAutoAdjustment *soap_alloc(void) const { return SOAP_NEW(ns2__IrCutFilterAutoAdjustment); }
      public:
        /// Constructor with initializations
        ns2__IrCutFilterAutoAdjustment()
        {
          BoundaryOffset = (float *)0;
          ResponseTime = (std::string *)0;
          Extension = (ns2__IrCutFilterAutoAdjustmentExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__IrCutFilterAutoAdjustment() { }
        /// Friend allocator used by soap_new_ns2__IrCutFilterAutoAdjustment(struct soap*, int)
        friend SOAP_FMAC1 ns2__IrCutFilterAutoAdjustment * SOAP_FMAC2 soap_instantiate_ns2__IrCutFilterAutoAdjustment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1687 */
#ifndef SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentExtension
#define SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentExtension (713)
/* complex XSD type 'ns2:IrCutFilterAutoAdjustmentExtension': */
class SOAP_CMAC ns2__IrCutFilterAutoAdjustmentExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__IrCutFilterAutoAdjustmentExtension, default initialized and not managed by a soap context
        virtual ns2__IrCutFilterAutoAdjustmentExtension *soap_alloc(void) const { return SOAP_NEW(ns2__IrCutFilterAutoAdjustmentExtension); }
      public:
        /// Constructor with initializations
        ns2__IrCutFilterAutoAdjustmentExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__IrCutFilterAutoAdjustmentExtension() { }
        /// Friend allocator used by soap_new_ns2__IrCutFilterAutoAdjustmentExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC2 soap_instantiate_ns2__IrCutFilterAutoAdjustmentExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1690 */
#ifndef SOAP_TYPE_ns2__WideDynamicRange20
#define SOAP_TYPE_ns2__WideDynamicRange20 (714)
/* complex XSD type 'ns2:WideDynamicRange20': */
class SOAP_CMAC ns2__WideDynamicRange20 {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:WideDynamicMode'
        ns2__WideDynamicMode Mode;
        /// Optional element 'ns2:Level' of XSD type 'xsd:float'
        float *Level;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__WideDynamicRange20
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__WideDynamicRange20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__WideDynamicRange20, default initialized and not managed by a soap context
        virtual ns2__WideDynamicRange20 *soap_alloc(void) const { return SOAP_NEW(ns2__WideDynamicRange20); }
      public:
        /// Constructor with initializations
        ns2__WideDynamicRange20()
        {
          Mode = (ns2__WideDynamicMode)0;
          Level = (float *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__WideDynamicRange20() { }
        /// Friend allocator used by soap_new_ns2__WideDynamicRange20(struct soap*, int)
        friend SOAP_FMAC1 ns2__WideDynamicRange20 * SOAP_FMAC2 soap_instantiate_ns2__WideDynamicRange20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1693 */
#ifndef SOAP_TYPE_ns2__BacklightCompensation20
#define SOAP_TYPE_ns2__BacklightCompensation20 (715)
/* complex XSD type 'ns2:BacklightCompensation20': */
class SOAP_CMAC ns2__BacklightCompensation20 {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:BacklightCompensationMode'
        ns2__BacklightCompensationMode Mode;
        /// Optional element 'ns2:Level' of XSD type 'xsd:float'
        float *Level;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BacklightCompensation20
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__BacklightCompensation20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BacklightCompensation20, default initialized and not managed by a soap context
        virtual ns2__BacklightCompensation20 *soap_alloc(void) const { return SOAP_NEW(ns2__BacklightCompensation20); }
      public:
        /// Constructor with initializations
        ns2__BacklightCompensation20()
        {
          Mode = (ns2__BacklightCompensationMode)0;
          Level = (float *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__BacklightCompensation20() { }
        /// Friend allocator used by soap_new_ns2__BacklightCompensation20(struct soap*, int)
        friend SOAP_FMAC1 ns2__BacklightCompensation20 * SOAP_FMAC2 soap_instantiate_ns2__BacklightCompensation20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1696 */
#ifndef SOAP_TYPE_ns2__Exposure20
#define SOAP_TYPE_ns2__Exposure20 (716)
/* complex XSD type 'ns2:Exposure20': */
class SOAP_CMAC ns2__Exposure20 {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:ExposureMode'
        ns2__ExposureMode Mode;
        /// Optional element 'ns2:Priority' of XSD type 'ns2:ExposurePriority'
        ns2__ExposurePriority *Priority;
        /// Optional element 'ns2:Window' of XSD type 'ns2:Rectangle'
        ns2__Rectangle *Window;
        /// Optional element 'ns2:MinExposureTime' of XSD type 'xsd:float'
        float *MinExposureTime;
        /// Optional element 'ns2:MaxExposureTime' of XSD type 'xsd:float'
        float *MaxExposureTime;
        /// Optional element 'ns2:MinGain' of XSD type 'xsd:float'
        float *MinGain;
        /// Optional element 'ns2:MaxGain' of XSD type 'xsd:float'
        float *MaxGain;
        /// Optional element 'ns2:MinIris' of XSD type 'xsd:float'
        float *MinIris;
        /// Optional element 'ns2:MaxIris' of XSD type 'xsd:float'
        float *MaxIris;
        /// Optional element 'ns2:ExposureTime' of XSD type 'xsd:float'
        float *ExposureTime;
        /// Optional element 'ns2:Gain' of XSD type 'xsd:float'
        float *Gain;
        /// Optional element 'ns2:Iris' of XSD type 'xsd:float'
        float *Iris;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Exposure20
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Exposure20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Exposure20, default initialized and not managed by a soap context
        virtual ns2__Exposure20 *soap_alloc(void) const { return SOAP_NEW(ns2__Exposure20); }
      public:
        /// Constructor with initializations
        ns2__Exposure20()
        {
          Mode = (ns2__ExposureMode)0;
          Priority = (ns2__ExposurePriority *)0;
          Window = (ns2__Rectangle *)0;
          MinExposureTime = (float *)0;
          MaxExposureTime = (float *)0;
          MinGain = (float *)0;
          MaxGain = (float *)0;
          MinIris = (float *)0;
          MaxIris = (float *)0;
          ExposureTime = (float *)0;
          Gain = (float *)0;
          Iris = (float *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Exposure20() { }
        /// Friend allocator used by soap_new_ns2__Exposure20(struct soap*, int)
        friend SOAP_FMAC1 ns2__Exposure20 * SOAP_FMAC2 soap_instantiate_ns2__Exposure20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1699 */
#ifndef SOAP_TYPE_ns2__ToneCompensation
#define SOAP_TYPE_ns2__ToneCompensation (717)
/* complex XSD type 'ns2:ToneCompensation': */
class SOAP_CMAC ns2__ToneCompensation {
      public:
        /// Required element 'ns2:Mode' of XSD type 'xsd:string'
        std::string Mode;
        /// Optional element 'ns2:Level' of XSD type 'xsd:float'
        float *Level;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ToneCompensationExtension'
        ns2__ToneCompensationExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ToneCompensation
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ToneCompensation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ToneCompensation, default initialized and not managed by a soap context
        virtual ns2__ToneCompensation *soap_alloc(void) const { return SOAP_NEW(ns2__ToneCompensation); }
      public:
        /// Constructor with initializations
        ns2__ToneCompensation()
        {
          Level = (float *)0;
          Extension = (ns2__ToneCompensationExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ToneCompensation() { }
        /// Friend allocator used by soap_new_ns2__ToneCompensation(struct soap*, int)
        friend SOAP_FMAC1 ns2__ToneCompensation * SOAP_FMAC2 soap_instantiate_ns2__ToneCompensation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1702 */
#ifndef SOAP_TYPE_ns2__ToneCompensationExtension
#define SOAP_TYPE_ns2__ToneCompensationExtension (718)
/* complex XSD type 'ns2:ToneCompensationExtension': */
class SOAP_CMAC ns2__ToneCompensationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ToneCompensationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ToneCompensationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ToneCompensationExtension, default initialized and not managed by a soap context
        virtual ns2__ToneCompensationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__ToneCompensationExtension); }
      public:
        /// Constructor with initializations
        ns2__ToneCompensationExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ToneCompensationExtension() { }
        /// Friend allocator used by soap_new_ns2__ToneCompensationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__ToneCompensationExtension * SOAP_FMAC2 soap_instantiate_ns2__ToneCompensationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1705 */
#ifndef SOAP_TYPE_ns2__Defogging
#define SOAP_TYPE_ns2__Defogging (719)
/* complex XSD type 'ns2:Defogging': */
class SOAP_CMAC ns2__Defogging {
      public:
        /// Required element 'ns2:Mode' of XSD type 'xsd:string'
        std::string Mode;
        /// Optional element 'ns2:Level' of XSD type 'xsd:float'
        float *Level;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:DefoggingExtension'
        ns2__DefoggingExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Defogging
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Defogging; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Defogging, default initialized and not managed by a soap context
        virtual ns2__Defogging *soap_alloc(void) const { return SOAP_NEW(ns2__Defogging); }
      public:
        /// Constructor with initializations
        ns2__Defogging()
        {
          Level = (float *)0;
          Extension = (ns2__DefoggingExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Defogging() { }
        /// Friend allocator used by soap_new_ns2__Defogging(struct soap*, int)
        friend SOAP_FMAC1 ns2__Defogging * SOAP_FMAC2 soap_instantiate_ns2__Defogging(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1708 */
#ifndef SOAP_TYPE_ns2__DefoggingExtension
#define SOAP_TYPE_ns2__DefoggingExtension (720)
/* complex XSD type 'ns2:DefoggingExtension': */
class SOAP_CMAC ns2__DefoggingExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DefoggingExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DefoggingExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DefoggingExtension, default initialized and not managed by a soap context
        virtual ns2__DefoggingExtension *soap_alloc(void) const { return SOAP_NEW(ns2__DefoggingExtension); }
      public:
        /// Constructor with initializations
        ns2__DefoggingExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__DefoggingExtension() { }
        /// Friend allocator used by soap_new_ns2__DefoggingExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__DefoggingExtension * SOAP_FMAC2 soap_instantiate_ns2__DefoggingExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1711 */
#ifndef SOAP_TYPE_ns2__NoiseReduction
#define SOAP_TYPE_ns2__NoiseReduction (721)
/* complex XSD type 'ns2:NoiseReduction': */
class SOAP_CMAC ns2__NoiseReduction {
      public:
        /// Required element 'ns2:Level' of XSD type 'xsd:float'
        float Level;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NoiseReduction
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NoiseReduction; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NoiseReduction, default initialized and not managed by a soap context
        virtual ns2__NoiseReduction *soap_alloc(void) const { return SOAP_NEW(ns2__NoiseReduction); }
      public:
        /// Constructor with initializations
        ns2__NoiseReduction()
        {
          Level = (float)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__NoiseReduction() { }
        /// Friend allocator used by soap_new_ns2__NoiseReduction(struct soap*, int)
        friend SOAP_FMAC1 ns2__NoiseReduction * SOAP_FMAC2 soap_instantiate_ns2__NoiseReduction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1714 */
#ifndef SOAP_TYPE_ns2__ImagingOptions20
#define SOAP_TYPE_ns2__ImagingOptions20 (722)
/* complex XSD type 'ns2:ImagingOptions20': */
class SOAP_CMAC ns2__ImagingOptions20 {
      public:
        /// Optional element 'ns2:BacklightCompensation' of XSD type 'ns2:BacklightCompensationOptions20'
        ns2__BacklightCompensationOptions20 *BacklightCompensation;
        /// Optional element 'ns2:Brightness' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *Brightness;
        /// Optional element 'ns2:ColorSaturation' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *ColorSaturation;
        /// Optional element 'ns2:Contrast' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *Contrast;
        /// Optional element 'ns2:Exposure' of XSD type 'ns2:ExposureOptions20'
        ns2__ExposureOptions20 *Exposure;
        /// Optional element 'ns2:Focus' of XSD type 'ns2:FocusOptions20'
        ns2__FocusOptions20 *Focus;
        /// Optional element 'ns2:IrCutFilterModes' of XSD type 'ns2:IrCutFilterMode'
        std::vector<ns2__IrCutFilterMode> IrCutFilterModes;
        /// Optional element 'ns2:Sharpness' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *Sharpness;
        /// Optional element 'ns2:WideDynamicRange' of XSD type 'ns2:WideDynamicRangeOptions20'
        ns2__WideDynamicRangeOptions20 *WideDynamicRange;
        /// Optional element 'ns2:WhiteBalance' of XSD type 'ns2:WhiteBalanceOptions20'
        ns2__WhiteBalanceOptions20 *WhiteBalance;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ImagingOptions20Extension'
        ns2__ImagingOptions20Extension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ImagingOptions20
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ImagingOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ImagingOptions20, default initialized and not managed by a soap context
        virtual ns2__ImagingOptions20 *soap_alloc(void) const { return SOAP_NEW(ns2__ImagingOptions20); }
      public:
        /// Constructor with initializations
        ns2__ImagingOptions20()
        {
          BacklightCompensation = (ns2__BacklightCompensationOptions20 *)0;
          Brightness = (ns2__FloatRange *)0;
          ColorSaturation = (ns2__FloatRange *)0;
          Contrast = (ns2__FloatRange *)0;
          Exposure = (ns2__ExposureOptions20 *)0;
          Focus = (ns2__FocusOptions20 *)0;
          Sharpness = (ns2__FloatRange *)0;
          WideDynamicRange = (ns2__WideDynamicRangeOptions20 *)0;
          WhiteBalance = (ns2__WhiteBalanceOptions20 *)0;
          Extension = (ns2__ImagingOptions20Extension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ImagingOptions20() { }
        /// Friend allocator used by soap_new_ns2__ImagingOptions20(struct soap*, int)
        friend SOAP_FMAC1 ns2__ImagingOptions20 * SOAP_FMAC2 soap_instantiate_ns2__ImagingOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1717 */
#ifndef SOAP_TYPE_ns2__ImagingOptions20Extension
#define SOAP_TYPE_ns2__ImagingOptions20Extension (723)
/* complex XSD type 'ns2:ImagingOptions20Extension': */
class SOAP_CMAC ns2__ImagingOptions20Extension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional element 'ns2:ImageStabilization' of XSD type 'ns2:ImageStabilizationOptions'
        ns2__ImageStabilizationOptions *ImageStabilization;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ImagingOptions20Extension2'
        ns2__ImagingOptions20Extension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ImagingOptions20Extension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ImagingOptions20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ImagingOptions20Extension, default initialized and not managed by a soap context
        virtual ns2__ImagingOptions20Extension *soap_alloc(void) const { return SOAP_NEW(ns2__ImagingOptions20Extension); }
      public:
        /// Constructor with initializations
        ns2__ImagingOptions20Extension()
        {
          ImageStabilization = (ns2__ImageStabilizationOptions *)0;
          Extension = (ns2__ImagingOptions20Extension2 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ImagingOptions20Extension() { }
        /// Friend allocator used by soap_new_ns2__ImagingOptions20Extension(struct soap*, int)
        friend SOAP_FMAC1 ns2__ImagingOptions20Extension * SOAP_FMAC2 soap_instantiate_ns2__ImagingOptions20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1720 */
#ifndef SOAP_TYPE_ns2__ImagingOptions20Extension2
#define SOAP_TYPE_ns2__ImagingOptions20Extension2 (724)
/* complex XSD type 'ns2:ImagingOptions20Extension2': */
class SOAP_CMAC ns2__ImagingOptions20Extension2 {
      public:
        /// Optional element 'ns2:IrCutFilterAutoAdjustment' of XSD type 'ns2:IrCutFilterAutoAdjustmentOptions'
        ns2__IrCutFilterAutoAdjustmentOptions *IrCutFilterAutoAdjustment;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ImagingOptions20Extension3'
        ns2__ImagingOptions20Extension3 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ImagingOptions20Extension2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ImagingOptions20Extension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ImagingOptions20Extension2, default initialized and not managed by a soap context
        virtual ns2__ImagingOptions20Extension2 *soap_alloc(void) const { return SOAP_NEW(ns2__ImagingOptions20Extension2); }
      public:
        /// Constructor with initializations
        ns2__ImagingOptions20Extension2()
        {
          IrCutFilterAutoAdjustment = (ns2__IrCutFilterAutoAdjustmentOptions *)0;
          Extension = (ns2__ImagingOptions20Extension3 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ImagingOptions20Extension2() { }
        /// Friend allocator used by soap_new_ns2__ImagingOptions20Extension2(struct soap*, int)
        friend SOAP_FMAC1 ns2__ImagingOptions20Extension2 * SOAP_FMAC2 soap_instantiate_ns2__ImagingOptions20Extension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1723 */
#ifndef SOAP_TYPE_ns2__ImagingOptions20Extension3
#define SOAP_TYPE_ns2__ImagingOptions20Extension3 (725)
/* complex XSD type 'ns2:ImagingOptions20Extension3': */
class SOAP_CMAC ns2__ImagingOptions20Extension3 {
      public:
        /// Optional element 'ns2:ToneCompensationOptions' of XSD type 'ns2:ToneCompensationOptions'
        ns2__ToneCompensationOptions *ToneCompensationOptions;
        /// Optional element 'ns2:DefoggingOptions' of XSD type 'ns2:DefoggingOptions'
        ns2__DefoggingOptions *DefoggingOptions;
        /// Optional element 'ns2:NoiseReductionOptions' of XSD type 'ns2:NoiseReductionOptions'
        ns2__NoiseReductionOptions *NoiseReductionOptions;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ImagingOptions20Extension4'
        ns2__ImagingOptions20Extension4 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ImagingOptions20Extension3
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ImagingOptions20Extension3; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ImagingOptions20Extension3, default initialized and not managed by a soap context
        virtual ns2__ImagingOptions20Extension3 *soap_alloc(void) const { return SOAP_NEW(ns2__ImagingOptions20Extension3); }
      public:
        /// Constructor with initializations
        ns2__ImagingOptions20Extension3()
        {
          ToneCompensationOptions = (ns2__ToneCompensationOptions *)0;
          DefoggingOptions = (ns2__DefoggingOptions *)0;
          NoiseReductionOptions = (ns2__NoiseReductionOptions *)0;
          Extension = (ns2__ImagingOptions20Extension4 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ImagingOptions20Extension3() { }
        /// Friend allocator used by soap_new_ns2__ImagingOptions20Extension3(struct soap*, int)
        friend SOAP_FMAC1 ns2__ImagingOptions20Extension3 * SOAP_FMAC2 soap_instantiate_ns2__ImagingOptions20Extension3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1726 */
#ifndef SOAP_TYPE_ns2__ImagingOptions20Extension4
#define SOAP_TYPE_ns2__ImagingOptions20Extension4 (726)
/* complex XSD type 'ns2:ImagingOptions20Extension4': */
class SOAP_CMAC ns2__ImagingOptions20Extension4 {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ImagingOptions20Extension4
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ImagingOptions20Extension4; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ImagingOptions20Extension4, default initialized and not managed by a soap context
        virtual ns2__ImagingOptions20Extension4 *soap_alloc(void) const { return SOAP_NEW(ns2__ImagingOptions20Extension4); }
      public:
        /// Constructor with initializations
        ns2__ImagingOptions20Extension4()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ImagingOptions20Extension4() { }
        /// Friend allocator used by soap_new_ns2__ImagingOptions20Extension4(struct soap*, int)
        friend SOAP_FMAC1 ns2__ImagingOptions20Extension4 * SOAP_FMAC2 soap_instantiate_ns2__ImagingOptions20Extension4(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1729 */
#ifndef SOAP_TYPE_ns2__ImageStabilizationOptions
#define SOAP_TYPE_ns2__ImageStabilizationOptions (727)
/* complex XSD type 'ns2:ImageStabilizationOptions': */
class SOAP_CMAC ns2__ImageStabilizationOptions {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:ImageStabilizationMode'
        std::vector<ns2__ImageStabilizationMode> Mode;
        /// Optional element 'ns2:Level' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *Level;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ImageStabilizationOptionsExtension'
        ns2__ImageStabilizationOptionsExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ImageStabilizationOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ImageStabilizationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ImageStabilizationOptions, default initialized and not managed by a soap context
        virtual ns2__ImageStabilizationOptions *soap_alloc(void) const { return SOAP_NEW(ns2__ImageStabilizationOptions); }
      public:
        /// Constructor with initializations
        ns2__ImageStabilizationOptions()
        {
          Level = (ns2__FloatRange *)0;
          Extension = (ns2__ImageStabilizationOptionsExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ImageStabilizationOptions() { }
        /// Friend allocator used by soap_new_ns2__ImageStabilizationOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__ImageStabilizationOptions * SOAP_FMAC2 soap_instantiate_ns2__ImageStabilizationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1732 */
#ifndef SOAP_TYPE_ns2__ImageStabilizationOptionsExtension
#define SOAP_TYPE_ns2__ImageStabilizationOptionsExtension (728)
/* complex XSD type 'ns2:ImageStabilizationOptionsExtension': */
class SOAP_CMAC ns2__ImageStabilizationOptionsExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ImageStabilizationOptionsExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ImageStabilizationOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ImageStabilizationOptionsExtension, default initialized and not managed by a soap context
        virtual ns2__ImageStabilizationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(ns2__ImageStabilizationOptionsExtension); }
      public:
        /// Constructor with initializations
        ns2__ImageStabilizationOptionsExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ImageStabilizationOptionsExtension() { }
        /// Friend allocator used by soap_new_ns2__ImageStabilizationOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__ImageStabilizationOptionsExtension * SOAP_FMAC2 soap_instantiate_ns2__ImageStabilizationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1735 */
#ifndef SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentOptions
#define SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentOptions (729)
/* complex XSD type 'ns2:IrCutFilterAutoAdjustmentOptions': */
class SOAP_CMAC ns2__IrCutFilterAutoAdjustmentOptions {
      public:
        /// Required element 'ns2:BoundaryType' of XSD type 'xsd:string'
        std::vector<std::string> BoundaryType;
        /// Optional element 'ns2:BoundaryOffset' of XSD type 'xsd:boolean'
        bool *BoundaryOffset;
        /// Optional element 'ns2:ResponseTimeRange' of XSD type 'ns2:DurationRange'
        ns2__DurationRange *ResponseTimeRange;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:IrCutFilterAutoAdjustmentOptionsExtension'
        ns2__IrCutFilterAutoAdjustmentOptionsExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__IrCutFilterAutoAdjustmentOptions, default initialized and not managed by a soap context
        virtual ns2__IrCutFilterAutoAdjustmentOptions *soap_alloc(void) const { return SOAP_NEW(ns2__IrCutFilterAutoAdjustmentOptions); }
      public:
        /// Constructor with initializations
        ns2__IrCutFilterAutoAdjustmentOptions()
        {
          BoundaryOffset = (bool *)0;
          ResponseTimeRange = (ns2__DurationRange *)0;
          Extension = (ns2__IrCutFilterAutoAdjustmentOptionsExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__IrCutFilterAutoAdjustmentOptions() { }
        /// Friend allocator used by soap_new_ns2__IrCutFilterAutoAdjustmentOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC2 soap_instantiate_ns2__IrCutFilterAutoAdjustmentOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1738 */
#ifndef SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentOptionsExtension
#define SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentOptionsExtension (730)
/* complex XSD type 'ns2:IrCutFilterAutoAdjustmentOptionsExtension': */
class SOAP_CMAC ns2__IrCutFilterAutoAdjustmentOptionsExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentOptionsExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__IrCutFilterAutoAdjustmentOptionsExtension, default initialized and not managed by a soap context
        virtual ns2__IrCutFilterAutoAdjustmentOptionsExtension *soap_alloc(void) const { return SOAP_NEW(ns2__IrCutFilterAutoAdjustmentOptionsExtension); }
      public:
        /// Constructor with initializations
        ns2__IrCutFilterAutoAdjustmentOptionsExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__IrCutFilterAutoAdjustmentOptionsExtension() { }
        /// Friend allocator used by soap_new_ns2__IrCutFilterAutoAdjustmentOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC2 soap_instantiate_ns2__IrCutFilterAutoAdjustmentOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1741 */
#ifndef SOAP_TYPE_ns2__WideDynamicRangeOptions20
#define SOAP_TYPE_ns2__WideDynamicRangeOptions20 (731)
/* complex XSD type 'ns2:WideDynamicRangeOptions20': */
class SOAP_CMAC ns2__WideDynamicRangeOptions20 {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:WideDynamicMode'
        std::vector<ns2__WideDynamicMode> Mode;
        /// Optional element 'ns2:Level' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *Level;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__WideDynamicRangeOptions20
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__WideDynamicRangeOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__WideDynamicRangeOptions20, default initialized and not managed by a soap context
        virtual ns2__WideDynamicRangeOptions20 *soap_alloc(void) const { return SOAP_NEW(ns2__WideDynamicRangeOptions20); }
      public:
        /// Constructor with initializations
        ns2__WideDynamicRangeOptions20()
        {
          Level = (ns2__FloatRange *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__WideDynamicRangeOptions20() { }
        /// Friend allocator used by soap_new_ns2__WideDynamicRangeOptions20(struct soap*, int)
        friend SOAP_FMAC1 ns2__WideDynamicRangeOptions20 * SOAP_FMAC2 soap_instantiate_ns2__WideDynamicRangeOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1744 */
#ifndef SOAP_TYPE_ns2__BacklightCompensationOptions20
#define SOAP_TYPE_ns2__BacklightCompensationOptions20 (732)
/* complex XSD type 'ns2:BacklightCompensationOptions20': */
class SOAP_CMAC ns2__BacklightCompensationOptions20 {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:BacklightCompensationMode'
        std::vector<ns2__BacklightCompensationMode> Mode;
        /// Optional element 'ns2:Level' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *Level;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BacklightCompensationOptions20
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__BacklightCompensationOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BacklightCompensationOptions20, default initialized and not managed by a soap context
        virtual ns2__BacklightCompensationOptions20 *soap_alloc(void) const { return SOAP_NEW(ns2__BacklightCompensationOptions20); }
      public:
        /// Constructor with initializations
        ns2__BacklightCompensationOptions20()
        {
          Level = (ns2__FloatRange *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__BacklightCompensationOptions20() { }
        /// Friend allocator used by soap_new_ns2__BacklightCompensationOptions20(struct soap*, int)
        friend SOAP_FMAC1 ns2__BacklightCompensationOptions20 * SOAP_FMAC2 soap_instantiate_ns2__BacklightCompensationOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1747 */
#ifndef SOAP_TYPE_ns2__ExposureOptions20
#define SOAP_TYPE_ns2__ExposureOptions20 (733)
/* complex XSD type 'ns2:ExposureOptions20': */
class SOAP_CMAC ns2__ExposureOptions20 {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:ExposureMode'
        std::vector<ns2__ExposureMode> Mode;
        /// Optional element 'ns2:Priority' of XSD type 'ns2:ExposurePriority'
        std::vector<ns2__ExposurePriority> Priority;
        /// Optional element 'ns2:MinExposureTime' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *MinExposureTime;
        /// Optional element 'ns2:MaxExposureTime' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *MaxExposureTime;
        /// Optional element 'ns2:MinGain' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *MinGain;
        /// Optional element 'ns2:MaxGain' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *MaxGain;
        /// Optional element 'ns2:MinIris' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *MinIris;
        /// Optional element 'ns2:MaxIris' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *MaxIris;
        /// Optional element 'ns2:ExposureTime' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *ExposureTime;
        /// Optional element 'ns2:Gain' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *Gain;
        /// Optional element 'ns2:Iris' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *Iris;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ExposureOptions20
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ExposureOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ExposureOptions20, default initialized and not managed by a soap context
        virtual ns2__ExposureOptions20 *soap_alloc(void) const { return SOAP_NEW(ns2__ExposureOptions20); }
      public:
        /// Constructor with initializations
        ns2__ExposureOptions20()
        {
          MinExposureTime = (ns2__FloatRange *)0;
          MaxExposureTime = (ns2__FloatRange *)0;
          MinGain = (ns2__FloatRange *)0;
          MaxGain = (ns2__FloatRange *)0;
          MinIris = (ns2__FloatRange *)0;
          MaxIris = (ns2__FloatRange *)0;
          ExposureTime = (ns2__FloatRange *)0;
          Gain = (ns2__FloatRange *)0;
          Iris = (ns2__FloatRange *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ExposureOptions20() { }
        /// Friend allocator used by soap_new_ns2__ExposureOptions20(struct soap*, int)
        friend SOAP_FMAC1 ns2__ExposureOptions20 * SOAP_FMAC2 soap_instantiate_ns2__ExposureOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1750 */
#ifndef SOAP_TYPE_ns2__MoveOptions20
#define SOAP_TYPE_ns2__MoveOptions20 (734)
/* complex XSD type 'ns2:MoveOptions20': */
class SOAP_CMAC ns2__MoveOptions20 {
      public:
        /// Optional element 'ns2:Absolute' of XSD type 'ns2:AbsoluteFocusOptions'
        ns2__AbsoluteFocusOptions *Absolute;
        /// Optional element 'ns2:Relative' of XSD type 'ns2:RelativeFocusOptions20'
        ns2__RelativeFocusOptions20 *Relative;
        /// Optional element 'ns2:Continuous' of XSD type 'ns2:ContinuousFocusOptions'
        ns2__ContinuousFocusOptions *Continuous;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MoveOptions20
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MoveOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MoveOptions20, default initialized and not managed by a soap context
        virtual ns2__MoveOptions20 *soap_alloc(void) const { return SOAP_NEW(ns2__MoveOptions20); }
      public:
        /// Constructor with initializations
        ns2__MoveOptions20()
        {
          Absolute = (ns2__AbsoluteFocusOptions *)0;
          Relative = (ns2__RelativeFocusOptions20 *)0;
          Continuous = (ns2__ContinuousFocusOptions *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__MoveOptions20() { }
        /// Friend allocator used by soap_new_ns2__MoveOptions20(struct soap*, int)
        friend SOAP_FMAC1 ns2__MoveOptions20 * SOAP_FMAC2 soap_instantiate_ns2__MoveOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1753 */
#ifndef SOAP_TYPE_ns2__RelativeFocusOptions20
#define SOAP_TYPE_ns2__RelativeFocusOptions20 (735)
/* complex XSD type 'ns2:RelativeFocusOptions20': */
class SOAP_CMAC ns2__RelativeFocusOptions20 {
      public:
        /// Required element 'ns2:Distance' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *Distance;
        /// Optional element 'ns2:Speed' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *Speed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RelativeFocusOptions20
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RelativeFocusOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RelativeFocusOptions20, default initialized and not managed by a soap context
        virtual ns2__RelativeFocusOptions20 *soap_alloc(void) const { return SOAP_NEW(ns2__RelativeFocusOptions20); }
      public:
        /// Constructor with initializations
        ns2__RelativeFocusOptions20()
        {
          Distance = (ns2__FloatRange *)0;
          Speed = (ns2__FloatRange *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__RelativeFocusOptions20() { }
        /// Friend allocator used by soap_new_ns2__RelativeFocusOptions20(struct soap*, int)
        friend SOAP_FMAC1 ns2__RelativeFocusOptions20 * SOAP_FMAC2 soap_instantiate_ns2__RelativeFocusOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1756 */
#ifndef SOAP_TYPE_ns2__WhiteBalance20
#define SOAP_TYPE_ns2__WhiteBalance20 (736)
/* complex XSD type 'ns2:WhiteBalance20': */
class SOAP_CMAC ns2__WhiteBalance20 {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:WhiteBalanceMode'
        ns2__WhiteBalanceMode Mode;
        /// Optional element 'ns2:CrGain' of XSD type 'xsd:float'
        float *CrGain;
        /// Optional element 'ns2:CbGain' of XSD type 'xsd:float'
        float *CbGain;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:WhiteBalance20Extension'
        ns2__WhiteBalance20Extension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__WhiteBalance20
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__WhiteBalance20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__WhiteBalance20, default initialized and not managed by a soap context
        virtual ns2__WhiteBalance20 *soap_alloc(void) const { return SOAP_NEW(ns2__WhiteBalance20); }
      public:
        /// Constructor with initializations
        ns2__WhiteBalance20()
        {
          Mode = (ns2__WhiteBalanceMode)0;
          CrGain = (float *)0;
          CbGain = (float *)0;
          Extension = (ns2__WhiteBalance20Extension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__WhiteBalance20() { }
        /// Friend allocator used by soap_new_ns2__WhiteBalance20(struct soap*, int)
        friend SOAP_FMAC1 ns2__WhiteBalance20 * SOAP_FMAC2 soap_instantiate_ns2__WhiteBalance20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1759 */
#ifndef SOAP_TYPE_ns2__WhiteBalance20Extension
#define SOAP_TYPE_ns2__WhiteBalance20Extension (737)
/* complex XSD type 'ns2:WhiteBalance20Extension': */
class SOAP_CMAC ns2__WhiteBalance20Extension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__WhiteBalance20Extension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__WhiteBalance20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__WhiteBalance20Extension, default initialized and not managed by a soap context
        virtual ns2__WhiteBalance20Extension *soap_alloc(void) const { return SOAP_NEW(ns2__WhiteBalance20Extension); }
      public:
        /// Constructor with initializations
        ns2__WhiteBalance20Extension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__WhiteBalance20Extension() { }
        /// Friend allocator used by soap_new_ns2__WhiteBalance20Extension(struct soap*, int)
        friend SOAP_FMAC1 ns2__WhiteBalance20Extension * SOAP_FMAC2 soap_instantiate_ns2__WhiteBalance20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1762 */
#ifndef SOAP_TYPE_ns2__FocusConfiguration20
#define SOAP_TYPE_ns2__FocusConfiguration20 (738)
/* complex XSD type 'ns2:FocusConfiguration20': */
class SOAP_CMAC ns2__FocusConfiguration20 {
      public:
        /// Required element 'ns2:AutoFocusMode' of XSD type 'ns2:AutoFocusMode'
        ns2__AutoFocusMode AutoFocusMode;
        /// Optional element 'ns2:DefaultSpeed' of XSD type 'xsd:float'
        float *DefaultSpeed;
        /// Optional element 'ns2:NearLimit' of XSD type 'xsd:float'
        float *NearLimit;
        /// Optional element 'ns2:FarLimit' of XSD type 'xsd:float'
        float *FarLimit;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:FocusConfiguration20Extension'
        ns2__FocusConfiguration20Extension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FocusConfiguration20
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FocusConfiguration20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FocusConfiguration20, default initialized and not managed by a soap context
        virtual ns2__FocusConfiguration20 *soap_alloc(void) const { return SOAP_NEW(ns2__FocusConfiguration20); }
      public:
        /// Constructor with initializations
        ns2__FocusConfiguration20()
        {
          AutoFocusMode = (ns2__AutoFocusMode)0;
          DefaultSpeed = (float *)0;
          NearLimit = (float *)0;
          FarLimit = (float *)0;
          Extension = (ns2__FocusConfiguration20Extension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__FocusConfiguration20() { }
        /// Friend allocator used by soap_new_ns2__FocusConfiguration20(struct soap*, int)
        friend SOAP_FMAC1 ns2__FocusConfiguration20 * SOAP_FMAC2 soap_instantiate_ns2__FocusConfiguration20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1765 */
#ifndef SOAP_TYPE_ns2__FocusConfiguration20Extension
#define SOAP_TYPE_ns2__FocusConfiguration20Extension (739)
/* complex XSD type 'ns2:FocusConfiguration20Extension': */
class SOAP_CMAC ns2__FocusConfiguration20Extension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FocusConfiguration20Extension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FocusConfiguration20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FocusConfiguration20Extension, default initialized and not managed by a soap context
        virtual ns2__FocusConfiguration20Extension *soap_alloc(void) const { return SOAP_NEW(ns2__FocusConfiguration20Extension); }
      public:
        /// Constructor with initializations
        ns2__FocusConfiguration20Extension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__FocusConfiguration20Extension() { }
        /// Friend allocator used by soap_new_ns2__FocusConfiguration20Extension(struct soap*, int)
        friend SOAP_FMAC1 ns2__FocusConfiguration20Extension * SOAP_FMAC2 soap_instantiate_ns2__FocusConfiguration20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1768 */
#ifndef SOAP_TYPE_ns2__WhiteBalanceOptions20
#define SOAP_TYPE_ns2__WhiteBalanceOptions20 (740)
/* complex XSD type 'ns2:WhiteBalanceOptions20': */
class SOAP_CMAC ns2__WhiteBalanceOptions20 {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:WhiteBalanceMode'
        std::vector<ns2__WhiteBalanceMode> Mode;
        /// Optional element 'ns2:YrGain' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *YrGain;
        /// Optional element 'ns2:YbGain' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *YbGain;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:WhiteBalanceOptions20Extension'
        ns2__WhiteBalanceOptions20Extension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__WhiteBalanceOptions20
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__WhiteBalanceOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__WhiteBalanceOptions20, default initialized and not managed by a soap context
        virtual ns2__WhiteBalanceOptions20 *soap_alloc(void) const { return SOAP_NEW(ns2__WhiteBalanceOptions20); }
      public:
        /// Constructor with initializations
        ns2__WhiteBalanceOptions20()
        {
          YrGain = (ns2__FloatRange *)0;
          YbGain = (ns2__FloatRange *)0;
          Extension = (ns2__WhiteBalanceOptions20Extension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__WhiteBalanceOptions20() { }
        /// Friend allocator used by soap_new_ns2__WhiteBalanceOptions20(struct soap*, int)
        friend SOAP_FMAC1 ns2__WhiteBalanceOptions20 * SOAP_FMAC2 soap_instantiate_ns2__WhiteBalanceOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1771 */
#ifndef SOAP_TYPE_ns2__WhiteBalanceOptions20Extension
#define SOAP_TYPE_ns2__WhiteBalanceOptions20Extension (741)
/* complex XSD type 'ns2:WhiteBalanceOptions20Extension': */
class SOAP_CMAC ns2__WhiteBalanceOptions20Extension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__WhiteBalanceOptions20Extension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__WhiteBalanceOptions20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__WhiteBalanceOptions20Extension, default initialized and not managed by a soap context
        virtual ns2__WhiteBalanceOptions20Extension *soap_alloc(void) const { return SOAP_NEW(ns2__WhiteBalanceOptions20Extension); }
      public:
        /// Constructor with initializations
        ns2__WhiteBalanceOptions20Extension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__WhiteBalanceOptions20Extension() { }
        /// Friend allocator used by soap_new_ns2__WhiteBalanceOptions20Extension(struct soap*, int)
        friend SOAP_FMAC1 ns2__WhiteBalanceOptions20Extension * SOAP_FMAC2 soap_instantiate_ns2__WhiteBalanceOptions20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1774 */
#ifndef SOAP_TYPE_ns2__FocusOptions20
#define SOAP_TYPE_ns2__FocusOptions20 (742)
/* complex XSD type 'ns2:FocusOptions20': */
class SOAP_CMAC ns2__FocusOptions20 {
      public:
        /// Optional element 'ns2:AutoFocusModes' of XSD type 'ns2:AutoFocusMode'
        std::vector<ns2__AutoFocusMode> AutoFocusModes;
        /// Optional element 'ns2:DefaultSpeed' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *DefaultSpeed;
        /// Optional element 'ns2:NearLimit' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *NearLimit;
        /// Optional element 'ns2:FarLimit' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *FarLimit;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:FocusOptions20Extension'
        ns2__FocusOptions20Extension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FocusOptions20
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FocusOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FocusOptions20, default initialized and not managed by a soap context
        virtual ns2__FocusOptions20 *soap_alloc(void) const { return SOAP_NEW(ns2__FocusOptions20); }
      public:
        /// Constructor with initializations
        ns2__FocusOptions20()
        {
          DefaultSpeed = (ns2__FloatRange *)0;
          NearLimit = (ns2__FloatRange *)0;
          FarLimit = (ns2__FloatRange *)0;
          Extension = (ns2__FocusOptions20Extension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__FocusOptions20() { }
        /// Friend allocator used by soap_new_ns2__FocusOptions20(struct soap*, int)
        friend SOAP_FMAC1 ns2__FocusOptions20 * SOAP_FMAC2 soap_instantiate_ns2__FocusOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1777 */
#ifndef SOAP_TYPE_ns2__FocusOptions20Extension
#define SOAP_TYPE_ns2__FocusOptions20Extension (743)
/* complex XSD type 'ns2:FocusOptions20Extension': */
class SOAP_CMAC ns2__FocusOptions20Extension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FocusOptions20Extension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FocusOptions20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FocusOptions20Extension, default initialized and not managed by a soap context
        virtual ns2__FocusOptions20Extension *soap_alloc(void) const { return SOAP_NEW(ns2__FocusOptions20Extension); }
      public:
        /// Constructor with initializations
        ns2__FocusOptions20Extension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__FocusOptions20Extension() { }
        /// Friend allocator used by soap_new_ns2__FocusOptions20Extension(struct soap*, int)
        friend SOAP_FMAC1 ns2__FocusOptions20Extension * SOAP_FMAC2 soap_instantiate_ns2__FocusOptions20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1780 */
#ifndef SOAP_TYPE_ns2__ToneCompensationOptions
#define SOAP_TYPE_ns2__ToneCompensationOptions (744)
/* complex XSD type 'ns2:ToneCompensationOptions': */
class SOAP_CMAC ns2__ToneCompensationOptions {
      public:
        /// Required element 'ns2:Mode' of XSD type 'xsd:string'
        std::vector<std::string> Mode;
        /// Required element 'ns2:Level' of XSD type 'xsd:boolean'
        bool Level;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ToneCompensationOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ToneCompensationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ToneCompensationOptions, default initialized and not managed by a soap context
        virtual ns2__ToneCompensationOptions *soap_alloc(void) const { return SOAP_NEW(ns2__ToneCompensationOptions); }
      public:
        /// Constructor with initializations
        ns2__ToneCompensationOptions()
        {
          Level = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ToneCompensationOptions() { }
        /// Friend allocator used by soap_new_ns2__ToneCompensationOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__ToneCompensationOptions * SOAP_FMAC2 soap_instantiate_ns2__ToneCompensationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1783 */
#ifndef SOAP_TYPE_ns2__DefoggingOptions
#define SOAP_TYPE_ns2__DefoggingOptions (745)
/* complex XSD type 'ns2:DefoggingOptions': */
class SOAP_CMAC ns2__DefoggingOptions {
      public:
        /// Required element 'ns2:Mode' of XSD type 'xsd:string'
        std::vector<std::string> Mode;
        /// Required element 'ns2:Level' of XSD type 'xsd:boolean'
        bool Level;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DefoggingOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DefoggingOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DefoggingOptions, default initialized and not managed by a soap context
        virtual ns2__DefoggingOptions *soap_alloc(void) const { return SOAP_NEW(ns2__DefoggingOptions); }
      public:
        /// Constructor with initializations
        ns2__DefoggingOptions()
        {
          Level = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DefoggingOptions() { }
        /// Friend allocator used by soap_new_ns2__DefoggingOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__DefoggingOptions * SOAP_FMAC2 soap_instantiate_ns2__DefoggingOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1786 */
#ifndef SOAP_TYPE_ns2__NoiseReductionOptions
#define SOAP_TYPE_ns2__NoiseReductionOptions (746)
/* complex XSD type 'ns2:NoiseReductionOptions': */
class SOAP_CMAC ns2__NoiseReductionOptions {
      public:
        /// Required element 'ns2:Level' of XSD type 'xsd:boolean'
        bool Level;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NoiseReductionOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NoiseReductionOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NoiseReductionOptions, default initialized and not managed by a soap context
        virtual ns2__NoiseReductionOptions *soap_alloc(void) const { return SOAP_NEW(ns2__NoiseReductionOptions); }
      public:
        /// Constructor with initializations
        ns2__NoiseReductionOptions()
        {
          Level = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__NoiseReductionOptions() { }
        /// Friend allocator used by soap_new_ns2__NoiseReductionOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__NoiseReductionOptions * SOAP_FMAC2 soap_instantiate_ns2__NoiseReductionOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1789 */
#ifndef SOAP_TYPE_ns2__MessageExtension
#define SOAP_TYPE_ns2__MessageExtension (747)
/* complex XSD type 'ns2:MessageExtension': */
class SOAP_CMAC ns2__MessageExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MessageExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MessageExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MessageExtension, default initialized and not managed by a soap context
        virtual ns2__MessageExtension *soap_alloc(void) const { return SOAP_NEW(ns2__MessageExtension); }
      public:
        /// Constructor with initializations
        ns2__MessageExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__MessageExtension() { }
        /// Friend allocator used by soap_new_ns2__MessageExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__MessageExtension * SOAP_FMAC2 soap_instantiate_ns2__MessageExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:19937 */
#ifndef SOAP_TYPE__ns2__ItemList_SimpleItem
#define SOAP_TYPE__ns2__ItemList_SimpleItem (1843)
/* complex XSD type 'ns2:ItemList-SimpleItem': */
class SOAP_CMAC _ns2__ItemList_SimpleItem {
      public:
        /// required attribute 'Name' of XSD type 'xsd:string'
        std::string Name;
        /// required attribute 'Value' of XSD type 'xsd:anySimpleType'
        std::string Value;
      public:
        /// Return unique type id SOAP_TYPE__ns2__ItemList_SimpleItem
        virtual int soap_type(void) const { return SOAP_TYPE__ns2__ItemList_SimpleItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__ItemList_SimpleItem, default initialized and not managed by a soap context
        virtual _ns2__ItemList_SimpleItem *soap_alloc(void) const { return SOAP_NEW(_ns2__ItemList_SimpleItem); }
      public:
        /// Constructor with initializations
        _ns2__ItemList_SimpleItem()
        {
        }
        virtual ~_ns2__ItemList_SimpleItem() { }
        /// Friend allocator used by soap_new__ns2__ItemList_SimpleItem(struct soap*, int)
        friend SOAP_FMAC1 _ns2__ItemList_SimpleItem * SOAP_FMAC2 soap_instantiate__ns2__ItemList_SimpleItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:19965 */
#ifndef SOAP_TYPE__ns2__ItemList_ElementItem
#define SOAP_TYPE__ns2__ItemList_ElementItem (1846)
/* complex XSD type 'ns2:ItemList-ElementItem': */
class SOAP_CMAC _ns2__ItemList_ElementItem {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// required attribute 'Name' of XSD type 'xsd:string'
        std::string Name;
      public:
        /// Return unique type id SOAP_TYPE__ns2__ItemList_ElementItem
        virtual int soap_type(void) const { return SOAP_TYPE__ns2__ItemList_ElementItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__ItemList_ElementItem, default initialized and not managed by a soap context
        virtual _ns2__ItemList_ElementItem *soap_alloc(void) const { return SOAP_NEW(_ns2__ItemList_ElementItem); }
      public:
        /// Constructor with initializations
        _ns2__ItemList_ElementItem()
        {
        }
        virtual ~_ns2__ItemList_ElementItem() { }
        /// Friend allocator used by soap_new__ns2__ItemList_ElementItem(struct soap*, int)
        friend SOAP_FMAC1 _ns2__ItemList_ElementItem * SOAP_FMAC2 soap_instantiate__ns2__ItemList_ElementItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1792 */
#ifndef SOAP_TYPE_ns2__ItemList
#define SOAP_TYPE_ns2__ItemList (748)
/* complex XSD type 'ns2:ItemList': */
class SOAP_CMAC ns2__ItemList {
      public:
        /// Optional element 'ns2:SimpleItem' of XSD type 'ns2:ItemList-SimpleItem'
        std::vector<_ns2__ItemList_SimpleItem> *SimpleItem;
        /// Optional element 'ns2:ElementItem' of XSD type 'ns2:ItemList-ElementItem'
        std::vector<_ns2__ItemList_ElementItem> *ElementItem;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ItemListExtension'
        ns2__ItemListExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ItemList
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ItemList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ItemList, default initialized and not managed by a soap context
        virtual ns2__ItemList *soap_alloc(void) const { return SOAP_NEW(ns2__ItemList); }
      public:
        /// Constructor with initializations
        ns2__ItemList()
        {
          SimpleItem = (std::vector<_ns2__ItemList_SimpleItem> *)0;
          ElementItem = (std::vector<_ns2__ItemList_ElementItem> *)0;
          Extension = (ns2__ItemListExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ItemList() { }
        /// Friend allocator used by soap_new_ns2__ItemList(struct soap*, int)
        friend SOAP_FMAC1 ns2__ItemList * SOAP_FMAC2 soap_instantiate_ns2__ItemList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1795 */
#ifndef SOAP_TYPE_ns2__ItemListExtension
#define SOAP_TYPE_ns2__ItemListExtension (749)
/* complex XSD type 'ns2:ItemListExtension': */
class SOAP_CMAC ns2__ItemListExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ItemListExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ItemListExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ItemListExtension, default initialized and not managed by a soap context
        virtual ns2__ItemListExtension *soap_alloc(void) const { return SOAP_NEW(ns2__ItemListExtension); }
      public:
        /// Constructor with initializations
        ns2__ItemListExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ItemListExtension() { }
        /// Friend allocator used by soap_new_ns2__ItemListExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__ItemListExtension * SOAP_FMAC2 soap_instantiate_ns2__ItemListExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1798 */
#ifndef SOAP_TYPE_ns2__MessageDescription
#define SOAP_TYPE_ns2__MessageDescription (750)
/* complex XSD type 'ns2:MessageDescription': */
class SOAP_CMAC ns2__MessageDescription {
      public:
        /// Optional element 'ns2:Source' of XSD type 'ns2:ItemListDescription'
        ns2__ItemListDescription *Source;
        /// Optional element 'ns2:Key' of XSD type 'ns2:ItemListDescription'
        ns2__ItemListDescription *Key;
        /// Optional element 'ns2:Data' of XSD type 'ns2:ItemListDescription'
        ns2__ItemListDescription *Data;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:MessageDescriptionExtension'
        ns2__MessageDescriptionExtension *Extension;
        /// optional attribute 'IsProperty' of XSD type 'xsd:boolean'
        bool *IsProperty;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MessageDescription
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MessageDescription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MessageDescription, default initialized and not managed by a soap context
        virtual ns2__MessageDescription *soap_alloc(void) const { return SOAP_NEW(ns2__MessageDescription); }
      public:
        /// Constructor with initializations
        ns2__MessageDescription()
        {
          Source = (ns2__ItemListDescription *)0;
          Key = (ns2__ItemListDescription *)0;
          Data = (ns2__ItemListDescription *)0;
          Extension = (ns2__MessageDescriptionExtension *)0;
          IsProperty = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__MessageDescription() { }
        /// Friend allocator used by soap_new_ns2__MessageDescription(struct soap*, int)
        friend SOAP_FMAC1 ns2__MessageDescription * SOAP_FMAC2 soap_instantiate_ns2__MessageDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1801 */
#ifndef SOAP_TYPE_ns2__MessageDescriptionExtension
#define SOAP_TYPE_ns2__MessageDescriptionExtension (751)
/* complex XSD type 'ns2:MessageDescriptionExtension': */
class SOAP_CMAC ns2__MessageDescriptionExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MessageDescriptionExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MessageDescriptionExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MessageDescriptionExtension, default initialized and not managed by a soap context
        virtual ns2__MessageDescriptionExtension *soap_alloc(void) const { return SOAP_NEW(ns2__MessageDescriptionExtension); }
      public:
        /// Constructor with initializations
        ns2__MessageDescriptionExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__MessageDescriptionExtension() { }
        /// Friend allocator used by soap_new_ns2__MessageDescriptionExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__MessageDescriptionExtension * SOAP_FMAC2 soap_instantiate_ns2__MessageDescriptionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:20128 */
#ifndef SOAP_TYPE__ns2__ItemListDescription_SimpleItemDescription
#define SOAP_TYPE__ns2__ItemListDescription_SimpleItemDescription (1852)
/* complex XSD type 'ns2:ItemListDescription-SimpleItemDescription': */
class SOAP_CMAC _ns2__ItemListDescription_SimpleItemDescription {
      public:
        /// required attribute 'Name' of XSD type 'xsd:string'
        std::string Name;
        /// required attribute 'Type' of XSD type 'xsd:QName'
        std::string Type;
      public:
        /// Return unique type id SOAP_TYPE__ns2__ItemListDescription_SimpleItemDescription
        virtual int soap_type(void) const { return SOAP_TYPE__ns2__ItemListDescription_SimpleItemDescription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__ItemListDescription_SimpleItemDescription, default initialized and not managed by a soap context
        virtual _ns2__ItemListDescription_SimpleItemDescription *soap_alloc(void) const { return SOAP_NEW(_ns2__ItemListDescription_SimpleItemDescription); }
      public:
        /// Constructor with initializations
        _ns2__ItemListDescription_SimpleItemDescription()
        {
        }
        virtual ~_ns2__ItemListDescription_SimpleItemDescription() { }
        /// Friend allocator used by soap_new__ns2__ItemListDescription_SimpleItemDescription(struct soap*, int)
        friend SOAP_FMAC1 _ns2__ItemListDescription_SimpleItemDescription * SOAP_FMAC2 soap_instantiate__ns2__ItemListDescription_SimpleItemDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:20153 */
#ifndef SOAP_TYPE__ns2__ItemListDescription_ElementItemDescription
#define SOAP_TYPE__ns2__ItemListDescription_ElementItemDescription (1855)
/* complex XSD type 'ns2:ItemListDescription-ElementItemDescription': */
class SOAP_CMAC _ns2__ItemListDescription_ElementItemDescription {
      public:
        /// required attribute 'Name' of XSD type 'xsd:string'
        std::string Name;
        /// required attribute 'Type' of XSD type 'xsd:QName'
        std::string Type;
      public:
        /// Return unique type id SOAP_TYPE__ns2__ItemListDescription_ElementItemDescription
        virtual int soap_type(void) const { return SOAP_TYPE__ns2__ItemListDescription_ElementItemDescription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__ItemListDescription_ElementItemDescription, default initialized and not managed by a soap context
        virtual _ns2__ItemListDescription_ElementItemDescription *soap_alloc(void) const { return SOAP_NEW(_ns2__ItemListDescription_ElementItemDescription); }
      public:
        /// Constructor with initializations
        _ns2__ItemListDescription_ElementItemDescription()
        {
        }
        virtual ~_ns2__ItemListDescription_ElementItemDescription() { }
        /// Friend allocator used by soap_new__ns2__ItemListDescription_ElementItemDescription(struct soap*, int)
        friend SOAP_FMAC1 _ns2__ItemListDescription_ElementItemDescription * SOAP_FMAC2 soap_instantiate__ns2__ItemListDescription_ElementItemDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1804 */
#ifndef SOAP_TYPE_ns2__ItemListDescription
#define SOAP_TYPE_ns2__ItemListDescription (752)
/* complex XSD type 'ns2:ItemListDescription': */
class SOAP_CMAC ns2__ItemListDescription {
      public:
        /// Optional element 'ns2:SimpleItemDescription' of XSD type 'ns2:ItemListDescription-SimpleItemDescription'
        std::vector<_ns2__ItemListDescription_SimpleItemDescription> *SimpleItemDescription;
        /// Optional element 'ns2:ElementItemDescription' of XSD type 'ns2:ItemListDescription-ElementItemDescription'
        std::vector<_ns2__ItemListDescription_ElementItemDescription> *ElementItemDescription;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ItemListDescriptionExtension'
        ns2__ItemListDescriptionExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ItemListDescription
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ItemListDescription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ItemListDescription, default initialized and not managed by a soap context
        virtual ns2__ItemListDescription *soap_alloc(void) const { return SOAP_NEW(ns2__ItemListDescription); }
      public:
        /// Constructor with initializations
        ns2__ItemListDescription()
        {
          SimpleItemDescription = (std::vector<_ns2__ItemListDescription_SimpleItemDescription> *)0;
          ElementItemDescription = (std::vector<_ns2__ItemListDescription_ElementItemDescription> *)0;
          Extension = (ns2__ItemListDescriptionExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ItemListDescription() { }
        /// Friend allocator used by soap_new_ns2__ItemListDescription(struct soap*, int)
        friend SOAP_FMAC1 ns2__ItemListDescription * SOAP_FMAC2 soap_instantiate_ns2__ItemListDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1807 */
#ifndef SOAP_TYPE_ns2__ItemListDescriptionExtension
#define SOAP_TYPE_ns2__ItemListDescriptionExtension (753)
/* complex XSD type 'ns2:ItemListDescriptionExtension': */
class SOAP_CMAC ns2__ItemListDescriptionExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ItemListDescriptionExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ItemListDescriptionExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ItemListDescriptionExtension, default initialized and not managed by a soap context
        virtual ns2__ItemListDescriptionExtension *soap_alloc(void) const { return SOAP_NEW(ns2__ItemListDescriptionExtension); }
      public:
        /// Constructor with initializations
        ns2__ItemListDescriptionExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ItemListDescriptionExtension() { }
        /// Friend allocator used by soap_new_ns2__ItemListDescriptionExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__ItemListDescriptionExtension * SOAP_FMAC2 soap_instantiate_ns2__ItemListDescriptionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1810 */
#ifndef SOAP_TYPE_ns2__Vector
#define SOAP_TYPE_ns2__Vector (754)
/* complex XSD type 'ns2:Vector': */
class SOAP_CMAC ns2__Vector {
      public:
        /// optional attribute 'x' of XSD type 'xsd:float'
        float *x;
        /// optional attribute 'y' of XSD type 'xsd:float'
        float *y;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Vector
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Vector; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Vector, default initialized and not managed by a soap context
        virtual ns2__Vector *soap_alloc(void) const { return SOAP_NEW(ns2__Vector); }
      public:
        /// Constructor with initializations
        ns2__Vector()
        {
          x = (float *)0;
          y = (float *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Vector() { }
        /// Friend allocator used by soap_new_ns2__Vector(struct soap*, int)
        friend SOAP_FMAC1 ns2__Vector * SOAP_FMAC2 soap_instantiate_ns2__Vector(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1813 */
#ifndef SOAP_TYPE_ns2__Rectangle
#define SOAP_TYPE_ns2__Rectangle (755)
/* complex XSD type 'ns2:Rectangle': */
class SOAP_CMAC ns2__Rectangle {
      public:
        /// optional attribute 'bottom' of XSD type 'xsd:float'
        float *bottom;
        /// optional attribute 'top' of XSD type 'xsd:float'
        float *top;
        /// optional attribute 'right' of XSD type 'xsd:float'
        float *right;
        /// optional attribute 'left' of XSD type 'xsd:float'
        float *left;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Rectangle
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Rectangle; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Rectangle, default initialized and not managed by a soap context
        virtual ns2__Rectangle *soap_alloc(void) const { return SOAP_NEW(ns2__Rectangle); }
      public:
        /// Constructor with initializations
        ns2__Rectangle()
        {
          bottom = (float *)0;
          top = (float *)0;
          right = (float *)0;
          left = (float *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Rectangle() { }
        /// Friend allocator used by soap_new_ns2__Rectangle(struct soap*, int)
        friend SOAP_FMAC1 ns2__Rectangle * SOAP_FMAC2 soap_instantiate_ns2__Rectangle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1816 */
#ifndef SOAP_TYPE_ns2__Polygon
#define SOAP_TYPE_ns2__Polygon (756)
/* complex XSD type 'ns2:Polygon': */
class SOAP_CMAC ns2__Polygon {
      public:
        /// Required element 'ns2:Point' of XSD type 'ns2:Vector'
        std::vector<ns2__Vector *> Point;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Polygon
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Polygon; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Polygon, default initialized and not managed by a soap context
        virtual ns2__Polygon *soap_alloc(void) const { return SOAP_NEW(ns2__Polygon); }
      public:
        /// Constructor with initializations
        ns2__Polygon()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__Polygon() { }
        /// Friend allocator used by soap_new_ns2__Polygon(struct soap*, int)
        friend SOAP_FMAC1 ns2__Polygon * SOAP_FMAC2 soap_instantiate_ns2__Polygon(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1819 */
#ifndef SOAP_TYPE_ns2__Polyline
#define SOAP_TYPE_ns2__Polyline (757)
/* complex XSD type 'ns2:Polyline': */
class SOAP_CMAC ns2__Polyline {
      public:
        /// Required element 'ns2:Point' of XSD type 'ns2:Vector'
        std::vector<ns2__Vector *> Point;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Polyline
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Polyline; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Polyline, default initialized and not managed by a soap context
        virtual ns2__Polyline *soap_alloc(void) const { return SOAP_NEW(ns2__Polyline); }
      public:
        /// Constructor with initializations
        ns2__Polyline()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__Polyline() { }
        /// Friend allocator used by soap_new_ns2__Polyline(struct soap*, int)
        friend SOAP_FMAC1 ns2__Polyline * SOAP_FMAC2 soap_instantiate_ns2__Polyline(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1822 */
#ifndef SOAP_TYPE_ns2__Color
#define SOAP_TYPE_ns2__Color (758)
/* complex XSD type 'ns2:Color': */
class SOAP_CMAC ns2__Color {
      public:
        /// required attribute 'X' of XSD type 'xsd:float'
        float X;
        /// required attribute 'Y' of XSD type 'xsd:float'
        float Y;
        /// required attribute 'Z' of XSD type 'xsd:float'
        float Z;
        /// optional attribute 'Colorspace' of XSD type 'xsd:anyURI'
        std::string *Colorspace;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Color
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Color; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Color, default initialized and not managed by a soap context
        virtual ns2__Color *soap_alloc(void) const { return SOAP_NEW(ns2__Color); }
      public:
        /// Constructor with initializations
        ns2__Color()
        {
          X = (float)0;
          Y = (float)0;
          Z = (float)0;
          Colorspace = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Color() { }
        /// Friend allocator used by soap_new_ns2__Color(struct soap*, int)
        friend SOAP_FMAC1 ns2__Color * SOAP_FMAC2 soap_instantiate_ns2__Color(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1825 */
#ifndef SOAP_TYPE_ns2__ColorCovariance
#define SOAP_TYPE_ns2__ColorCovariance (759)
/* complex XSD type 'ns2:ColorCovariance': */
class SOAP_CMAC ns2__ColorCovariance {
      public:
        /// required attribute 'XX' of XSD type 'xsd:float'
        float XX;
        /// required attribute 'YY' of XSD type 'xsd:float'
        float YY;
        /// required attribute 'ZZ' of XSD type 'xsd:float'
        float ZZ;
        /// optional attribute 'XY' of XSD type 'xsd:float'
        float *XY;
        /// optional attribute 'XZ' of XSD type 'xsd:float'
        float *XZ;
        /// optional attribute 'YZ' of XSD type 'xsd:float'
        float *YZ;
        /// optional attribute 'Colorspace' of XSD type 'xsd:anyURI'
        std::string *Colorspace;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ColorCovariance
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ColorCovariance; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ColorCovariance, default initialized and not managed by a soap context
        virtual ns2__ColorCovariance *soap_alloc(void) const { return SOAP_NEW(ns2__ColorCovariance); }
      public:
        /// Constructor with initializations
        ns2__ColorCovariance()
        {
          XX = (float)0;
          YY = (float)0;
          ZZ = (float)0;
          XY = (float *)0;
          XZ = (float *)0;
          YZ = (float *)0;
          Colorspace = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ColorCovariance() { }
        /// Friend allocator used by soap_new_ns2__ColorCovariance(struct soap*, int)
        friend SOAP_FMAC1 ns2__ColorCovariance * SOAP_FMAC2 soap_instantiate_ns2__ColorCovariance(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1828 */
#ifndef SOAP_TYPE_ns2__Appearance
#define SOAP_TYPE_ns2__Appearance (760)
/* complex XSD type 'ns2:Appearance': */
class SOAP_CMAC ns2__Appearance {
      public:
        /// Optional element 'ns2:Transformation' of XSD type 'ns2:Transformation'
        ns2__Transformation *Transformation;
        /// Optional element 'ns2:Shape' of XSD type 'ns2:ShapeDescriptor'
        ns2__ShapeDescriptor *Shape;
        /// Optional element 'ns2:Color' of XSD type 'ns2:ColorDescriptor'
        ns2__ColorDescriptor *Color;
        /// Optional element 'ns2:Class' of XSD type 'ns2:ClassDescriptor'
        ns2__ClassDescriptor *Class;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:AppearanceExtension'
        ns2__AppearanceExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Appearance
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Appearance; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Appearance, default initialized and not managed by a soap context
        virtual ns2__Appearance *soap_alloc(void) const { return SOAP_NEW(ns2__Appearance); }
      public:
        /// Constructor with initializations
        ns2__Appearance()
        {
          Transformation = (ns2__Transformation *)0;
          Shape = (ns2__ShapeDescriptor *)0;
          Color = (ns2__ColorDescriptor *)0;
          Class = (ns2__ClassDescriptor *)0;
          Extension = (ns2__AppearanceExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Appearance() { }
        /// Friend allocator used by soap_new_ns2__Appearance(struct soap*, int)
        friend SOAP_FMAC1 ns2__Appearance * SOAP_FMAC2 soap_instantiate_ns2__Appearance(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1831 */
#ifndef SOAP_TYPE_ns2__AppearanceExtension
#define SOAP_TYPE_ns2__AppearanceExtension (761)
/* complex XSD type 'ns2:AppearanceExtension': */
class SOAP_CMAC ns2__AppearanceExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AppearanceExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AppearanceExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AppearanceExtension, default initialized and not managed by a soap context
        virtual ns2__AppearanceExtension *soap_alloc(void) const { return SOAP_NEW(ns2__AppearanceExtension); }
      public:
        /// Constructor with initializations
        ns2__AppearanceExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__AppearanceExtension() { }
        /// Friend allocator used by soap_new_ns2__AppearanceExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__AppearanceExtension * SOAP_FMAC2 soap_instantiate_ns2__AppearanceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1834 */
#ifndef SOAP_TYPE_ns2__ShapeDescriptor
#define SOAP_TYPE_ns2__ShapeDescriptor (762)
/* complex XSD type 'ns2:ShapeDescriptor': */
class SOAP_CMAC ns2__ShapeDescriptor {
      public:
        /// Required element 'ns2:BoundingBox' of XSD type 'ns2:Rectangle'
        ns2__Rectangle *BoundingBox;
        /// Required element 'ns2:CenterOfGravity' of XSD type 'ns2:Vector'
        ns2__Vector *CenterOfGravity;
        /// Optional element 'ns2:Polygon' of XSD type 'ns2:Polygon'
        std::vector<ns2__Polygon *> Polygon;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ShapeDescriptorExtension'
        ns2__ShapeDescriptorExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ShapeDescriptor
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ShapeDescriptor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ShapeDescriptor, default initialized and not managed by a soap context
        virtual ns2__ShapeDescriptor *soap_alloc(void) const { return SOAP_NEW(ns2__ShapeDescriptor); }
      public:
        /// Constructor with initializations
        ns2__ShapeDescriptor()
        {
          BoundingBox = (ns2__Rectangle *)0;
          CenterOfGravity = (ns2__Vector *)0;
          Extension = (ns2__ShapeDescriptorExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ShapeDescriptor() { }
        /// Friend allocator used by soap_new_ns2__ShapeDescriptor(struct soap*, int)
        friend SOAP_FMAC1 ns2__ShapeDescriptor * SOAP_FMAC2 soap_instantiate_ns2__ShapeDescriptor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1837 */
#ifndef SOAP_TYPE_ns2__ShapeDescriptorExtension
#define SOAP_TYPE_ns2__ShapeDescriptorExtension (763)
/* complex XSD type 'ns2:ShapeDescriptorExtension': */
class SOAP_CMAC ns2__ShapeDescriptorExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ShapeDescriptorExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ShapeDescriptorExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ShapeDescriptorExtension, default initialized and not managed by a soap context
        virtual ns2__ShapeDescriptorExtension *soap_alloc(void) const { return SOAP_NEW(ns2__ShapeDescriptorExtension); }
      public:
        /// Constructor with initializations
        ns2__ShapeDescriptorExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ShapeDescriptorExtension() { }
        /// Friend allocator used by soap_new_ns2__ShapeDescriptorExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__ShapeDescriptorExtension * SOAP_FMAC2 soap_instantiate_ns2__ShapeDescriptorExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:20494 */
#ifndef SOAP_TYPE__ns2__ColorDescriptor_ColorCluster
#define SOAP_TYPE__ns2__ColorDescriptor_ColorCluster (1869)
/* complex XSD type 'ns2:ColorDescriptor-ColorCluster': */
class SOAP_CMAC _ns2__ColorDescriptor_ColorCluster {
      public:
        /// Required element 'ns2:Color' of XSD type 'ns2:Color'
        ns2__Color *Color;
        /// Optional element 'ns2:Weight' of XSD type 'xsd:float'
        float *Weight;
        /// Optional element 'ns2:Covariance' of XSD type 'ns2:ColorCovariance'
        ns2__ColorCovariance *Covariance;
      public:
        /// Return unique type id SOAP_TYPE__ns2__ColorDescriptor_ColorCluster
        virtual int soap_type(void) const { return SOAP_TYPE__ns2__ColorDescriptor_ColorCluster; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__ColorDescriptor_ColorCluster, default initialized and not managed by a soap context
        virtual _ns2__ColorDescriptor_ColorCluster *soap_alloc(void) const { return SOAP_NEW(_ns2__ColorDescriptor_ColorCluster); }
      public:
        /// Constructor with initializations
        _ns2__ColorDescriptor_ColorCluster()
        {
          Color = (ns2__Color *)0;
          Weight = (float *)0;
          Covariance = (ns2__ColorCovariance *)0;
        }
        virtual ~_ns2__ColorDescriptor_ColorCluster() { }
        /// Friend allocator used by soap_new__ns2__ColorDescriptor_ColorCluster(struct soap*, int)
        friend SOAP_FMAC1 _ns2__ColorDescriptor_ColorCluster * SOAP_FMAC2 soap_instantiate__ns2__ColorDescriptor_ColorCluster(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1840 */
#ifndef SOAP_TYPE_ns2__ColorDescriptor
#define SOAP_TYPE_ns2__ColorDescriptor (764)
/* complex XSD type 'ns2:ColorDescriptor': */
class SOAP_CMAC ns2__ColorDescriptor {
      public:
        /// Optional element 'ns2:ColorCluster' of XSD type 'ns2:ColorDescriptor-ColorCluster'
        std::vector<_ns2__ColorDescriptor_ColorCluster> *ColorCluster;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ColorDescriptorExtension'
        ns2__ColorDescriptorExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ColorDescriptor
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ColorDescriptor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ColorDescriptor, default initialized and not managed by a soap context
        virtual ns2__ColorDescriptor *soap_alloc(void) const { return SOAP_NEW(ns2__ColorDescriptor); }
      public:
        /// Constructor with initializations
        ns2__ColorDescriptor()
        {
          ColorCluster = (std::vector<_ns2__ColorDescriptor_ColorCluster> *)0;
          Extension = (ns2__ColorDescriptorExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ColorDescriptor() { }
        /// Friend allocator used by soap_new_ns2__ColorDescriptor(struct soap*, int)
        friend SOAP_FMAC1 ns2__ColorDescriptor * SOAP_FMAC2 soap_instantiate_ns2__ColorDescriptor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1843 */
#ifndef SOAP_TYPE_ns2__ColorDescriptorExtension
#define SOAP_TYPE_ns2__ColorDescriptorExtension (765)
/* complex XSD type 'ns2:ColorDescriptorExtension': */
class SOAP_CMAC ns2__ColorDescriptorExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ColorDescriptorExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ColorDescriptorExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ColorDescriptorExtension, default initialized and not managed by a soap context
        virtual ns2__ColorDescriptorExtension *soap_alloc(void) const { return SOAP_NEW(ns2__ColorDescriptorExtension); }
      public:
        /// Constructor with initializations
        ns2__ColorDescriptorExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ColorDescriptorExtension() { }
        /// Friend allocator used by soap_new_ns2__ColorDescriptorExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__ColorDescriptorExtension * SOAP_FMAC2 soap_instantiate_ns2__ColorDescriptorExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:20567 */
#ifndef SOAP_TYPE__ns2__ClassDescriptor_ClassCandidate
#define SOAP_TYPE__ns2__ClassDescriptor_ClassCandidate (1875)
/* complex XSD type 'ns2:ClassDescriptor-ClassCandidate': */
class SOAP_CMAC _ns2__ClassDescriptor_ClassCandidate {
      public:
        /// Required element 'ns2:Type' of XSD type 'ns2:ClassType'
        ns2__ClassType Type;
        /// Required element 'ns2:Likelihood' of XSD type 'xsd:float'
        float Likelihood;
      public:
        /// Return unique type id SOAP_TYPE__ns2__ClassDescriptor_ClassCandidate
        virtual int soap_type(void) const { return SOAP_TYPE__ns2__ClassDescriptor_ClassCandidate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__ClassDescriptor_ClassCandidate, default initialized and not managed by a soap context
        virtual _ns2__ClassDescriptor_ClassCandidate *soap_alloc(void) const { return SOAP_NEW(_ns2__ClassDescriptor_ClassCandidate); }
      public:
        /// Constructor with initializations
        _ns2__ClassDescriptor_ClassCandidate()
        {
          Type = (ns2__ClassType)0;
          Likelihood = (float)0;
        }
        virtual ~_ns2__ClassDescriptor_ClassCandidate() { }
        /// Friend allocator used by soap_new__ns2__ClassDescriptor_ClassCandidate(struct soap*, int)
        friend SOAP_FMAC1 _ns2__ClassDescriptor_ClassCandidate * SOAP_FMAC2 soap_instantiate__ns2__ClassDescriptor_ClassCandidate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1846 */
#ifndef SOAP_TYPE_ns2__ClassDescriptor
#define SOAP_TYPE_ns2__ClassDescriptor (766)
/* complex XSD type 'ns2:ClassDescriptor': */
class SOAP_CMAC ns2__ClassDescriptor {
      public:
        /// Optional element 'ns2:ClassCandidate' of XSD type 'ns2:ClassDescriptor-ClassCandidate'
        std::vector<_ns2__ClassDescriptor_ClassCandidate> *ClassCandidate;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ClassDescriptorExtension'
        ns2__ClassDescriptorExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ClassDescriptor
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ClassDescriptor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ClassDescriptor, default initialized and not managed by a soap context
        virtual ns2__ClassDescriptor *soap_alloc(void) const { return SOAP_NEW(ns2__ClassDescriptor); }
      public:
        /// Constructor with initializations
        ns2__ClassDescriptor()
        {
          ClassCandidate = (std::vector<_ns2__ClassDescriptor_ClassCandidate> *)0;
          Extension = (ns2__ClassDescriptorExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ClassDescriptor() { }
        /// Friend allocator used by soap_new_ns2__ClassDescriptor(struct soap*, int)
        friend SOAP_FMAC1 ns2__ClassDescriptor * SOAP_FMAC2 soap_instantiate_ns2__ClassDescriptor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1849 */
#ifndef SOAP_TYPE_ns2__ClassDescriptorExtension
#define SOAP_TYPE_ns2__ClassDescriptorExtension (767)
/* complex XSD type 'ns2:ClassDescriptorExtension': */
class SOAP_CMAC ns2__ClassDescriptorExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Required element 'ns2:OtherTypes' of XSD type 'ns2:OtherType'
        std::vector<ns2__OtherType *> OtherTypes;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ClassDescriptorExtension2'
        ns2__ClassDescriptorExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ClassDescriptorExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ClassDescriptorExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ClassDescriptorExtension, default initialized and not managed by a soap context
        virtual ns2__ClassDescriptorExtension *soap_alloc(void) const { return SOAP_NEW(ns2__ClassDescriptorExtension); }
      public:
        /// Constructor with initializations
        ns2__ClassDescriptorExtension()
        {
          Extension = (ns2__ClassDescriptorExtension2 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ClassDescriptorExtension() { }
        /// Friend allocator used by soap_new_ns2__ClassDescriptorExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__ClassDescriptorExtension * SOAP_FMAC2 soap_instantiate_ns2__ClassDescriptorExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1852 */
#ifndef SOAP_TYPE_ns2__ClassDescriptorExtension2
#define SOAP_TYPE_ns2__ClassDescriptorExtension2 (768)
/* complex XSD type 'ns2:ClassDescriptorExtension2': */
class SOAP_CMAC ns2__ClassDescriptorExtension2 {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ClassDescriptorExtension2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ClassDescriptorExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ClassDescriptorExtension2, default initialized and not managed by a soap context
        virtual ns2__ClassDescriptorExtension2 *soap_alloc(void) const { return SOAP_NEW(ns2__ClassDescriptorExtension2); }
      public:
        /// Constructor with initializations
        ns2__ClassDescriptorExtension2()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ClassDescriptorExtension2() { }
        /// Friend allocator used by soap_new_ns2__ClassDescriptorExtension2(struct soap*, int)
        friend SOAP_FMAC1 ns2__ClassDescriptorExtension2 * SOAP_FMAC2 soap_instantiate_ns2__ClassDescriptorExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1855 */
#ifndef SOAP_TYPE_ns2__OtherType
#define SOAP_TYPE_ns2__OtherType (769)
/* complex XSD type 'ns2:OtherType': */
class SOAP_CMAC ns2__OtherType {
      public:
        /// Required element 'ns2:Type' of XSD type 'xsd:string'
        std::string Type;
        /// Required element 'ns2:Likelihood' of XSD type 'xsd:float'
        float Likelihood;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OtherType
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__OtherType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OtherType, default initialized and not managed by a soap context
        virtual ns2__OtherType *soap_alloc(void) const { return SOAP_NEW(ns2__OtherType); }
      public:
        /// Constructor with initializations
        ns2__OtherType()
        {
          Likelihood = (float)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__OtherType() { }
        /// Friend allocator used by soap_new_ns2__OtherType(struct soap*, int)
        friend SOAP_FMAC1 ns2__OtherType * SOAP_FMAC2 soap_instantiate_ns2__OtherType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1861 */
#ifndef SOAP_TYPE_ns2__ObjectExtension
#define SOAP_TYPE_ns2__ObjectExtension (771)
/* complex XSD type 'ns2:ObjectExtension': */
class SOAP_CMAC ns2__ObjectExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ObjectExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ObjectExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ObjectExtension, default initialized and not managed by a soap context
        virtual ns2__ObjectExtension *soap_alloc(void) const { return SOAP_NEW(ns2__ObjectExtension); }
      public:
        /// Constructor with initializations
        ns2__ObjectExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ObjectExtension() { }
        /// Friend allocator used by soap_new_ns2__ObjectExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__ObjectExtension * SOAP_FMAC2 soap_instantiate_ns2__ObjectExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1864 */
#ifndef SOAP_TYPE_ns2__Transformation
#define SOAP_TYPE_ns2__Transformation (772)
/* complex XSD type 'ns2:Transformation': */
class SOAP_CMAC ns2__Transformation {
      public:
        /// Optional element 'ns2:Translate' of XSD type 'ns2:Vector'
        ns2__Vector *Translate;
        /// Optional element 'ns2:Scale' of XSD type 'ns2:Vector'
        ns2__Vector *Scale;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:TransformationExtension'
        ns2__TransformationExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Transformation
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Transformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Transformation, default initialized and not managed by a soap context
        virtual ns2__Transformation *soap_alloc(void) const { return SOAP_NEW(ns2__Transformation); }
      public:
        /// Constructor with initializations
        ns2__Transformation()
        {
          Translate = (ns2__Vector *)0;
          Scale = (ns2__Vector *)0;
          Extension = (ns2__TransformationExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Transformation() { }
        /// Friend allocator used by soap_new_ns2__Transformation(struct soap*, int)
        friend SOAP_FMAC1 ns2__Transformation * SOAP_FMAC2 soap_instantiate_ns2__Transformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1867 */
#ifndef SOAP_TYPE_ns2__TransformationExtension
#define SOAP_TYPE_ns2__TransformationExtension (773)
/* complex XSD type 'ns2:TransformationExtension': */
class SOAP_CMAC ns2__TransformationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__TransformationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__TransformationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__TransformationExtension, default initialized and not managed by a soap context
        virtual ns2__TransformationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__TransformationExtension); }
      public:
        /// Constructor with initializations
        ns2__TransformationExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__TransformationExtension() { }
        /// Friend allocator used by soap_new_ns2__TransformationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__TransformationExtension * SOAP_FMAC2 soap_instantiate_ns2__TransformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1870 */
#ifndef SOAP_TYPE_ns2__Frame
#define SOAP_TYPE_ns2__Frame (774)
/* complex XSD type 'ns2:Frame': */
class SOAP_CMAC ns2__Frame {
      public:
        /// Optional element 'ns2:PTZStatus' of XSD type 'ns2:PTZStatus'
        ns2__PTZStatus *PTZStatus;
        /// Optional element 'ns2:Transformation' of XSD type 'ns2:Transformation'
        ns2__Transformation *Transformation;
        /// Optional element 'ns2:Object' of XSD type 'ns2:Object'
        std::vector<ns2__Object *> Object;
        /// Optional element 'ns2:ObjectTree' of XSD type 'ns2:ObjectTree'
        ns2__ObjectTree *ObjectTree;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:FrameExtension'
        ns2__FrameExtension *Extension;
        /// required attribute 'UtcTime' of XSD type 'xsd:dateTime'
        time_t UtcTime;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Frame
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Frame; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Frame, default initialized and not managed by a soap context
        virtual ns2__Frame *soap_alloc(void) const { return SOAP_NEW(ns2__Frame); }
      public:
        /// Constructor with initializations
        ns2__Frame()
        {
          PTZStatus = (ns2__PTZStatus *)0;
          Transformation = (ns2__Transformation *)0;
          ObjectTree = (ns2__ObjectTree *)0;
          Extension = (ns2__FrameExtension *)0;
          UtcTime = (time_t)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Frame() { }
        /// Friend allocator used by soap_new_ns2__Frame(struct soap*, int)
        friend SOAP_FMAC1 ns2__Frame * SOAP_FMAC2 soap_instantiate_ns2__Frame(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1873 */
#ifndef SOAP_TYPE_ns2__FrameExtension
#define SOAP_TYPE_ns2__FrameExtension (775)
/* complex XSD type 'ns2:FrameExtension': */
class SOAP_CMAC ns2__FrameExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional element 'ns2:MotionInCells' of XSD type 'ns2:MotionInCells'
        ns2__MotionInCells *MotionInCells;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:FrameExtension2'
        ns2__FrameExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FrameExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FrameExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FrameExtension, default initialized and not managed by a soap context
        virtual ns2__FrameExtension *soap_alloc(void) const { return SOAP_NEW(ns2__FrameExtension); }
      public:
        /// Constructor with initializations
        ns2__FrameExtension()
        {
          MotionInCells = (ns2__MotionInCells *)0;
          Extension = (ns2__FrameExtension2 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__FrameExtension() { }
        /// Friend allocator used by soap_new_ns2__FrameExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__FrameExtension * SOAP_FMAC2 soap_instantiate_ns2__FrameExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1876 */
#ifndef SOAP_TYPE_ns2__FrameExtension2
#define SOAP_TYPE_ns2__FrameExtension2 (776)
/* complex XSD type 'ns2:FrameExtension2': */
class SOAP_CMAC ns2__FrameExtension2 {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FrameExtension2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FrameExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FrameExtension2, default initialized and not managed by a soap context
        virtual ns2__FrameExtension2 *soap_alloc(void) const { return SOAP_NEW(ns2__FrameExtension2); }
      public:
        /// Constructor with initializations
        ns2__FrameExtension2()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__FrameExtension2() { }
        /// Friend allocator used by soap_new_ns2__FrameExtension2(struct soap*, int)
        friend SOAP_FMAC1 ns2__FrameExtension2 * SOAP_FMAC2 soap_instantiate_ns2__FrameExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1879 */
#ifndef SOAP_TYPE_ns2__Merge
#define SOAP_TYPE_ns2__Merge (777)
/* complex XSD type 'ns2:Merge': */
class SOAP_CMAC ns2__Merge {
      public:
        /// Required element 'ns2:from' of XSD type 'ns2:ObjectId'
        std::vector<ns2__ObjectId *> from;
        /// Required element 'ns2:to' of XSD type 'ns2:ObjectId'
        ns2__ObjectId *to;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Merge
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Merge; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Merge, default initialized and not managed by a soap context
        virtual ns2__Merge *soap_alloc(void) const { return SOAP_NEW(ns2__Merge); }
      public:
        /// Constructor with initializations
        ns2__Merge()
        {
          to = (ns2__ObjectId *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Merge() { }
        /// Friend allocator used by soap_new_ns2__Merge(struct soap*, int)
        friend SOAP_FMAC1 ns2__Merge * SOAP_FMAC2 soap_instantiate_ns2__Merge(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1882 */
#ifndef SOAP_TYPE_ns2__Split
#define SOAP_TYPE_ns2__Split (778)
/* complex XSD type 'ns2:Split': */
class SOAP_CMAC ns2__Split {
      public:
        /// Required element 'ns2:from' of XSD type 'ns2:ObjectId'
        ns2__ObjectId *from;
        /// Required element 'ns2:to' of XSD type 'ns2:ObjectId'
        std::vector<ns2__ObjectId *> to;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Split
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Split; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Split, default initialized and not managed by a soap context
        virtual ns2__Split *soap_alloc(void) const { return SOAP_NEW(ns2__Split); }
      public:
        /// Constructor with initializations
        ns2__Split()
        {
          from = (ns2__ObjectId *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Split() { }
        /// Friend allocator used by soap_new_ns2__Split(struct soap*, int)
        friend SOAP_FMAC1 ns2__Split * SOAP_FMAC2 soap_instantiate_ns2__Split(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1885 */
#ifndef SOAP_TYPE_ns2__Rename
#define SOAP_TYPE_ns2__Rename (779)
/* complex XSD type 'ns2:Rename': */
class SOAP_CMAC ns2__Rename {
      public:
        /// Required element 'ns2:from' of XSD type 'ns2:ObjectId'
        ns2__ObjectId *from;
        /// Required element 'ns2:to' of XSD type 'ns2:ObjectId'
        ns2__ObjectId *to;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Rename
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Rename; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Rename, default initialized and not managed by a soap context
        virtual ns2__Rename *soap_alloc(void) const { return SOAP_NEW(ns2__Rename); }
      public:
        /// Constructor with initializations
        ns2__Rename()
        {
          from = (ns2__ObjectId *)0;
          to = (ns2__ObjectId *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Rename() { }
        /// Friend allocator used by soap_new_ns2__Rename(struct soap*, int)
        friend SOAP_FMAC1 ns2__Rename * SOAP_FMAC2 soap_instantiate_ns2__Rename(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1888 */
#ifndef SOAP_TYPE_ns2__ObjectId
#define SOAP_TYPE_ns2__ObjectId (780)
/* Type ns2__ObjectId is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:ObjectId': */
class SOAP_CMAC ns2__ObjectId {
      public:
        /// optional attribute 'ObjectId' of XSD type 'xsd:integer'
        std::string *ObjectId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ObjectId
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ObjectId; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ObjectId, default initialized and not managed by a soap context
        virtual ns2__ObjectId *soap_alloc(void) const { return SOAP_NEW(ns2__ObjectId); }
      public:
        /// Constructor with initializations
        ns2__ObjectId()
        {
          ObjectId = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ObjectId() { }
        /// Friend allocator used by soap_new_ns2__ObjectId(struct soap*, int)
        friend SOAP_FMAC1 ns2__ObjectId * SOAP_FMAC2 soap_instantiate_ns2__ObjectId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:20968 */
#ifndef SOAP_TYPE__ns2__Behaviour_Removed
#define SOAP_TYPE__ns2__Behaviour_Removed (1893)
/* complex XSD type 'ns2:Behaviour-Removed': */
class SOAP_CMAC _ns2__Behaviour_Removed {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
      public:
        /// Return unique type id SOAP_TYPE__ns2__Behaviour_Removed
        virtual int soap_type(void) const { return SOAP_TYPE__ns2__Behaviour_Removed; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__Behaviour_Removed, default initialized and not managed by a soap context
        virtual _ns2__Behaviour_Removed *soap_alloc(void) const { return SOAP_NEW(_ns2__Behaviour_Removed); }
      public:
        /// Constructor with initializations
        _ns2__Behaviour_Removed()
        {
        }
        virtual ~_ns2__Behaviour_Removed() { }
        /// Friend allocator used by soap_new__ns2__Behaviour_Removed(struct soap*, int)
        friend SOAP_FMAC1 _ns2__Behaviour_Removed * SOAP_FMAC2 soap_instantiate__ns2__Behaviour_Removed(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:20989 */
#ifndef SOAP_TYPE__ns2__Behaviour_Idle
#define SOAP_TYPE__ns2__Behaviour_Idle (1895)
/* complex XSD type 'ns2:Behaviour-Idle': */
class SOAP_CMAC _ns2__Behaviour_Idle {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
      public:
        /// Return unique type id SOAP_TYPE__ns2__Behaviour_Idle
        virtual int soap_type(void) const { return SOAP_TYPE__ns2__Behaviour_Idle; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__Behaviour_Idle, default initialized and not managed by a soap context
        virtual _ns2__Behaviour_Idle *soap_alloc(void) const { return SOAP_NEW(_ns2__Behaviour_Idle); }
      public:
        /// Constructor with initializations
        _ns2__Behaviour_Idle()
        {
        }
        virtual ~_ns2__Behaviour_Idle() { }
        /// Friend allocator used by soap_new__ns2__Behaviour_Idle(struct soap*, int)
        friend SOAP_FMAC1 _ns2__Behaviour_Idle * SOAP_FMAC2 soap_instantiate__ns2__Behaviour_Idle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1891 */
#ifndef SOAP_TYPE_ns2__Behaviour
#define SOAP_TYPE_ns2__Behaviour (781)
/* complex XSD type 'ns2:Behaviour': */
class SOAP_CMAC ns2__Behaviour {
      public:
        /// Optional element 'ns2:Removed' of XSD type 'ns2:Behaviour-Removed'
        _ns2__Behaviour_Removed *Removed;
        /// Optional element 'ns2:Idle' of XSD type 'ns2:Behaviour-Idle'
        _ns2__Behaviour_Idle *Idle;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:BehaviourExtension'
        ns2__BehaviourExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Behaviour
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Behaviour; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Behaviour, default initialized and not managed by a soap context
        virtual ns2__Behaviour *soap_alloc(void) const { return SOAP_NEW(ns2__Behaviour); }
      public:
        /// Constructor with initializations
        ns2__Behaviour()
        {
          Removed = (_ns2__Behaviour_Removed *)0;
          Idle = (_ns2__Behaviour_Idle *)0;
          Extension = (ns2__BehaviourExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Behaviour() { }
        /// Friend allocator used by soap_new_ns2__Behaviour(struct soap*, int)
        friend SOAP_FMAC1 ns2__Behaviour * SOAP_FMAC2 soap_instantiate_ns2__Behaviour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1894 */
#ifndef SOAP_TYPE_ns2__BehaviourExtension
#define SOAP_TYPE_ns2__BehaviourExtension (782)
/* complex XSD type 'ns2:BehaviourExtension': */
class SOAP_CMAC ns2__BehaviourExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BehaviourExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__BehaviourExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BehaviourExtension, default initialized and not managed by a soap context
        virtual ns2__BehaviourExtension *soap_alloc(void) const { return SOAP_NEW(ns2__BehaviourExtension); }
      public:
        /// Constructor with initializations
        ns2__BehaviourExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__BehaviourExtension() { }
        /// Friend allocator used by soap_new_ns2__BehaviourExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__BehaviourExtension * SOAP_FMAC2 soap_instantiate_ns2__BehaviourExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1897 */
#ifndef SOAP_TYPE_ns2__ObjectTree
#define SOAP_TYPE_ns2__ObjectTree (783)
/* complex XSD type 'ns2:ObjectTree': */
class SOAP_CMAC ns2__ObjectTree {
      public:
        /// Optional element 'ns2:Rename' of XSD type 'ns2:Rename'
        std::vector<ns2__Rename *> Rename;
        /// Optional element 'ns2:Split' of XSD type 'ns2:Split'
        std::vector<ns2__Split *> Split;
        /// Optional element 'ns2:Merge' of XSD type 'ns2:Merge'
        std::vector<ns2__Merge *> Merge;
        /// Optional element 'ns2:Delete' of XSD type 'ns2:ObjectId'
        std::vector<ns2__ObjectId *> Delete;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ObjectTreeExtension'
        ns2__ObjectTreeExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ObjectTree
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ObjectTree; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ObjectTree, default initialized and not managed by a soap context
        virtual ns2__ObjectTree *soap_alloc(void) const { return SOAP_NEW(ns2__ObjectTree); }
      public:
        /// Constructor with initializations
        ns2__ObjectTree()
        {
          Extension = (ns2__ObjectTreeExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ObjectTree() { }
        /// Friend allocator used by soap_new_ns2__ObjectTree(struct soap*, int)
        friend SOAP_FMAC1 ns2__ObjectTree * SOAP_FMAC2 soap_instantiate_ns2__ObjectTree(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1900 */
#ifndef SOAP_TYPE_ns2__ObjectTreeExtension
#define SOAP_TYPE_ns2__ObjectTreeExtension (784)
/* complex XSD type 'ns2:ObjectTreeExtension': */
class SOAP_CMAC ns2__ObjectTreeExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ObjectTreeExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ObjectTreeExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ObjectTreeExtension, default initialized and not managed by a soap context
        virtual ns2__ObjectTreeExtension *soap_alloc(void) const { return SOAP_NEW(ns2__ObjectTreeExtension); }
      public:
        /// Constructor with initializations
        ns2__ObjectTreeExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ObjectTreeExtension() { }
        /// Friend allocator used by soap_new_ns2__ObjectTreeExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__ObjectTreeExtension * SOAP_FMAC2 soap_instantiate_ns2__ObjectTreeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1903 */
#ifndef SOAP_TYPE_ns2__MotionInCells
#define SOAP_TYPE_ns2__MotionInCells (785)
/* complex XSD type 'ns2:MotionInCells': */
class SOAP_CMAC ns2__MotionInCells {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// required attribute 'Columns' of XSD type 'xsd:integer'
        std::string Columns;
        /// required attribute 'Rows' of XSD type 'xsd:integer'
        std::string Rows;
        /// required attribute 'Cells' of XSD type 'xsd:base64Binary'
        xsd__base64Binary Cells;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MotionInCells
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MotionInCells; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MotionInCells, default initialized and not managed by a soap context
        virtual ns2__MotionInCells *soap_alloc(void) const { return SOAP_NEW(ns2__MotionInCells); }
      public:
        /// Constructor with initializations
        ns2__MotionInCells()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__MotionInCells() { }
        /// Friend allocator used by soap_new_ns2__MotionInCells(struct soap*, int)
        friend SOAP_FMAC1 ns2__MotionInCells * SOAP_FMAC2 soap_instantiate_ns2__MotionInCells(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1906 */
#ifndef SOAP_TYPE_ns2__AnalyticsEngineConfiguration
#define SOAP_TYPE_ns2__AnalyticsEngineConfiguration (786)
/* complex XSD type 'ns2:AnalyticsEngineConfiguration': */
class SOAP_CMAC ns2__AnalyticsEngineConfiguration {
      public:
        /// Optional element 'ns2:AnalyticsModule' of XSD type 'ns2:Config'
        std::vector<ns2__Config *> AnalyticsModule;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:AnalyticsEngineConfigurationExtension'
        ns2__AnalyticsEngineConfigurationExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AnalyticsEngineConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AnalyticsEngineConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AnalyticsEngineConfiguration, default initialized and not managed by a soap context
        virtual ns2__AnalyticsEngineConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__AnalyticsEngineConfiguration); }
      public:
        /// Constructor with initializations
        ns2__AnalyticsEngineConfiguration()
        {
          Extension = (ns2__AnalyticsEngineConfigurationExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AnalyticsEngineConfiguration() { }
        /// Friend allocator used by soap_new_ns2__AnalyticsEngineConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__AnalyticsEngineConfiguration * SOAP_FMAC2 soap_instantiate_ns2__AnalyticsEngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1909 */
#ifndef SOAP_TYPE_ns2__AnalyticsEngineConfigurationExtension
#define SOAP_TYPE_ns2__AnalyticsEngineConfigurationExtension (787)
/* complex XSD type 'ns2:AnalyticsEngineConfigurationExtension': */
class SOAP_CMAC ns2__AnalyticsEngineConfigurationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AnalyticsEngineConfigurationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AnalyticsEngineConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AnalyticsEngineConfigurationExtension, default initialized and not managed by a soap context
        virtual ns2__AnalyticsEngineConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__AnalyticsEngineConfigurationExtension); }
      public:
        /// Constructor with initializations
        ns2__AnalyticsEngineConfigurationExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__AnalyticsEngineConfigurationExtension() { }
        /// Friend allocator used by soap_new_ns2__AnalyticsEngineConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__AnalyticsEngineConfigurationExtension * SOAP_FMAC2 soap_instantiate_ns2__AnalyticsEngineConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1912 */
#ifndef SOAP_TYPE_ns2__RuleEngineConfiguration
#define SOAP_TYPE_ns2__RuleEngineConfiguration (788)
/* complex XSD type 'ns2:RuleEngineConfiguration': */
class SOAP_CMAC ns2__RuleEngineConfiguration {
      public:
        /// Optional element 'ns2:Rule' of XSD type 'ns2:Config'
        std::vector<ns2__Config *> Rule;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:RuleEngineConfigurationExtension'
        ns2__RuleEngineConfigurationExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RuleEngineConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RuleEngineConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RuleEngineConfiguration, default initialized and not managed by a soap context
        virtual ns2__RuleEngineConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__RuleEngineConfiguration); }
      public:
        /// Constructor with initializations
        ns2__RuleEngineConfiguration()
        {
          Extension = (ns2__RuleEngineConfigurationExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__RuleEngineConfiguration() { }
        /// Friend allocator used by soap_new_ns2__RuleEngineConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__RuleEngineConfiguration * SOAP_FMAC2 soap_instantiate_ns2__RuleEngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1915 */
#ifndef SOAP_TYPE_ns2__RuleEngineConfigurationExtension
#define SOAP_TYPE_ns2__RuleEngineConfigurationExtension (789)
/* complex XSD type 'ns2:RuleEngineConfigurationExtension': */
class SOAP_CMAC ns2__RuleEngineConfigurationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RuleEngineConfigurationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RuleEngineConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RuleEngineConfigurationExtension, default initialized and not managed by a soap context
        virtual ns2__RuleEngineConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__RuleEngineConfigurationExtension); }
      public:
        /// Constructor with initializations
        ns2__RuleEngineConfigurationExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__RuleEngineConfigurationExtension() { }
        /// Friend allocator used by soap_new_ns2__RuleEngineConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__RuleEngineConfigurationExtension * SOAP_FMAC2 soap_instantiate_ns2__RuleEngineConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1918 */
#ifndef SOAP_TYPE_ns2__Config
#define SOAP_TYPE_ns2__Config (790)
/* complex XSD type 'ns2:Config': */
class SOAP_CMAC ns2__Config {
      public:
        /// Required element 'ns2:Parameters' of XSD type 'ns2:ItemList'
        ns2__ItemList *Parameters;
        /// required attribute 'Name' of XSD type 'xsd:string'
        std::string Name;
        /// required attribute 'Type' of XSD type 'xsd:QName'
        std::string Type;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Config
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Config; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Config, default initialized and not managed by a soap context
        virtual ns2__Config *soap_alloc(void) const { return SOAP_NEW(ns2__Config); }
      public:
        /// Constructor with initializations
        ns2__Config()
        {
          Parameters = (ns2__ItemList *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Config() { }
        /// Friend allocator used by soap_new_ns2__Config(struct soap*, int)
        friend SOAP_FMAC1 ns2__Config * SOAP_FMAC2 soap_instantiate_ns2__Config(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:21325 */
#ifndef SOAP_TYPE__ns2__ConfigDescription_Messages
#define SOAP_TYPE__ns2__ConfigDescription_Messages (1910)
/* complex XSD type 'ns2:ConfigDescription-Messages': */
class SOAP_CMAC _ns2__ConfigDescription_Messages {
      public:
        /// Optional element 'ns2:Source' of XSD type 'ns2:ItemListDescription'
        ns2__ItemListDescription *Source;
        /// Optional element 'ns2:Key' of XSD type 'ns2:ItemListDescription'
        ns2__ItemListDescription *Key;
        /// Optional element 'ns2:Data' of XSD type 'ns2:ItemListDescription'
        ns2__ItemListDescription *Data;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:MessageDescriptionExtension'
        ns2__MessageDescriptionExtension *Extension;
        /// optional attribute 'IsProperty' of XSD type 'xsd:boolean'
        bool *IsProperty;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Required element 'ns2:ParentTopic' of XSD type 'xsd:string'
        std::string ParentTopic;
      public:
        /// Return unique type id SOAP_TYPE__ns2__ConfigDescription_Messages
        virtual int soap_type(void) const { return SOAP_TYPE__ns2__ConfigDescription_Messages; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__ConfigDescription_Messages, default initialized and not managed by a soap context
        virtual _ns2__ConfigDescription_Messages *soap_alloc(void) const { return SOAP_NEW(_ns2__ConfigDescription_Messages); }
      public:
        /// Constructor with initializations
        _ns2__ConfigDescription_Messages()
        {
          Source = (ns2__ItemListDescription *)0;
          Key = (ns2__ItemListDescription *)0;
          Data = (ns2__ItemListDescription *)0;
          Extension = (ns2__MessageDescriptionExtension *)0;
          IsProperty = (bool *)0;
        }
        virtual ~_ns2__ConfigDescription_Messages() { }
        /// Friend allocator used by soap_new__ns2__ConfigDescription_Messages(struct soap*, int)
        friend SOAP_FMAC1 _ns2__ConfigDescription_Messages * SOAP_FMAC2 soap_instantiate__ns2__ConfigDescription_Messages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1921 */
#ifndef SOAP_TYPE_ns2__ConfigDescription
#define SOAP_TYPE_ns2__ConfigDescription (791)
/* complex XSD type 'ns2:ConfigDescription': */
class SOAP_CMAC ns2__ConfigDescription {
      public:
        /// Required element 'ns2:Parameters' of XSD type 'ns2:ItemListDescription'
        ns2__ItemListDescription *Parameters;
        /// Optional element 'ns2:Messages' of XSD type 'ns2:ConfigDescription-Messages'
        std::vector<_ns2__ConfigDescription_Messages> *Messages;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ConfigDescriptionExtension'
        ns2__ConfigDescriptionExtension *Extension;
        /// required attribute 'Name' of XSD type 'xsd:QName'
        std::string Name;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ConfigDescription
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ConfigDescription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ConfigDescription, default initialized and not managed by a soap context
        virtual ns2__ConfigDescription *soap_alloc(void) const { return SOAP_NEW(ns2__ConfigDescription); }
      public:
        /// Constructor with initializations
        ns2__ConfigDescription()
        {
          Parameters = (ns2__ItemListDescription *)0;
          Messages = (std::vector<_ns2__ConfigDescription_Messages> *)0;
          Extension = (ns2__ConfigDescriptionExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ConfigDescription() { }
        /// Friend allocator used by soap_new_ns2__ConfigDescription(struct soap*, int)
        friend SOAP_FMAC1 ns2__ConfigDescription * SOAP_FMAC2 soap_instantiate_ns2__ConfigDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1924 */
#ifndef SOAP_TYPE_ns2__ConfigDescriptionExtension
#define SOAP_TYPE_ns2__ConfigDescriptionExtension (792)
/* complex XSD type 'ns2:ConfigDescriptionExtension': */
class SOAP_CMAC ns2__ConfigDescriptionExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ConfigDescriptionExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ConfigDescriptionExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ConfigDescriptionExtension, default initialized and not managed by a soap context
        virtual ns2__ConfigDescriptionExtension *soap_alloc(void) const { return SOAP_NEW(ns2__ConfigDescriptionExtension); }
      public:
        /// Constructor with initializations
        ns2__ConfigDescriptionExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ConfigDescriptionExtension() { }
        /// Friend allocator used by soap_new_ns2__ConfigDescriptionExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__ConfigDescriptionExtension * SOAP_FMAC2 soap_instantiate_ns2__ConfigDescriptionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1927 */
#ifndef SOAP_TYPE_ns2__SupportedRules
#define SOAP_TYPE_ns2__SupportedRules (793)
/* complex XSD type 'ns2:SupportedRules': */
class SOAP_CMAC ns2__SupportedRules {
      public:
        /// Optional element 'ns2:RuleContentSchemaLocation' of XSD type 'xsd:anyURI'
        std::vector<std::string> RuleContentSchemaLocation;
        /// Optional element 'ns2:RuleDescription' of XSD type 'ns2:ConfigDescription'
        std::vector<ns2__ConfigDescription *> RuleDescription;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:SupportedRulesExtension'
        ns2__SupportedRulesExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SupportedRules
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SupportedRules; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SupportedRules, default initialized and not managed by a soap context
        virtual ns2__SupportedRules *soap_alloc(void) const { return SOAP_NEW(ns2__SupportedRules); }
      public:
        /// Constructor with initializations
        ns2__SupportedRules()
        {
          Extension = (ns2__SupportedRulesExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__SupportedRules() { }
        /// Friend allocator used by soap_new_ns2__SupportedRules(struct soap*, int)
        friend SOAP_FMAC1 ns2__SupportedRules * SOAP_FMAC2 soap_instantiate_ns2__SupportedRules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1930 */
#ifndef SOAP_TYPE_ns2__SupportedRulesExtension
#define SOAP_TYPE_ns2__SupportedRulesExtension (794)
/* complex XSD type 'ns2:SupportedRulesExtension': */
class SOAP_CMAC ns2__SupportedRulesExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SupportedRulesExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SupportedRulesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SupportedRulesExtension, default initialized and not managed by a soap context
        virtual ns2__SupportedRulesExtension *soap_alloc(void) const { return SOAP_NEW(ns2__SupportedRulesExtension); }
      public:
        /// Constructor with initializations
        ns2__SupportedRulesExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__SupportedRulesExtension() { }
        /// Friend allocator used by soap_new_ns2__SupportedRulesExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__SupportedRulesExtension * SOAP_FMAC2 soap_instantiate_ns2__SupportedRulesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1933 */
#ifndef SOAP_TYPE_ns2__SupportedAnalyticsModules
#define SOAP_TYPE_ns2__SupportedAnalyticsModules (795)
/* complex XSD type 'ns2:SupportedAnalyticsModules': */
class SOAP_CMAC ns2__SupportedAnalyticsModules {
      public:
        /// Optional element 'ns2:AnalyticsModuleContentSchemaLocation' of XSD type 'xsd:anyURI'
        std::vector<std::string> AnalyticsModuleContentSchemaLocation;
        /// Optional element 'ns2:AnalyticsModuleDescription' of XSD type 'ns2:ConfigDescription'
        std::vector<ns2__ConfigDescription *> AnalyticsModuleDescription;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:SupportedAnalyticsModulesExtension'
        ns2__SupportedAnalyticsModulesExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SupportedAnalyticsModules
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SupportedAnalyticsModules; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SupportedAnalyticsModules, default initialized and not managed by a soap context
        virtual ns2__SupportedAnalyticsModules *soap_alloc(void) const { return SOAP_NEW(ns2__SupportedAnalyticsModules); }
      public:
        /// Constructor with initializations
        ns2__SupportedAnalyticsModules()
        {
          Extension = (ns2__SupportedAnalyticsModulesExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__SupportedAnalyticsModules() { }
        /// Friend allocator used by soap_new_ns2__SupportedAnalyticsModules(struct soap*, int)
        friend SOAP_FMAC1 ns2__SupportedAnalyticsModules * SOAP_FMAC2 soap_instantiate_ns2__SupportedAnalyticsModules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1936 */
#ifndef SOAP_TYPE_ns2__SupportedAnalyticsModulesExtension
#define SOAP_TYPE_ns2__SupportedAnalyticsModulesExtension (796)
/* complex XSD type 'ns2:SupportedAnalyticsModulesExtension': */
class SOAP_CMAC ns2__SupportedAnalyticsModulesExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SupportedAnalyticsModulesExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SupportedAnalyticsModulesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SupportedAnalyticsModulesExtension, default initialized and not managed by a soap context
        virtual ns2__SupportedAnalyticsModulesExtension *soap_alloc(void) const { return SOAP_NEW(ns2__SupportedAnalyticsModulesExtension); }
      public:
        /// Constructor with initializations
        ns2__SupportedAnalyticsModulesExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__SupportedAnalyticsModulesExtension() { }
        /// Friend allocator used by soap_new_ns2__SupportedAnalyticsModulesExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__SupportedAnalyticsModulesExtension * SOAP_FMAC2 soap_instantiate_ns2__SupportedAnalyticsModulesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1939 */
#ifndef SOAP_TYPE_ns2__PolygonConfiguration
#define SOAP_TYPE_ns2__PolygonConfiguration (797)
/* complex XSD type 'ns2:PolygonConfiguration': */
class SOAP_CMAC ns2__PolygonConfiguration {
      public:
        /// Required element 'ns2:Polygon' of XSD type 'ns2:Polygon'
        ns2__Polygon *Polygon;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PolygonConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PolygonConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PolygonConfiguration, default initialized and not managed by a soap context
        virtual ns2__PolygonConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__PolygonConfiguration); }
      public:
        /// Constructor with initializations
        ns2__PolygonConfiguration()
        {
          Polygon = (ns2__Polygon *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PolygonConfiguration() { }
        /// Friend allocator used by soap_new_ns2__PolygonConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__PolygonConfiguration * SOAP_FMAC2 soap_instantiate_ns2__PolygonConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1942 */
#ifndef SOAP_TYPE_ns2__PolylineArray
#define SOAP_TYPE_ns2__PolylineArray (798)
/* complex XSD type 'ns2:PolylineArray': */
class SOAP_CMAC ns2__PolylineArray {
      public:
        /// Required element 'ns2:Segment' of XSD type 'ns2:Polyline'
        std::vector<ns2__Polyline *> Segment;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:PolylineArrayExtension'
        ns2__PolylineArrayExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PolylineArray
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PolylineArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PolylineArray, default initialized and not managed by a soap context
        virtual ns2__PolylineArray *soap_alloc(void) const { return SOAP_NEW(ns2__PolylineArray); }
      public:
        /// Constructor with initializations
        ns2__PolylineArray()
        {
          Extension = (ns2__PolylineArrayExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PolylineArray() { }
        /// Friend allocator used by soap_new_ns2__PolylineArray(struct soap*, int)
        friend SOAP_FMAC1 ns2__PolylineArray * SOAP_FMAC2 soap_instantiate_ns2__PolylineArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1945 */
#ifndef SOAP_TYPE_ns2__PolylineArrayExtension
#define SOAP_TYPE_ns2__PolylineArrayExtension (799)
/* complex XSD type 'ns2:PolylineArrayExtension': */
class SOAP_CMAC ns2__PolylineArrayExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PolylineArrayExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PolylineArrayExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PolylineArrayExtension, default initialized and not managed by a soap context
        virtual ns2__PolylineArrayExtension *soap_alloc(void) const { return SOAP_NEW(ns2__PolylineArrayExtension); }
      public:
        /// Constructor with initializations
        ns2__PolylineArrayExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PolylineArrayExtension() { }
        /// Friend allocator used by soap_new_ns2__PolylineArrayExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__PolylineArrayExtension * SOAP_FMAC2 soap_instantiate_ns2__PolylineArrayExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1948 */
#ifndef SOAP_TYPE_ns2__PolylineArrayConfiguration
#define SOAP_TYPE_ns2__PolylineArrayConfiguration (800)
/* complex XSD type 'ns2:PolylineArrayConfiguration': */
class SOAP_CMAC ns2__PolylineArrayConfiguration {
      public:
        /// Required element 'ns2:PolylineArray' of XSD type 'ns2:PolylineArray'
        ns2__PolylineArray *PolylineArray;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PolylineArrayConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PolylineArrayConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PolylineArrayConfiguration, default initialized and not managed by a soap context
        virtual ns2__PolylineArrayConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__PolylineArrayConfiguration); }
      public:
        /// Constructor with initializations
        ns2__PolylineArrayConfiguration()
        {
          PolylineArray = (ns2__PolylineArray *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PolylineArrayConfiguration() { }
        /// Friend allocator used by soap_new_ns2__PolylineArrayConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__PolylineArrayConfiguration * SOAP_FMAC2 soap_instantiate_ns2__PolylineArrayConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1951 */
#ifndef SOAP_TYPE_ns2__MotionExpression
#define SOAP_TYPE_ns2__MotionExpression (801)
/* complex XSD type 'ns2:MotionExpression': */
class SOAP_CMAC ns2__MotionExpression {
      public:
        /// Required element 'ns2:Expression' of XSD type 'xsd:string'
        std::string Expression;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// optional attribute 'Type' of XSD type 'xsd:string'
        std::string *Type;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MotionExpression
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MotionExpression; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MotionExpression, default initialized and not managed by a soap context
        virtual ns2__MotionExpression *soap_alloc(void) const { return SOAP_NEW(ns2__MotionExpression); }
      public:
        /// Constructor with initializations
        ns2__MotionExpression()
        {
          Type = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__MotionExpression() { }
        /// Friend allocator used by soap_new_ns2__MotionExpression(struct soap*, int)
        friend SOAP_FMAC1 ns2__MotionExpression * SOAP_FMAC2 soap_instantiate_ns2__MotionExpression(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1954 */
#ifndef SOAP_TYPE_ns2__MotionExpressionConfiguration
#define SOAP_TYPE_ns2__MotionExpressionConfiguration (802)
/* complex XSD type 'ns2:MotionExpressionConfiguration': */
class SOAP_CMAC ns2__MotionExpressionConfiguration {
      public:
        /// Required element 'ns2:MotionExpression' of XSD type 'ns2:MotionExpression'
        ns2__MotionExpression *MotionExpression;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MotionExpressionConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MotionExpressionConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MotionExpressionConfiguration, default initialized and not managed by a soap context
        virtual ns2__MotionExpressionConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__MotionExpressionConfiguration); }
      public:
        /// Constructor with initializations
        ns2__MotionExpressionConfiguration()
        {
          MotionExpression = (ns2__MotionExpression *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__MotionExpressionConfiguration() { }
        /// Friend allocator used by soap_new_ns2__MotionExpressionConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__MotionExpressionConfiguration * SOAP_FMAC2 soap_instantiate_ns2__MotionExpressionConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1957 */
#ifndef SOAP_TYPE_ns2__CellLayout
#define SOAP_TYPE_ns2__CellLayout (803)
/* complex XSD type 'ns2:CellLayout': */
class SOAP_CMAC ns2__CellLayout {
      public:
        /// Required element 'ns2:Transformation' of XSD type 'ns2:Transformation'
        ns2__Transformation *Transformation;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// required attribute 'Columns' of XSD type 'xsd:integer'
        std::string Columns;
        /// required attribute 'Rows' of XSD type 'xsd:integer'
        std::string Rows;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CellLayout
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CellLayout; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CellLayout, default initialized and not managed by a soap context
        virtual ns2__CellLayout *soap_alloc(void) const { return SOAP_NEW(ns2__CellLayout); }
      public:
        /// Constructor with initializations
        ns2__CellLayout()
        {
          Transformation = (ns2__Transformation *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CellLayout() { }
        /// Friend allocator used by soap_new_ns2__CellLayout(struct soap*, int)
        friend SOAP_FMAC1 ns2__CellLayout * SOAP_FMAC2 soap_instantiate_ns2__CellLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:21820 */
#ifndef SOAP_TYPE__ns2__union_MetadataStream
#define SOAP_TYPE__ns2__union_MetadataStream (1928)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns2__union_MetadataStream
{
        #define SOAP_UNION__ns2__union_MetadataStream_VideoAnalytics	(1)	/**< union variant selector value for member VideoAnalytics */
        ns2__VideoAnalyticsStream *VideoAnalytics;
        #define SOAP_UNION__ns2__union_MetadataStream_PTZ	(2)	/**< union variant selector value for member PTZ */
        ns2__PTZStream *PTZ;
        #define SOAP_UNION__ns2__union_MetadataStream_Event	(3)	/**< union variant selector value for member Event */
        ns2__EventStream *Event;
        #define SOAP_UNION__ns2__union_MetadataStream_Extension	(4)	/**< union variant selector value for member Extension */
        ns2__MetadataStreamExtension *Extension;
};
#endif

/* onvifgen/onvif.h:21807 */
#ifndef SOAP_TYPE___ns2__union_MetadataStream
#define SOAP_TYPE___ns2__union_MetadataStream (1923)
/* Wrapper: */
class SOAP_CMAC __ns2__union_MetadataStream {
      public:
        /// Union with union _ns2__union_MetadataStream variant selector __union_MetadataStream set to one of: SOAP_UNION__ns2__union_MetadataStream_VideoAnalytics SOAP_UNION__ns2__union_MetadataStream_PTZ SOAP_UNION__ns2__union_MetadataStream_Event SOAP_UNION__ns2__union_MetadataStream_Extension
        int __union_MetadataStream;
        union _ns2__union_MetadataStream union_MetadataStream;
      public:
        /// Return unique type id SOAP_TYPE___ns2__union_MetadataStream
        virtual int soap_type(void) const { return SOAP_TYPE___ns2__union_MetadataStream; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __ns2__union_MetadataStream, default initialized and not managed by a soap context
        virtual __ns2__union_MetadataStream *soap_alloc(void) const { return SOAP_NEW(__ns2__union_MetadataStream); }
      public:
        /// Constructor with initializations
        __ns2__union_MetadataStream()
        {
          __union_MetadataStream = -1;
        }
        virtual ~__ns2__union_MetadataStream() { }
        /// Friend allocator used by soap_new___ns2__union_MetadataStream(struct soap*, int)
        friend SOAP_FMAC1 __ns2__union_MetadataStream * SOAP_FMAC2 soap_instantiate___ns2__union_MetadataStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1960 */
#ifndef SOAP_TYPE_ns2__MetadataStream
#define SOAP_TYPE_ns2__MetadataStream (804)
/* complex XSD type 'ns2:MetadataStream': */
class SOAP_CMAC ns2__MetadataStream {
      public:
        /// Sequence of elements '-union-MetadataStream' of XSD type '-ns2:union-MetadataStream' stored in dynamic array __union_MetadataStream of length __size_MetadataStream
        int __size_MetadataStream;
        __ns2__union_MetadataStream *__union_MetadataStream;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MetadataStream
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MetadataStream; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MetadataStream, default initialized and not managed by a soap context
        virtual ns2__MetadataStream *soap_alloc(void) const { return SOAP_NEW(ns2__MetadataStream); }
      public:
        /// Constructor with initializations
        ns2__MetadataStream()
        {
          __size_MetadataStream = 0;
          __union_MetadataStream = NULL;
          soap = (struct soap *)0;
        }
        virtual ~ns2__MetadataStream() { }
        /// Friend allocator used by soap_new_ns2__MetadataStream(struct soap*, int)
        friend SOAP_FMAC1 ns2__MetadataStream * SOAP_FMAC2 soap_instantiate_ns2__MetadataStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1963 */
#ifndef SOAP_TYPE_ns2__MetadataStreamExtension
#define SOAP_TYPE_ns2__MetadataStreamExtension (805)
/* complex XSD type 'ns2:MetadataStreamExtension': */
class SOAP_CMAC ns2__MetadataStreamExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional element 'ns2:AudioAnalyticsStream' of XSD type 'ns2:AudioAnalyticsStream'
        ns2__AudioAnalyticsStream *AudioAnalyticsStream;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:MetadataStreamExtension2'
        ns2__MetadataStreamExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MetadataStreamExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MetadataStreamExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MetadataStreamExtension, default initialized and not managed by a soap context
        virtual ns2__MetadataStreamExtension *soap_alloc(void) const { return SOAP_NEW(ns2__MetadataStreamExtension); }
      public:
        /// Constructor with initializations
        ns2__MetadataStreamExtension()
        {
          AudioAnalyticsStream = (ns2__AudioAnalyticsStream *)0;
          Extension = (ns2__MetadataStreamExtension2 *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__MetadataStreamExtension() { }
        /// Friend allocator used by soap_new_ns2__MetadataStreamExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__MetadataStreamExtension * SOAP_FMAC2 soap_instantiate_ns2__MetadataStreamExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1966 */
#ifndef SOAP_TYPE_ns2__MetadataStreamExtension2
#define SOAP_TYPE_ns2__MetadataStreamExtension2 (806)
/* complex XSD type 'ns2:MetadataStreamExtension2': */
class SOAP_CMAC ns2__MetadataStreamExtension2 {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MetadataStreamExtension2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MetadataStreamExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MetadataStreamExtension2, default initialized and not managed by a soap context
        virtual ns2__MetadataStreamExtension2 *soap_alloc(void) const { return SOAP_NEW(ns2__MetadataStreamExtension2); }
      public:
        /// Constructor with initializations
        ns2__MetadataStreamExtension2()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__MetadataStreamExtension2() { }
        /// Friend allocator used by soap_new_ns2__MetadataStreamExtension2(struct soap*, int)
        friend SOAP_FMAC1 ns2__MetadataStreamExtension2 * SOAP_FMAC2 soap_instantiate_ns2__MetadataStreamExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1969 */
#ifndef SOAP_TYPE_ns2__AudioAnalyticsStream
#define SOAP_TYPE_ns2__AudioAnalyticsStream (807)
/* complex XSD type 'ns2:AudioAnalyticsStream': */
class SOAP_CMAC ns2__AudioAnalyticsStream {
      public:
        /// Optional element 'ns2:AudioDescriptor' of XSD type 'ns2:AudioDescriptor'
        std::vector<ns2__AudioDescriptor *> AudioDescriptor;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:AudioAnalyticsStreamExtension'
        ns2__AudioAnalyticsStreamExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AudioAnalyticsStream
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AudioAnalyticsStream; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AudioAnalyticsStream, default initialized and not managed by a soap context
        virtual ns2__AudioAnalyticsStream *soap_alloc(void) const { return SOAP_NEW(ns2__AudioAnalyticsStream); }
      public:
        /// Constructor with initializations
        ns2__AudioAnalyticsStream()
        {
          Extension = (ns2__AudioAnalyticsStreamExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AudioAnalyticsStream() { }
        /// Friend allocator used by soap_new_ns2__AudioAnalyticsStream(struct soap*, int)
        friend SOAP_FMAC1 ns2__AudioAnalyticsStream * SOAP_FMAC2 soap_instantiate_ns2__AudioAnalyticsStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1972 */
#ifndef SOAP_TYPE_ns2__AudioDescriptor
#define SOAP_TYPE_ns2__AudioDescriptor (808)
/* complex XSD type 'ns2:AudioDescriptor': */
class SOAP_CMAC ns2__AudioDescriptor {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// required attribute 'UtcTime' of XSD type 'xsd:dateTime'
        time_t UtcTime;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AudioDescriptor
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AudioDescriptor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AudioDescriptor, default initialized and not managed by a soap context
        virtual ns2__AudioDescriptor *soap_alloc(void) const { return SOAP_NEW(ns2__AudioDescriptor); }
      public:
        /// Constructor with initializations
        ns2__AudioDescriptor()
        {
          UtcTime = (time_t)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AudioDescriptor() { }
        /// Friend allocator used by soap_new_ns2__AudioDescriptor(struct soap*, int)
        friend SOAP_FMAC1 ns2__AudioDescriptor * SOAP_FMAC2 soap_instantiate_ns2__AudioDescriptor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1975 */
#ifndef SOAP_TYPE_ns2__AudioAnalyticsStreamExtension
#define SOAP_TYPE_ns2__AudioAnalyticsStreamExtension (809)
/* complex XSD type 'ns2:AudioAnalyticsStreamExtension': */
class SOAP_CMAC ns2__AudioAnalyticsStreamExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AudioAnalyticsStreamExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AudioAnalyticsStreamExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AudioAnalyticsStreamExtension, default initialized and not managed by a soap context
        virtual ns2__AudioAnalyticsStreamExtension *soap_alloc(void) const { return SOAP_NEW(ns2__AudioAnalyticsStreamExtension); }
      public:
        /// Constructor with initializations
        ns2__AudioAnalyticsStreamExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__AudioAnalyticsStreamExtension() { }
        /// Friend allocator used by soap_new_ns2__AudioAnalyticsStreamExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__AudioAnalyticsStreamExtension * SOAP_FMAC2 soap_instantiate_ns2__AudioAnalyticsStreamExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:22015 */
#ifndef SOAP_TYPE__ns2__union_VideoAnalyticsStream
#define SOAP_TYPE__ns2__union_VideoAnalyticsStream (1938)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns2__union_VideoAnalyticsStream
{
        #define SOAP_UNION__ns2__union_VideoAnalyticsStream_Frame	(1)	/**< union variant selector value for member Frame */
        ns2__Frame *Frame;
        #define SOAP_UNION__ns2__union_VideoAnalyticsStream_Extension	(2)	/**< union variant selector value for member Extension */
        ns2__VideoAnalyticsStreamExtension *Extension;
};
#endif

/* onvifgen/onvif.h:22005 */
#ifndef SOAP_TYPE___ns2__union_VideoAnalyticsStream
#define SOAP_TYPE___ns2__union_VideoAnalyticsStream (1935)
/* Wrapper: */
class SOAP_CMAC __ns2__union_VideoAnalyticsStream {
      public:
        /// Union with union _ns2__union_VideoAnalyticsStream variant selector __union_VideoAnalyticsStream set to one of: SOAP_UNION__ns2__union_VideoAnalyticsStream_Frame SOAP_UNION__ns2__union_VideoAnalyticsStream_Extension
        int __union_VideoAnalyticsStream;
        union _ns2__union_VideoAnalyticsStream union_VideoAnalyticsStream;
      public:
        /// Return unique type id SOAP_TYPE___ns2__union_VideoAnalyticsStream
        virtual int soap_type(void) const { return SOAP_TYPE___ns2__union_VideoAnalyticsStream; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __ns2__union_VideoAnalyticsStream, default initialized and not managed by a soap context
        virtual __ns2__union_VideoAnalyticsStream *soap_alloc(void) const { return SOAP_NEW(__ns2__union_VideoAnalyticsStream); }
      public:
        /// Constructor with initializations
        __ns2__union_VideoAnalyticsStream()
        {
          __union_VideoAnalyticsStream = -1;
        }
        virtual ~__ns2__union_VideoAnalyticsStream() { }
        /// Friend allocator used by soap_new___ns2__union_VideoAnalyticsStream(struct soap*, int)
        friend SOAP_FMAC1 __ns2__union_VideoAnalyticsStream * SOAP_FMAC2 soap_instantiate___ns2__union_VideoAnalyticsStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1978 */
#ifndef SOAP_TYPE_ns2__VideoAnalyticsStream
#define SOAP_TYPE_ns2__VideoAnalyticsStream (810)
/* complex XSD type 'ns2:VideoAnalyticsStream': */
class SOAP_CMAC ns2__VideoAnalyticsStream {
      public:
        /// Sequence of elements '-union-VideoAnalyticsStream' of XSD type '-ns2:union-VideoAnalyticsStream' stored in dynamic array __union_VideoAnalyticsStream of length __size_VideoAnalyticsStream
        int __size_VideoAnalyticsStream;
        __ns2__union_VideoAnalyticsStream *__union_VideoAnalyticsStream;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoAnalyticsStream
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoAnalyticsStream; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoAnalyticsStream, default initialized and not managed by a soap context
        virtual ns2__VideoAnalyticsStream *soap_alloc(void) const { return SOAP_NEW(ns2__VideoAnalyticsStream); }
      public:
        /// Constructor with initializations
        ns2__VideoAnalyticsStream()
        {
          __size_VideoAnalyticsStream = 0;
          __union_VideoAnalyticsStream = NULL;
          soap = (struct soap *)0;
        }
        virtual ~ns2__VideoAnalyticsStream() { }
        /// Friend allocator used by soap_new_ns2__VideoAnalyticsStream(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoAnalyticsStream * SOAP_FMAC2 soap_instantiate_ns2__VideoAnalyticsStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1981 */
#ifndef SOAP_TYPE_ns2__VideoAnalyticsStreamExtension
#define SOAP_TYPE_ns2__VideoAnalyticsStreamExtension (811)
/* complex XSD type 'ns2:VideoAnalyticsStreamExtension': */
class SOAP_CMAC ns2__VideoAnalyticsStreamExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoAnalyticsStreamExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoAnalyticsStreamExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoAnalyticsStreamExtension, default initialized and not managed by a soap context
        virtual ns2__VideoAnalyticsStreamExtension *soap_alloc(void) const { return SOAP_NEW(ns2__VideoAnalyticsStreamExtension); }
      public:
        /// Constructor with initializations
        ns2__VideoAnalyticsStreamExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__VideoAnalyticsStreamExtension() { }
        /// Friend allocator used by soap_new_ns2__VideoAnalyticsStreamExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoAnalyticsStreamExtension * SOAP_FMAC2 soap_instantiate_ns2__VideoAnalyticsStreamExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:22074 */
#ifndef SOAP_TYPE__ns2__union_PTZStream
#define SOAP_TYPE__ns2__union_PTZStream (1942)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns2__union_PTZStream
{
        #define SOAP_UNION__ns2__union_PTZStream_PTZStatus	(1)	/**< union variant selector value for member PTZStatus */
        ns2__PTZStatus *PTZStatus;
        #define SOAP_UNION__ns2__union_PTZStream_Extension	(2)	/**< union variant selector value for member Extension */
        ns2__PTZStreamExtension *Extension;
};
#endif

/* onvifgen/onvif.h:22064 */
#ifndef SOAP_TYPE___ns2__union_PTZStream
#define SOAP_TYPE___ns2__union_PTZStream (1940)
/* Wrapper: */
class SOAP_CMAC __ns2__union_PTZStream {
      public:
        /// Union with union _ns2__union_PTZStream variant selector __union_PTZStream set to one of: SOAP_UNION__ns2__union_PTZStream_PTZStatus SOAP_UNION__ns2__union_PTZStream_Extension
        int __union_PTZStream;
        union _ns2__union_PTZStream union_PTZStream;
      public:
        /// Return unique type id SOAP_TYPE___ns2__union_PTZStream
        virtual int soap_type(void) const { return SOAP_TYPE___ns2__union_PTZStream; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __ns2__union_PTZStream, default initialized and not managed by a soap context
        virtual __ns2__union_PTZStream *soap_alloc(void) const { return SOAP_NEW(__ns2__union_PTZStream); }
      public:
        /// Constructor with initializations
        __ns2__union_PTZStream()
        {
          __union_PTZStream = -1;
        }
        virtual ~__ns2__union_PTZStream() { }
        /// Friend allocator used by soap_new___ns2__union_PTZStream(struct soap*, int)
        friend SOAP_FMAC1 __ns2__union_PTZStream * SOAP_FMAC2 soap_instantiate___ns2__union_PTZStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1984 */
#ifndef SOAP_TYPE_ns2__PTZStream
#define SOAP_TYPE_ns2__PTZStream (812)
/* complex XSD type 'ns2:PTZStream': */
class SOAP_CMAC ns2__PTZStream {
      public:
        /// Sequence of elements '-union-PTZStream' of XSD type '-ns2:union-PTZStream' stored in dynamic array __union_PTZStream of length __size_PTZStream
        int __size_PTZStream;
        __ns2__union_PTZStream *__union_PTZStream;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZStream
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZStream; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZStream, default initialized and not managed by a soap context
        virtual ns2__PTZStream *soap_alloc(void) const { return SOAP_NEW(ns2__PTZStream); }
      public:
        /// Constructor with initializations
        ns2__PTZStream()
        {
          __size_PTZStream = 0;
          __union_PTZStream = NULL;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZStream() { }
        /// Friend allocator used by soap_new_ns2__PTZStream(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZStream * SOAP_FMAC2 soap_instantiate_ns2__PTZStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1987 */
#ifndef SOAP_TYPE_ns2__PTZStreamExtension
#define SOAP_TYPE_ns2__PTZStreamExtension (813)
/* complex XSD type 'ns2:PTZStreamExtension': */
class SOAP_CMAC ns2__PTZStreamExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZStreamExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZStreamExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZStreamExtension, default initialized and not managed by a soap context
        virtual ns2__PTZStreamExtension *soap_alloc(void) const { return SOAP_NEW(ns2__PTZStreamExtension); }
      public:
        /// Constructor with initializations
        ns2__PTZStreamExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZStreamExtension() { }
        /// Friend allocator used by soap_new_ns2__PTZStreamExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZStreamExtension * SOAP_FMAC2 soap_instantiate_ns2__PTZStreamExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:22133 */
#ifndef SOAP_TYPE__ns2__union_EventStream
#define SOAP_TYPE__ns2__union_EventStream (1947)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns2__union_EventStream
{
        #define SOAP_UNION__ns2__union_EventStream_ns3__NotificationMessage	(1)	/**< union variant selector value for member ns3__NotificationMessage */
        ns3__NotificationMessageHolderType *ns3__NotificationMessage;
        #define SOAP_UNION__ns2__union_EventStream_Extension	(2)	/**< union variant selector value for member Extension */
        ns2__EventStreamExtension *Extension;
};
#endif

/* onvifgen/onvif.h:22123 */
#ifndef SOAP_TYPE___ns2__union_EventStream
#define SOAP_TYPE___ns2__union_EventStream (1944)
/* Wrapper: */
class SOAP_CMAC __ns2__union_EventStream {
      public:
        /// Union with union _ns2__union_EventStream variant selector __union_EventStream set to one of: SOAP_UNION__ns2__union_EventStream_ns3__NotificationMessage SOAP_UNION__ns2__union_EventStream_Extension
        int __union_EventStream;
        union _ns2__union_EventStream union_EventStream;
      public:
        /// Return unique type id SOAP_TYPE___ns2__union_EventStream
        virtual int soap_type(void) const { return SOAP_TYPE___ns2__union_EventStream; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __ns2__union_EventStream, default initialized and not managed by a soap context
        virtual __ns2__union_EventStream *soap_alloc(void) const { return SOAP_NEW(__ns2__union_EventStream); }
      public:
        /// Constructor with initializations
        __ns2__union_EventStream()
        {
          __union_EventStream = -1;
        }
        virtual ~__ns2__union_EventStream() { }
        /// Friend allocator used by soap_new___ns2__union_EventStream(struct soap*, int)
        friend SOAP_FMAC1 __ns2__union_EventStream * SOAP_FMAC2 soap_instantiate___ns2__union_EventStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1990 */
#ifndef SOAP_TYPE_ns2__EventStream
#define SOAP_TYPE_ns2__EventStream (814)
/* complex XSD type 'ns2:EventStream': */
class SOAP_CMAC ns2__EventStream {
      public:
        /// Sequence of elements '-union-EventStream' of XSD type '-ns2:union-EventStream' stored in dynamic array __union_EventStream of length __size_EventStream
        int __size_EventStream;
        __ns2__union_EventStream *__union_EventStream;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__EventStream
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__EventStream; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__EventStream, default initialized and not managed by a soap context
        virtual ns2__EventStream *soap_alloc(void) const { return SOAP_NEW(ns2__EventStream); }
      public:
        /// Constructor with initializations
        ns2__EventStream()
        {
          __size_EventStream = 0;
          __union_EventStream = NULL;
          soap = (struct soap *)0;
        }
        virtual ~ns2__EventStream() { }
        /// Friend allocator used by soap_new_ns2__EventStream(struct soap*, int)
        friend SOAP_FMAC1 ns2__EventStream * SOAP_FMAC2 soap_instantiate_ns2__EventStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1993 */
#ifndef SOAP_TYPE_ns2__EventStreamExtension
#define SOAP_TYPE_ns2__EventStreamExtension (815)
/* complex XSD type 'ns2:EventStreamExtension': */
class SOAP_CMAC ns2__EventStreamExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__EventStreamExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__EventStreamExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__EventStreamExtension, default initialized and not managed by a soap context
        virtual ns2__EventStreamExtension *soap_alloc(void) const { return SOAP_NEW(ns2__EventStreamExtension); }
      public:
        /// Constructor with initializations
        ns2__EventStreamExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__EventStreamExtension() { }
        /// Friend allocator used by soap_new_ns2__EventStreamExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__EventStreamExtension * SOAP_FMAC2 soap_instantiate_ns2__EventStreamExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1996 */
#ifndef SOAP_TYPE_ns2__PaneConfiguration
#define SOAP_TYPE_ns2__PaneConfiguration (816)
/* complex XSD type 'ns2:PaneConfiguration': */
class SOAP_CMAC ns2__PaneConfiguration {
      public:
        /// Optional element 'ns2:PaneName' of XSD type 'xsd:string'
        std::string *PaneName;
        /// Optional element 'ns2:AudioOutputToken' of XSD type 'ns2:ReferenceToken'
        std::string *AudioOutputToken;
        /// Optional element 'ns2:AudioSourceToken' of XSD type 'ns2:ReferenceToken'
        std::string *AudioSourceToken;
        /// Optional element 'ns2:AudioEncoderConfiguration' of XSD type 'ns2:AudioEncoderConfiguration'
        ns2__AudioEncoderConfiguration *AudioEncoderConfiguration;
        /// Optional element 'ns2:ReceiverToken' of XSD type 'ns2:ReferenceToken'
        std::string *ReceiverToken;
        /// Required element 'ns2:Token' of XSD type 'ns2:ReferenceToken'
        std::string Token;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaneConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PaneConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaneConfiguration, default initialized and not managed by a soap context
        virtual ns2__PaneConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__PaneConfiguration); }
      public:
        /// Constructor with initializations
        ns2__PaneConfiguration()
        {
          PaneName = (std::string *)0;
          AudioOutputToken = (std::string *)0;
          AudioSourceToken = (std::string *)0;
          AudioEncoderConfiguration = (ns2__AudioEncoderConfiguration *)0;
          ReceiverToken = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PaneConfiguration() { }
        /// Friend allocator used by soap_new_ns2__PaneConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaneConfiguration * SOAP_FMAC2 soap_instantiate_ns2__PaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1999 */
#ifndef SOAP_TYPE_ns2__PaneLayout
#define SOAP_TYPE_ns2__PaneLayout (817)
/* complex XSD type 'ns2:PaneLayout': */
class SOAP_CMAC ns2__PaneLayout {
      public:
        /// Required element 'ns2:Pane' of XSD type 'ns2:ReferenceToken'
        std::string Pane;
        /// Required element 'ns2:Area' of XSD type 'ns2:Rectangle'
        ns2__Rectangle *Area;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaneLayout
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PaneLayout; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaneLayout, default initialized and not managed by a soap context
        virtual ns2__PaneLayout *soap_alloc(void) const { return SOAP_NEW(ns2__PaneLayout); }
      public:
        /// Constructor with initializations
        ns2__PaneLayout()
        {
          Area = (ns2__Rectangle *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PaneLayout() { }
        /// Friend allocator used by soap_new_ns2__PaneLayout(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaneLayout * SOAP_FMAC2 soap_instantiate_ns2__PaneLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2002 */
#ifndef SOAP_TYPE_ns2__Layout
#define SOAP_TYPE_ns2__Layout (818)
/* complex XSD type 'ns2:Layout': */
class SOAP_CMAC ns2__Layout {
      public:
        /// Required element 'ns2:PaneLayout' of XSD type 'ns2:PaneLayout'
        std::vector<ns2__PaneLayout *> PaneLayout;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:LayoutExtension'
        ns2__LayoutExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Layout
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Layout; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Layout, default initialized and not managed by a soap context
        virtual ns2__Layout *soap_alloc(void) const { return SOAP_NEW(ns2__Layout); }
      public:
        /// Constructor with initializations
        ns2__Layout()
        {
          Extension = (ns2__LayoutExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Layout() { }
        /// Friend allocator used by soap_new_ns2__Layout(struct soap*, int)
        friend SOAP_FMAC1 ns2__Layout * SOAP_FMAC2 soap_instantiate_ns2__Layout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2005 */
#ifndef SOAP_TYPE_ns2__LayoutExtension
#define SOAP_TYPE_ns2__LayoutExtension (819)
/* complex XSD type 'ns2:LayoutExtension': */
class SOAP_CMAC ns2__LayoutExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__LayoutExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__LayoutExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__LayoutExtension, default initialized and not managed by a soap context
        virtual ns2__LayoutExtension *soap_alloc(void) const { return SOAP_NEW(ns2__LayoutExtension); }
      public:
        /// Constructor with initializations
        ns2__LayoutExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__LayoutExtension() { }
        /// Friend allocator used by soap_new_ns2__LayoutExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__LayoutExtension * SOAP_FMAC2 soap_instantiate_ns2__LayoutExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2008 */
#ifndef SOAP_TYPE_ns2__CodingCapabilities
#define SOAP_TYPE_ns2__CodingCapabilities (820)
/* complex XSD type 'ns2:CodingCapabilities': */
class SOAP_CMAC ns2__CodingCapabilities {
      public:
        /// Optional element 'ns2:AudioEncodingCapabilities' of XSD type 'ns2:AudioEncoderConfigurationOptions'
        ns2__AudioEncoderConfigurationOptions *AudioEncodingCapabilities;
        /// Optional element 'ns2:AudioDecodingCapabilities' of XSD type 'ns2:AudioDecoderConfigurationOptions'
        ns2__AudioDecoderConfigurationOptions *AudioDecodingCapabilities;
        /// Required element 'ns2:VideoDecodingCapabilities' of XSD type 'ns2:VideoDecoderConfigurationOptions'
        ns2__VideoDecoderConfigurationOptions *VideoDecodingCapabilities;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CodingCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CodingCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CodingCapabilities, default initialized and not managed by a soap context
        virtual ns2__CodingCapabilities *soap_alloc(void) const { return SOAP_NEW(ns2__CodingCapabilities); }
      public:
        /// Constructor with initializations
        ns2__CodingCapabilities()
        {
          AudioEncodingCapabilities = (ns2__AudioEncoderConfigurationOptions *)0;
          AudioDecodingCapabilities = (ns2__AudioDecoderConfigurationOptions *)0;
          VideoDecodingCapabilities = (ns2__VideoDecoderConfigurationOptions *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CodingCapabilities() { }
        /// Friend allocator used by soap_new_ns2__CodingCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns2__CodingCapabilities * SOAP_FMAC2 soap_instantiate_ns2__CodingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2011 */
#ifndef SOAP_TYPE_ns2__LayoutOptions
#define SOAP_TYPE_ns2__LayoutOptions (821)
/* complex XSD type 'ns2:LayoutOptions': */
class SOAP_CMAC ns2__LayoutOptions {
      public:
        /// Required element 'ns2:PaneLayoutOptions' of XSD type 'ns2:PaneLayoutOptions'
        std::vector<ns2__PaneLayoutOptions *> PaneLayoutOptions;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:LayoutOptionsExtension'
        ns2__LayoutOptionsExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__LayoutOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__LayoutOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__LayoutOptions, default initialized and not managed by a soap context
        virtual ns2__LayoutOptions *soap_alloc(void) const { return SOAP_NEW(ns2__LayoutOptions); }
      public:
        /// Constructor with initializations
        ns2__LayoutOptions()
        {
          Extension = (ns2__LayoutOptionsExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__LayoutOptions() { }
        /// Friend allocator used by soap_new_ns2__LayoutOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__LayoutOptions * SOAP_FMAC2 soap_instantiate_ns2__LayoutOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2014 */
#ifndef SOAP_TYPE_ns2__LayoutOptionsExtension
#define SOAP_TYPE_ns2__LayoutOptionsExtension (822)
/* complex XSD type 'ns2:LayoutOptionsExtension': */
class SOAP_CMAC ns2__LayoutOptionsExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__LayoutOptionsExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__LayoutOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__LayoutOptionsExtension, default initialized and not managed by a soap context
        virtual ns2__LayoutOptionsExtension *soap_alloc(void) const { return SOAP_NEW(ns2__LayoutOptionsExtension); }
      public:
        /// Constructor with initializations
        ns2__LayoutOptionsExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__LayoutOptionsExtension() { }
        /// Friend allocator used by soap_new_ns2__LayoutOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__LayoutOptionsExtension * SOAP_FMAC2 soap_instantiate_ns2__LayoutOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2017 */
#ifndef SOAP_TYPE_ns2__PaneLayoutOptions
#define SOAP_TYPE_ns2__PaneLayoutOptions (823)
/* complex XSD type 'ns2:PaneLayoutOptions': */
class SOAP_CMAC ns2__PaneLayoutOptions {
      public:
        /// Required element 'ns2:Area' of XSD type 'ns2:Rectangle'
        std::vector<ns2__Rectangle *> Area;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:PaneOptionExtension'
        ns2__PaneOptionExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaneLayoutOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PaneLayoutOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaneLayoutOptions, default initialized and not managed by a soap context
        virtual ns2__PaneLayoutOptions *soap_alloc(void) const { return SOAP_NEW(ns2__PaneLayoutOptions); }
      public:
        /// Constructor with initializations
        ns2__PaneLayoutOptions()
        {
          Extension = (ns2__PaneOptionExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PaneLayoutOptions() { }
        /// Friend allocator used by soap_new_ns2__PaneLayoutOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaneLayoutOptions * SOAP_FMAC2 soap_instantiate_ns2__PaneLayoutOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2020 */
#ifndef SOAP_TYPE_ns2__PaneOptionExtension
#define SOAP_TYPE_ns2__PaneOptionExtension (824)
/* complex XSD type 'ns2:PaneOptionExtension': */
class SOAP_CMAC ns2__PaneOptionExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaneOptionExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PaneOptionExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaneOptionExtension, default initialized and not managed by a soap context
        virtual ns2__PaneOptionExtension *soap_alloc(void) const { return SOAP_NEW(ns2__PaneOptionExtension); }
      public:
        /// Constructor with initializations
        ns2__PaneOptionExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PaneOptionExtension() { }
        /// Friend allocator used by soap_new_ns2__PaneOptionExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaneOptionExtension * SOAP_FMAC2 soap_instantiate_ns2__PaneOptionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2023 */
#ifndef SOAP_TYPE_ns2__Receiver
#define SOAP_TYPE_ns2__Receiver (825)
/* complex XSD type 'ns2:Receiver': */
class SOAP_CMAC ns2__Receiver {
      public:
        /// Required element 'ns2:Token' of XSD type 'ns2:ReferenceToken'
        std::string Token;
        /// Required element 'ns2:Configuration' of XSD type 'ns2:ReceiverConfiguration'
        ns2__ReceiverConfiguration *Configuration;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Receiver
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Receiver; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Receiver, default initialized and not managed by a soap context
        virtual ns2__Receiver *soap_alloc(void) const { return SOAP_NEW(ns2__Receiver); }
      public:
        /// Constructor with initializations
        ns2__Receiver()
        {
          Configuration = (ns2__ReceiverConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Receiver() { }
        /// Friend allocator used by soap_new_ns2__Receiver(struct soap*, int)
        friend SOAP_FMAC1 ns2__Receiver * SOAP_FMAC2 soap_instantiate_ns2__Receiver(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2026 */
#ifndef SOAP_TYPE_ns2__ReceiverConfiguration
#define SOAP_TYPE_ns2__ReceiverConfiguration (826)
/* complex XSD type 'ns2:ReceiverConfiguration': */
class SOAP_CMAC ns2__ReceiverConfiguration {
      public:
        /// Required element 'ns2:Mode' of XSD type 'ns2:ReceiverMode'
        ns2__ReceiverMode Mode;
        /// Required element 'ns2:MediaUri' of XSD type 'xsd:anyURI'
        std::string MediaUri;
        /// Required element 'ns2:StreamSetup' of XSD type 'ns2:StreamSetup'
        ns2__StreamSetup *StreamSetup;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ReceiverConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ReceiverConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ReceiverConfiguration, default initialized and not managed by a soap context
        virtual ns2__ReceiverConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__ReceiverConfiguration); }
      public:
        /// Constructor with initializations
        ns2__ReceiverConfiguration()
        {
          Mode = (ns2__ReceiverMode)0;
          StreamSetup = (ns2__StreamSetup *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ReceiverConfiguration() { }
        /// Friend allocator used by soap_new_ns2__ReceiverConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__ReceiverConfiguration * SOAP_FMAC2 soap_instantiate_ns2__ReceiverConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2029 */
#ifndef SOAP_TYPE_ns2__ReceiverStateInformation
#define SOAP_TYPE_ns2__ReceiverStateInformation (827)
/* complex XSD type 'ns2:ReceiverStateInformation': */
class SOAP_CMAC ns2__ReceiverStateInformation {
      public:
        /// Required element 'ns2:State' of XSD type 'ns2:ReceiverState'
        ns2__ReceiverState State;
        /// Required element 'ns2:AutoCreated' of XSD type 'xsd:boolean'
        bool AutoCreated;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ReceiverStateInformation
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ReceiverStateInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ReceiverStateInformation, default initialized and not managed by a soap context
        virtual ns2__ReceiverStateInformation *soap_alloc(void) const { return SOAP_NEW(ns2__ReceiverStateInformation); }
      public:
        /// Constructor with initializations
        ns2__ReceiverStateInformation()
        {
          State = (ns2__ReceiverState)0;
          AutoCreated = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ReceiverStateInformation() { }
        /// Friend allocator used by soap_new_ns2__ReceiverStateInformation(struct soap*, int)
        friend SOAP_FMAC1 ns2__ReceiverStateInformation * SOAP_FMAC2 soap_instantiate_ns2__ReceiverStateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2032 */
#ifndef SOAP_TYPE_ns2__SourceReference
#define SOAP_TYPE_ns2__SourceReference (828)
/* complex XSD type 'ns2:SourceReference': */
class SOAP_CMAC ns2__SourceReference {
      public:
        /// Required element 'ns2:Token' of XSD type 'ns2:ReferenceToken'
        std::string Token;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// optional attribute 'Type' of XSD type 'xsd:anyURI'
        std::string Type;	///< default = "http://www.onvif.org/ver10/schema/Receiver"
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SourceReference
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SourceReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SourceReference, default initialized and not managed by a soap context
        virtual ns2__SourceReference *soap_alloc(void) const { return SOAP_NEW(ns2__SourceReference); }
      public:
        /// Constructor with initializations
        ns2__SourceReference()
        {
          Type = "http://www.onvif.org/ver10/schema/Receiver";
          soap = (struct soap *)0;
        }
        virtual ~ns2__SourceReference() { }
        /// Friend allocator used by soap_new_ns2__SourceReference(struct soap*, int)
        friend SOAP_FMAC1 ns2__SourceReference * SOAP_FMAC2 soap_instantiate_ns2__SourceReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2035 */
#ifndef SOAP_TYPE_ns2__DateTimeRange
#define SOAP_TYPE_ns2__DateTimeRange (829)
/* complex XSD type 'ns2:DateTimeRange': */
class SOAP_CMAC ns2__DateTimeRange {
      public:
        /// Required element 'ns2:From' of XSD type 'xsd:dateTime'
        time_t From;
        /// Required element 'ns2:Until' of XSD type 'xsd:dateTime'
        time_t Until;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DateTimeRange
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DateTimeRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DateTimeRange, default initialized and not managed by a soap context
        virtual ns2__DateTimeRange *soap_alloc(void) const { return SOAP_NEW(ns2__DateTimeRange); }
      public:
        /// Constructor with initializations
        ns2__DateTimeRange()
        {
          From = (time_t)0;
          Until = (time_t)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DateTimeRange() { }
        /// Friend allocator used by soap_new_ns2__DateTimeRange(struct soap*, int)
        friend SOAP_FMAC1 ns2__DateTimeRange * SOAP_FMAC2 soap_instantiate_ns2__DateTimeRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2038 */
#ifndef SOAP_TYPE_ns2__RecordingSummary
#define SOAP_TYPE_ns2__RecordingSummary (830)
/* complex XSD type 'ns2:RecordingSummary': */
class SOAP_CMAC ns2__RecordingSummary {
      public:
        /// Required element 'ns2:DataFrom' of XSD type 'xsd:dateTime'
        time_t DataFrom;
        /// Required element 'ns2:DataUntil' of XSD type 'xsd:dateTime'
        time_t DataUntil;
        /// Required element 'ns2:NumberRecordings' of XSD type 'xsd:int'
        int NumberRecordings;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RecordingSummary
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RecordingSummary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RecordingSummary, default initialized and not managed by a soap context
        virtual ns2__RecordingSummary *soap_alloc(void) const { return SOAP_NEW(ns2__RecordingSummary); }
      public:
        /// Constructor with initializations
        ns2__RecordingSummary()
        {
          DataFrom = (time_t)0;
          DataUntil = (time_t)0;
          NumberRecordings = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__RecordingSummary() { }
        /// Friend allocator used by soap_new_ns2__RecordingSummary(struct soap*, int)
        friend SOAP_FMAC1 ns2__RecordingSummary * SOAP_FMAC2 soap_instantiate_ns2__RecordingSummary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2041 */
#ifndef SOAP_TYPE_ns2__SearchScope
#define SOAP_TYPE_ns2__SearchScope (831)
/* complex XSD type 'ns2:SearchScope': */
class SOAP_CMAC ns2__SearchScope {
      public:
        /// Optional element 'ns2:IncludedSources' of XSD type 'ns2:SourceReference'
        std::vector<ns2__SourceReference *> IncludedSources;
        /// Optional element 'ns2:IncludedRecordings' of XSD type 'ns2:RecordingReference'
        std::vector<std::string> IncludedRecordings;
        /// Optional element 'ns2:RecordingInformationFilter' of XSD type 'ns2:XPathExpression'
        std::string *RecordingInformationFilter;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:SearchScopeExtension'
        ns2__SearchScopeExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SearchScope
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SearchScope; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SearchScope, default initialized and not managed by a soap context
        virtual ns2__SearchScope *soap_alloc(void) const { return SOAP_NEW(ns2__SearchScope); }
      public:
        /// Constructor with initializations
        ns2__SearchScope()
        {
          RecordingInformationFilter = (std::string *)0;
          Extension = (ns2__SearchScopeExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__SearchScope() { }
        /// Friend allocator used by soap_new_ns2__SearchScope(struct soap*, int)
        friend SOAP_FMAC1 ns2__SearchScope * SOAP_FMAC2 soap_instantiate_ns2__SearchScope(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2044 */
#ifndef SOAP_TYPE_ns2__SearchScopeExtension
#define SOAP_TYPE_ns2__SearchScopeExtension (832)
/* complex XSD type 'ns2:SearchScopeExtension': */
class SOAP_CMAC ns2__SearchScopeExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SearchScopeExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SearchScopeExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SearchScopeExtension, default initialized and not managed by a soap context
        virtual ns2__SearchScopeExtension *soap_alloc(void) const { return SOAP_NEW(ns2__SearchScopeExtension); }
      public:
        /// Constructor with initializations
        ns2__SearchScopeExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__SearchScopeExtension() { }
        /// Friend allocator used by soap_new_ns2__SearchScopeExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__SearchScopeExtension * SOAP_FMAC2 soap_instantiate_ns2__SearchScopeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2050 */
#ifndef SOAP_TYPE_ns2__PTZPositionFilter
#define SOAP_TYPE_ns2__PTZPositionFilter (834)
/* complex XSD type 'ns2:PTZPositionFilter': */
class SOAP_CMAC ns2__PTZPositionFilter {
      public:
        /// Required element 'ns2:MinPosition' of XSD type 'ns2:PTZVector'
        ns2__PTZVector *MinPosition;
        /// Required element 'ns2:MaxPosition' of XSD type 'ns2:PTZVector'
        ns2__PTZVector *MaxPosition;
        /// Required element 'ns2:EnterOrExit' of XSD type 'xsd:boolean'
        bool EnterOrExit;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZPositionFilter
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZPositionFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZPositionFilter, default initialized and not managed by a soap context
        virtual ns2__PTZPositionFilter *soap_alloc(void) const { return SOAP_NEW(ns2__PTZPositionFilter); }
      public:
        /// Constructor with initializations
        ns2__PTZPositionFilter()
        {
          MinPosition = (ns2__PTZVector *)0;
          MaxPosition = (ns2__PTZVector *)0;
          EnterOrExit = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PTZPositionFilter() { }
        /// Friend allocator used by soap_new_ns2__PTZPositionFilter(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZPositionFilter * SOAP_FMAC2 soap_instantiate_ns2__PTZPositionFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2053 */
#ifndef SOAP_TYPE_ns2__MetadataFilter
#define SOAP_TYPE_ns2__MetadataFilter (835)
/* complex XSD type 'ns2:MetadataFilter': */
class SOAP_CMAC ns2__MetadataFilter {
      public:
        /// Required element 'ns2:MetadataStreamFilter' of XSD type 'ns2:XPathExpression'
        std::string MetadataStreamFilter;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MetadataFilter
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MetadataFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MetadataFilter, default initialized and not managed by a soap context
        virtual ns2__MetadataFilter *soap_alloc(void) const { return SOAP_NEW(ns2__MetadataFilter); }
      public:
        /// Constructor with initializations
        ns2__MetadataFilter()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__MetadataFilter() { }
        /// Friend allocator used by soap_new_ns2__MetadataFilter(struct soap*, int)
        friend SOAP_FMAC1 ns2__MetadataFilter * SOAP_FMAC2 soap_instantiate_ns2__MetadataFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2056 */
#ifndef SOAP_TYPE_ns2__FindRecordingResultList
#define SOAP_TYPE_ns2__FindRecordingResultList (836)
/* complex XSD type 'ns2:FindRecordingResultList': */
class SOAP_CMAC ns2__FindRecordingResultList {
      public:
        /// Required element 'ns2:SearchState' of XSD type 'ns2:SearchState'
        ns2__SearchState SearchState;
        /// Optional element 'ns2:RecordingInformation' of XSD type 'ns2:RecordingInformation'
        std::vector<ns2__RecordingInformation *> RecordingInformation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FindRecordingResultList
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FindRecordingResultList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FindRecordingResultList, default initialized and not managed by a soap context
        virtual ns2__FindRecordingResultList *soap_alloc(void) const { return SOAP_NEW(ns2__FindRecordingResultList); }
      public:
        /// Constructor with initializations
        ns2__FindRecordingResultList()
        {
          SearchState = (ns2__SearchState)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__FindRecordingResultList() { }
        /// Friend allocator used by soap_new_ns2__FindRecordingResultList(struct soap*, int)
        friend SOAP_FMAC1 ns2__FindRecordingResultList * SOAP_FMAC2 soap_instantiate_ns2__FindRecordingResultList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2059 */
#ifndef SOAP_TYPE_ns2__FindEventResultList
#define SOAP_TYPE_ns2__FindEventResultList (837)
/* complex XSD type 'ns2:FindEventResultList': */
class SOAP_CMAC ns2__FindEventResultList {
      public:
        /// Required element 'ns2:SearchState' of XSD type 'ns2:SearchState'
        ns2__SearchState SearchState;
        /// Optional element 'ns2:Result' of XSD type 'ns2:FindEventResult'
        std::vector<ns2__FindEventResult *> Result;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FindEventResultList
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FindEventResultList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FindEventResultList, default initialized and not managed by a soap context
        virtual ns2__FindEventResultList *soap_alloc(void) const { return SOAP_NEW(ns2__FindEventResultList); }
      public:
        /// Constructor with initializations
        ns2__FindEventResultList()
        {
          SearchState = (ns2__SearchState)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__FindEventResultList() { }
        /// Friend allocator used by soap_new_ns2__FindEventResultList(struct soap*, int)
        friend SOAP_FMAC1 ns2__FindEventResultList * SOAP_FMAC2 soap_instantiate_ns2__FindEventResultList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2062 */
#ifndef SOAP_TYPE_ns2__FindEventResult
#define SOAP_TYPE_ns2__FindEventResult (838)
/* complex XSD type 'ns2:FindEventResult': */
class SOAP_CMAC ns2__FindEventResult {
      public:
        /// Required element 'ns2:RecordingToken' of XSD type 'ns2:RecordingReference'
        std::string RecordingToken;
        /// Required element 'ns2:TrackToken' of XSD type 'ns2:TrackReference'
        std::string TrackToken;
        /// Required element 'ns2:Time' of XSD type 'xsd:dateTime'
        time_t Time;
        /// Required element 'ns2:Event' of XSD type 'ns3:NotificationMessageHolderType'
        ns3__NotificationMessageHolderType *Event;
        /// Required element 'ns2:StartStateEvent' of XSD type 'xsd:boolean'
        bool StartStateEvent;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FindEventResult
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FindEventResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FindEventResult, default initialized and not managed by a soap context
        virtual ns2__FindEventResult *soap_alloc(void) const { return SOAP_NEW(ns2__FindEventResult); }
      public:
        /// Constructor with initializations
        ns2__FindEventResult()
        {
          Time = (time_t)0;
          Event = (ns3__NotificationMessageHolderType *)0;
          StartStateEvent = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__FindEventResult() { }
        /// Friend allocator used by soap_new_ns2__FindEventResult(struct soap*, int)
        friend SOAP_FMAC1 ns2__FindEventResult * SOAP_FMAC2 soap_instantiate_ns2__FindEventResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2065 */
#ifndef SOAP_TYPE_ns2__FindPTZPositionResultList
#define SOAP_TYPE_ns2__FindPTZPositionResultList (839)
/* complex XSD type 'ns2:FindPTZPositionResultList': */
class SOAP_CMAC ns2__FindPTZPositionResultList {
      public:
        /// Required element 'ns2:SearchState' of XSD type 'ns2:SearchState'
        ns2__SearchState SearchState;
        /// Optional element 'ns2:Result' of XSD type 'ns2:FindPTZPositionResult'
        std::vector<ns2__FindPTZPositionResult *> Result;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FindPTZPositionResultList
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FindPTZPositionResultList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FindPTZPositionResultList, default initialized and not managed by a soap context
        virtual ns2__FindPTZPositionResultList *soap_alloc(void) const { return SOAP_NEW(ns2__FindPTZPositionResultList); }
      public:
        /// Constructor with initializations
        ns2__FindPTZPositionResultList()
        {
          SearchState = (ns2__SearchState)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__FindPTZPositionResultList() { }
        /// Friend allocator used by soap_new_ns2__FindPTZPositionResultList(struct soap*, int)
        friend SOAP_FMAC1 ns2__FindPTZPositionResultList * SOAP_FMAC2 soap_instantiate_ns2__FindPTZPositionResultList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2068 */
#ifndef SOAP_TYPE_ns2__FindPTZPositionResult
#define SOAP_TYPE_ns2__FindPTZPositionResult (840)
/* complex XSD type 'ns2:FindPTZPositionResult': */
class SOAP_CMAC ns2__FindPTZPositionResult {
      public:
        /// Required element 'ns2:RecordingToken' of XSD type 'ns2:RecordingReference'
        std::string RecordingToken;
        /// Required element 'ns2:TrackToken' of XSD type 'ns2:TrackReference'
        std::string TrackToken;
        /// Required element 'ns2:Time' of XSD type 'xsd:dateTime'
        time_t Time;
        /// Required element 'ns2:Position' of XSD type 'ns2:PTZVector'
        ns2__PTZVector *Position;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FindPTZPositionResult
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FindPTZPositionResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FindPTZPositionResult, default initialized and not managed by a soap context
        virtual ns2__FindPTZPositionResult *soap_alloc(void) const { return SOAP_NEW(ns2__FindPTZPositionResult); }
      public:
        /// Constructor with initializations
        ns2__FindPTZPositionResult()
        {
          Time = (time_t)0;
          Position = (ns2__PTZVector *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__FindPTZPositionResult() { }
        /// Friend allocator used by soap_new_ns2__FindPTZPositionResult(struct soap*, int)
        friend SOAP_FMAC1 ns2__FindPTZPositionResult * SOAP_FMAC2 soap_instantiate_ns2__FindPTZPositionResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2071 */
#ifndef SOAP_TYPE_ns2__FindMetadataResultList
#define SOAP_TYPE_ns2__FindMetadataResultList (841)
/* complex XSD type 'ns2:FindMetadataResultList': */
class SOAP_CMAC ns2__FindMetadataResultList {
      public:
        /// Required element 'ns2:SearchState' of XSD type 'ns2:SearchState'
        ns2__SearchState SearchState;
        /// Optional element 'ns2:Result' of XSD type 'ns2:FindMetadataResult'
        std::vector<ns2__FindMetadataResult *> Result;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FindMetadataResultList
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FindMetadataResultList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FindMetadataResultList, default initialized and not managed by a soap context
        virtual ns2__FindMetadataResultList *soap_alloc(void) const { return SOAP_NEW(ns2__FindMetadataResultList); }
      public:
        /// Constructor with initializations
        ns2__FindMetadataResultList()
        {
          SearchState = (ns2__SearchState)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__FindMetadataResultList() { }
        /// Friend allocator used by soap_new_ns2__FindMetadataResultList(struct soap*, int)
        friend SOAP_FMAC1 ns2__FindMetadataResultList * SOAP_FMAC2 soap_instantiate_ns2__FindMetadataResultList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2074 */
#ifndef SOAP_TYPE_ns2__FindMetadataResult
#define SOAP_TYPE_ns2__FindMetadataResult (842)
/* complex XSD type 'ns2:FindMetadataResult': */
class SOAP_CMAC ns2__FindMetadataResult {
      public:
        /// Required element 'ns2:RecordingToken' of XSD type 'ns2:RecordingReference'
        std::string RecordingToken;
        /// Required element 'ns2:TrackToken' of XSD type 'ns2:TrackReference'
        std::string TrackToken;
        /// Required element 'ns2:Time' of XSD type 'xsd:dateTime'
        time_t Time;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FindMetadataResult
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FindMetadataResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FindMetadataResult, default initialized and not managed by a soap context
        virtual ns2__FindMetadataResult *soap_alloc(void) const { return SOAP_NEW(ns2__FindMetadataResult); }
      public:
        /// Constructor with initializations
        ns2__FindMetadataResult()
        {
          Time = (time_t)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__FindMetadataResult() { }
        /// Friend allocator used by soap_new_ns2__FindMetadataResult(struct soap*, int)
        friend SOAP_FMAC1 ns2__FindMetadataResult * SOAP_FMAC2 soap_instantiate_ns2__FindMetadataResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2077 */
#ifndef SOAP_TYPE_ns2__RecordingInformation
#define SOAP_TYPE_ns2__RecordingInformation (843)
/* complex XSD type 'ns2:RecordingInformation': */
class SOAP_CMAC ns2__RecordingInformation {
      public:
        /// Required element 'ns2:RecordingToken' of XSD type 'ns2:RecordingReference'
        std::string RecordingToken;
        /// Required element 'ns2:Source' of XSD type 'ns2:RecordingSourceInformation'
        ns2__RecordingSourceInformation *Source;
        /// Optional element 'ns2:EarliestRecording' of XSD type 'xsd:dateTime'
        time_t *EarliestRecording;
        /// Optional element 'ns2:LatestRecording' of XSD type 'xsd:dateTime'
        time_t *LatestRecording;
        /// Required element 'ns2:Content' of XSD type 'ns2:Description'
        std::string Content;
        /// Optional element 'ns2:Track' of XSD type 'ns2:TrackInformation'
        std::vector<ns2__TrackInformation *> Track;
        /// Required element 'ns2:RecordingStatus' of XSD type 'ns2:RecordingStatus'
        ns2__RecordingStatus RecordingStatus;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RecordingInformation
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RecordingInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RecordingInformation, default initialized and not managed by a soap context
        virtual ns2__RecordingInformation *soap_alloc(void) const { return SOAP_NEW(ns2__RecordingInformation); }
      public:
        /// Constructor with initializations
        ns2__RecordingInformation()
        {
          Source = (ns2__RecordingSourceInformation *)0;
          EarliestRecording = (time_t *)0;
          LatestRecording = (time_t *)0;
          RecordingStatus = (ns2__RecordingStatus)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__RecordingInformation() { }
        /// Friend allocator used by soap_new_ns2__RecordingInformation(struct soap*, int)
        friend SOAP_FMAC1 ns2__RecordingInformation * SOAP_FMAC2 soap_instantiate_ns2__RecordingInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2080 */
#ifndef SOAP_TYPE_ns2__RecordingSourceInformation
#define SOAP_TYPE_ns2__RecordingSourceInformation (844)
/* complex XSD type 'ns2:RecordingSourceInformation': */
class SOAP_CMAC ns2__RecordingSourceInformation {
      public:
        /// Required element 'ns2:SourceId' of XSD type 'xsd:anyURI'
        std::string SourceId;
        /// Required element 'ns2:Name' of XSD type 'ns2:Name'
        std::string Name;
        /// Required element 'ns2:Location' of XSD type 'ns2:Description'
        std::string Location;
        /// Required element 'ns2:Description' of XSD type 'ns2:Description'
        std::string Description;
        /// Required element 'ns2:Address' of XSD type 'xsd:anyURI'
        std::string Address;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RecordingSourceInformation
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RecordingSourceInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RecordingSourceInformation, default initialized and not managed by a soap context
        virtual ns2__RecordingSourceInformation *soap_alloc(void) const { return SOAP_NEW(ns2__RecordingSourceInformation); }
      public:
        /// Constructor with initializations
        ns2__RecordingSourceInformation()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__RecordingSourceInformation() { }
        /// Friend allocator used by soap_new_ns2__RecordingSourceInformation(struct soap*, int)
        friend SOAP_FMAC1 ns2__RecordingSourceInformation * SOAP_FMAC2 soap_instantiate_ns2__RecordingSourceInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2083 */
#ifndef SOAP_TYPE_ns2__TrackInformation
#define SOAP_TYPE_ns2__TrackInformation (845)
/* complex XSD type 'ns2:TrackInformation': */
class SOAP_CMAC ns2__TrackInformation {
      public:
        /// Required element 'ns2:TrackToken' of XSD type 'ns2:TrackReference'
        std::string TrackToken;
        /// Required element 'ns2:TrackType' of XSD type 'ns2:TrackType'
        ns2__TrackType TrackType;
        /// Required element 'ns2:Description' of XSD type 'ns2:Description'
        std::string Description;
        /// Required element 'ns2:DataFrom' of XSD type 'xsd:dateTime'
        time_t DataFrom;
        /// Required element 'ns2:DataTo' of XSD type 'xsd:dateTime'
        time_t DataTo;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__TrackInformation
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__TrackInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__TrackInformation, default initialized and not managed by a soap context
        virtual ns2__TrackInformation *soap_alloc(void) const { return SOAP_NEW(ns2__TrackInformation); }
      public:
        /// Constructor with initializations
        ns2__TrackInformation()
        {
          TrackType = (ns2__TrackType)0;
          DataFrom = (time_t)0;
          DataTo = (time_t)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__TrackInformation() { }
        /// Friend allocator used by soap_new_ns2__TrackInformation(struct soap*, int)
        friend SOAP_FMAC1 ns2__TrackInformation * SOAP_FMAC2 soap_instantiate_ns2__TrackInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2086 */
#ifndef SOAP_TYPE_ns2__MediaAttributes
#define SOAP_TYPE_ns2__MediaAttributes (846)
/* complex XSD type 'ns2:MediaAttributes': */
class SOAP_CMAC ns2__MediaAttributes {
      public:
        /// Required element 'ns2:RecordingToken' of XSD type 'ns2:RecordingReference'
        std::string RecordingToken;
        /// Optional element 'ns2:TrackAttributes' of XSD type 'ns2:TrackAttributes'
        std::vector<ns2__TrackAttributes *> TrackAttributes;
        /// Required element 'ns2:From' of XSD type 'xsd:dateTime'
        time_t From;
        /// Required element 'ns2:Until' of XSD type 'xsd:dateTime'
        time_t Until;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MediaAttributes
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MediaAttributes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MediaAttributes, default initialized and not managed by a soap context
        virtual ns2__MediaAttributes *soap_alloc(void) const { return SOAP_NEW(ns2__MediaAttributes); }
      public:
        /// Constructor with initializations
        ns2__MediaAttributes()
        {
          From = (time_t)0;
          Until = (time_t)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__MediaAttributes() { }
        /// Friend allocator used by soap_new_ns2__MediaAttributes(struct soap*, int)
        friend SOAP_FMAC1 ns2__MediaAttributes * SOAP_FMAC2 soap_instantiate_ns2__MediaAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2089 */
#ifndef SOAP_TYPE_ns2__TrackAttributes
#define SOAP_TYPE_ns2__TrackAttributes (847)
/* complex XSD type 'ns2:TrackAttributes': */
class SOAP_CMAC ns2__TrackAttributes {
      public:
        /// Required element 'ns2:TrackInformation' of XSD type 'ns2:TrackInformation'
        ns2__TrackInformation *TrackInformation;
        /// Optional element 'ns2:VideoAttributes' of XSD type 'ns2:VideoAttributes'
        ns2__VideoAttributes *VideoAttributes;
        /// Optional element 'ns2:AudioAttributes' of XSD type 'ns2:AudioAttributes'
        ns2__AudioAttributes *AudioAttributes;
        /// Optional element 'ns2:MetadataAttributes' of XSD type 'ns2:MetadataAttributes'
        ns2__MetadataAttributes *MetadataAttributes;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:TrackAttributesExtension'
        ns2__TrackAttributesExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__TrackAttributes
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__TrackAttributes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__TrackAttributes, default initialized and not managed by a soap context
        virtual ns2__TrackAttributes *soap_alloc(void) const { return SOAP_NEW(ns2__TrackAttributes); }
      public:
        /// Constructor with initializations
        ns2__TrackAttributes()
        {
          TrackInformation = (ns2__TrackInformation *)0;
          VideoAttributes = (ns2__VideoAttributes *)0;
          AudioAttributes = (ns2__AudioAttributes *)0;
          MetadataAttributes = (ns2__MetadataAttributes *)0;
          Extension = (ns2__TrackAttributesExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__TrackAttributes() { }
        /// Friend allocator used by soap_new_ns2__TrackAttributes(struct soap*, int)
        friend SOAP_FMAC1 ns2__TrackAttributes * SOAP_FMAC2 soap_instantiate_ns2__TrackAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2092 */
#ifndef SOAP_TYPE_ns2__TrackAttributesExtension
#define SOAP_TYPE_ns2__TrackAttributesExtension (848)
/* complex XSD type 'ns2:TrackAttributesExtension': */
class SOAP_CMAC ns2__TrackAttributesExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__TrackAttributesExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__TrackAttributesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__TrackAttributesExtension, default initialized and not managed by a soap context
        virtual ns2__TrackAttributesExtension *soap_alloc(void) const { return SOAP_NEW(ns2__TrackAttributesExtension); }
      public:
        /// Constructor with initializations
        ns2__TrackAttributesExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__TrackAttributesExtension() { }
        /// Friend allocator used by soap_new_ns2__TrackAttributesExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__TrackAttributesExtension * SOAP_FMAC2 soap_instantiate_ns2__TrackAttributesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2095 */
#ifndef SOAP_TYPE_ns2__VideoAttributes
#define SOAP_TYPE_ns2__VideoAttributes (849)
/* complex XSD type 'ns2:VideoAttributes': */
class SOAP_CMAC ns2__VideoAttributes {
      public:
        /// Optional element 'ns2:Bitrate' of XSD type 'xsd:int'
        int *Bitrate;
        /// Required element 'ns2:Width' of XSD type 'xsd:int'
        int Width;
        /// Required element 'ns2:Height' of XSD type 'xsd:int'
        int Height;
        /// Required element 'ns2:Encoding' of XSD type 'ns2:VideoEncoding'
        ns2__VideoEncoding Encoding;
        /// Required element 'ns2:Framerate' of XSD type 'xsd:float'
        float Framerate;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoAttributes
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoAttributes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoAttributes, default initialized and not managed by a soap context
        virtual ns2__VideoAttributes *soap_alloc(void) const { return SOAP_NEW(ns2__VideoAttributes); }
      public:
        /// Constructor with initializations
        ns2__VideoAttributes()
        {
          Bitrate = (int *)0;
          Width = (int)0;
          Height = (int)0;
          Encoding = (ns2__VideoEncoding)0;
          Framerate = (float)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__VideoAttributes() { }
        /// Friend allocator used by soap_new_ns2__VideoAttributes(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoAttributes * SOAP_FMAC2 soap_instantiate_ns2__VideoAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2098 */
#ifndef SOAP_TYPE_ns2__AudioAttributes
#define SOAP_TYPE_ns2__AudioAttributes (850)
/* complex XSD type 'ns2:AudioAttributes': */
class SOAP_CMAC ns2__AudioAttributes {
      public:
        /// Optional element 'ns2:Bitrate' of XSD type 'xsd:int'
        int *Bitrate;
        /// Required element 'ns2:Encoding' of XSD type 'ns2:AudioEncoding'
        ns2__AudioEncoding Encoding;
        /// Required element 'ns2:Samplerate' of XSD type 'xsd:int'
        int Samplerate;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AudioAttributes
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AudioAttributes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AudioAttributes, default initialized and not managed by a soap context
        virtual ns2__AudioAttributes *soap_alloc(void) const { return SOAP_NEW(ns2__AudioAttributes); }
      public:
        /// Constructor with initializations
        ns2__AudioAttributes()
        {
          Bitrate = (int *)0;
          Encoding = (ns2__AudioEncoding)0;
          Samplerate = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AudioAttributes() { }
        /// Friend allocator used by soap_new_ns2__AudioAttributes(struct soap*, int)
        friend SOAP_FMAC1 ns2__AudioAttributes * SOAP_FMAC2 soap_instantiate_ns2__AudioAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2101 */
#ifndef SOAP_TYPE_ns2__MetadataAttributes
#define SOAP_TYPE_ns2__MetadataAttributes (851)
/* complex XSD type 'ns2:MetadataAttributes': */
class SOAP_CMAC ns2__MetadataAttributes {
      public:
        /// Required element 'ns2:CanContainPTZ' of XSD type 'xsd:boolean'
        bool CanContainPTZ;
        /// Required element 'ns2:CanContainAnalytics' of XSD type 'xsd:boolean'
        bool CanContainAnalytics;
        /// Required element 'ns2:CanContainNotifications' of XSD type 'xsd:boolean'
        bool CanContainNotifications;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// optional attribute 'PtzSpaces' of XSD type 'ns2:StringAttrList'
        std::string *PtzSpaces;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MetadataAttributes
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MetadataAttributes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MetadataAttributes, default initialized and not managed by a soap context
        virtual ns2__MetadataAttributes *soap_alloc(void) const { return SOAP_NEW(ns2__MetadataAttributes); }
      public:
        /// Constructor with initializations
        ns2__MetadataAttributes()
        {
          CanContainPTZ = (bool)0;
          CanContainAnalytics = (bool)0;
          CanContainNotifications = (bool)0;
          PtzSpaces = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__MetadataAttributes() { }
        /// Friend allocator used by soap_new_ns2__MetadataAttributes(struct soap*, int)
        friend SOAP_FMAC1 ns2__MetadataAttributes * SOAP_FMAC2 soap_instantiate_ns2__MetadataAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2104 */
#ifndef SOAP_TYPE_ns2__RecordingConfiguration
#define SOAP_TYPE_ns2__RecordingConfiguration (852)
/* complex XSD type 'ns2:RecordingConfiguration': */
class SOAP_CMAC ns2__RecordingConfiguration {
      public:
        /// Required element 'ns2:Source' of XSD type 'ns2:RecordingSourceInformation'
        ns2__RecordingSourceInformation *Source;
        /// Required element 'ns2:Content' of XSD type 'ns2:Description'
        std::string Content;
        /// Required element 'ns2:MaximumRetentionTime' of XSD type 'xsd:duration'
        std::string MaximumRetentionTime;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RecordingConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RecordingConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RecordingConfiguration, default initialized and not managed by a soap context
        virtual ns2__RecordingConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__RecordingConfiguration); }
      public:
        /// Constructor with initializations
        ns2__RecordingConfiguration()
        {
          Source = (ns2__RecordingSourceInformation *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__RecordingConfiguration() { }
        /// Friend allocator used by soap_new_ns2__RecordingConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__RecordingConfiguration * SOAP_FMAC2 soap_instantiate_ns2__RecordingConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2107 */
#ifndef SOAP_TYPE_ns2__TrackConfiguration
#define SOAP_TYPE_ns2__TrackConfiguration (853)
/* complex XSD type 'ns2:TrackConfiguration': */
class SOAP_CMAC ns2__TrackConfiguration {
      public:
        /// Required element 'ns2:TrackType' of XSD type 'ns2:TrackType'
        ns2__TrackType TrackType;
        /// Required element 'ns2:Description' of XSD type 'ns2:Description'
        std::string Description;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__TrackConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__TrackConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__TrackConfiguration, default initialized and not managed by a soap context
        virtual ns2__TrackConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__TrackConfiguration); }
      public:
        /// Constructor with initializations
        ns2__TrackConfiguration()
        {
          TrackType = (ns2__TrackType)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__TrackConfiguration() { }
        /// Friend allocator used by soap_new_ns2__TrackConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__TrackConfiguration * SOAP_FMAC2 soap_instantiate_ns2__TrackConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2110 */
#ifndef SOAP_TYPE_ns2__GetRecordingsResponseItem
#define SOAP_TYPE_ns2__GetRecordingsResponseItem (854)
/* complex XSD type 'ns2:GetRecordingsResponseItem': */
class SOAP_CMAC ns2__GetRecordingsResponseItem {
      public:
        /// Required element 'ns2:RecordingToken' of XSD type 'ns2:RecordingReference'
        std::string RecordingToken;
        /// Required element 'ns2:Configuration' of XSD type 'ns2:RecordingConfiguration'
        ns2__RecordingConfiguration *Configuration;
        /// Required element 'ns2:Tracks' of XSD type 'ns2:GetTracksResponseList'
        ns2__GetTracksResponseList *Tracks;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GetRecordingsResponseItem
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__GetRecordingsResponseItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GetRecordingsResponseItem, default initialized and not managed by a soap context
        virtual ns2__GetRecordingsResponseItem *soap_alloc(void) const { return SOAP_NEW(ns2__GetRecordingsResponseItem); }
      public:
        /// Constructor with initializations
        ns2__GetRecordingsResponseItem()
        {
          Configuration = (ns2__RecordingConfiguration *)0;
          Tracks = (ns2__GetTracksResponseList *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__GetRecordingsResponseItem() { }
        /// Friend allocator used by soap_new_ns2__GetRecordingsResponseItem(struct soap*, int)
        friend SOAP_FMAC1 ns2__GetRecordingsResponseItem * SOAP_FMAC2 soap_instantiate_ns2__GetRecordingsResponseItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2113 */
#ifndef SOAP_TYPE_ns2__GetTracksResponseList
#define SOAP_TYPE_ns2__GetTracksResponseList (855)
/* complex XSD type 'ns2:GetTracksResponseList': */
class SOAP_CMAC ns2__GetTracksResponseList {
      public:
        /// Optional element 'ns2:Track' of XSD type 'ns2:GetTracksResponseItem'
        std::vector<ns2__GetTracksResponseItem *> Track;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GetTracksResponseList
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__GetTracksResponseList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GetTracksResponseList, default initialized and not managed by a soap context
        virtual ns2__GetTracksResponseList *soap_alloc(void) const { return SOAP_NEW(ns2__GetTracksResponseList); }
      public:
        /// Constructor with initializations
        ns2__GetTracksResponseList()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__GetTracksResponseList() { }
        /// Friend allocator used by soap_new_ns2__GetTracksResponseList(struct soap*, int)
        friend SOAP_FMAC1 ns2__GetTracksResponseList * SOAP_FMAC2 soap_instantiate_ns2__GetTracksResponseList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2116 */
#ifndef SOAP_TYPE_ns2__GetTracksResponseItem
#define SOAP_TYPE_ns2__GetTracksResponseItem (856)
/* complex XSD type 'ns2:GetTracksResponseItem': */
class SOAP_CMAC ns2__GetTracksResponseItem {
      public:
        /// Required element 'ns2:TrackToken' of XSD type 'ns2:TrackReference'
        std::string TrackToken;
        /// Required element 'ns2:Configuration' of XSD type 'ns2:TrackConfiguration'
        ns2__TrackConfiguration *Configuration;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GetTracksResponseItem
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__GetTracksResponseItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GetTracksResponseItem, default initialized and not managed by a soap context
        virtual ns2__GetTracksResponseItem *soap_alloc(void) const { return SOAP_NEW(ns2__GetTracksResponseItem); }
      public:
        /// Constructor with initializations
        ns2__GetTracksResponseItem()
        {
          Configuration = (ns2__TrackConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__GetTracksResponseItem() { }
        /// Friend allocator used by soap_new_ns2__GetTracksResponseItem(struct soap*, int)
        friend SOAP_FMAC1 ns2__GetTracksResponseItem * SOAP_FMAC2 soap_instantiate_ns2__GetTracksResponseItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2119 */
#ifndef SOAP_TYPE_ns2__RecordingJobConfiguration
#define SOAP_TYPE_ns2__RecordingJobConfiguration (857)
/* complex XSD type 'ns2:RecordingJobConfiguration': */
class SOAP_CMAC ns2__RecordingJobConfiguration {
      public:
        /// Required element 'ns2:RecordingToken' of XSD type 'ns2:RecordingReference'
        std::string RecordingToken;
        /// Required element 'ns2:Mode' of XSD type 'ns2:RecordingJobMode'
        std::string Mode;
        /// Required element 'ns2:Priority' of XSD type 'xsd:int'
        int Priority;
        /// Optional element 'ns2:Source' of XSD type 'ns2:RecordingJobSource'
        std::vector<ns2__RecordingJobSource *> Source;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:RecordingJobConfigurationExtension'
        ns2__RecordingJobConfigurationExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RecordingJobConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RecordingJobConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RecordingJobConfiguration, default initialized and not managed by a soap context
        virtual ns2__RecordingJobConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__RecordingJobConfiguration); }
      public:
        /// Constructor with initializations
        ns2__RecordingJobConfiguration()
        {
          Priority = (int)0;
          Extension = (ns2__RecordingJobConfigurationExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__RecordingJobConfiguration() { }
        /// Friend allocator used by soap_new_ns2__RecordingJobConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__RecordingJobConfiguration * SOAP_FMAC2 soap_instantiate_ns2__RecordingJobConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2122 */
#ifndef SOAP_TYPE_ns2__RecordingJobConfigurationExtension
#define SOAP_TYPE_ns2__RecordingJobConfigurationExtension (858)
/* complex XSD type 'ns2:RecordingJobConfigurationExtension': */
class SOAP_CMAC ns2__RecordingJobConfigurationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RecordingJobConfigurationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RecordingJobConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RecordingJobConfigurationExtension, default initialized and not managed by a soap context
        virtual ns2__RecordingJobConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__RecordingJobConfigurationExtension); }
      public:
        /// Constructor with initializations
        ns2__RecordingJobConfigurationExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__RecordingJobConfigurationExtension() { }
        /// Friend allocator used by soap_new_ns2__RecordingJobConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__RecordingJobConfigurationExtension * SOAP_FMAC2 soap_instantiate_ns2__RecordingJobConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2125 */
#ifndef SOAP_TYPE_ns2__RecordingJobSource
#define SOAP_TYPE_ns2__RecordingJobSource (859)
/* complex XSD type 'ns2:RecordingJobSource': */
class SOAP_CMAC ns2__RecordingJobSource {
      public:
        /// Optional element 'ns2:SourceToken' of XSD type 'ns2:SourceReference'
        ns2__SourceReference *SourceToken;
        /// Optional element 'ns2:AutoCreateReceiver' of XSD type 'xsd:boolean'
        bool *AutoCreateReceiver;
        /// Optional element 'ns2:Tracks' of XSD type 'ns2:RecordingJobTrack'
        std::vector<ns2__RecordingJobTrack *> Tracks;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:RecordingJobSourceExtension'
        ns2__RecordingJobSourceExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RecordingJobSource
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RecordingJobSource; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RecordingJobSource, default initialized and not managed by a soap context
        virtual ns2__RecordingJobSource *soap_alloc(void) const { return SOAP_NEW(ns2__RecordingJobSource); }
      public:
        /// Constructor with initializations
        ns2__RecordingJobSource()
        {
          SourceToken = (ns2__SourceReference *)0;
          AutoCreateReceiver = (bool *)0;
          Extension = (ns2__RecordingJobSourceExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__RecordingJobSource() { }
        /// Friend allocator used by soap_new_ns2__RecordingJobSource(struct soap*, int)
        friend SOAP_FMAC1 ns2__RecordingJobSource * SOAP_FMAC2 soap_instantiate_ns2__RecordingJobSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2128 */
#ifndef SOAP_TYPE_ns2__RecordingJobSourceExtension
#define SOAP_TYPE_ns2__RecordingJobSourceExtension (860)
/* complex XSD type 'ns2:RecordingJobSourceExtension': */
class SOAP_CMAC ns2__RecordingJobSourceExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RecordingJobSourceExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RecordingJobSourceExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RecordingJobSourceExtension, default initialized and not managed by a soap context
        virtual ns2__RecordingJobSourceExtension *soap_alloc(void) const { return SOAP_NEW(ns2__RecordingJobSourceExtension); }
      public:
        /// Constructor with initializations
        ns2__RecordingJobSourceExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__RecordingJobSourceExtension() { }
        /// Friend allocator used by soap_new_ns2__RecordingJobSourceExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__RecordingJobSourceExtension * SOAP_FMAC2 soap_instantiate_ns2__RecordingJobSourceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2131 */
#ifndef SOAP_TYPE_ns2__RecordingJobTrack
#define SOAP_TYPE_ns2__RecordingJobTrack (861)
/* complex XSD type 'ns2:RecordingJobTrack': */
class SOAP_CMAC ns2__RecordingJobTrack {
      public:
        /// Required element 'ns2:SourceTag' of XSD type 'xsd:string'
        std::string SourceTag;
        /// Required element 'ns2:Destination' of XSD type 'ns2:TrackReference'
        std::string Destination;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RecordingJobTrack
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RecordingJobTrack; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RecordingJobTrack, default initialized and not managed by a soap context
        virtual ns2__RecordingJobTrack *soap_alloc(void) const { return SOAP_NEW(ns2__RecordingJobTrack); }
      public:
        /// Constructor with initializations
        ns2__RecordingJobTrack()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__RecordingJobTrack() { }
        /// Friend allocator used by soap_new_ns2__RecordingJobTrack(struct soap*, int)
        friend SOAP_FMAC1 ns2__RecordingJobTrack * SOAP_FMAC2 soap_instantiate_ns2__RecordingJobTrack(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2134 */
#ifndef SOAP_TYPE_ns2__RecordingJobStateInformation
#define SOAP_TYPE_ns2__RecordingJobStateInformation (862)
/* complex XSD type 'ns2:RecordingJobStateInformation': */
class SOAP_CMAC ns2__RecordingJobStateInformation {
      public:
        /// Required element 'ns2:RecordingToken' of XSD type 'ns2:RecordingReference'
        std::string RecordingToken;
        /// Required element 'ns2:State' of XSD type 'ns2:RecordingJobState'
        std::string State;
        /// Optional element 'ns2:Sources' of XSD type 'ns2:RecordingJobStateSource'
        std::vector<ns2__RecordingJobStateSource *> Sources;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:RecordingJobStateInformationExtension'
        ns2__RecordingJobStateInformationExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RecordingJobStateInformation
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RecordingJobStateInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RecordingJobStateInformation, default initialized and not managed by a soap context
        virtual ns2__RecordingJobStateInformation *soap_alloc(void) const { return SOAP_NEW(ns2__RecordingJobStateInformation); }
      public:
        /// Constructor with initializations
        ns2__RecordingJobStateInformation()
        {
          Extension = (ns2__RecordingJobStateInformationExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__RecordingJobStateInformation() { }
        /// Friend allocator used by soap_new_ns2__RecordingJobStateInformation(struct soap*, int)
        friend SOAP_FMAC1 ns2__RecordingJobStateInformation * SOAP_FMAC2 soap_instantiate_ns2__RecordingJobStateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2137 */
#ifndef SOAP_TYPE_ns2__RecordingJobStateInformationExtension
#define SOAP_TYPE_ns2__RecordingJobStateInformationExtension (863)
/* complex XSD type 'ns2:RecordingJobStateInformationExtension': */
class SOAP_CMAC ns2__RecordingJobStateInformationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RecordingJobStateInformationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RecordingJobStateInformationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RecordingJobStateInformationExtension, default initialized and not managed by a soap context
        virtual ns2__RecordingJobStateInformationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__RecordingJobStateInformationExtension); }
      public:
        /// Constructor with initializations
        ns2__RecordingJobStateInformationExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__RecordingJobStateInformationExtension() { }
        /// Friend allocator used by soap_new_ns2__RecordingJobStateInformationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__RecordingJobStateInformationExtension * SOAP_FMAC2 soap_instantiate_ns2__RecordingJobStateInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2140 */
#ifndef SOAP_TYPE_ns2__RecordingJobStateSource
#define SOAP_TYPE_ns2__RecordingJobStateSource (864)
/* complex XSD type 'ns2:RecordingJobStateSource': */
class SOAP_CMAC ns2__RecordingJobStateSource {
      public:
        /// Required element 'ns2:SourceToken' of XSD type 'ns2:SourceReference'
        ns2__SourceReference *SourceToken;
        /// Required element 'ns2:State' of XSD type 'ns2:RecordingJobState'
        std::string State;
        /// Required element 'ns2:Tracks' of XSD type 'ns2:RecordingJobStateTracks'
        ns2__RecordingJobStateTracks *Tracks;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RecordingJobStateSource
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RecordingJobStateSource; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RecordingJobStateSource, default initialized and not managed by a soap context
        virtual ns2__RecordingJobStateSource *soap_alloc(void) const { return SOAP_NEW(ns2__RecordingJobStateSource); }
      public:
        /// Constructor with initializations
        ns2__RecordingJobStateSource()
        {
          SourceToken = (ns2__SourceReference *)0;
          Tracks = (ns2__RecordingJobStateTracks *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__RecordingJobStateSource() { }
        /// Friend allocator used by soap_new_ns2__RecordingJobStateSource(struct soap*, int)
        friend SOAP_FMAC1 ns2__RecordingJobStateSource * SOAP_FMAC2 soap_instantiate_ns2__RecordingJobStateSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2143 */
#ifndef SOAP_TYPE_ns2__RecordingJobStateTracks
#define SOAP_TYPE_ns2__RecordingJobStateTracks (865)
/* complex XSD type 'ns2:RecordingJobStateTracks': */
class SOAP_CMAC ns2__RecordingJobStateTracks {
      public:
        /// Optional element 'ns2:Track' of XSD type 'ns2:RecordingJobStateTrack'
        std::vector<ns2__RecordingJobStateTrack *> Track;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RecordingJobStateTracks
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RecordingJobStateTracks; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RecordingJobStateTracks, default initialized and not managed by a soap context
        virtual ns2__RecordingJobStateTracks *soap_alloc(void) const { return SOAP_NEW(ns2__RecordingJobStateTracks); }
      public:
        /// Constructor with initializations
        ns2__RecordingJobStateTracks()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__RecordingJobStateTracks() { }
        /// Friend allocator used by soap_new_ns2__RecordingJobStateTracks(struct soap*, int)
        friend SOAP_FMAC1 ns2__RecordingJobStateTracks * SOAP_FMAC2 soap_instantiate_ns2__RecordingJobStateTracks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2146 */
#ifndef SOAP_TYPE_ns2__RecordingJobStateTrack
#define SOAP_TYPE_ns2__RecordingJobStateTrack (866)
/* complex XSD type 'ns2:RecordingJobStateTrack': */
class SOAP_CMAC ns2__RecordingJobStateTrack {
      public:
        /// Required element 'ns2:SourceTag' of XSD type 'xsd:string'
        std::string SourceTag;
        /// Required element 'ns2:Destination' of XSD type 'ns2:TrackReference'
        std::string Destination;
        /// Optional element 'ns2:Error' of XSD type 'xsd:string'
        std::string *Error;
        /// Required element 'ns2:State' of XSD type 'ns2:RecordingJobState'
        std::string State;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RecordingJobStateTrack
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RecordingJobStateTrack; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RecordingJobStateTrack, default initialized and not managed by a soap context
        virtual ns2__RecordingJobStateTrack *soap_alloc(void) const { return SOAP_NEW(ns2__RecordingJobStateTrack); }
      public:
        /// Constructor with initializations
        ns2__RecordingJobStateTrack()
        {
          Error = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__RecordingJobStateTrack() { }
        /// Friend allocator used by soap_new_ns2__RecordingJobStateTrack(struct soap*, int)
        friend SOAP_FMAC1 ns2__RecordingJobStateTrack * SOAP_FMAC2 soap_instantiate_ns2__RecordingJobStateTrack(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2149 */
#ifndef SOAP_TYPE_ns2__GetRecordingJobsResponseItem
#define SOAP_TYPE_ns2__GetRecordingJobsResponseItem (867)
/* complex XSD type 'ns2:GetRecordingJobsResponseItem': */
class SOAP_CMAC ns2__GetRecordingJobsResponseItem {
      public:
        /// Required element 'ns2:JobToken' of XSD type 'ns2:RecordingJobReference'
        std::string JobToken;
        /// Required element 'ns2:JobConfiguration' of XSD type 'ns2:RecordingJobConfiguration'
        ns2__RecordingJobConfiguration *JobConfiguration;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GetRecordingJobsResponseItem
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__GetRecordingJobsResponseItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GetRecordingJobsResponseItem, default initialized and not managed by a soap context
        virtual ns2__GetRecordingJobsResponseItem *soap_alloc(void) const { return SOAP_NEW(ns2__GetRecordingJobsResponseItem); }
      public:
        /// Constructor with initializations
        ns2__GetRecordingJobsResponseItem()
        {
          JobConfiguration = (ns2__RecordingJobConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__GetRecordingJobsResponseItem() { }
        /// Friend allocator used by soap_new_ns2__GetRecordingJobsResponseItem(struct soap*, int)
        friend SOAP_FMAC1 ns2__GetRecordingJobsResponseItem * SOAP_FMAC2 soap_instantiate_ns2__GetRecordingJobsResponseItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2152 */
#ifndef SOAP_TYPE_ns2__ReplayConfiguration
#define SOAP_TYPE_ns2__ReplayConfiguration (868)
/* complex XSD type 'ns2:ReplayConfiguration': */
class SOAP_CMAC ns2__ReplayConfiguration {
      public:
        /// Required element 'ns2:SessionTimeout' of XSD type 'xsd:duration'
        std::string SessionTimeout;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ReplayConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ReplayConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ReplayConfiguration, default initialized and not managed by a soap context
        virtual ns2__ReplayConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__ReplayConfiguration); }
      public:
        /// Constructor with initializations
        ns2__ReplayConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ReplayConfiguration() { }
        /// Friend allocator used by soap_new_ns2__ReplayConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__ReplayConfiguration * SOAP_FMAC2 soap_instantiate_ns2__ReplayConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2158 */
#ifndef SOAP_TYPE_ns2__AnalyticsDeviceEngineConfiguration
#define SOAP_TYPE_ns2__AnalyticsDeviceEngineConfiguration (870)
/* complex XSD type 'ns2:AnalyticsDeviceEngineConfiguration': */
class SOAP_CMAC ns2__AnalyticsDeviceEngineConfiguration {
      public:
        /// Required element 'ns2:EngineConfiguration' of XSD type 'ns2:EngineConfiguration'
        std::vector<ns2__EngineConfiguration *> EngineConfiguration;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:AnalyticsDeviceEngineConfigurationExtension'
        ns2__AnalyticsDeviceEngineConfigurationExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AnalyticsDeviceEngineConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AnalyticsDeviceEngineConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AnalyticsDeviceEngineConfiguration, default initialized and not managed by a soap context
        virtual ns2__AnalyticsDeviceEngineConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__AnalyticsDeviceEngineConfiguration); }
      public:
        /// Constructor with initializations
        ns2__AnalyticsDeviceEngineConfiguration()
        {
          Extension = (ns2__AnalyticsDeviceEngineConfigurationExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AnalyticsDeviceEngineConfiguration() { }
        /// Friend allocator used by soap_new_ns2__AnalyticsDeviceEngineConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__AnalyticsDeviceEngineConfiguration * SOAP_FMAC2 soap_instantiate_ns2__AnalyticsDeviceEngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2161 */
#ifndef SOAP_TYPE_ns2__AnalyticsDeviceEngineConfigurationExtension
#define SOAP_TYPE_ns2__AnalyticsDeviceEngineConfigurationExtension (871)
/* complex XSD type 'ns2:AnalyticsDeviceEngineConfigurationExtension': */
class SOAP_CMAC ns2__AnalyticsDeviceEngineConfigurationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AnalyticsDeviceEngineConfigurationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AnalyticsDeviceEngineConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AnalyticsDeviceEngineConfigurationExtension, default initialized and not managed by a soap context
        virtual ns2__AnalyticsDeviceEngineConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__AnalyticsDeviceEngineConfigurationExtension); }
      public:
        /// Constructor with initializations
        ns2__AnalyticsDeviceEngineConfigurationExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__AnalyticsDeviceEngineConfigurationExtension() { }
        /// Friend allocator used by soap_new_ns2__AnalyticsDeviceEngineConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__AnalyticsDeviceEngineConfigurationExtension * SOAP_FMAC2 soap_instantiate_ns2__AnalyticsDeviceEngineConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2164 */
#ifndef SOAP_TYPE_ns2__EngineConfiguration
#define SOAP_TYPE_ns2__EngineConfiguration (872)
/* complex XSD type 'ns2:EngineConfiguration': */
class SOAP_CMAC ns2__EngineConfiguration {
      public:
        /// Required element 'ns2:VideoAnalyticsConfiguration' of XSD type 'ns2:VideoAnalyticsConfiguration'
        ns2__VideoAnalyticsConfiguration *VideoAnalyticsConfiguration;
        /// Required element 'ns2:AnalyticsEngineInputInfo' of XSD type 'ns2:AnalyticsEngineInputInfo'
        ns2__AnalyticsEngineInputInfo *AnalyticsEngineInputInfo;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__EngineConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__EngineConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__EngineConfiguration, default initialized and not managed by a soap context
        virtual ns2__EngineConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__EngineConfiguration); }
      public:
        /// Constructor with initializations
        ns2__EngineConfiguration()
        {
          VideoAnalyticsConfiguration = (ns2__VideoAnalyticsConfiguration *)0;
          AnalyticsEngineInputInfo = (ns2__AnalyticsEngineInputInfo *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__EngineConfiguration() { }
        /// Friend allocator used by soap_new_ns2__EngineConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__EngineConfiguration * SOAP_FMAC2 soap_instantiate_ns2__EngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2167 */
#ifndef SOAP_TYPE_ns2__AnalyticsEngineInputInfo
#define SOAP_TYPE_ns2__AnalyticsEngineInputInfo (873)
/* complex XSD type 'ns2:AnalyticsEngineInputInfo': */
class SOAP_CMAC ns2__AnalyticsEngineInputInfo {
      public:
        /// Optional element 'ns2:InputInfo' of XSD type 'ns2:Config'
        ns2__Config *InputInfo;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:AnalyticsEngineInputInfoExtension'
        ns2__AnalyticsEngineInputInfoExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AnalyticsEngineInputInfo
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AnalyticsEngineInputInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AnalyticsEngineInputInfo, default initialized and not managed by a soap context
        virtual ns2__AnalyticsEngineInputInfo *soap_alloc(void) const { return SOAP_NEW(ns2__AnalyticsEngineInputInfo); }
      public:
        /// Constructor with initializations
        ns2__AnalyticsEngineInputInfo()
        {
          InputInfo = (ns2__Config *)0;
          Extension = (ns2__AnalyticsEngineInputInfoExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AnalyticsEngineInputInfo() { }
        /// Friend allocator used by soap_new_ns2__AnalyticsEngineInputInfo(struct soap*, int)
        friend SOAP_FMAC1 ns2__AnalyticsEngineInputInfo * SOAP_FMAC2 soap_instantiate_ns2__AnalyticsEngineInputInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2170 */
#ifndef SOAP_TYPE_ns2__AnalyticsEngineInputInfoExtension
#define SOAP_TYPE_ns2__AnalyticsEngineInputInfoExtension (874)
/* complex XSD type 'ns2:AnalyticsEngineInputInfoExtension': */
class SOAP_CMAC ns2__AnalyticsEngineInputInfoExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AnalyticsEngineInputInfoExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AnalyticsEngineInputInfoExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AnalyticsEngineInputInfoExtension, default initialized and not managed by a soap context
        virtual ns2__AnalyticsEngineInputInfoExtension *soap_alloc(void) const { return SOAP_NEW(ns2__AnalyticsEngineInputInfoExtension); }
      public:
        /// Constructor with initializations
        ns2__AnalyticsEngineInputInfoExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__AnalyticsEngineInputInfoExtension() { }
        /// Friend allocator used by soap_new_ns2__AnalyticsEngineInputInfoExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__AnalyticsEngineInputInfoExtension * SOAP_FMAC2 soap_instantiate_ns2__AnalyticsEngineInputInfoExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2176 */
#ifndef SOAP_TYPE_ns2__SourceIdentification
#define SOAP_TYPE_ns2__SourceIdentification (876)
/* complex XSD type 'ns2:SourceIdentification': */
class SOAP_CMAC ns2__SourceIdentification {
      public:
        /// Required element 'ns2:Name' of XSD type 'xsd:string'
        std::string Name;
        /// Required element 'ns2:Token' of XSD type 'ns2:ReferenceToken'
        std::vector<std::string> Token;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:SourceIdentificationExtension'
        ns2__SourceIdentificationExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SourceIdentification
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SourceIdentification; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SourceIdentification, default initialized and not managed by a soap context
        virtual ns2__SourceIdentification *soap_alloc(void) const { return SOAP_NEW(ns2__SourceIdentification); }
      public:
        /// Constructor with initializations
        ns2__SourceIdentification()
        {
          Extension = (ns2__SourceIdentificationExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__SourceIdentification() { }
        /// Friend allocator used by soap_new_ns2__SourceIdentification(struct soap*, int)
        friend SOAP_FMAC1 ns2__SourceIdentification * SOAP_FMAC2 soap_instantiate_ns2__SourceIdentification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2179 */
#ifndef SOAP_TYPE_ns2__SourceIdentificationExtension
#define SOAP_TYPE_ns2__SourceIdentificationExtension (877)
/* complex XSD type 'ns2:SourceIdentificationExtension': */
class SOAP_CMAC ns2__SourceIdentificationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SourceIdentificationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SourceIdentificationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SourceIdentificationExtension, default initialized and not managed by a soap context
        virtual ns2__SourceIdentificationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__SourceIdentificationExtension); }
      public:
        /// Constructor with initializations
        ns2__SourceIdentificationExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__SourceIdentificationExtension() { }
        /// Friend allocator used by soap_new_ns2__SourceIdentificationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__SourceIdentificationExtension * SOAP_FMAC2 soap_instantiate_ns2__SourceIdentificationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2182 */
#ifndef SOAP_TYPE_ns2__MetadataInput
#define SOAP_TYPE_ns2__MetadataInput (878)
/* complex XSD type 'ns2:MetadataInput': */
class SOAP_CMAC ns2__MetadataInput {
      public:
        /// Optional element 'ns2:MetadataConfig' of XSD type 'ns2:Config'
        std::vector<ns2__Config *> MetadataConfig;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:MetadataInputExtension'
        ns2__MetadataInputExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MetadataInput
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MetadataInput; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MetadataInput, default initialized and not managed by a soap context
        virtual ns2__MetadataInput *soap_alloc(void) const { return SOAP_NEW(ns2__MetadataInput); }
      public:
        /// Constructor with initializations
        ns2__MetadataInput()
        {
          Extension = (ns2__MetadataInputExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__MetadataInput() { }
        /// Friend allocator used by soap_new_ns2__MetadataInput(struct soap*, int)
        friend SOAP_FMAC1 ns2__MetadataInput * SOAP_FMAC2 soap_instantiate_ns2__MetadataInput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2185 */
#ifndef SOAP_TYPE_ns2__MetadataInputExtension
#define SOAP_TYPE_ns2__MetadataInputExtension (879)
/* complex XSD type 'ns2:MetadataInputExtension': */
class SOAP_CMAC ns2__MetadataInputExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MetadataInputExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MetadataInputExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MetadataInputExtension, default initialized and not managed by a soap context
        virtual ns2__MetadataInputExtension *soap_alloc(void) const { return SOAP_NEW(ns2__MetadataInputExtension); }
      public:
        /// Constructor with initializations
        ns2__MetadataInputExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__MetadataInputExtension() { }
        /// Friend allocator used by soap_new_ns2__MetadataInputExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__MetadataInputExtension * SOAP_FMAC2 soap_instantiate_ns2__MetadataInputExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2191 */
#ifndef SOAP_TYPE_ns2__AnalyticsStateInformation
#define SOAP_TYPE_ns2__AnalyticsStateInformation (881)
/* complex XSD type 'ns2:AnalyticsStateInformation': */
class SOAP_CMAC ns2__AnalyticsStateInformation {
      public:
        /// Required element 'ns2:AnalyticsEngineControlToken' of XSD type 'ns2:ReferenceToken'
        std::string AnalyticsEngineControlToken;
        /// Required element 'ns2:State' of XSD type 'ns2:AnalyticsState'
        ns2__AnalyticsState *State;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AnalyticsStateInformation
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AnalyticsStateInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AnalyticsStateInformation, default initialized and not managed by a soap context
        virtual ns2__AnalyticsStateInformation *soap_alloc(void) const { return SOAP_NEW(ns2__AnalyticsStateInformation); }
      public:
        /// Constructor with initializations
        ns2__AnalyticsStateInformation()
        {
          State = (ns2__AnalyticsState *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AnalyticsStateInformation() { }
        /// Friend allocator used by soap_new_ns2__AnalyticsStateInformation(struct soap*, int)
        friend SOAP_FMAC1 ns2__AnalyticsStateInformation * SOAP_FMAC2 soap_instantiate_ns2__AnalyticsStateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2194 */
#ifndef SOAP_TYPE_ns2__AnalyticsState
#define SOAP_TYPE_ns2__AnalyticsState (882)
/* complex XSD type 'ns2:AnalyticsState': */
class SOAP_CMAC ns2__AnalyticsState {
      public:
        /// Optional element 'ns2:Error' of XSD type 'xsd:string'
        std::string *Error;
        /// Required element 'ns2:State' of XSD type 'xsd:string'
        std::string State;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AnalyticsState
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AnalyticsState; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AnalyticsState, default initialized and not managed by a soap context
        virtual ns2__AnalyticsState *soap_alloc(void) const { return SOAP_NEW(ns2__AnalyticsState); }
      public:
        /// Constructor with initializations
        ns2__AnalyticsState()
        {
          Error = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AnalyticsState() { }
        /// Friend allocator used by soap_new_ns2__AnalyticsState(struct soap*, int)
        friend SOAP_FMAC1 ns2__AnalyticsState * SOAP_FMAC2 soap_instantiate_ns2__AnalyticsState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:24688 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (2011)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault()
        {
          faultcode = (char *)0;
          faultstring = (char *)0;
          faultactor = (char *)0;
          detail = (struct SOAP_ENV__Detail *)0;
          SOAP_ENV__Code = (struct SOAP_ENV__Code *)0;
          SOAP_ENV__Reason = (struct SOAP_ENV__Reason *)0;
          SOAP_ENV__Node = (char *)0;
          SOAP_ENV__Role = (char *)0;
          SOAP_ENV__Detail = (struct SOAP_ENV__Detail *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Fault(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* onvifgen/onvif.h:2197 */
#ifndef SOAP_TYPE_ns2__ActionEngineEventPayload
#define SOAP_TYPE_ns2__ActionEngineEventPayload (883)
/* complex XSD type 'ns2:ActionEngineEventPayload': */
class SOAP_CMAC ns2__ActionEngineEventPayload {
      public:
        /// Optional element 'ns2:RequestInfo' of XSD type 'SOAP-ENV:Envelope'
        std::string *RequestInfo;
        /// Optional element 'ns2:ResponseInfo' of XSD type 'SOAP-ENV:Envelope'
        std::string *ResponseInfo;
        /// Optional element 'ns2:Fault' of XSD type 'SOAP-ENV:Fault'
        struct SOAP_ENV__Fault *Fault;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ActionEngineEventPayloadExtension'
        ns2__ActionEngineEventPayloadExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ActionEngineEventPayload
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ActionEngineEventPayload; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ActionEngineEventPayload, default initialized and not managed by a soap context
        virtual ns2__ActionEngineEventPayload *soap_alloc(void) const { return SOAP_NEW(ns2__ActionEngineEventPayload); }
      public:
        /// Constructor with initializations
        ns2__ActionEngineEventPayload()
        {
          RequestInfo = (std::string *)0;
          ResponseInfo = (std::string *)0;
          Fault = (struct SOAP_ENV__Fault *)0;
          Extension = (ns2__ActionEngineEventPayloadExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ActionEngineEventPayload() { }
        /// Friend allocator used by soap_new_ns2__ActionEngineEventPayload(struct soap*, int)
        friend SOAP_FMAC1 ns2__ActionEngineEventPayload * SOAP_FMAC2 soap_instantiate_ns2__ActionEngineEventPayload(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2200 */
#ifndef SOAP_TYPE_ns2__ActionEngineEventPayloadExtension
#define SOAP_TYPE_ns2__ActionEngineEventPayloadExtension (884)
/* complex XSD type 'ns2:ActionEngineEventPayloadExtension': */
class SOAP_CMAC ns2__ActionEngineEventPayloadExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ActionEngineEventPayloadExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ActionEngineEventPayloadExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ActionEngineEventPayloadExtension, default initialized and not managed by a soap context
        virtual ns2__ActionEngineEventPayloadExtension *soap_alloc(void) const { return SOAP_NEW(ns2__ActionEngineEventPayloadExtension); }
      public:
        /// Constructor with initializations
        ns2__ActionEngineEventPayloadExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ActionEngineEventPayloadExtension() { }
        /// Friend allocator used by soap_new_ns2__ActionEngineEventPayloadExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__ActionEngineEventPayloadExtension * SOAP_FMAC2 soap_instantiate_ns2__ActionEngineEventPayloadExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2203 */
#ifndef SOAP_TYPE_ns2__AudioClassCandidate
#define SOAP_TYPE_ns2__AudioClassCandidate (885)
/* complex XSD type 'ns2:AudioClassCandidate': */
class SOAP_CMAC ns2__AudioClassCandidate {
      public:
        /// Required element 'ns2:Type' of XSD type 'ns2:AudioClassType'
        std::string Type;
        /// Required element 'ns2:Likelihood' of XSD type 'xsd:float'
        float Likelihood;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AudioClassCandidate
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AudioClassCandidate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AudioClassCandidate, default initialized and not managed by a soap context
        virtual ns2__AudioClassCandidate *soap_alloc(void) const { return SOAP_NEW(ns2__AudioClassCandidate); }
      public:
        /// Constructor with initializations
        ns2__AudioClassCandidate()
        {
          Likelihood = (float)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AudioClassCandidate() { }
        /// Friend allocator used by soap_new_ns2__AudioClassCandidate(struct soap*, int)
        friend SOAP_FMAC1 ns2__AudioClassCandidate * SOAP_FMAC2 soap_instantiate_ns2__AudioClassCandidate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2206 */
#ifndef SOAP_TYPE_ns2__AudioClassDescriptor
#define SOAP_TYPE_ns2__AudioClassDescriptor (886)
/* complex XSD type 'ns2:AudioClassDescriptor': */
class SOAP_CMAC ns2__AudioClassDescriptor {
      public:
        /// Optional element 'ns2:ClassCandidate' of XSD type 'ns2:AudioClassCandidate'
        std::vector<ns2__AudioClassCandidate *> ClassCandidate;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:AudioClassDescriptorExtension'
        ns2__AudioClassDescriptorExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AudioClassDescriptor
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AudioClassDescriptor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AudioClassDescriptor, default initialized and not managed by a soap context
        virtual ns2__AudioClassDescriptor *soap_alloc(void) const { return SOAP_NEW(ns2__AudioClassDescriptor); }
      public:
        /// Constructor with initializations
        ns2__AudioClassDescriptor()
        {
          Extension = (ns2__AudioClassDescriptorExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AudioClassDescriptor() { }
        /// Friend allocator used by soap_new_ns2__AudioClassDescriptor(struct soap*, int)
        friend SOAP_FMAC1 ns2__AudioClassDescriptor * SOAP_FMAC2 soap_instantiate_ns2__AudioClassDescriptor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2209 */
#ifndef SOAP_TYPE_ns2__AudioClassDescriptorExtension
#define SOAP_TYPE_ns2__AudioClassDescriptorExtension (887)
/* complex XSD type 'ns2:AudioClassDescriptorExtension': */
class SOAP_CMAC ns2__AudioClassDescriptorExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AudioClassDescriptorExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AudioClassDescriptorExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AudioClassDescriptorExtension, default initialized and not managed by a soap context
        virtual ns2__AudioClassDescriptorExtension *soap_alloc(void) const { return SOAP_NEW(ns2__AudioClassDescriptorExtension); }
      public:
        /// Constructor with initializations
        ns2__AudioClassDescriptorExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__AudioClassDescriptorExtension() { }
        /// Friend allocator used by soap_new_ns2__AudioClassDescriptorExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__AudioClassDescriptorExtension * SOAP_FMAC2 soap_instantiate_ns2__AudioClassDescriptorExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2212 */
#ifndef SOAP_TYPE_ns2__ActiveConnection
#define SOAP_TYPE_ns2__ActiveConnection (888)
/* complex XSD type 'ns2:ActiveConnection': */
class SOAP_CMAC ns2__ActiveConnection {
      public:
        /// Required element 'ns2:CurrentBitrate' of XSD type 'xsd:float'
        float CurrentBitrate;
        /// Required element 'ns2:CurrentFps' of XSD type 'xsd:float'
        float CurrentFps;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ActiveConnection
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ActiveConnection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ActiveConnection, default initialized and not managed by a soap context
        virtual ns2__ActiveConnection *soap_alloc(void) const { return SOAP_NEW(ns2__ActiveConnection); }
      public:
        /// Constructor with initializations
        ns2__ActiveConnection()
        {
          CurrentBitrate = (float)0;
          CurrentFps = (float)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ActiveConnection() { }
        /// Friend allocator used by soap_new_ns2__ActiveConnection(struct soap*, int)
        friend SOAP_FMAC1 ns2__ActiveConnection * SOAP_FMAC2 soap_instantiate_ns2__ActiveConnection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2215 */
#ifndef SOAP_TYPE_ns2__ProfileStatus
#define SOAP_TYPE_ns2__ProfileStatus (889)
/* complex XSD type 'ns2:ProfileStatus': */
class SOAP_CMAC ns2__ProfileStatus {
      public:
        /// Optional element 'ns2:ActiveConnections' of XSD type 'ns2:ActiveConnection'
        std::vector<ns2__ActiveConnection *> ActiveConnections;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ProfileStatusExtension'
        ns2__ProfileStatusExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ProfileStatus
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ProfileStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ProfileStatus, default initialized and not managed by a soap context
        virtual ns2__ProfileStatus *soap_alloc(void) const { return SOAP_NEW(ns2__ProfileStatus); }
      public:
        /// Constructor with initializations
        ns2__ProfileStatus()
        {
          Extension = (ns2__ProfileStatusExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ProfileStatus() { }
        /// Friend allocator used by soap_new_ns2__ProfileStatus(struct soap*, int)
        friend SOAP_FMAC1 ns2__ProfileStatus * SOAP_FMAC2 soap_instantiate_ns2__ProfileStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2218 */
#ifndef SOAP_TYPE_ns2__ProfileStatusExtension
#define SOAP_TYPE_ns2__ProfileStatusExtension (890)
/* complex XSD type 'ns2:ProfileStatusExtension': */
class SOAP_CMAC ns2__ProfileStatusExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ProfileStatusExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ProfileStatusExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ProfileStatusExtension, default initialized and not managed by a soap context
        virtual ns2__ProfileStatusExtension *soap_alloc(void) const { return SOAP_NEW(ns2__ProfileStatusExtension); }
      public:
        /// Constructor with initializations
        ns2__ProfileStatusExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ProfileStatusExtension() { }
        /// Friend allocator used by soap_new_ns2__ProfileStatusExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__ProfileStatusExtension * SOAP_FMAC2 soap_instantiate_ns2__ProfileStatusExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2224 */
#ifndef SOAP_TYPE_ns2__OSDPosConfiguration
#define SOAP_TYPE_ns2__OSDPosConfiguration (892)
/* complex XSD type 'ns2:OSDPosConfiguration': */
class SOAP_CMAC ns2__OSDPosConfiguration {
      public:
        /// Required element 'ns2:Type' of XSD type 'xsd:string'
        std::string Type;
        /// Optional element 'ns2:Pos' of XSD type 'ns2:Vector'
        ns2__Vector *Pos;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:OSDPosConfigurationExtension'
        ns2__OSDPosConfigurationExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OSDPosConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__OSDPosConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OSDPosConfiguration, default initialized and not managed by a soap context
        virtual ns2__OSDPosConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__OSDPosConfiguration); }
      public:
        /// Constructor with initializations
        ns2__OSDPosConfiguration()
        {
          Pos = (ns2__Vector *)0;
          Extension = (ns2__OSDPosConfigurationExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__OSDPosConfiguration() { }
        /// Friend allocator used by soap_new_ns2__OSDPosConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__OSDPosConfiguration * SOAP_FMAC2 soap_instantiate_ns2__OSDPosConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2227 */
#ifndef SOAP_TYPE_ns2__OSDPosConfigurationExtension
#define SOAP_TYPE_ns2__OSDPosConfigurationExtension (893)
/* complex XSD type 'ns2:OSDPosConfigurationExtension': */
class SOAP_CMAC ns2__OSDPosConfigurationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OSDPosConfigurationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__OSDPosConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OSDPosConfigurationExtension, default initialized and not managed by a soap context
        virtual ns2__OSDPosConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__OSDPosConfigurationExtension); }
      public:
        /// Constructor with initializations
        ns2__OSDPosConfigurationExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__OSDPosConfigurationExtension() { }
        /// Friend allocator used by soap_new_ns2__OSDPosConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__OSDPosConfigurationExtension * SOAP_FMAC2 soap_instantiate_ns2__OSDPosConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2230 */
#ifndef SOAP_TYPE_ns2__OSDColor
#define SOAP_TYPE_ns2__OSDColor (894)
/* complex XSD type 'ns2:OSDColor': */
class SOAP_CMAC ns2__OSDColor {
      public:
        /// Required element 'ns2:Color' of XSD type 'ns2:Color'
        ns2__Color *Color;
        /// optional attribute 'Transparent' of XSD type 'xsd:int'
        int *Transparent;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OSDColor
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__OSDColor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OSDColor, default initialized and not managed by a soap context
        virtual ns2__OSDColor *soap_alloc(void) const { return SOAP_NEW(ns2__OSDColor); }
      public:
        /// Constructor with initializations
        ns2__OSDColor()
        {
          Color = (ns2__Color *)0;
          Transparent = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__OSDColor() { }
        /// Friend allocator used by soap_new_ns2__OSDColor(struct soap*, int)
        friend SOAP_FMAC1 ns2__OSDColor * SOAP_FMAC2 soap_instantiate_ns2__OSDColor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2233 */
#ifndef SOAP_TYPE_ns2__OSDTextConfiguration
#define SOAP_TYPE_ns2__OSDTextConfiguration (895)
/* complex XSD type 'ns2:OSDTextConfiguration': */
class SOAP_CMAC ns2__OSDTextConfiguration {
      public:
        /// Required element 'ns2:Type' of XSD type 'xsd:string'
        std::string Type;
        /// Optional element 'ns2:DateFormat' of XSD type 'xsd:string'
        std::string *DateFormat;
        /// Optional element 'ns2:TimeFormat' of XSD type 'xsd:string'
        std::string *TimeFormat;
        /// Optional element 'ns2:FontSize' of XSD type 'xsd:int'
        int *FontSize;
        /// Optional element 'ns2:FontColor' of XSD type 'ns2:OSDColor'
        ns2__OSDColor *FontColor;
        /// Optional element 'ns2:BackgroundColor' of XSD type 'ns2:OSDColor'
        ns2__OSDColor *BackgroundColor;
        /// Optional element 'ns2:PlainText' of XSD type 'xsd:string'
        std::string *PlainText;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:OSDTextConfigurationExtension'
        ns2__OSDTextConfigurationExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OSDTextConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__OSDTextConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OSDTextConfiguration, default initialized and not managed by a soap context
        virtual ns2__OSDTextConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__OSDTextConfiguration); }
      public:
        /// Constructor with initializations
        ns2__OSDTextConfiguration()
        {
          DateFormat = (std::string *)0;
          TimeFormat = (std::string *)0;
          FontSize = (int *)0;
          FontColor = (ns2__OSDColor *)0;
          BackgroundColor = (ns2__OSDColor *)0;
          PlainText = (std::string *)0;
          Extension = (ns2__OSDTextConfigurationExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__OSDTextConfiguration() { }
        /// Friend allocator used by soap_new_ns2__OSDTextConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__OSDTextConfiguration * SOAP_FMAC2 soap_instantiate_ns2__OSDTextConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2236 */
#ifndef SOAP_TYPE_ns2__OSDTextConfigurationExtension
#define SOAP_TYPE_ns2__OSDTextConfigurationExtension (896)
/* complex XSD type 'ns2:OSDTextConfigurationExtension': */
class SOAP_CMAC ns2__OSDTextConfigurationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OSDTextConfigurationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__OSDTextConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OSDTextConfigurationExtension, default initialized and not managed by a soap context
        virtual ns2__OSDTextConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__OSDTextConfigurationExtension); }
      public:
        /// Constructor with initializations
        ns2__OSDTextConfigurationExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__OSDTextConfigurationExtension() { }
        /// Friend allocator used by soap_new_ns2__OSDTextConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__OSDTextConfigurationExtension * SOAP_FMAC2 soap_instantiate_ns2__OSDTextConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2239 */
#ifndef SOAP_TYPE_ns2__OSDImgConfiguration
#define SOAP_TYPE_ns2__OSDImgConfiguration (897)
/* complex XSD type 'ns2:OSDImgConfiguration': */
class SOAP_CMAC ns2__OSDImgConfiguration {
      public:
        /// Required element 'ns2:ImgPath' of XSD type 'xsd:anyURI'
        std::string ImgPath;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:OSDImgConfigurationExtension'
        ns2__OSDImgConfigurationExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OSDImgConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__OSDImgConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OSDImgConfiguration, default initialized and not managed by a soap context
        virtual ns2__OSDImgConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__OSDImgConfiguration); }
      public:
        /// Constructor with initializations
        ns2__OSDImgConfiguration()
        {
          Extension = (ns2__OSDImgConfigurationExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__OSDImgConfiguration() { }
        /// Friend allocator used by soap_new_ns2__OSDImgConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__OSDImgConfiguration * SOAP_FMAC2 soap_instantiate_ns2__OSDImgConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2242 */
#ifndef SOAP_TYPE_ns2__OSDImgConfigurationExtension
#define SOAP_TYPE_ns2__OSDImgConfigurationExtension (898)
/* complex XSD type 'ns2:OSDImgConfigurationExtension': */
class SOAP_CMAC ns2__OSDImgConfigurationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OSDImgConfigurationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__OSDImgConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OSDImgConfigurationExtension, default initialized and not managed by a soap context
        virtual ns2__OSDImgConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__OSDImgConfigurationExtension); }
      public:
        /// Constructor with initializations
        ns2__OSDImgConfigurationExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__OSDImgConfigurationExtension() { }
        /// Friend allocator used by soap_new_ns2__OSDImgConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__OSDImgConfigurationExtension * SOAP_FMAC2 soap_instantiate_ns2__OSDImgConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2245 */
#ifndef SOAP_TYPE_ns2__ColorspaceRange
#define SOAP_TYPE_ns2__ColorspaceRange (899)
/* complex XSD type 'ns2:ColorspaceRange': */
class SOAP_CMAC ns2__ColorspaceRange {
      public:
        /// Required element 'ns2:X' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *X;
        /// Required element 'ns2:Y' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *Y;
        /// Required element 'ns2:Z' of XSD type 'ns2:FloatRange'
        ns2__FloatRange *Z;
        /// Required element 'ns2:Colorspace' of XSD type 'xsd:anyURI'
        std::string Colorspace;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ColorspaceRange
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ColorspaceRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ColorspaceRange, default initialized and not managed by a soap context
        virtual ns2__ColorspaceRange *soap_alloc(void) const { return SOAP_NEW(ns2__ColorspaceRange); }
      public:
        /// Constructor with initializations
        ns2__ColorspaceRange()
        {
          X = (ns2__FloatRange *)0;
          Y = (ns2__FloatRange *)0;
          Z = (ns2__FloatRange *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ColorspaceRange() { }
        /// Friend allocator used by soap_new_ns2__ColorspaceRange(struct soap*, int)
        friend SOAP_FMAC1 ns2__ColorspaceRange * SOAP_FMAC2 soap_instantiate_ns2__ColorspaceRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:25269 */
#ifndef SOAP_TYPE__ns2__union_ColorOptions
#define SOAP_TYPE__ns2__union_ColorOptions (2029)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns2__union_ColorOptions
{
        #define SOAP_UNION__ns2__union_ColorOptions_ColorList	(1)	/**< union variant selector value for member ColorList */
        std::vector<ns2__Color *> *ColorList;
        #define SOAP_UNION__ns2__union_ColorOptions_ColorspaceRange	(2)	/**< union variant selector value for member ColorspaceRange */
        std::vector<ns2__ColorspaceRange *> *ColorspaceRange;
};
#endif

/* onvifgen/onvif.h:2248 */
#ifndef SOAP_TYPE_ns2__ColorOptions
#define SOAP_TYPE_ns2__ColorOptions (900)
/* complex XSD type 'ns2:ColorOptions': */
class SOAP_CMAC ns2__ColorOptions {
      public:
        /// Union with union _ns2__union_ColorOptions variant selector __union_ColorOptions set to one of: SOAP_UNION__ns2__union_ColorOptions_ColorList SOAP_UNION__ns2__union_ColorOptions_ColorspaceRange
        int __union_ColorOptions;
        union _ns2__union_ColorOptions union_ColorOptions;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ColorOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ColorOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ColorOptions, default initialized and not managed by a soap context
        virtual ns2__ColorOptions *soap_alloc(void) const { return SOAP_NEW(ns2__ColorOptions); }
      public:
        /// Constructor with initializations
        ns2__ColorOptions()
        {
          __union_ColorOptions = -1;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ColorOptions() { }
        /// Friend allocator used by soap_new_ns2__ColorOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__ColorOptions * SOAP_FMAC2 soap_instantiate_ns2__ColorOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2251 */
#ifndef SOAP_TYPE_ns2__OSDColorOptions
#define SOAP_TYPE_ns2__OSDColorOptions (901)
/* complex XSD type 'ns2:OSDColorOptions': */
class SOAP_CMAC ns2__OSDColorOptions {
      public:
        /// Optional element 'ns2:Color' of XSD type 'ns2:ColorOptions'
        ns2__ColorOptions *Color;
        /// Optional element 'ns2:Transparent' of XSD type 'ns2:IntRange'
        ns2__IntRange *Transparent;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:OSDColorOptionsExtension'
        ns2__OSDColorOptionsExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OSDColorOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__OSDColorOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OSDColorOptions, default initialized and not managed by a soap context
        virtual ns2__OSDColorOptions *soap_alloc(void) const { return SOAP_NEW(ns2__OSDColorOptions); }
      public:
        /// Constructor with initializations
        ns2__OSDColorOptions()
        {
          Color = (ns2__ColorOptions *)0;
          Transparent = (ns2__IntRange *)0;
          Extension = (ns2__OSDColorOptionsExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__OSDColorOptions() { }
        /// Friend allocator used by soap_new_ns2__OSDColorOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__OSDColorOptions * SOAP_FMAC2 soap_instantiate_ns2__OSDColorOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2254 */
#ifndef SOAP_TYPE_ns2__OSDColorOptionsExtension
#define SOAP_TYPE_ns2__OSDColorOptionsExtension (902)
/* complex XSD type 'ns2:OSDColorOptionsExtension': */
class SOAP_CMAC ns2__OSDColorOptionsExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OSDColorOptionsExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__OSDColorOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OSDColorOptionsExtension, default initialized and not managed by a soap context
        virtual ns2__OSDColorOptionsExtension *soap_alloc(void) const { return SOAP_NEW(ns2__OSDColorOptionsExtension); }
      public:
        /// Constructor with initializations
        ns2__OSDColorOptionsExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__OSDColorOptionsExtension() { }
        /// Friend allocator used by soap_new_ns2__OSDColorOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__OSDColorOptionsExtension * SOAP_FMAC2 soap_instantiate_ns2__OSDColorOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2257 */
#ifndef SOAP_TYPE_ns2__OSDTextOptions
#define SOAP_TYPE_ns2__OSDTextOptions (903)
/* complex XSD type 'ns2:OSDTextOptions': */
class SOAP_CMAC ns2__OSDTextOptions {
      public:
        /// Required element 'ns2:Type' of XSD type 'xsd:string'
        std::vector<std::string> Type;
        /// Optional element 'ns2:FontSizeRange' of XSD type 'ns2:IntRange'
        ns2__IntRange *FontSizeRange;
        /// Optional element 'ns2:DateFormat' of XSD type 'xsd:string'
        std::vector<std::string> DateFormat;
        /// Optional element 'ns2:TimeFormat' of XSD type 'xsd:string'
        std::vector<std::string> TimeFormat;
        /// Optional element 'ns2:FontColor' of XSD type 'ns2:OSDColorOptions'
        ns2__OSDColorOptions *FontColor;
        /// Optional element 'ns2:BackgroundColor' of XSD type 'ns2:OSDColorOptions'
        ns2__OSDColorOptions *BackgroundColor;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:OSDTextOptionsExtension'
        ns2__OSDTextOptionsExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OSDTextOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__OSDTextOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OSDTextOptions, default initialized and not managed by a soap context
        virtual ns2__OSDTextOptions *soap_alloc(void) const { return SOAP_NEW(ns2__OSDTextOptions); }
      public:
        /// Constructor with initializations
        ns2__OSDTextOptions()
        {
          FontSizeRange = (ns2__IntRange *)0;
          FontColor = (ns2__OSDColorOptions *)0;
          BackgroundColor = (ns2__OSDColorOptions *)0;
          Extension = (ns2__OSDTextOptionsExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__OSDTextOptions() { }
        /// Friend allocator used by soap_new_ns2__OSDTextOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__OSDTextOptions * SOAP_FMAC2 soap_instantiate_ns2__OSDTextOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2260 */
#ifndef SOAP_TYPE_ns2__OSDTextOptionsExtension
#define SOAP_TYPE_ns2__OSDTextOptionsExtension (904)
/* complex XSD type 'ns2:OSDTextOptionsExtension': */
class SOAP_CMAC ns2__OSDTextOptionsExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OSDTextOptionsExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__OSDTextOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OSDTextOptionsExtension, default initialized and not managed by a soap context
        virtual ns2__OSDTextOptionsExtension *soap_alloc(void) const { return SOAP_NEW(ns2__OSDTextOptionsExtension); }
      public:
        /// Constructor with initializations
        ns2__OSDTextOptionsExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__OSDTextOptionsExtension() { }
        /// Friend allocator used by soap_new_ns2__OSDTextOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__OSDTextOptionsExtension * SOAP_FMAC2 soap_instantiate_ns2__OSDTextOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2263 */
#ifndef SOAP_TYPE_ns2__OSDImgOptions
#define SOAP_TYPE_ns2__OSDImgOptions (905)
/* complex XSD type 'ns2:OSDImgOptions': */
class SOAP_CMAC ns2__OSDImgOptions {
      public:
        /// Required element 'ns2:ImagePath' of XSD type 'xsd:anyURI'
        std::vector<std::string> ImagePath;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:OSDImgOptionsExtension'
        ns2__OSDImgOptionsExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OSDImgOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__OSDImgOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OSDImgOptions, default initialized and not managed by a soap context
        virtual ns2__OSDImgOptions *soap_alloc(void) const { return SOAP_NEW(ns2__OSDImgOptions); }
      public:
        /// Constructor with initializations
        ns2__OSDImgOptions()
        {
          Extension = (ns2__OSDImgOptionsExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__OSDImgOptions() { }
        /// Friend allocator used by soap_new_ns2__OSDImgOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__OSDImgOptions * SOAP_FMAC2 soap_instantiate_ns2__OSDImgOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2266 */
#ifndef SOAP_TYPE_ns2__OSDImgOptionsExtension
#define SOAP_TYPE_ns2__OSDImgOptionsExtension (906)
/* complex XSD type 'ns2:OSDImgOptionsExtension': */
class SOAP_CMAC ns2__OSDImgOptionsExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OSDImgOptionsExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__OSDImgOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OSDImgOptionsExtension, default initialized and not managed by a soap context
        virtual ns2__OSDImgOptionsExtension *soap_alloc(void) const { return SOAP_NEW(ns2__OSDImgOptionsExtension); }
      public:
        /// Constructor with initializations
        ns2__OSDImgOptionsExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__OSDImgOptionsExtension() { }
        /// Friend allocator used by soap_new_ns2__OSDImgOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__OSDImgOptionsExtension * SOAP_FMAC2 soap_instantiate_ns2__OSDImgOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2272 */
#ifndef SOAP_TYPE_ns2__OSDConfigurationExtension
#define SOAP_TYPE_ns2__OSDConfigurationExtension (908)
/* complex XSD type 'ns2:OSDConfigurationExtension': */
class SOAP_CMAC ns2__OSDConfigurationExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OSDConfigurationExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__OSDConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OSDConfigurationExtension, default initialized and not managed by a soap context
        virtual ns2__OSDConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(ns2__OSDConfigurationExtension); }
      public:
        /// Constructor with initializations
        ns2__OSDConfigurationExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__OSDConfigurationExtension() { }
        /// Friend allocator used by soap_new_ns2__OSDConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__OSDConfigurationExtension * SOAP_FMAC2 soap_instantiate_ns2__OSDConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2275 */
#ifndef SOAP_TYPE_ns2__MaximumNumberOfOSDs
#define SOAP_TYPE_ns2__MaximumNumberOfOSDs (909)
/* complex XSD type 'ns2:MaximumNumberOfOSDs': */
class SOAP_CMAC ns2__MaximumNumberOfOSDs {
      public:
        /// required attribute 'Total' of XSD type 'xsd:int'
        int Total;
        /// optional attribute 'Image' of XSD type 'xsd:int'
        int *Image;
        /// optional attribute 'PlainText' of XSD type 'xsd:int'
        int *PlainText;
        /// optional attribute 'Date' of XSD type 'xsd:int'
        int *Date;
        /// optional attribute 'Time' of XSD type 'xsd:int'
        int *Time;
        /// optional attribute 'DateAndTime' of XSD type 'xsd:int'
        int *DateAndTime;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MaximumNumberOfOSDs
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MaximumNumberOfOSDs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MaximumNumberOfOSDs, default initialized and not managed by a soap context
        virtual ns2__MaximumNumberOfOSDs *soap_alloc(void) const { return SOAP_NEW(ns2__MaximumNumberOfOSDs); }
      public:
        /// Constructor with initializations
        ns2__MaximumNumberOfOSDs()
        {
          Total = (int)0;
          Image = (int *)0;
          PlainText = (int *)0;
          Date = (int *)0;
          Time = (int *)0;
          DateAndTime = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__MaximumNumberOfOSDs() { }
        /// Friend allocator used by soap_new_ns2__MaximumNumberOfOSDs(struct soap*, int)
        friend SOAP_FMAC1 ns2__MaximumNumberOfOSDs * SOAP_FMAC2 soap_instantiate_ns2__MaximumNumberOfOSDs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2278 */
#ifndef SOAP_TYPE_ns2__OSDConfigurationOptions
#define SOAP_TYPE_ns2__OSDConfigurationOptions (910)
/* complex XSD type 'ns2:OSDConfigurationOptions': */
class SOAP_CMAC ns2__OSDConfigurationOptions {
      public:
        /// Required element 'ns2:MaximumNumberOfOSDs' of XSD type 'ns2:MaximumNumberOfOSDs'
        ns2__MaximumNumberOfOSDs *MaximumNumberOfOSDs;
        /// Required element 'ns2:Type' of XSD type 'ns2:OSDType'
        std::vector<ns2__OSDType> Type;
        /// Required element 'ns2:PositionOption' of XSD type 'xsd:string'
        std::vector<std::string> PositionOption;
        /// Optional element 'ns2:TextOption' of XSD type 'ns2:OSDTextOptions'
        ns2__OSDTextOptions *TextOption;
        /// Optional element 'ns2:ImageOption' of XSD type 'ns2:OSDImgOptions'
        ns2__OSDImgOptions *ImageOption;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:OSDConfigurationOptionsExtension'
        ns2__OSDConfigurationOptionsExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OSDConfigurationOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__OSDConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OSDConfigurationOptions, default initialized and not managed by a soap context
        virtual ns2__OSDConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(ns2__OSDConfigurationOptions); }
      public:
        /// Constructor with initializations
        ns2__OSDConfigurationOptions()
        {
          MaximumNumberOfOSDs = (ns2__MaximumNumberOfOSDs *)0;
          TextOption = (ns2__OSDTextOptions *)0;
          ImageOption = (ns2__OSDImgOptions *)0;
          Extension = (ns2__OSDConfigurationOptionsExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__OSDConfigurationOptions() { }
        /// Friend allocator used by soap_new_ns2__OSDConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 ns2__OSDConfigurationOptions * SOAP_FMAC2 soap_instantiate_ns2__OSDConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2281 */
#ifndef SOAP_TYPE_ns2__OSDConfigurationOptionsExtension
#define SOAP_TYPE_ns2__OSDConfigurationOptionsExtension (911)
/* complex XSD type 'ns2:OSDConfigurationOptionsExtension': */
class SOAP_CMAC ns2__OSDConfigurationOptionsExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OSDConfigurationOptionsExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__OSDConfigurationOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OSDConfigurationOptionsExtension, default initialized and not managed by a soap context
        virtual ns2__OSDConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(ns2__OSDConfigurationOptionsExtension); }
      public:
        /// Constructor with initializations
        ns2__OSDConfigurationOptionsExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__OSDConfigurationOptionsExtension() { }
        /// Friend allocator used by soap_new_ns2__OSDConfigurationOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__OSDConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_ns2__OSDConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2284 */
#ifndef SOAP_TYPE_ns2__FileProgress
#define SOAP_TYPE_ns2__FileProgress (912)
/* complex XSD type 'ns2:FileProgress': */
class SOAP_CMAC ns2__FileProgress {
      public:
        /// Required element 'ns2:FileName' of XSD type 'xsd:string'
        std::string FileName;
        /// Required element 'ns2:Progress' of XSD type 'xsd:float'
        float Progress;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FileProgress
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FileProgress; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FileProgress, default initialized and not managed by a soap context
        virtual ns2__FileProgress *soap_alloc(void) const { return SOAP_NEW(ns2__FileProgress); }
      public:
        /// Constructor with initializations
        ns2__FileProgress()
        {
          Progress = (float)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__FileProgress() { }
        /// Friend allocator used by soap_new_ns2__FileProgress(struct soap*, int)
        friend SOAP_FMAC1 ns2__FileProgress * SOAP_FMAC2 soap_instantiate_ns2__FileProgress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2287 */
#ifndef SOAP_TYPE_ns2__ArrayOfFileProgress
#define SOAP_TYPE_ns2__ArrayOfFileProgress (913)
/* complex XSD type 'ns2:ArrayOfFileProgress': */
class SOAP_CMAC ns2__ArrayOfFileProgress {
      public:
        /// Optional element 'ns2:FileProgress' of XSD type 'ns2:FileProgress'
        std::vector<ns2__FileProgress *> FileProgress;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ArrayOfFileProgressExtension'
        ns2__ArrayOfFileProgressExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ArrayOfFileProgress
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ArrayOfFileProgress; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ArrayOfFileProgress, default initialized and not managed by a soap context
        virtual ns2__ArrayOfFileProgress *soap_alloc(void) const { return SOAP_NEW(ns2__ArrayOfFileProgress); }
      public:
        /// Constructor with initializations
        ns2__ArrayOfFileProgress()
        {
          Extension = (ns2__ArrayOfFileProgressExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ArrayOfFileProgress() { }
        /// Friend allocator used by soap_new_ns2__ArrayOfFileProgress(struct soap*, int)
        friend SOAP_FMAC1 ns2__ArrayOfFileProgress * SOAP_FMAC2 soap_instantiate_ns2__ArrayOfFileProgress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2290 */
#ifndef SOAP_TYPE_ns2__ArrayOfFileProgressExtension
#define SOAP_TYPE_ns2__ArrayOfFileProgressExtension (914)
/* complex XSD type 'ns2:ArrayOfFileProgressExtension': */
class SOAP_CMAC ns2__ArrayOfFileProgressExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ArrayOfFileProgressExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ArrayOfFileProgressExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ArrayOfFileProgressExtension, default initialized and not managed by a soap context
        virtual ns2__ArrayOfFileProgressExtension *soap_alloc(void) const { return SOAP_NEW(ns2__ArrayOfFileProgressExtension); }
      public:
        /// Constructor with initializations
        ns2__ArrayOfFileProgressExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ArrayOfFileProgressExtension() { }
        /// Friend allocator used by soap_new_ns2__ArrayOfFileProgressExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__ArrayOfFileProgressExtension * SOAP_FMAC2 soap_instantiate_ns2__ArrayOfFileProgressExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2293 */
#ifndef SOAP_TYPE_ns2__StorageReferencePath
#define SOAP_TYPE_ns2__StorageReferencePath (915)
/* complex XSD type 'ns2:StorageReferencePath': */
class SOAP_CMAC ns2__StorageReferencePath {
      public:
        /// Required element 'ns2:StorageToken' of XSD type 'ns2:ReferenceToken'
        std::string StorageToken;
        /// Optional element 'ns2:RelativePath' of XSD type 'xsd:string'
        std::string *RelativePath;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:StorageReferencePathExtension'
        ns2__StorageReferencePathExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__StorageReferencePath
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__StorageReferencePath; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__StorageReferencePath, default initialized and not managed by a soap context
        virtual ns2__StorageReferencePath *soap_alloc(void) const { return SOAP_NEW(ns2__StorageReferencePath); }
      public:
        /// Constructor with initializations
        ns2__StorageReferencePath()
        {
          RelativePath = (std::string *)0;
          Extension = (ns2__StorageReferencePathExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__StorageReferencePath() { }
        /// Friend allocator used by soap_new_ns2__StorageReferencePath(struct soap*, int)
        friend SOAP_FMAC1 ns2__StorageReferencePath * SOAP_FMAC2 soap_instantiate_ns2__StorageReferencePath(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2296 */
#ifndef SOAP_TYPE_ns2__StorageReferencePathExtension
#define SOAP_TYPE_ns2__StorageReferencePathExtension (916)
/* complex XSD type 'ns2:StorageReferencePathExtension': */
class SOAP_CMAC ns2__StorageReferencePathExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__StorageReferencePathExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__StorageReferencePathExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__StorageReferencePathExtension, default initialized and not managed by a soap context
        virtual ns2__StorageReferencePathExtension *soap_alloc(void) const { return SOAP_NEW(ns2__StorageReferencePathExtension); }
      public:
        /// Constructor with initializations
        ns2__StorageReferencePathExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__StorageReferencePathExtension() { }
        /// Friend allocator used by soap_new_ns2__StorageReferencePathExtension(struct soap*, int)
        friend SOAP_FMAC1 ns2__StorageReferencePathExtension * SOAP_FMAC2 soap_instantiate_ns2__StorageReferencePathExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2299 */
#ifndef SOAP_TYPE__ns2__Message
#define SOAP_TYPE__ns2__Message (917)
/* complex XSD type 'ns2:Message': */
class SOAP_CMAC _ns2__Message {
      public:
        /// Optional element 'ns2:Source' of XSD type 'ns2:ItemList'
        ns2__ItemList *Source;
        /// Optional element 'ns2:Key' of XSD type 'ns2:ItemList'
        ns2__ItemList *Key;
        /// Optional element 'ns2:Data' of XSD type 'ns2:ItemList'
        ns2__ItemList *Data;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:MessageExtension'
        ns2__MessageExtension *Extension;
        /// required attribute 'UtcTime' of XSD type 'xsd:dateTime'
        time_t UtcTime;
        /// optional attribute 'PropertyOperation' of XSD type 'ns2:PropertyOperation'
        ns2__PropertyOperation *PropertyOperation;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__Message
        virtual int soap_type(void) const { return SOAP_TYPE__ns2__Message; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__Message, default initialized and not managed by a soap context
        virtual _ns2__Message *soap_alloc(void) const { return SOAP_NEW(_ns2__Message); }
      public:
        /// Constructor with initializations
        _ns2__Message()
        {
          Source = (ns2__ItemList *)0;
          Key = (ns2__ItemList *)0;
          Data = (ns2__ItemList *)0;
          Extension = (ns2__MessageExtension *)0;
          UtcTime = (time_t)0;
          PropertyOperation = (ns2__PropertyOperation *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns2__Message() { }
        /// Friend allocator used by soap_new__ns2__Message(struct soap*, int)
        friend SOAP_FMAC1 _ns2__Message * SOAP_FMAC2 soap_instantiate__ns2__Message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2302 */
#ifndef SOAP_TYPE_ns3__QueryExpressionType
#define SOAP_TYPE_ns3__QueryExpressionType (918)
/* complex XSD type 'ns3:QueryExpressionType': */
class SOAP_CMAC ns3__QueryExpressionType {
      public:
        /// XML DOM element node graph
        struct soap_dom_element __any;
        /// required attribute 'Dialect' of XSD type 'xsd:anyURI'
        std::string Dialect;
        /// XML DOM element node graph
        struct soap_dom_element __mixed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__QueryExpressionType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__QueryExpressionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__QueryExpressionType, default initialized and not managed by a soap context
        virtual ns3__QueryExpressionType *soap_alloc(void) const { return SOAP_NEW(ns3__QueryExpressionType); }
      public:
        /// Constructor with initializations
        ns3__QueryExpressionType()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns3__QueryExpressionType() { }
        /// Friend allocator used by soap_new_ns3__QueryExpressionType(struct soap*, int)
        friend SOAP_FMAC1 ns3__QueryExpressionType * SOAP_FMAC2 soap_instantiate_ns3__QueryExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2305 */
#ifndef SOAP_TYPE_ns3__TopicExpressionType
#define SOAP_TYPE_ns3__TopicExpressionType (919)
/* complex XSD type 'ns3:TopicExpressionType': */
class SOAP_CMAC ns3__TopicExpressionType {
      public:
        /// XML DOM element node graph
        struct soap_dom_element __any;
        /// required attribute 'Dialect' of XSD type 'xsd:anyURI'
        std::string Dialect;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// XML DOM element node graph
        struct soap_dom_element __mixed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__TopicExpressionType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__TopicExpressionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__TopicExpressionType, default initialized and not managed by a soap context
        virtual ns3__TopicExpressionType *soap_alloc(void) const { return SOAP_NEW(ns3__TopicExpressionType); }
      public:
        /// Constructor with initializations
        ns3__TopicExpressionType()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns3__TopicExpressionType() { }
        /// Friend allocator used by soap_new_ns3__TopicExpressionType(struct soap*, int)
        friend SOAP_FMAC1 ns3__TopicExpressionType * SOAP_FMAC2 soap_instantiate_ns3__TopicExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2308 */
#ifndef SOAP_TYPE_ns3__FilterType
#define SOAP_TYPE_ns3__FilterType (920)
/* Type ns3__FilterType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:FilterType': */
class SOAP_CMAC ns3__FilterType {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__FilterType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__FilterType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__FilterType, default initialized and not managed by a soap context
        virtual ns3__FilterType *soap_alloc(void) const { return SOAP_NEW(ns3__FilterType); }
      public:
        /// Constructor with initializations
        ns3__FilterType()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns3__FilterType() { }
        /// Friend allocator used by soap_new_ns3__FilterType(struct soap*, int)
        friend SOAP_FMAC1 ns3__FilterType * SOAP_FMAC2 soap_instantiate_ns3__FilterType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2311 */
#ifndef SOAP_TYPE_ns3__SubscriptionPolicyType
#define SOAP_TYPE_ns3__SubscriptionPolicyType (921)
/* complex XSD type 'ns3:SubscriptionPolicyType': */
class SOAP_CMAC ns3__SubscriptionPolicyType {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__SubscriptionPolicyType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__SubscriptionPolicyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__SubscriptionPolicyType, default initialized and not managed by a soap context
        virtual ns3__SubscriptionPolicyType *soap_alloc(void) const { return SOAP_NEW(ns3__SubscriptionPolicyType); }
      public:
        /// Constructor with initializations
        ns3__SubscriptionPolicyType()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns3__SubscriptionPolicyType() { }
        /// Friend allocator used by soap_new_ns3__SubscriptionPolicyType(struct soap*, int)
        friend SOAP_FMAC1 ns3__SubscriptionPolicyType * SOAP_FMAC2 soap_instantiate_ns3__SubscriptionPolicyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:26029 */
#ifndef SOAP_TYPE__ns3__NotificationMessageHolderType_Message
#define SOAP_TYPE__ns3__NotificationMessageHolderType_Message (2048)
/* complex XSD type 'ns3:NotificationMessageHolderType-Message': */
class SOAP_CMAC _ns3__NotificationMessageHolderType_Message {
      public:
        /// XML DOM element node graph
        struct soap_dom_element __any;
      public:
        /// Return unique type id SOAP_TYPE__ns3__NotificationMessageHolderType_Message
        virtual int soap_type(void) const { return SOAP_TYPE__ns3__NotificationMessageHolderType_Message; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__NotificationMessageHolderType_Message, default initialized and not managed by a soap context
        virtual _ns3__NotificationMessageHolderType_Message *soap_alloc(void) const { return SOAP_NEW(_ns3__NotificationMessageHolderType_Message); }
      public:
        /// Constructor with initializations
        _ns3__NotificationMessageHolderType_Message()
        {
        }
        virtual ~_ns3__NotificationMessageHolderType_Message() { }
        /// Friend allocator used by soap_new__ns3__NotificationMessageHolderType_Message(struct soap*, int)
        friend SOAP_FMAC1 _ns3__NotificationMessageHolderType_Message * SOAP_FMAC2 soap_instantiate__ns3__NotificationMessageHolderType_Message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2314 */
#ifndef SOAP_TYPE_ns3__NotificationMessageHolderType
#define SOAP_TYPE_ns3__NotificationMessageHolderType (922)
/* complex XSD type 'ns3:NotificationMessageHolderType': */
class SOAP_CMAC ns3__NotificationMessageHolderType {
      public:
        /// Optional element 'ns3:SubscriptionReference' of XSD type 'ns14:EndpointReferenceType'
        ns14__EndpointReferenceType *SubscriptionReference;
        /// Optional element 'ns3:Topic' of XSD type 'ns3:TopicExpressionType'
        ns3__TopicExpressionType *Topic;
        /// Optional element 'ns3:ProducerReference' of XSD type 'ns14:EndpointReferenceType'
        ns14__EndpointReferenceType *ProducerReference;
        /// Required element 'ns3:Message' of XSD type 'ns3:NotificationMessageHolderType-Message'
        _ns3__NotificationMessageHolderType_Message Message;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__NotificationMessageHolderType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__NotificationMessageHolderType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__NotificationMessageHolderType, default initialized and not managed by a soap context
        virtual ns3__NotificationMessageHolderType *soap_alloc(void) const { return SOAP_NEW(ns3__NotificationMessageHolderType); }
      public:
        /// Constructor with initializations
        ns3__NotificationMessageHolderType()
        {
          SubscriptionReference = (ns14__EndpointReferenceType *)0;
          Topic = (ns3__TopicExpressionType *)0;
          ProducerReference = (ns14__EndpointReferenceType *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns3__NotificationMessageHolderType() { }
        /// Friend allocator used by soap_new_ns3__NotificationMessageHolderType(struct soap*, int)
        friend SOAP_FMAC1 ns3__NotificationMessageHolderType * SOAP_FMAC2 soap_instantiate_ns3__NotificationMessageHolderType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2377 */
#ifndef SOAP_TYPE__ns3__NotificationProducerRP
#define SOAP_TYPE__ns3__NotificationProducerRP (943)
/* complex XSD type 'ns3:NotificationProducerRP': */
class SOAP_CMAC _ns3__NotificationProducerRP {
      public:
        /// Optional element 'ns3:TopicExpression' of XSD type 'ns3:TopicExpressionType'
        std::vector<ns3__TopicExpressionType *> TopicExpression;
        /// Optional element 'ns3:FixedTopicSet' of XSD type 'xsd:boolean'
        bool FixedTopicSet;	///< default = (bool)1
        /// Optional element 'ns3:TopicExpressionDialect' of XSD type 'xsd:anyURI'
        std::vector<std::string> TopicExpressionDialect;
        /// Optional element 'ns6:TopicSet' of XSD type 'ns6:TopicSetType'
        ns6__TopicSetType *ns6__TopicSet;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__NotificationProducerRP
        virtual int soap_type(void) const { return SOAP_TYPE__ns3__NotificationProducerRP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__NotificationProducerRP, default initialized and not managed by a soap context
        virtual _ns3__NotificationProducerRP *soap_alloc(void) const { return SOAP_NEW(_ns3__NotificationProducerRP); }
      public:
        /// Constructor with initializations
        _ns3__NotificationProducerRP()
        {
          FixedTopicSet = (bool)1;
          ns6__TopicSet = (ns6__TopicSetType *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns3__NotificationProducerRP() { }
        /// Friend allocator used by soap_new__ns3__NotificationProducerRP(struct soap*, int)
        friend SOAP_FMAC1 _ns3__NotificationProducerRP * SOAP_FMAC2 soap_instantiate__ns3__NotificationProducerRP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2380 */
#ifndef SOAP_TYPE__ns3__SubscriptionManagerRP
#define SOAP_TYPE__ns3__SubscriptionManagerRP (944)
/* complex XSD type 'ns3:SubscriptionManagerRP': */
class SOAP_CMAC _ns3__SubscriptionManagerRP {
      public:
        /// Required element 'ns3:ConsumerReference' of XSD type 'ns14:EndpointReferenceType'
        ns14__EndpointReferenceType *ConsumerReference;
        /// Optional element 'ns3:Filter' of XSD type 'ns3:FilterType'
        ns3__FilterType *Filter;
        /// Optional element 'ns3:SubscriptionPolicy' of XSD type 'ns3:SubscriptionPolicyType'
        ns3__SubscriptionPolicyType *SubscriptionPolicy;
        /// Optional element 'ns3:CreationTime' of XSD type 'xsd:dateTime'
        time_t *CreationTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__SubscriptionManagerRP
        virtual int soap_type(void) const { return SOAP_TYPE__ns3__SubscriptionManagerRP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__SubscriptionManagerRP, default initialized and not managed by a soap context
        virtual _ns3__SubscriptionManagerRP *soap_alloc(void) const { return SOAP_NEW(_ns3__SubscriptionManagerRP); }
      public:
        /// Constructor with initializations
        _ns3__SubscriptionManagerRP()
        {
          ConsumerReference = (ns14__EndpointReferenceType *)0;
          Filter = (ns3__FilterType *)0;
          SubscriptionPolicy = (ns3__SubscriptionPolicyType *)0;
          CreationTime = (time_t *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns3__SubscriptionManagerRP() { }
        /// Friend allocator used by soap_new__ns3__SubscriptionManagerRP(struct soap*, int)
        friend SOAP_FMAC1 _ns3__SubscriptionManagerRP * SOAP_FMAC2 soap_instantiate__ns3__SubscriptionManagerRP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2383 */
#ifndef SOAP_TYPE__ns3__Notify
#define SOAP_TYPE__ns3__Notify (945)
/* complex XSD type 'ns3:Notify': */
class SOAP_CMAC _ns3__Notify {
      public:
        /// Required element 'ns3:NotificationMessage' of XSD type 'ns3:NotificationMessageHolderType'
        std::vector<ns3__NotificationMessageHolderType *> NotificationMessage;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__Notify
        virtual int soap_type(void) const { return SOAP_TYPE__ns3__Notify; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__Notify, default initialized and not managed by a soap context
        virtual _ns3__Notify *soap_alloc(void) const { return SOAP_NEW(_ns3__Notify); }
      public:
        /// Constructor with initializations
        _ns3__Notify()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns3__Notify() { }
        /// Friend allocator used by soap_new__ns3__Notify(struct soap*, int)
        friend SOAP_FMAC1 _ns3__Notify * SOAP_FMAC2 soap_instantiate__ns3__Notify(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2386 */
#ifndef SOAP_TYPE__ns3__UseRaw
#define SOAP_TYPE__ns3__UseRaw (946)
/* complex XSD type 'ns3:UseRaw': */
class SOAP_CMAC _ns3__UseRaw {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__UseRaw
        virtual int soap_type(void) const { return SOAP_TYPE__ns3__UseRaw; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__UseRaw, default initialized and not managed by a soap context
        virtual _ns3__UseRaw *soap_alloc(void) const { return SOAP_NEW(_ns3__UseRaw); }
      public:
        /// Constructor with initializations
        _ns3__UseRaw()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns3__UseRaw() { }
        /// Friend allocator used by soap_new__ns3__UseRaw(struct soap*, int)
        friend SOAP_FMAC1 _ns3__UseRaw * SOAP_FMAC2 soap_instantiate__ns3__UseRaw(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:26176 */
#ifndef SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy
#define SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy (2054)
/* complex XSD type 'ns3:Subscribe-SubscriptionPolicy': */
class SOAP_CMAC _ns3__Subscribe_SubscriptionPolicy {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
      public:
        /// Return unique type id SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy
        virtual int soap_type(void) const { return SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__Subscribe_SubscriptionPolicy, default initialized and not managed by a soap context
        virtual _ns3__Subscribe_SubscriptionPolicy *soap_alloc(void) const { return SOAP_NEW(_ns3__Subscribe_SubscriptionPolicy); }
      public:
        /// Constructor with initializations
        _ns3__Subscribe_SubscriptionPolicy()
        {
        }
        virtual ~_ns3__Subscribe_SubscriptionPolicy() { }
        /// Friend allocator used by soap_new__ns3__Subscribe_SubscriptionPolicy(struct soap*, int)
        friend SOAP_FMAC1 _ns3__Subscribe_SubscriptionPolicy * SOAP_FMAC2 soap_instantiate__ns3__Subscribe_SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2389 */
#ifndef SOAP_TYPE__ns3__Subscribe
#define SOAP_TYPE__ns3__Subscribe (947)
/* complex XSD type 'ns3:Subscribe': */
class SOAP_CMAC _ns3__Subscribe {
      public:
        /// Required element 'ns3:ConsumerReference' of XSD type 'ns14:EndpointReferenceType'
        ns14__EndpointReferenceType *ConsumerReference;
        /// Optional element 'ns3:Filter' of XSD type 'ns3:FilterType'
        ns3__FilterType *Filter;
        /// Optional element 'ns3:InitialTerminationTime' of XSD type 'ns3:AbsoluteOrRelativeTimeType'
        std::string *InitialTerminationTime;
        /// Optional element 'ns3:SubscriptionPolicy' of XSD type 'ns3:Subscribe-SubscriptionPolicy'
        _ns3__Subscribe_SubscriptionPolicy *SubscriptionPolicy;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__Subscribe
        virtual int soap_type(void) const { return SOAP_TYPE__ns3__Subscribe; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__Subscribe, default initialized and not managed by a soap context
        virtual _ns3__Subscribe *soap_alloc(void) const { return SOAP_NEW(_ns3__Subscribe); }
      public:
        /// Constructor with initializations
        _ns3__Subscribe()
        {
          ConsumerReference = (ns14__EndpointReferenceType *)0;
          Filter = (ns3__FilterType *)0;
          InitialTerminationTime = (std::string *)0;
          SubscriptionPolicy = (_ns3__Subscribe_SubscriptionPolicy *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns3__Subscribe() { }
        /// Friend allocator used by soap_new__ns3__Subscribe(struct soap*, int)
        friend SOAP_FMAC1 _ns3__Subscribe * SOAP_FMAC2 soap_instantiate__ns3__Subscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2392 */
#ifndef SOAP_TYPE__ns3__SubscribeResponse
#define SOAP_TYPE__ns3__SubscribeResponse (948)
/* complex XSD type 'ns3:SubscribeResponse': */
class SOAP_CMAC _ns3__SubscribeResponse {
      public:
        /// Required element 'ns3:SubscriptionReference' of XSD type 'ns14:EndpointReferenceType'
        ns14__EndpointReferenceType *SubscriptionReference;
        /// Optional element 'ns3:CurrentTime' of XSD type 'xsd:dateTime'
        time_t *CurrentTime;
        /// Optional element 'ns3:TerminationTime' of XSD type 'xsd:dateTime'
        time_t *TerminationTime;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__SubscribeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns3__SubscribeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__SubscribeResponse, default initialized and not managed by a soap context
        virtual _ns3__SubscribeResponse *soap_alloc(void) const { return SOAP_NEW(_ns3__SubscribeResponse); }
      public:
        /// Constructor with initializations
        _ns3__SubscribeResponse()
        {
          SubscriptionReference = (ns14__EndpointReferenceType *)0;
          CurrentTime = (time_t *)0;
          TerminationTime = (time_t *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns3__SubscribeResponse() { }
        /// Friend allocator used by soap_new__ns3__SubscribeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns3__SubscribeResponse * SOAP_FMAC2 soap_instantiate__ns3__SubscribeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2395 */
#ifndef SOAP_TYPE__ns3__GetCurrentMessage
#define SOAP_TYPE__ns3__GetCurrentMessage (949)
/* complex XSD type 'ns3:GetCurrentMessage': */
class SOAP_CMAC _ns3__GetCurrentMessage {
      public:
        /// Required element 'ns3:Topic' of XSD type 'ns3:TopicExpressionType'
        ns3__TopicExpressionType *Topic;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__GetCurrentMessage
        virtual int soap_type(void) const { return SOAP_TYPE__ns3__GetCurrentMessage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__GetCurrentMessage, default initialized and not managed by a soap context
        virtual _ns3__GetCurrentMessage *soap_alloc(void) const { return SOAP_NEW(_ns3__GetCurrentMessage); }
      public:
        /// Constructor with initializations
        _ns3__GetCurrentMessage()
        {
          Topic = (ns3__TopicExpressionType *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns3__GetCurrentMessage() { }
        /// Friend allocator used by soap_new__ns3__GetCurrentMessage(struct soap*, int)
        friend SOAP_FMAC1 _ns3__GetCurrentMessage * SOAP_FMAC2 soap_instantiate__ns3__GetCurrentMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2398 */
#ifndef SOAP_TYPE__ns3__GetCurrentMessageResponse
#define SOAP_TYPE__ns3__GetCurrentMessageResponse (950)
/* complex XSD type 'ns3:GetCurrentMessageResponse': */
class SOAP_CMAC _ns3__GetCurrentMessageResponse {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__GetCurrentMessageResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns3__GetCurrentMessageResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__GetCurrentMessageResponse, default initialized and not managed by a soap context
        virtual _ns3__GetCurrentMessageResponse *soap_alloc(void) const { return SOAP_NEW(_ns3__GetCurrentMessageResponse); }
      public:
        /// Constructor with initializations
        _ns3__GetCurrentMessageResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns3__GetCurrentMessageResponse() { }
        /// Friend allocator used by soap_new__ns3__GetCurrentMessageResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns3__GetCurrentMessageResponse * SOAP_FMAC2 soap_instantiate__ns3__GetCurrentMessageResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2401 */
#ifndef SOAP_TYPE__ns3__GetMessages
#define SOAP_TYPE__ns3__GetMessages (951)
/* complex XSD type 'ns3:GetMessages': */
class SOAP_CMAC _ns3__GetMessages {
      public:
        /// Optional element 'ns3:MaximumNumber' of XSD type 'xsd:nonNegativeInteger'
        std::string *MaximumNumber;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__GetMessages
        virtual int soap_type(void) const { return SOAP_TYPE__ns3__GetMessages; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__GetMessages, default initialized and not managed by a soap context
        virtual _ns3__GetMessages *soap_alloc(void) const { return SOAP_NEW(_ns3__GetMessages); }
      public:
        /// Constructor with initializations
        _ns3__GetMessages()
        {
          MaximumNumber = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns3__GetMessages() { }
        /// Friend allocator used by soap_new__ns3__GetMessages(struct soap*, int)
        friend SOAP_FMAC1 _ns3__GetMessages * SOAP_FMAC2 soap_instantiate__ns3__GetMessages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2404 */
#ifndef SOAP_TYPE__ns3__GetMessagesResponse
#define SOAP_TYPE__ns3__GetMessagesResponse (952)
/* complex XSD type 'ns3:GetMessagesResponse': */
class SOAP_CMAC _ns3__GetMessagesResponse {
      public:
        /// Optional element 'ns3:NotificationMessage' of XSD type 'ns3:NotificationMessageHolderType'
        std::vector<ns3__NotificationMessageHolderType *> NotificationMessage;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__GetMessagesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns3__GetMessagesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__GetMessagesResponse, default initialized and not managed by a soap context
        virtual _ns3__GetMessagesResponse *soap_alloc(void) const { return SOAP_NEW(_ns3__GetMessagesResponse); }
      public:
        /// Constructor with initializations
        _ns3__GetMessagesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns3__GetMessagesResponse() { }
        /// Friend allocator used by soap_new__ns3__GetMessagesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns3__GetMessagesResponse * SOAP_FMAC2 soap_instantiate__ns3__GetMessagesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2407 */
#ifndef SOAP_TYPE__ns3__DestroyPullPoint
#define SOAP_TYPE__ns3__DestroyPullPoint (953)
/* complex XSD type 'ns3:DestroyPullPoint': */
class SOAP_CMAC _ns3__DestroyPullPoint {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__DestroyPullPoint
        virtual int soap_type(void) const { return SOAP_TYPE__ns3__DestroyPullPoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__DestroyPullPoint, default initialized and not managed by a soap context
        virtual _ns3__DestroyPullPoint *soap_alloc(void) const { return SOAP_NEW(_ns3__DestroyPullPoint); }
      public:
        /// Constructor with initializations
        _ns3__DestroyPullPoint()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns3__DestroyPullPoint() { }
        /// Friend allocator used by soap_new__ns3__DestroyPullPoint(struct soap*, int)
        friend SOAP_FMAC1 _ns3__DestroyPullPoint * SOAP_FMAC2 soap_instantiate__ns3__DestroyPullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2410 */
#ifndef SOAP_TYPE__ns3__DestroyPullPointResponse
#define SOAP_TYPE__ns3__DestroyPullPointResponse (954)
/* complex XSD type 'ns3:DestroyPullPointResponse': */
class SOAP_CMAC _ns3__DestroyPullPointResponse {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__DestroyPullPointResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns3__DestroyPullPointResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__DestroyPullPointResponse, default initialized and not managed by a soap context
        virtual _ns3__DestroyPullPointResponse *soap_alloc(void) const { return SOAP_NEW(_ns3__DestroyPullPointResponse); }
      public:
        /// Constructor with initializations
        _ns3__DestroyPullPointResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns3__DestroyPullPointResponse() { }
        /// Friend allocator used by soap_new__ns3__DestroyPullPointResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns3__DestroyPullPointResponse * SOAP_FMAC2 soap_instantiate__ns3__DestroyPullPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2413 */
#ifndef SOAP_TYPE__ns3__CreatePullPoint
#define SOAP_TYPE__ns3__CreatePullPoint (955)
/* complex XSD type 'ns3:CreatePullPoint': */
class SOAP_CMAC _ns3__CreatePullPoint {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__CreatePullPoint
        virtual int soap_type(void) const { return SOAP_TYPE__ns3__CreatePullPoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__CreatePullPoint, default initialized and not managed by a soap context
        virtual _ns3__CreatePullPoint *soap_alloc(void) const { return SOAP_NEW(_ns3__CreatePullPoint); }
      public:
        /// Constructor with initializations
        _ns3__CreatePullPoint()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns3__CreatePullPoint() { }
        /// Friend allocator used by soap_new__ns3__CreatePullPoint(struct soap*, int)
        friend SOAP_FMAC1 _ns3__CreatePullPoint * SOAP_FMAC2 soap_instantiate__ns3__CreatePullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2416 */
#ifndef SOAP_TYPE__ns3__CreatePullPointResponse
#define SOAP_TYPE__ns3__CreatePullPointResponse (956)
/* complex XSD type 'ns3:CreatePullPointResponse': */
class SOAP_CMAC _ns3__CreatePullPointResponse {
      public:
        /// Required element 'ns3:PullPoint' of XSD type 'ns14:EndpointReferenceType'
        ns14__EndpointReferenceType *PullPoint;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__CreatePullPointResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns3__CreatePullPointResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__CreatePullPointResponse, default initialized and not managed by a soap context
        virtual _ns3__CreatePullPointResponse *soap_alloc(void) const { return SOAP_NEW(_ns3__CreatePullPointResponse); }
      public:
        /// Constructor with initializations
        _ns3__CreatePullPointResponse()
        {
          PullPoint = (ns14__EndpointReferenceType *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns3__CreatePullPointResponse() { }
        /// Friend allocator used by soap_new__ns3__CreatePullPointResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns3__CreatePullPointResponse * SOAP_FMAC2 soap_instantiate__ns3__CreatePullPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2419 */
#ifndef SOAP_TYPE__ns3__Renew
#define SOAP_TYPE__ns3__Renew (957)
/* complex XSD type 'ns3:Renew': */
class SOAP_CMAC _ns3__Renew {
      public:
        /// Required nillable (xsi:nil when NULL) element 'ns3:TerminationTime' of XSD type 'ns3:AbsoluteOrRelativeTimeType'
        std::string *TerminationTime;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__Renew
        virtual int soap_type(void) const { return SOAP_TYPE__ns3__Renew; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__Renew, default initialized and not managed by a soap context
        virtual _ns3__Renew *soap_alloc(void) const { return SOAP_NEW(_ns3__Renew); }
      public:
        /// Constructor with initializations
        _ns3__Renew()
        {
          TerminationTime = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns3__Renew() { }
        /// Friend allocator used by soap_new__ns3__Renew(struct soap*, int)
        friend SOAP_FMAC1 _ns3__Renew * SOAP_FMAC2 soap_instantiate__ns3__Renew(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2422 */
#ifndef SOAP_TYPE__ns3__RenewResponse
#define SOAP_TYPE__ns3__RenewResponse (958)
/* complex XSD type 'ns3:RenewResponse': */
class SOAP_CMAC _ns3__RenewResponse {
      public:
        /// Required element 'ns3:TerminationTime' of XSD type 'xsd:dateTime'
        time_t TerminationTime;
        /// Optional element 'ns3:CurrentTime' of XSD type 'xsd:dateTime'
        time_t *CurrentTime;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__RenewResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns3__RenewResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__RenewResponse, default initialized and not managed by a soap context
        virtual _ns3__RenewResponse *soap_alloc(void) const { return SOAP_NEW(_ns3__RenewResponse); }
      public:
        /// Constructor with initializations
        _ns3__RenewResponse()
        {
          TerminationTime = (time_t)0;
          CurrentTime = (time_t *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns3__RenewResponse() { }
        /// Friend allocator used by soap_new__ns3__RenewResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns3__RenewResponse * SOAP_FMAC2 soap_instantiate__ns3__RenewResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2425 */
#ifndef SOAP_TYPE__ns3__Unsubscribe
#define SOAP_TYPE__ns3__Unsubscribe (959)
/* complex XSD type 'ns3:Unsubscribe': */
class SOAP_CMAC _ns3__Unsubscribe {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__Unsubscribe
        virtual int soap_type(void) const { return SOAP_TYPE__ns3__Unsubscribe; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__Unsubscribe, default initialized and not managed by a soap context
        virtual _ns3__Unsubscribe *soap_alloc(void) const { return SOAP_NEW(_ns3__Unsubscribe); }
      public:
        /// Constructor with initializations
        _ns3__Unsubscribe()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns3__Unsubscribe() { }
        /// Friend allocator used by soap_new__ns3__Unsubscribe(struct soap*, int)
        friend SOAP_FMAC1 _ns3__Unsubscribe * SOAP_FMAC2 soap_instantiate__ns3__Unsubscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2428 */
#ifndef SOAP_TYPE__ns3__UnsubscribeResponse
#define SOAP_TYPE__ns3__UnsubscribeResponse (960)
/* complex XSD type 'ns3:UnsubscribeResponse': */
class SOAP_CMAC _ns3__UnsubscribeResponse {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__UnsubscribeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns3__UnsubscribeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__UnsubscribeResponse, default initialized and not managed by a soap context
        virtual _ns3__UnsubscribeResponse *soap_alloc(void) const { return SOAP_NEW(_ns3__UnsubscribeResponse); }
      public:
        /// Constructor with initializations
        _ns3__UnsubscribeResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns3__UnsubscribeResponse() { }
        /// Friend allocator used by soap_new__ns3__UnsubscribeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns3__UnsubscribeResponse * SOAP_FMAC2 soap_instantiate__ns3__UnsubscribeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2431 */
#ifndef SOAP_TYPE__ns3__PauseSubscription
#define SOAP_TYPE__ns3__PauseSubscription (961)
/* complex XSD type 'ns3:PauseSubscription': */
class SOAP_CMAC _ns3__PauseSubscription {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__PauseSubscription
        virtual int soap_type(void) const { return SOAP_TYPE__ns3__PauseSubscription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__PauseSubscription, default initialized and not managed by a soap context
        virtual _ns3__PauseSubscription *soap_alloc(void) const { return SOAP_NEW(_ns3__PauseSubscription); }
      public:
        /// Constructor with initializations
        _ns3__PauseSubscription()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns3__PauseSubscription() { }
        /// Friend allocator used by soap_new__ns3__PauseSubscription(struct soap*, int)
        friend SOAP_FMAC1 _ns3__PauseSubscription * SOAP_FMAC2 soap_instantiate__ns3__PauseSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2434 */
#ifndef SOAP_TYPE__ns3__PauseSubscriptionResponse
#define SOAP_TYPE__ns3__PauseSubscriptionResponse (962)
/* complex XSD type 'ns3:PauseSubscriptionResponse': */
class SOAP_CMAC _ns3__PauseSubscriptionResponse {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__PauseSubscriptionResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns3__PauseSubscriptionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__PauseSubscriptionResponse, default initialized and not managed by a soap context
        virtual _ns3__PauseSubscriptionResponse *soap_alloc(void) const { return SOAP_NEW(_ns3__PauseSubscriptionResponse); }
      public:
        /// Constructor with initializations
        _ns3__PauseSubscriptionResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns3__PauseSubscriptionResponse() { }
        /// Friend allocator used by soap_new__ns3__PauseSubscriptionResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns3__PauseSubscriptionResponse * SOAP_FMAC2 soap_instantiate__ns3__PauseSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2437 */
#ifndef SOAP_TYPE__ns3__ResumeSubscription
#define SOAP_TYPE__ns3__ResumeSubscription (963)
/* complex XSD type 'ns3:ResumeSubscription': */
class SOAP_CMAC _ns3__ResumeSubscription {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__ResumeSubscription
        virtual int soap_type(void) const { return SOAP_TYPE__ns3__ResumeSubscription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__ResumeSubscription, default initialized and not managed by a soap context
        virtual _ns3__ResumeSubscription *soap_alloc(void) const { return SOAP_NEW(_ns3__ResumeSubscription); }
      public:
        /// Constructor with initializations
        _ns3__ResumeSubscription()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns3__ResumeSubscription() { }
        /// Friend allocator used by soap_new__ns3__ResumeSubscription(struct soap*, int)
        friend SOAP_FMAC1 _ns3__ResumeSubscription * SOAP_FMAC2 soap_instantiate__ns3__ResumeSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2440 */
#ifndef SOAP_TYPE__ns3__ResumeSubscriptionResponse
#define SOAP_TYPE__ns3__ResumeSubscriptionResponse (964)
/* complex XSD type 'ns3:ResumeSubscriptionResponse': */
class SOAP_CMAC _ns3__ResumeSubscriptionResponse {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__ResumeSubscriptionResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns3__ResumeSubscriptionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__ResumeSubscriptionResponse, default initialized and not managed by a soap context
        virtual _ns3__ResumeSubscriptionResponse *soap_alloc(void) const { return SOAP_NEW(_ns3__ResumeSubscriptionResponse); }
      public:
        /// Constructor with initializations
        _ns3__ResumeSubscriptionResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns3__ResumeSubscriptionResponse() { }
        /// Friend allocator used by soap_new__ns3__ResumeSubscriptionResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns3__ResumeSubscriptionResponse * SOAP_FMAC2 soap_instantiate__ns3__ResumeSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2443 */
#ifndef SOAP_TYPE_ns4__Include
#define SOAP_TYPE_ns4__Include (965)
/* complex XSD type 'ns4:Include': */
class SOAP_CMAC ns4__Include {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// required attribute 'href' of XSD type 'xsd:anyURI'
        std::string href;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__Include
        virtual int soap_type(void) const { return SOAP_TYPE_ns4__Include; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__Include, default initialized and not managed by a soap context
        virtual ns4__Include *soap_alloc(void) const { return SOAP_NEW(ns4__Include); }
      public:
        /// Constructor with initializations
        ns4__Include()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns4__Include() { }
        /// Friend allocator used by soap_new_ns4__Include(struct soap*, int)
        friend SOAP_FMAC1 ns4__Include * SOAP_FMAC2 soap_instantiate_ns4__Include(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:26800 */
#ifndef SOAP_TYPE__ns5__BaseFaultType_ErrorCode
#define SOAP_TYPE__ns5__BaseFaultType_ErrorCode (2057)
/* complex XSD type 'ns5:BaseFaultType-ErrorCode': */
class SOAP_CMAC _ns5__BaseFaultType_ErrorCode {
      public:
        /// required attribute 'dialect' of XSD type 'xsd:anyURI'
        std::string dialect;
        /// XML DOM element node graph
        struct soap_dom_element __mixed;
      public:
        /// Return unique type id SOAP_TYPE__ns5__BaseFaultType_ErrorCode
        virtual int soap_type(void) const { return SOAP_TYPE__ns5__BaseFaultType_ErrorCode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__BaseFaultType_ErrorCode, default initialized and not managed by a soap context
        virtual _ns5__BaseFaultType_ErrorCode *soap_alloc(void) const { return SOAP_NEW(_ns5__BaseFaultType_ErrorCode); }
      public:
        /// Constructor with initializations
        _ns5__BaseFaultType_ErrorCode()
        {
        }
        virtual ~_ns5__BaseFaultType_ErrorCode() { }
        /// Friend allocator used by soap_new__ns5__BaseFaultType_ErrorCode(struct soap*, int)
        friend SOAP_FMAC1 _ns5__BaseFaultType_ErrorCode * SOAP_FMAC2 soap_instantiate__ns5__BaseFaultType_ErrorCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:26821 */
#ifndef SOAP_TYPE__ns5__BaseFaultType_Description
#define SOAP_TYPE__ns5__BaseFaultType_Description (2059)
/* simple XSD type 'ns5:BaseFaultType-Description': */
class SOAP_CMAC _ns5__BaseFaultType_Description {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        std::string __item;
        /// optional attribute 'xml:lang' of XSD type 'xml:lang'
        std::string *xml__lang;
      public:
        /// Return unique type id SOAP_TYPE__ns5__BaseFaultType_Description
        virtual int soap_type(void) const { return SOAP_TYPE__ns5__BaseFaultType_Description; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__BaseFaultType_Description, default initialized and not managed by a soap context
        virtual _ns5__BaseFaultType_Description *soap_alloc(void) const { return SOAP_NEW(_ns5__BaseFaultType_Description); }
      public:
        /// Constructor with initializations
        _ns5__BaseFaultType_Description()
        {
          xml__lang = (std::string *)0;
        }
        virtual ~_ns5__BaseFaultType_Description() { }
        /// Friend allocator used by soap_new__ns5__BaseFaultType_Description(struct soap*, int)
        friend SOAP_FMAC1 _ns5__BaseFaultType_Description * SOAP_FMAC2 soap_instantiate__ns5__BaseFaultType_Description(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:26838 */
#ifndef SOAP_TYPE__ns5__BaseFaultType_FaultCause
#define SOAP_TYPE__ns5__BaseFaultType_FaultCause (2063)
/* complex XSD type 'ns5:BaseFaultType-FaultCause': */
class SOAP_CMAC _ns5__BaseFaultType_FaultCause {
      public:
        /// XML DOM element node graph
        struct soap_dom_element __any;
      public:
        /// Return unique type id SOAP_TYPE__ns5__BaseFaultType_FaultCause
        virtual int soap_type(void) const { return SOAP_TYPE__ns5__BaseFaultType_FaultCause; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__BaseFaultType_FaultCause, default initialized and not managed by a soap context
        virtual _ns5__BaseFaultType_FaultCause *soap_alloc(void) const { return SOAP_NEW(_ns5__BaseFaultType_FaultCause); }
      public:
        /// Constructor with initializations
        _ns5__BaseFaultType_FaultCause()
        {
        }
        virtual ~_ns5__BaseFaultType_FaultCause() { }
        /// Friend allocator used by soap_new__ns5__BaseFaultType_FaultCause(struct soap*, int)
        friend SOAP_FMAC1 _ns5__BaseFaultType_FaultCause * SOAP_FMAC2 soap_instantiate__ns5__BaseFaultType_FaultCause(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2446 */
#ifndef SOAP_TYPE_ns5__BaseFaultType
#define SOAP_TYPE_ns5__BaseFaultType (966)
/* Type ns5__BaseFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:BaseFaultType': */
class SOAP_CMAC ns5__BaseFaultType {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Required element 'ns5:Timestamp' of XSD type 'xsd:dateTime'
        time_t Timestamp;
        /// Optional element 'ns5:Originator' of XSD type 'ns14:EndpointReferenceType'
        ns14__EndpointReferenceType *Originator;
        /// Optional element 'ns5:ErrorCode' of XSD type 'ns5:BaseFaultType-ErrorCode'
        _ns5__BaseFaultType_ErrorCode *ErrorCode;
        /// Optional element 'ns5:Description' of XSD type 'ns5:BaseFaultType-Description'
        std::vector<_ns5__BaseFaultType_Description> *Description;
        /// Optional element 'ns5:FaultCause' of XSD type 'ns5:BaseFaultType-FaultCause'
        _ns5__BaseFaultType_FaultCause *FaultCause;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__BaseFaultType
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__BaseFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__BaseFaultType, default initialized and not managed by a soap context
        virtual ns5__BaseFaultType *soap_alloc(void) const { return SOAP_NEW(ns5__BaseFaultType); }
      public:
        /// Constructor with initializations
        ns5__BaseFaultType()
        {
          Timestamp = (time_t)0;
          Originator = (ns14__EndpointReferenceType *)0;
          ErrorCode = (_ns5__BaseFaultType_ErrorCode *)0;
          Description = (std::vector<_ns5__BaseFaultType_Description> *)0;
          FaultCause = (_ns5__BaseFaultType_FaultCause *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns5__BaseFaultType() { }
        /// Friend allocator used by soap_new_ns5__BaseFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns5__BaseFaultType * SOAP_FMAC2 soap_instantiate_ns5__BaseFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2449 */
#ifndef SOAP_TYPE_ns6__Documentation
#define SOAP_TYPE_ns6__Documentation (967)
/* complex XSD type 'ns6:Documentation': */
class SOAP_CMAC ns6__Documentation {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM element node graph
        struct soap_dom_element __mixed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__Documentation
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__Documentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__Documentation, default initialized and not managed by a soap context
        virtual ns6__Documentation *soap_alloc(void) const { return SOAP_NEW(ns6__Documentation); }
      public:
        /// Constructor with initializations
        ns6__Documentation()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns6__Documentation() { }
        /// Friend allocator used by soap_new_ns6__Documentation(struct soap*, int)
        friend SOAP_FMAC1 ns6__Documentation * SOAP_FMAC2 soap_instantiate_ns6__Documentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2452 */
#ifndef SOAP_TYPE_ns6__ExtensibleDocumented
#define SOAP_TYPE_ns6__ExtensibleDocumented (968)
/* Type ns6__ExtensibleDocumented is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns6:ExtensibleDocumented': */
class SOAP_CMAC ns6__ExtensibleDocumented {
      public:
        /// Optional element 'ns6:documentation' of XSD type 'ns6:Documentation'
        ns6__Documentation *documentation;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__ExtensibleDocumented
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__ExtensibleDocumented; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__ExtensibleDocumented, default initialized and not managed by a soap context
        virtual ns6__ExtensibleDocumented *soap_alloc(void) const { return SOAP_NEW(ns6__ExtensibleDocumented); }
      public:
        /// Constructor with initializations
        ns6__ExtensibleDocumented()
        {
          documentation = (ns6__Documentation *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns6__ExtensibleDocumented() { }
        /// Friend allocator used by soap_new_ns6__ExtensibleDocumented(struct soap*, int)
        friend SOAP_FMAC1 ns6__ExtensibleDocumented * SOAP_FMAC2 soap_instantiate_ns6__ExtensibleDocumented(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2455 */
#ifndef SOAP_TYPE_ns6__QueryExpressionType
#define SOAP_TYPE_ns6__QueryExpressionType (969)
/* complex XSD type 'ns6:QueryExpressionType': */
class SOAP_CMAC ns6__QueryExpressionType {
      public:
        /// XML DOM element node graph
        struct soap_dom_element __any;
        /// required attribute 'Dialect' of XSD type 'xsd:anyURI'
        std::string Dialect;
        /// XML DOM element node graph
        struct soap_dom_element __mixed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__QueryExpressionType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__QueryExpressionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__QueryExpressionType, default initialized and not managed by a soap context
        virtual ns6__QueryExpressionType *soap_alloc(void) const { return SOAP_NEW(ns6__QueryExpressionType); }
      public:
        /// Constructor with initializations
        ns6__QueryExpressionType()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns6__QueryExpressionType() { }
        /// Friend allocator used by soap_new_ns6__QueryExpressionType(struct soap*, int)
        friend SOAP_FMAC1 ns6__QueryExpressionType * SOAP_FMAC2 soap_instantiate_ns6__QueryExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2467 */
#ifndef SOAP_TYPE_ns7__Capabilities
#define SOAP_TYPE_ns7__Capabilities (973)
/* complex XSD type 'ns7:Capabilities': */
class SOAP_CMAC ns7__Capabilities {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// optional attribute 'FixedLayout' of XSD type 'xsd:boolean'
        bool *FixedLayout;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__Capabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__Capabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__Capabilities, default initialized and not managed by a soap context
        virtual ns7__Capabilities *soap_alloc(void) const { return SOAP_NEW(ns7__Capabilities); }
      public:
        /// Constructor with initializations
        ns7__Capabilities()
        {
          FixedLayout = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns7__Capabilities() { }
        /// Friend allocator used by soap_new_ns7__Capabilities(struct soap*, int)
        friend SOAP_FMAC1 ns7__Capabilities * SOAP_FMAC2 soap_instantiate_ns7__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2470 */
#ifndef SOAP_TYPE__ns7__GetServiceCapabilities
#define SOAP_TYPE__ns7__GetServiceCapabilities (974)
/* complex XSD type 'ns7:GetServiceCapabilities': */
class SOAP_CMAC _ns7__GetServiceCapabilities {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__GetServiceCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__GetServiceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__GetServiceCapabilities, default initialized and not managed by a soap context
        virtual _ns7__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_ns7__GetServiceCapabilities); }
      public:
        /// Constructor with initializations
        _ns7__GetServiceCapabilities()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns7__GetServiceCapabilities() { }
        /// Friend allocator used by soap_new__ns7__GetServiceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 _ns7__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__ns7__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2473 */
#ifndef SOAP_TYPE__ns7__GetServiceCapabilitiesResponse
#define SOAP_TYPE__ns7__GetServiceCapabilitiesResponse (975)
/* complex XSD type 'ns7:GetServiceCapabilitiesResponse': */
class SOAP_CMAC _ns7__GetServiceCapabilitiesResponse {
      public:
        /// Required element 'ns7:Capabilities' of XSD type 'ns7:Capabilities'
        ns7__Capabilities *Capabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__GetServiceCapabilitiesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__GetServiceCapabilitiesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
        virtual _ns7__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__GetServiceCapabilitiesResponse); }
      public:
        /// Constructor with initializations
        _ns7__GetServiceCapabilitiesResponse()
        {
          Capabilities = (ns7__Capabilities *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns7__GetServiceCapabilitiesResponse() { }
        /// Friend allocator used by soap_new__ns7__GetServiceCapabilitiesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__ns7__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2476 */
#ifndef SOAP_TYPE__ns7__GetLayout
#define SOAP_TYPE__ns7__GetLayout (976)
/* complex XSD type 'ns7:GetLayout': */
class SOAP_CMAC _ns7__GetLayout {
      public:
        /// Required element 'ns7:VideoOutput' of XSD type 'ns2:ReferenceToken'
        std::string VideoOutput;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__GetLayout
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__GetLayout; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__GetLayout, default initialized and not managed by a soap context
        virtual _ns7__GetLayout *soap_alloc(void) const { return SOAP_NEW(_ns7__GetLayout); }
      public:
        /// Constructor with initializations
        _ns7__GetLayout()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns7__GetLayout() { }
        /// Friend allocator used by soap_new__ns7__GetLayout(struct soap*, int)
        friend SOAP_FMAC1 _ns7__GetLayout * SOAP_FMAC2 soap_instantiate__ns7__GetLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2479 */
#ifndef SOAP_TYPE__ns7__GetLayoutResponse
#define SOAP_TYPE__ns7__GetLayoutResponse (977)
/* complex XSD type 'ns7:GetLayoutResponse': */
class SOAP_CMAC _ns7__GetLayoutResponse {
      public:
        /// Required element 'ns7:Layout' of XSD type 'ns2:Layout'
        ns2__Layout *Layout;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__GetLayoutResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__GetLayoutResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__GetLayoutResponse, default initialized and not managed by a soap context
        virtual _ns7__GetLayoutResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__GetLayoutResponse); }
      public:
        /// Constructor with initializations
        _ns7__GetLayoutResponse()
        {
          Layout = (ns2__Layout *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns7__GetLayoutResponse() { }
        /// Friend allocator used by soap_new__ns7__GetLayoutResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__GetLayoutResponse * SOAP_FMAC2 soap_instantiate__ns7__GetLayoutResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2482 */
#ifndef SOAP_TYPE__ns7__SetLayout
#define SOAP_TYPE__ns7__SetLayout (978)
/* complex XSD type 'ns7:SetLayout': */
class SOAP_CMAC _ns7__SetLayout {
      public:
        /// Required element 'ns7:VideoOutput' of XSD type 'ns2:ReferenceToken'
        std::string VideoOutput;
        /// Required element 'ns7:Layout' of XSD type 'ns2:Layout'
        ns2__Layout *Layout;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__SetLayout
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__SetLayout; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__SetLayout, default initialized and not managed by a soap context
        virtual _ns7__SetLayout *soap_alloc(void) const { return SOAP_NEW(_ns7__SetLayout); }
      public:
        /// Constructor with initializations
        _ns7__SetLayout()
        {
          Layout = (ns2__Layout *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns7__SetLayout() { }
        /// Friend allocator used by soap_new__ns7__SetLayout(struct soap*, int)
        friend SOAP_FMAC1 _ns7__SetLayout * SOAP_FMAC2 soap_instantiate__ns7__SetLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2485 */
#ifndef SOAP_TYPE__ns7__SetLayoutResponse
#define SOAP_TYPE__ns7__SetLayoutResponse (979)
/* complex XSD type 'ns7:SetLayoutResponse': */
class SOAP_CMAC _ns7__SetLayoutResponse {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__SetLayoutResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__SetLayoutResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__SetLayoutResponse, default initialized and not managed by a soap context
        virtual _ns7__SetLayoutResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__SetLayoutResponse); }
      public:
        /// Constructor with initializations
        _ns7__SetLayoutResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns7__SetLayoutResponse() { }
        /// Friend allocator used by soap_new__ns7__SetLayoutResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__SetLayoutResponse * SOAP_FMAC2 soap_instantiate__ns7__SetLayoutResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2488 */
#ifndef SOAP_TYPE__ns7__GetDisplayOptions
#define SOAP_TYPE__ns7__GetDisplayOptions (980)
/* complex XSD type 'ns7:GetDisplayOptions': */
class SOAP_CMAC _ns7__GetDisplayOptions {
      public:
        /// Required element 'ns7:VideoOutput' of XSD type 'ns2:ReferenceToken'
        std::string VideoOutput;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__GetDisplayOptions
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__GetDisplayOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__GetDisplayOptions, default initialized and not managed by a soap context
        virtual _ns7__GetDisplayOptions *soap_alloc(void) const { return SOAP_NEW(_ns7__GetDisplayOptions); }
      public:
        /// Constructor with initializations
        _ns7__GetDisplayOptions()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns7__GetDisplayOptions() { }
        /// Friend allocator used by soap_new__ns7__GetDisplayOptions(struct soap*, int)
        friend SOAP_FMAC1 _ns7__GetDisplayOptions * SOAP_FMAC2 soap_instantiate__ns7__GetDisplayOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2491 */
#ifndef SOAP_TYPE__ns7__GetDisplayOptionsResponse
#define SOAP_TYPE__ns7__GetDisplayOptionsResponse (981)
/* complex XSD type 'ns7:GetDisplayOptionsResponse': */
class SOAP_CMAC _ns7__GetDisplayOptionsResponse {
      public:
        /// Optional element 'ns7:LayoutOptions' of XSD type 'ns2:LayoutOptions'
        ns2__LayoutOptions *LayoutOptions;
        /// Required element 'ns7:CodingCapabilities' of XSD type 'ns2:CodingCapabilities'
        ns2__CodingCapabilities *CodingCapabilities;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__GetDisplayOptionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__GetDisplayOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__GetDisplayOptionsResponse, default initialized and not managed by a soap context
        virtual _ns7__GetDisplayOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__GetDisplayOptionsResponse); }
      public:
        /// Constructor with initializations
        _ns7__GetDisplayOptionsResponse()
        {
          LayoutOptions = (ns2__LayoutOptions *)0;
          CodingCapabilities = (ns2__CodingCapabilities *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns7__GetDisplayOptionsResponse() { }
        /// Friend allocator used by soap_new__ns7__GetDisplayOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__GetDisplayOptionsResponse * SOAP_FMAC2 soap_instantiate__ns7__GetDisplayOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2494 */
#ifndef SOAP_TYPE__ns7__GetPaneConfigurations
#define SOAP_TYPE__ns7__GetPaneConfigurations (982)
/* complex XSD type 'ns7:GetPaneConfigurations': */
class SOAP_CMAC _ns7__GetPaneConfigurations {
      public:
        /// Required element 'ns7:VideoOutput' of XSD type 'ns2:ReferenceToken'
        std::string VideoOutput;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__GetPaneConfigurations
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__GetPaneConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__GetPaneConfigurations, default initialized and not managed by a soap context
        virtual _ns7__GetPaneConfigurations *soap_alloc(void) const { return SOAP_NEW(_ns7__GetPaneConfigurations); }
      public:
        /// Constructor with initializations
        _ns7__GetPaneConfigurations()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns7__GetPaneConfigurations() { }
        /// Friend allocator used by soap_new__ns7__GetPaneConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns7__GetPaneConfigurations * SOAP_FMAC2 soap_instantiate__ns7__GetPaneConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2497 */
#ifndef SOAP_TYPE__ns7__GetPaneConfigurationsResponse
#define SOAP_TYPE__ns7__GetPaneConfigurationsResponse (983)
/* complex XSD type 'ns7:GetPaneConfigurationsResponse': */
class SOAP_CMAC _ns7__GetPaneConfigurationsResponse {
      public:
        /// Required element 'ns7:PaneConfiguration' of XSD type 'ns2:PaneConfiguration'
        std::vector<ns2__PaneConfiguration *> PaneConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__GetPaneConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__GetPaneConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__GetPaneConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns7__GetPaneConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__GetPaneConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns7__GetPaneConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns7__GetPaneConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns7__GetPaneConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__GetPaneConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns7__GetPaneConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2500 */
#ifndef SOAP_TYPE__ns7__GetPaneConfiguration
#define SOAP_TYPE__ns7__GetPaneConfiguration (984)
/* complex XSD type 'ns7:GetPaneConfiguration': */
class SOAP_CMAC _ns7__GetPaneConfiguration {
      public:
        /// Required element 'ns7:VideoOutput' of XSD type 'ns2:ReferenceToken'
        std::string VideoOutput;
        /// Required element 'ns7:Pane' of XSD type 'ns2:ReferenceToken'
        std::string Pane;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__GetPaneConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__GetPaneConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__GetPaneConfiguration, default initialized and not managed by a soap context
        virtual _ns7__GetPaneConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns7__GetPaneConfiguration); }
      public:
        /// Constructor with initializations
        _ns7__GetPaneConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns7__GetPaneConfiguration() { }
        /// Friend allocator used by soap_new__ns7__GetPaneConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns7__GetPaneConfiguration * SOAP_FMAC2 soap_instantiate__ns7__GetPaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2503 */
#ifndef SOAP_TYPE__ns7__GetPaneConfigurationResponse
#define SOAP_TYPE__ns7__GetPaneConfigurationResponse (985)
/* complex XSD type 'ns7:GetPaneConfigurationResponse': */
class SOAP_CMAC _ns7__GetPaneConfigurationResponse {
      public:
        /// Required element 'ns7:PaneConfiguration' of XSD type 'ns2:PaneConfiguration'
        ns2__PaneConfiguration *PaneConfiguration;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__GetPaneConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__GetPaneConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__GetPaneConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns7__GetPaneConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__GetPaneConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns7__GetPaneConfigurationResponse()
        {
          PaneConfiguration = (ns2__PaneConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns7__GetPaneConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns7__GetPaneConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__GetPaneConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns7__GetPaneConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2506 */
#ifndef SOAP_TYPE__ns7__SetPaneConfigurations
#define SOAP_TYPE__ns7__SetPaneConfigurations (986)
/* complex XSD type 'ns7:SetPaneConfigurations': */
class SOAP_CMAC _ns7__SetPaneConfigurations {
      public:
        /// Required element 'ns7:VideoOutput' of XSD type 'ns2:ReferenceToken'
        std::string VideoOutput;
        /// Required element 'ns7:PaneConfiguration' of XSD type 'ns2:PaneConfiguration'
        std::vector<ns2__PaneConfiguration *> PaneConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__SetPaneConfigurations
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__SetPaneConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__SetPaneConfigurations, default initialized and not managed by a soap context
        virtual _ns7__SetPaneConfigurations *soap_alloc(void) const { return SOAP_NEW(_ns7__SetPaneConfigurations); }
      public:
        /// Constructor with initializations
        _ns7__SetPaneConfigurations()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns7__SetPaneConfigurations() { }
        /// Friend allocator used by soap_new__ns7__SetPaneConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns7__SetPaneConfigurations * SOAP_FMAC2 soap_instantiate__ns7__SetPaneConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2509 */
#ifndef SOAP_TYPE__ns7__SetPaneConfigurationsResponse
#define SOAP_TYPE__ns7__SetPaneConfigurationsResponse (987)
/* complex XSD type 'ns7:SetPaneConfigurationsResponse': */
class SOAP_CMAC _ns7__SetPaneConfigurationsResponse {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__SetPaneConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__SetPaneConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__SetPaneConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns7__SetPaneConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__SetPaneConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns7__SetPaneConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns7__SetPaneConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns7__SetPaneConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__SetPaneConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns7__SetPaneConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2512 */
#ifndef SOAP_TYPE__ns7__SetPaneConfiguration
#define SOAP_TYPE__ns7__SetPaneConfiguration (988)
/* complex XSD type 'ns7:SetPaneConfiguration': */
class SOAP_CMAC _ns7__SetPaneConfiguration {
      public:
        /// Required element 'ns7:VideoOutput' of XSD type 'ns2:ReferenceToken'
        std::string VideoOutput;
        /// Required element 'ns7:PaneConfiguration' of XSD type 'ns2:PaneConfiguration'
        ns2__PaneConfiguration *PaneConfiguration;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__SetPaneConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__SetPaneConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__SetPaneConfiguration, default initialized and not managed by a soap context
        virtual _ns7__SetPaneConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns7__SetPaneConfiguration); }
      public:
        /// Constructor with initializations
        _ns7__SetPaneConfiguration()
        {
          PaneConfiguration = (ns2__PaneConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns7__SetPaneConfiguration() { }
        /// Friend allocator used by soap_new__ns7__SetPaneConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns7__SetPaneConfiguration * SOAP_FMAC2 soap_instantiate__ns7__SetPaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2515 */
#ifndef SOAP_TYPE__ns7__SetPaneConfigurationResponse
#define SOAP_TYPE__ns7__SetPaneConfigurationResponse (989)
/* complex XSD type 'ns7:SetPaneConfigurationResponse': */
class SOAP_CMAC _ns7__SetPaneConfigurationResponse {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__SetPaneConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__SetPaneConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__SetPaneConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns7__SetPaneConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__SetPaneConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns7__SetPaneConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns7__SetPaneConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns7__SetPaneConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__SetPaneConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns7__SetPaneConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2518 */
#ifndef SOAP_TYPE__ns7__CreatePaneConfiguration
#define SOAP_TYPE__ns7__CreatePaneConfiguration (990)
/* complex XSD type 'ns7:CreatePaneConfiguration': */
class SOAP_CMAC _ns7__CreatePaneConfiguration {
      public:
        /// Required element 'ns7:VideoOutput' of XSD type 'ns2:ReferenceToken'
        std::string VideoOutput;
        /// Required element 'ns7:PaneConfiguration' of XSD type 'ns2:PaneConfiguration'
        ns2__PaneConfiguration *PaneConfiguration;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__CreatePaneConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__CreatePaneConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__CreatePaneConfiguration, default initialized and not managed by a soap context
        virtual _ns7__CreatePaneConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns7__CreatePaneConfiguration); }
      public:
        /// Constructor with initializations
        _ns7__CreatePaneConfiguration()
        {
          PaneConfiguration = (ns2__PaneConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns7__CreatePaneConfiguration() { }
        /// Friend allocator used by soap_new__ns7__CreatePaneConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns7__CreatePaneConfiguration * SOAP_FMAC2 soap_instantiate__ns7__CreatePaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2521 */
#ifndef SOAP_TYPE__ns7__CreatePaneConfigurationResponse
#define SOAP_TYPE__ns7__CreatePaneConfigurationResponse (991)
/* complex XSD type 'ns7:CreatePaneConfigurationResponse': */
class SOAP_CMAC _ns7__CreatePaneConfigurationResponse {
      public:
        /// Required element 'ns7:PaneToken' of XSD type 'ns2:ReferenceToken'
        std::string PaneToken;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__CreatePaneConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__CreatePaneConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__CreatePaneConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns7__CreatePaneConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__CreatePaneConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns7__CreatePaneConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns7__CreatePaneConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns7__CreatePaneConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__CreatePaneConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns7__CreatePaneConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2524 */
#ifndef SOAP_TYPE__ns7__DeletePaneConfiguration
#define SOAP_TYPE__ns7__DeletePaneConfiguration (992)
/* complex XSD type 'ns7:DeletePaneConfiguration': */
class SOAP_CMAC _ns7__DeletePaneConfiguration {
      public:
        /// Required element 'ns7:VideoOutput' of XSD type 'ns2:ReferenceToken'
        std::string VideoOutput;
        /// Required element 'ns7:PaneToken' of XSD type 'ns2:ReferenceToken'
        std::string PaneToken;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__DeletePaneConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__DeletePaneConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__DeletePaneConfiguration, default initialized and not managed by a soap context
        virtual _ns7__DeletePaneConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns7__DeletePaneConfiguration); }
      public:
        /// Constructor with initializations
        _ns7__DeletePaneConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns7__DeletePaneConfiguration() { }
        /// Friend allocator used by soap_new__ns7__DeletePaneConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns7__DeletePaneConfiguration * SOAP_FMAC2 soap_instantiate__ns7__DeletePaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2527 */
#ifndef SOAP_TYPE__ns7__DeletePaneConfigurationResponse
#define SOAP_TYPE__ns7__DeletePaneConfigurationResponse (993)
/* complex XSD type 'ns7:DeletePaneConfigurationResponse': */
class SOAP_CMAC _ns7__DeletePaneConfigurationResponse {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__DeletePaneConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__DeletePaneConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__DeletePaneConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns7__DeletePaneConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__DeletePaneConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns7__DeletePaneConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns7__DeletePaneConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns7__DeletePaneConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__DeletePaneConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns7__DeletePaneConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2530 */
#ifndef SOAP_TYPE_ns8__Capabilities
#define SOAP_TYPE_ns8__Capabilities (994)
/* complex XSD type 'ns8:Capabilities': */
class SOAP_CMAC ns8__Capabilities {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// optional attribute 'ImageStabilization' of XSD type 'xsd:boolean'
        bool *ImageStabilization;
        /// optional attribute 'Presets' of XSD type 'xsd:boolean'
        bool *Presets;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns8__Capabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns8__Capabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns8__Capabilities, default initialized and not managed by a soap context
        virtual ns8__Capabilities *soap_alloc(void) const { return SOAP_NEW(ns8__Capabilities); }
      public:
        /// Constructor with initializations
        ns8__Capabilities()
        {
          ImageStabilization = (bool *)0;
          Presets = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns8__Capabilities() { }
        /// Friend allocator used by soap_new_ns8__Capabilities(struct soap*, int)
        friend SOAP_FMAC1 ns8__Capabilities * SOAP_FMAC2 soap_instantiate_ns8__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2533 */
#ifndef SOAP_TYPE_ns8__ImagingPreset
#define SOAP_TYPE_ns8__ImagingPreset (995)
/* complex XSD type 'ns8:ImagingPreset': */
class SOAP_CMAC ns8__ImagingPreset {
      public:
        /// Required element 'ns8:Name' of XSD type 'ns2:Name'
        std::string Name;
        /// required attribute 'token' of XSD type 'ns2:ReferenceToken'
        std::string token;
        /// required attribute 'type' of XSD type 'xsd:string'
        std::string type;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns8__ImagingPreset
        virtual int soap_type(void) const { return SOAP_TYPE_ns8__ImagingPreset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns8__ImagingPreset, default initialized and not managed by a soap context
        virtual ns8__ImagingPreset *soap_alloc(void) const { return SOAP_NEW(ns8__ImagingPreset); }
      public:
        /// Constructor with initializations
        ns8__ImagingPreset()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns8__ImagingPreset() { }
        /// Friend allocator used by soap_new_ns8__ImagingPreset(struct soap*, int)
        friend SOAP_FMAC1 ns8__ImagingPreset * SOAP_FMAC2 soap_instantiate_ns8__ImagingPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2536 */
#ifndef SOAP_TYPE__ns8__GetServiceCapabilities
#define SOAP_TYPE__ns8__GetServiceCapabilities (996)
/* complex XSD type 'ns8:GetServiceCapabilities': */
class SOAP_CMAC _ns8__GetServiceCapabilities {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns8__GetServiceCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE__ns8__GetServiceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns8__GetServiceCapabilities, default initialized and not managed by a soap context
        virtual _ns8__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_ns8__GetServiceCapabilities); }
      public:
        /// Constructor with initializations
        _ns8__GetServiceCapabilities()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns8__GetServiceCapabilities() { }
        /// Friend allocator used by soap_new__ns8__GetServiceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 _ns8__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__ns8__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2539 */
#ifndef SOAP_TYPE__ns8__GetServiceCapabilitiesResponse
#define SOAP_TYPE__ns8__GetServiceCapabilitiesResponse (997)
/* complex XSD type 'ns8:GetServiceCapabilitiesResponse': */
class SOAP_CMAC _ns8__GetServiceCapabilitiesResponse {
      public:
        /// Required element 'ns8:Capabilities' of XSD type 'ns8:Capabilities'
        ns8__Capabilities *Capabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns8__GetServiceCapabilitiesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns8__GetServiceCapabilitiesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns8__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
        virtual _ns8__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_ns8__GetServiceCapabilitiesResponse); }
      public:
        /// Constructor with initializations
        _ns8__GetServiceCapabilitiesResponse()
        {
          Capabilities = (ns8__Capabilities *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns8__GetServiceCapabilitiesResponse() { }
        /// Friend allocator used by soap_new__ns8__GetServiceCapabilitiesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns8__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__ns8__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2542 */
#ifndef SOAP_TYPE__ns8__GetImagingSettings
#define SOAP_TYPE__ns8__GetImagingSettings (998)
/* complex XSD type 'ns8:GetImagingSettings': */
class SOAP_CMAC _ns8__GetImagingSettings {
      public:
        /// Required element 'ns8:VideoSourceToken' of XSD type 'ns2:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns8__GetImagingSettings
        virtual int soap_type(void) const { return SOAP_TYPE__ns8__GetImagingSettings; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns8__GetImagingSettings, default initialized and not managed by a soap context
        virtual _ns8__GetImagingSettings *soap_alloc(void) const { return SOAP_NEW(_ns8__GetImagingSettings); }
      public:
        /// Constructor with initializations
        _ns8__GetImagingSettings()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns8__GetImagingSettings() { }
        /// Friend allocator used by soap_new__ns8__GetImagingSettings(struct soap*, int)
        friend SOAP_FMAC1 _ns8__GetImagingSettings * SOAP_FMAC2 soap_instantiate__ns8__GetImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2545 */
#ifndef SOAP_TYPE__ns8__GetImagingSettingsResponse
#define SOAP_TYPE__ns8__GetImagingSettingsResponse (999)
/* complex XSD type 'ns8:GetImagingSettingsResponse': */
class SOAP_CMAC _ns8__GetImagingSettingsResponse {
      public:
        /// Required element 'ns8:ImagingSettings' of XSD type 'ns2:ImagingSettings20'
        ns2__ImagingSettings20 *ImagingSettings;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns8__GetImagingSettingsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns8__GetImagingSettingsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns8__GetImagingSettingsResponse, default initialized and not managed by a soap context
        virtual _ns8__GetImagingSettingsResponse *soap_alloc(void) const { return SOAP_NEW(_ns8__GetImagingSettingsResponse); }
      public:
        /// Constructor with initializations
        _ns8__GetImagingSettingsResponse()
        {
          ImagingSettings = (ns2__ImagingSettings20 *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns8__GetImagingSettingsResponse() { }
        /// Friend allocator used by soap_new__ns8__GetImagingSettingsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns8__GetImagingSettingsResponse * SOAP_FMAC2 soap_instantiate__ns8__GetImagingSettingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2548 */
#ifndef SOAP_TYPE__ns8__SetImagingSettings
#define SOAP_TYPE__ns8__SetImagingSettings (1000)
/* complex XSD type 'ns8:SetImagingSettings': */
class SOAP_CMAC _ns8__SetImagingSettings {
      public:
        /// Required element 'ns8:VideoSourceToken' of XSD type 'ns2:ReferenceToken'
        std::string VideoSourceToken;
        /// Required element 'ns8:ImagingSettings' of XSD type 'ns2:ImagingSettings20'
        ns2__ImagingSettings20 *ImagingSettings;
        /// Optional element 'ns8:ForcePersistence' of XSD type 'xsd:boolean'
        bool *ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns8__SetImagingSettings
        virtual int soap_type(void) const { return SOAP_TYPE__ns8__SetImagingSettings; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns8__SetImagingSettings, default initialized and not managed by a soap context
        virtual _ns8__SetImagingSettings *soap_alloc(void) const { return SOAP_NEW(_ns8__SetImagingSettings); }
      public:
        /// Constructor with initializations
        _ns8__SetImagingSettings()
        {
          ImagingSettings = (ns2__ImagingSettings20 *)0;
          ForcePersistence = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns8__SetImagingSettings() { }
        /// Friend allocator used by soap_new__ns8__SetImagingSettings(struct soap*, int)
        friend SOAP_FMAC1 _ns8__SetImagingSettings * SOAP_FMAC2 soap_instantiate__ns8__SetImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2551 */
#ifndef SOAP_TYPE__ns8__SetImagingSettingsResponse
#define SOAP_TYPE__ns8__SetImagingSettingsResponse (1001)
/* complex XSD type 'ns8:SetImagingSettingsResponse': */
class SOAP_CMAC _ns8__SetImagingSettingsResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns8__SetImagingSettingsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns8__SetImagingSettingsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns8__SetImagingSettingsResponse, default initialized and not managed by a soap context
        virtual _ns8__SetImagingSettingsResponse *soap_alloc(void) const { return SOAP_NEW(_ns8__SetImagingSettingsResponse); }
      public:
        /// Constructor with initializations
        _ns8__SetImagingSettingsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns8__SetImagingSettingsResponse() { }
        /// Friend allocator used by soap_new__ns8__SetImagingSettingsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns8__SetImagingSettingsResponse * SOAP_FMAC2 soap_instantiate__ns8__SetImagingSettingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2554 */
#ifndef SOAP_TYPE__ns8__GetOptions
#define SOAP_TYPE__ns8__GetOptions (1002)
/* complex XSD type 'ns8:GetOptions': */
class SOAP_CMAC _ns8__GetOptions {
      public:
        /// Required element 'ns8:VideoSourceToken' of XSD type 'ns2:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns8__GetOptions
        virtual int soap_type(void) const { return SOAP_TYPE__ns8__GetOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns8__GetOptions, default initialized and not managed by a soap context
        virtual _ns8__GetOptions *soap_alloc(void) const { return SOAP_NEW(_ns8__GetOptions); }
      public:
        /// Constructor with initializations
        _ns8__GetOptions()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns8__GetOptions() { }
        /// Friend allocator used by soap_new__ns8__GetOptions(struct soap*, int)
        friend SOAP_FMAC1 _ns8__GetOptions * SOAP_FMAC2 soap_instantiate__ns8__GetOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2557 */
#ifndef SOAP_TYPE__ns8__GetOptionsResponse
#define SOAP_TYPE__ns8__GetOptionsResponse (1003)
/* complex XSD type 'ns8:GetOptionsResponse': */
class SOAP_CMAC _ns8__GetOptionsResponse {
      public:
        /// Required element 'ns8:ImagingOptions' of XSD type 'ns2:ImagingOptions20'
        ns2__ImagingOptions20 *ImagingOptions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns8__GetOptionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns8__GetOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns8__GetOptionsResponse, default initialized and not managed by a soap context
        virtual _ns8__GetOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns8__GetOptionsResponse); }
      public:
        /// Constructor with initializations
        _ns8__GetOptionsResponse()
        {
          ImagingOptions = (ns2__ImagingOptions20 *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns8__GetOptionsResponse() { }
        /// Friend allocator used by soap_new__ns8__GetOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns8__GetOptionsResponse * SOAP_FMAC2 soap_instantiate__ns8__GetOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2560 */
#ifndef SOAP_TYPE__ns8__Move
#define SOAP_TYPE__ns8__Move (1004)
/* complex XSD type 'ns8:Move': */
class SOAP_CMAC _ns8__Move {
      public:
        /// Required element 'ns8:VideoSourceToken' of XSD type 'ns2:ReferenceToken'
        std::string VideoSourceToken;
        /// Required element 'ns8:Focus' of XSD type 'ns2:FocusMove'
        ns2__FocusMove *Focus;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns8__Move
        virtual int soap_type(void) const { return SOAP_TYPE__ns8__Move; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns8__Move, default initialized and not managed by a soap context
        virtual _ns8__Move *soap_alloc(void) const { return SOAP_NEW(_ns8__Move); }
      public:
        /// Constructor with initializations
        _ns8__Move()
        {
          Focus = (ns2__FocusMove *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns8__Move() { }
        /// Friend allocator used by soap_new__ns8__Move(struct soap*, int)
        friend SOAP_FMAC1 _ns8__Move * SOAP_FMAC2 soap_instantiate__ns8__Move(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2563 */
#ifndef SOAP_TYPE__ns8__MoveResponse
#define SOAP_TYPE__ns8__MoveResponse (1005)
/* complex XSD type 'ns8:MoveResponse': */
class SOAP_CMAC _ns8__MoveResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns8__MoveResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns8__MoveResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns8__MoveResponse, default initialized and not managed by a soap context
        virtual _ns8__MoveResponse *soap_alloc(void) const { return SOAP_NEW(_ns8__MoveResponse); }
      public:
        /// Constructor with initializations
        _ns8__MoveResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns8__MoveResponse() { }
        /// Friend allocator used by soap_new__ns8__MoveResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns8__MoveResponse * SOAP_FMAC2 soap_instantiate__ns8__MoveResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2566 */
#ifndef SOAP_TYPE__ns8__GetMoveOptions
#define SOAP_TYPE__ns8__GetMoveOptions (1006)
/* complex XSD type 'ns8:GetMoveOptions': */
class SOAP_CMAC _ns8__GetMoveOptions {
      public:
        /// Required element 'ns8:VideoSourceToken' of XSD type 'ns2:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns8__GetMoveOptions
        virtual int soap_type(void) const { return SOAP_TYPE__ns8__GetMoveOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns8__GetMoveOptions, default initialized and not managed by a soap context
        virtual _ns8__GetMoveOptions *soap_alloc(void) const { return SOAP_NEW(_ns8__GetMoveOptions); }
      public:
        /// Constructor with initializations
        _ns8__GetMoveOptions()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns8__GetMoveOptions() { }
        /// Friend allocator used by soap_new__ns8__GetMoveOptions(struct soap*, int)
        friend SOAP_FMAC1 _ns8__GetMoveOptions * SOAP_FMAC2 soap_instantiate__ns8__GetMoveOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2569 */
#ifndef SOAP_TYPE__ns8__GetMoveOptionsResponse
#define SOAP_TYPE__ns8__GetMoveOptionsResponse (1007)
/* complex XSD type 'ns8:GetMoveOptionsResponse': */
class SOAP_CMAC _ns8__GetMoveOptionsResponse {
      public:
        /// Required element 'ns8:MoveOptions' of XSD type 'ns2:MoveOptions20'
        ns2__MoveOptions20 *MoveOptions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns8__GetMoveOptionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns8__GetMoveOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns8__GetMoveOptionsResponse, default initialized and not managed by a soap context
        virtual _ns8__GetMoveOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns8__GetMoveOptionsResponse); }
      public:
        /// Constructor with initializations
        _ns8__GetMoveOptionsResponse()
        {
          MoveOptions = (ns2__MoveOptions20 *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns8__GetMoveOptionsResponse() { }
        /// Friend allocator used by soap_new__ns8__GetMoveOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns8__GetMoveOptionsResponse * SOAP_FMAC2 soap_instantiate__ns8__GetMoveOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2572 */
#ifndef SOAP_TYPE__ns8__Stop
#define SOAP_TYPE__ns8__Stop (1008)
/* complex XSD type 'ns8:Stop': */
class SOAP_CMAC _ns8__Stop {
      public:
        /// Required element 'ns8:VideoSourceToken' of XSD type 'ns2:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns8__Stop
        virtual int soap_type(void) const { return SOAP_TYPE__ns8__Stop; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns8__Stop, default initialized and not managed by a soap context
        virtual _ns8__Stop *soap_alloc(void) const { return SOAP_NEW(_ns8__Stop); }
      public:
        /// Constructor with initializations
        _ns8__Stop()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns8__Stop() { }
        /// Friend allocator used by soap_new__ns8__Stop(struct soap*, int)
        friend SOAP_FMAC1 _ns8__Stop * SOAP_FMAC2 soap_instantiate__ns8__Stop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2575 */
#ifndef SOAP_TYPE__ns8__StopResponse
#define SOAP_TYPE__ns8__StopResponse (1009)
/* complex XSD type 'ns8:StopResponse': */
class SOAP_CMAC _ns8__StopResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns8__StopResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns8__StopResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns8__StopResponse, default initialized and not managed by a soap context
        virtual _ns8__StopResponse *soap_alloc(void) const { return SOAP_NEW(_ns8__StopResponse); }
      public:
        /// Constructor with initializations
        _ns8__StopResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns8__StopResponse() { }
        /// Friend allocator used by soap_new__ns8__StopResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns8__StopResponse * SOAP_FMAC2 soap_instantiate__ns8__StopResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2578 */
#ifndef SOAP_TYPE__ns8__GetStatus
#define SOAP_TYPE__ns8__GetStatus (1010)
/* complex XSD type 'ns8:GetStatus': */
class SOAP_CMAC _ns8__GetStatus {
      public:
        /// Required element 'ns8:VideoSourceToken' of XSD type 'ns2:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns8__GetStatus
        virtual int soap_type(void) const { return SOAP_TYPE__ns8__GetStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns8__GetStatus, default initialized and not managed by a soap context
        virtual _ns8__GetStatus *soap_alloc(void) const { return SOAP_NEW(_ns8__GetStatus); }
      public:
        /// Constructor with initializations
        _ns8__GetStatus()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns8__GetStatus() { }
        /// Friend allocator used by soap_new__ns8__GetStatus(struct soap*, int)
        friend SOAP_FMAC1 _ns8__GetStatus * SOAP_FMAC2 soap_instantiate__ns8__GetStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2581 */
#ifndef SOAP_TYPE__ns8__GetStatusResponse
#define SOAP_TYPE__ns8__GetStatusResponse (1011)
/* complex XSD type 'ns8:GetStatusResponse': */
class SOAP_CMAC _ns8__GetStatusResponse {
      public:
        /// Required element 'ns8:Status' of XSD type 'ns2:ImagingStatus20'
        ns2__ImagingStatus20 *Status;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns8__GetStatusResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns8__GetStatusResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns8__GetStatusResponse, default initialized and not managed by a soap context
        virtual _ns8__GetStatusResponse *soap_alloc(void) const { return SOAP_NEW(_ns8__GetStatusResponse); }
      public:
        /// Constructor with initializations
        _ns8__GetStatusResponse()
        {
          Status = (ns2__ImagingStatus20 *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns8__GetStatusResponse() { }
        /// Friend allocator used by soap_new__ns8__GetStatusResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns8__GetStatusResponse * SOAP_FMAC2 soap_instantiate__ns8__GetStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2584 */
#ifndef SOAP_TYPE__ns8__GetPresets
#define SOAP_TYPE__ns8__GetPresets (1012)
/* complex XSD type 'ns8:GetPresets': */
class SOAP_CMAC _ns8__GetPresets {
      public:
        /// Required element 'ns8:VideoSourceToken' of XSD type 'ns2:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns8__GetPresets
        virtual int soap_type(void) const { return SOAP_TYPE__ns8__GetPresets; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns8__GetPresets, default initialized and not managed by a soap context
        virtual _ns8__GetPresets *soap_alloc(void) const { return SOAP_NEW(_ns8__GetPresets); }
      public:
        /// Constructor with initializations
        _ns8__GetPresets()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns8__GetPresets() { }
        /// Friend allocator used by soap_new__ns8__GetPresets(struct soap*, int)
        friend SOAP_FMAC1 _ns8__GetPresets * SOAP_FMAC2 soap_instantiate__ns8__GetPresets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2587 */
#ifndef SOAP_TYPE__ns8__GetPresetsResponse
#define SOAP_TYPE__ns8__GetPresetsResponse (1013)
/* complex XSD type 'ns8:GetPresetsResponse': */
class SOAP_CMAC _ns8__GetPresetsResponse {
      public:
        /// Required element 'ns8:Preset' of XSD type 'ns8:ImagingPreset'
        std::vector<ns8__ImagingPreset *> Preset;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns8__GetPresetsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns8__GetPresetsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns8__GetPresetsResponse, default initialized and not managed by a soap context
        virtual _ns8__GetPresetsResponse *soap_alloc(void) const { return SOAP_NEW(_ns8__GetPresetsResponse); }
      public:
        /// Constructor with initializations
        _ns8__GetPresetsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns8__GetPresetsResponse() { }
        /// Friend allocator used by soap_new__ns8__GetPresetsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns8__GetPresetsResponse * SOAP_FMAC2 soap_instantiate__ns8__GetPresetsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2590 */
#ifndef SOAP_TYPE__ns8__GetCurrentPreset
#define SOAP_TYPE__ns8__GetCurrentPreset (1014)
/* complex XSD type 'ns8:GetCurrentPreset': */
class SOAP_CMAC _ns8__GetCurrentPreset {
      public:
        /// Required element 'ns8:VideoSourceToken' of XSD type 'ns2:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns8__GetCurrentPreset
        virtual int soap_type(void) const { return SOAP_TYPE__ns8__GetCurrentPreset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns8__GetCurrentPreset, default initialized and not managed by a soap context
        virtual _ns8__GetCurrentPreset *soap_alloc(void) const { return SOAP_NEW(_ns8__GetCurrentPreset); }
      public:
        /// Constructor with initializations
        _ns8__GetCurrentPreset()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns8__GetCurrentPreset() { }
        /// Friend allocator used by soap_new__ns8__GetCurrentPreset(struct soap*, int)
        friend SOAP_FMAC1 _ns8__GetCurrentPreset * SOAP_FMAC2 soap_instantiate__ns8__GetCurrentPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2593 */
#ifndef SOAP_TYPE__ns8__GetCurrentPresetResponse
#define SOAP_TYPE__ns8__GetCurrentPresetResponse (1015)
/* complex XSD type 'ns8:GetCurrentPresetResponse': */
class SOAP_CMAC _ns8__GetCurrentPresetResponse {
      public:
        /// Optional element 'ns8:Preset' of XSD type 'ns8:ImagingPreset'
        ns8__ImagingPreset *Preset;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns8__GetCurrentPresetResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns8__GetCurrentPresetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns8__GetCurrentPresetResponse, default initialized and not managed by a soap context
        virtual _ns8__GetCurrentPresetResponse *soap_alloc(void) const { return SOAP_NEW(_ns8__GetCurrentPresetResponse); }
      public:
        /// Constructor with initializations
        _ns8__GetCurrentPresetResponse()
        {
          Preset = (ns8__ImagingPreset *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns8__GetCurrentPresetResponse() { }
        /// Friend allocator used by soap_new__ns8__GetCurrentPresetResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns8__GetCurrentPresetResponse * SOAP_FMAC2 soap_instantiate__ns8__GetCurrentPresetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2596 */
#ifndef SOAP_TYPE__ns8__SetCurrentPreset
#define SOAP_TYPE__ns8__SetCurrentPreset (1016)
/* complex XSD type 'ns8:SetCurrentPreset': */
class SOAP_CMAC _ns8__SetCurrentPreset {
      public:
        /// Required element 'ns8:VideoSourceToken' of XSD type 'ns2:ReferenceToken'
        std::string VideoSourceToken;
        /// Required element 'ns8:PresetToken' of XSD type 'ns2:ReferenceToken'
        std::string PresetToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns8__SetCurrentPreset
        virtual int soap_type(void) const { return SOAP_TYPE__ns8__SetCurrentPreset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns8__SetCurrentPreset, default initialized and not managed by a soap context
        virtual _ns8__SetCurrentPreset *soap_alloc(void) const { return SOAP_NEW(_ns8__SetCurrentPreset); }
      public:
        /// Constructor with initializations
        _ns8__SetCurrentPreset()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns8__SetCurrentPreset() { }
        /// Friend allocator used by soap_new__ns8__SetCurrentPreset(struct soap*, int)
        friend SOAP_FMAC1 _ns8__SetCurrentPreset * SOAP_FMAC2 soap_instantiate__ns8__SetCurrentPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2599 */
#ifndef SOAP_TYPE__ns8__SetCurrentPresetResponse
#define SOAP_TYPE__ns8__SetCurrentPresetResponse (1017)
/* complex XSD type 'ns8:SetCurrentPresetResponse': */
class SOAP_CMAC _ns8__SetCurrentPresetResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns8__SetCurrentPresetResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns8__SetCurrentPresetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns8__SetCurrentPresetResponse, default initialized and not managed by a soap context
        virtual _ns8__SetCurrentPresetResponse *soap_alloc(void) const { return SOAP_NEW(_ns8__SetCurrentPresetResponse); }
      public:
        /// Constructor with initializations
        _ns8__SetCurrentPresetResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns8__SetCurrentPresetResponse() { }
        /// Friend allocator used by soap_new__ns8__SetCurrentPresetResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns8__SetCurrentPresetResponse * SOAP_FMAC2 soap_instantiate__ns8__SetCurrentPresetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2602 */
#ifndef SOAP_TYPE_ns9__Capabilities
#define SOAP_TYPE_ns9__Capabilities (1018)
/* complex XSD type 'ns9:Capabilities': */
class SOAP_CMAC ns9__Capabilities {
      public:
        /// Required element 'ns9:ProfileCapabilities' of XSD type 'ns9:ProfileCapabilities'
        ns9__ProfileCapabilities *ProfileCapabilities;
        /// Required element 'ns9:StreamingCapabilities' of XSD type 'ns9:StreamingCapabilities'
        ns9__StreamingCapabilities *StreamingCapabilities;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// optional attribute 'SnapshotUri' of XSD type 'xsd:boolean'
        bool *SnapshotUri;
        /// optional attribute 'Rotation' of XSD type 'xsd:boolean'
        bool *Rotation;
        /// optional attribute 'VideoSourceMode' of XSD type 'xsd:boolean'
        bool *VideoSourceMode;
        /// optional attribute 'OSD' of XSD type 'xsd:boolean'
        bool *OSD;
        /// optional attribute 'EXICompression' of XSD type 'xsd:boolean'
        bool *EXICompression;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns9__Capabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns9__Capabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns9__Capabilities, default initialized and not managed by a soap context
        virtual ns9__Capabilities *soap_alloc(void) const { return SOAP_NEW(ns9__Capabilities); }
      public:
        /// Constructor with initializations
        ns9__Capabilities()
        {
          ProfileCapabilities = (ns9__ProfileCapabilities *)0;
          StreamingCapabilities = (ns9__StreamingCapabilities *)0;
          SnapshotUri = (bool *)0;
          Rotation = (bool *)0;
          VideoSourceMode = (bool *)0;
          OSD = (bool *)0;
          EXICompression = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns9__Capabilities() { }
        /// Friend allocator used by soap_new_ns9__Capabilities(struct soap*, int)
        friend SOAP_FMAC1 ns9__Capabilities * SOAP_FMAC2 soap_instantiate_ns9__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2605 */
#ifndef SOAP_TYPE_ns9__ProfileCapabilities
#define SOAP_TYPE_ns9__ProfileCapabilities (1019)
/* complex XSD type 'ns9:ProfileCapabilities': */
class SOAP_CMAC ns9__ProfileCapabilities {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// optional attribute 'MaximumNumberOfProfiles' of XSD type 'xsd:int'
        int *MaximumNumberOfProfiles;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns9__ProfileCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns9__ProfileCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns9__ProfileCapabilities, default initialized and not managed by a soap context
        virtual ns9__ProfileCapabilities *soap_alloc(void) const { return SOAP_NEW(ns9__ProfileCapabilities); }
      public:
        /// Constructor with initializations
        ns9__ProfileCapabilities()
        {
          MaximumNumberOfProfiles = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns9__ProfileCapabilities() { }
        /// Friend allocator used by soap_new_ns9__ProfileCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns9__ProfileCapabilities * SOAP_FMAC2 soap_instantiate_ns9__ProfileCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2608 */
#ifndef SOAP_TYPE_ns9__StreamingCapabilities
#define SOAP_TYPE_ns9__StreamingCapabilities (1020)
/* complex XSD type 'ns9:StreamingCapabilities': */
class SOAP_CMAC ns9__StreamingCapabilities {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// optional attribute 'RTPMulticast' of XSD type 'xsd:boolean'
        bool *RTPMulticast;
        /// optional attribute 'RTP_TCP' of XSD type 'xsd:boolean'
        bool *RTP_USCORETCP;
        /// optional attribute 'RTP_RTSP_TCP' of XSD type 'xsd:boolean'
        bool *RTP_USCORERTSP_USCORETCP;
        /// optional attribute 'NonAggregateControl' of XSD type 'xsd:boolean'
        bool *NonAggregateControl;
        /// optional attribute 'NoRTSPStreaming' of XSD type 'xsd:boolean'
        bool *NoRTSPStreaming;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns9__StreamingCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns9__StreamingCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns9__StreamingCapabilities, default initialized and not managed by a soap context
        virtual ns9__StreamingCapabilities *soap_alloc(void) const { return SOAP_NEW(ns9__StreamingCapabilities); }
      public:
        /// Constructor with initializations
        ns9__StreamingCapabilities()
        {
          RTPMulticast = (bool *)0;
          RTP_USCORETCP = (bool *)0;
          RTP_USCORERTSP_USCORETCP = (bool *)0;
          NonAggregateControl = (bool *)0;
          NoRTSPStreaming = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns9__StreamingCapabilities() { }
        /// Friend allocator used by soap_new_ns9__StreamingCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns9__StreamingCapabilities * SOAP_FMAC2 soap_instantiate_ns9__StreamingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2611 */
#ifndef SOAP_TYPE_ns9__VideoSourceMode
#define SOAP_TYPE_ns9__VideoSourceMode (1021)
/* complex XSD type 'ns9:VideoSourceMode': */
class SOAP_CMAC ns9__VideoSourceMode {
      public:
        /// Required element 'ns9:MaxFramerate' of XSD type 'xsd:float'
        float MaxFramerate;
        /// Required element 'ns9:MaxResolution' of XSD type 'ns2:VideoResolution'
        ns2__VideoResolution *MaxResolution;
        /// Required element 'ns9:Encodings' of XSD type 'ns9:EncodingTypes'
        std::string Encodings;
        /// Required element 'ns9:Reboot' of XSD type 'xsd:boolean'
        bool Reboot;
        /// Optional element 'ns9:Description' of XSD type 'ns2:Description'
        std::string *Description;
        /// Optional element 'ns9:Extension' of XSD type 'ns9:VideoSourceModeExtension'
        ns9__VideoSourceModeExtension *Extension;
        /// required attribute 'token' of XSD type 'ns2:ReferenceToken'
        std::string token;
        /// optional attribute 'Enabled' of XSD type 'xsd:boolean'
        bool *Enabled;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns9__VideoSourceMode
        virtual int soap_type(void) const { return SOAP_TYPE_ns9__VideoSourceMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns9__VideoSourceMode, default initialized and not managed by a soap context
        virtual ns9__VideoSourceMode *soap_alloc(void) const { return SOAP_NEW(ns9__VideoSourceMode); }
      public:
        /// Constructor with initializations
        ns9__VideoSourceMode()
        {
          MaxFramerate = (float)0;
          MaxResolution = (ns2__VideoResolution *)0;
          Reboot = (bool)0;
          Description = (std::string *)0;
          Extension = (ns9__VideoSourceModeExtension *)0;
          Enabled = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns9__VideoSourceMode() { }
        /// Friend allocator used by soap_new_ns9__VideoSourceMode(struct soap*, int)
        friend SOAP_FMAC1 ns9__VideoSourceMode * SOAP_FMAC2 soap_instantiate_ns9__VideoSourceMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2614 */
#ifndef SOAP_TYPE_ns9__VideoSourceModeExtension
#define SOAP_TYPE_ns9__VideoSourceModeExtension (1022)
/* complex XSD type 'ns9:VideoSourceModeExtension': */
class SOAP_CMAC ns9__VideoSourceModeExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns9__VideoSourceModeExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns9__VideoSourceModeExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns9__VideoSourceModeExtension, default initialized and not managed by a soap context
        virtual ns9__VideoSourceModeExtension *soap_alloc(void) const { return SOAP_NEW(ns9__VideoSourceModeExtension); }
      public:
        /// Constructor with initializations
        ns9__VideoSourceModeExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns9__VideoSourceModeExtension() { }
        /// Friend allocator used by soap_new_ns9__VideoSourceModeExtension(struct soap*, int)
        friend SOAP_FMAC1 ns9__VideoSourceModeExtension * SOAP_FMAC2 soap_instantiate_ns9__VideoSourceModeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2617 */
#ifndef SOAP_TYPE__ns9__GetServiceCapabilities
#define SOAP_TYPE__ns9__GetServiceCapabilities (1023)
/* complex XSD type 'ns9:GetServiceCapabilities': */
class SOAP_CMAC _ns9__GetServiceCapabilities {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetServiceCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetServiceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetServiceCapabilities, default initialized and not managed by a soap context
        virtual _ns9__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_ns9__GetServiceCapabilities); }
      public:
        /// Constructor with initializations
        _ns9__GetServiceCapabilities()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetServiceCapabilities() { }
        /// Friend allocator used by soap_new__ns9__GetServiceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__ns9__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2620 */
#ifndef SOAP_TYPE__ns9__GetServiceCapabilitiesResponse
#define SOAP_TYPE__ns9__GetServiceCapabilitiesResponse (1024)
/* complex XSD type 'ns9:GetServiceCapabilitiesResponse': */
class SOAP_CMAC _ns9__GetServiceCapabilitiesResponse {
      public:
        /// Required element 'ns9:Capabilities' of XSD type 'ns9:Capabilities'
        ns9__Capabilities *Capabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetServiceCapabilitiesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetServiceCapabilitiesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
        virtual _ns9__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetServiceCapabilitiesResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetServiceCapabilitiesResponse()
        {
          Capabilities = (ns9__Capabilities *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetServiceCapabilitiesResponse() { }
        /// Friend allocator used by soap_new__ns9__GetServiceCapabilitiesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__ns9__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2623 */
#ifndef SOAP_TYPE__ns9__GetVideoSources
#define SOAP_TYPE__ns9__GetVideoSources (1025)
/* complex XSD type 'ns9:GetVideoSources': */
class SOAP_CMAC _ns9__GetVideoSources {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetVideoSources
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetVideoSources; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetVideoSources, default initialized and not managed by a soap context
        virtual _ns9__GetVideoSources *soap_alloc(void) const { return SOAP_NEW(_ns9__GetVideoSources); }
      public:
        /// Constructor with initializations
        _ns9__GetVideoSources()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetVideoSources() { }
        /// Friend allocator used by soap_new__ns9__GetVideoSources(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetVideoSources * SOAP_FMAC2 soap_instantiate__ns9__GetVideoSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2626 */
#ifndef SOAP_TYPE__ns9__GetVideoSourcesResponse
#define SOAP_TYPE__ns9__GetVideoSourcesResponse (1026)
/* complex XSD type 'ns9:GetVideoSourcesResponse': */
class SOAP_CMAC _ns9__GetVideoSourcesResponse {
      public:
        /// Optional element 'ns9:VideoSources' of XSD type 'ns2:VideoSource'
        std::vector<ns2__VideoSource *> VideoSources;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetVideoSourcesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetVideoSourcesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetVideoSourcesResponse, default initialized and not managed by a soap context
        virtual _ns9__GetVideoSourcesResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetVideoSourcesResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetVideoSourcesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetVideoSourcesResponse() { }
        /// Friend allocator used by soap_new__ns9__GetVideoSourcesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetVideoSourcesResponse * SOAP_FMAC2 soap_instantiate__ns9__GetVideoSourcesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2629 */
#ifndef SOAP_TYPE__ns9__GetAudioSources
#define SOAP_TYPE__ns9__GetAudioSources (1027)
/* complex XSD type 'ns9:GetAudioSources': */
class SOAP_CMAC _ns9__GetAudioSources {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioSources
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioSources; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioSources, default initialized and not managed by a soap context
        virtual _ns9__GetAudioSources *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioSources); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioSources()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioSources() { }
        /// Friend allocator used by soap_new__ns9__GetAudioSources(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioSources * SOAP_FMAC2 soap_instantiate__ns9__GetAudioSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2632 */
#ifndef SOAP_TYPE__ns9__GetAudioSourcesResponse
#define SOAP_TYPE__ns9__GetAudioSourcesResponse (1028)
/* complex XSD type 'ns9:GetAudioSourcesResponse': */
class SOAP_CMAC _ns9__GetAudioSourcesResponse {
      public:
        /// Optional element 'ns9:AudioSources' of XSD type 'ns2:AudioSource'
        std::vector<ns2__AudioSource *> AudioSources;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioSourcesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioSourcesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioSourcesResponse, default initialized and not managed by a soap context
        virtual _ns9__GetAudioSourcesResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioSourcesResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioSourcesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioSourcesResponse() { }
        /// Friend allocator used by soap_new__ns9__GetAudioSourcesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioSourcesResponse * SOAP_FMAC2 soap_instantiate__ns9__GetAudioSourcesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2635 */
#ifndef SOAP_TYPE__ns9__GetAudioOutputs
#define SOAP_TYPE__ns9__GetAudioOutputs (1029)
/* complex XSD type 'ns9:GetAudioOutputs': */
class SOAP_CMAC _ns9__GetAudioOutputs {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioOutputs
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioOutputs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioOutputs, default initialized and not managed by a soap context
        virtual _ns9__GetAudioOutputs *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioOutputs); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioOutputs()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioOutputs() { }
        /// Friend allocator used by soap_new__ns9__GetAudioOutputs(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioOutputs * SOAP_FMAC2 soap_instantiate__ns9__GetAudioOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2638 */
#ifndef SOAP_TYPE__ns9__GetAudioOutputsResponse
#define SOAP_TYPE__ns9__GetAudioOutputsResponse (1030)
/* complex XSD type 'ns9:GetAudioOutputsResponse': */
class SOAP_CMAC _ns9__GetAudioOutputsResponse {
      public:
        /// Optional element 'ns9:AudioOutputs' of XSD type 'ns2:AudioOutput'
        std::vector<ns2__AudioOutput *> AudioOutputs;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioOutputsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioOutputsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioOutputsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetAudioOutputsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioOutputsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioOutputsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioOutputsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetAudioOutputsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioOutputsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetAudioOutputsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2641 */
#ifndef SOAP_TYPE__ns9__CreateProfile
#define SOAP_TYPE__ns9__CreateProfile (1031)
/* complex XSD type 'ns9:CreateProfile': */
class SOAP_CMAC _ns9__CreateProfile {
      public:
        /// Required element 'ns9:Name' of XSD type 'ns2:Name'
        std::string Name;
        /// Optional element 'ns9:Token' of XSD type 'ns2:ReferenceToken'
        std::string *Token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__CreateProfile
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__CreateProfile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__CreateProfile, default initialized and not managed by a soap context
        virtual _ns9__CreateProfile *soap_alloc(void) const { return SOAP_NEW(_ns9__CreateProfile); }
      public:
        /// Constructor with initializations
        _ns9__CreateProfile()
        {
          Token = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__CreateProfile() { }
        /// Friend allocator used by soap_new__ns9__CreateProfile(struct soap*, int)
        friend SOAP_FMAC1 _ns9__CreateProfile * SOAP_FMAC2 soap_instantiate__ns9__CreateProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2644 */
#ifndef SOAP_TYPE__ns9__CreateProfileResponse
#define SOAP_TYPE__ns9__CreateProfileResponse (1032)
/* complex XSD type 'ns9:CreateProfileResponse': */
class SOAP_CMAC _ns9__CreateProfileResponse {
      public:
        /// Required element 'ns9:Profile' of XSD type 'ns2:Profile'
        ns2__Profile *Profile;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__CreateProfileResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__CreateProfileResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__CreateProfileResponse, default initialized and not managed by a soap context
        virtual _ns9__CreateProfileResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__CreateProfileResponse); }
      public:
        /// Constructor with initializations
        _ns9__CreateProfileResponse()
        {
          Profile = (ns2__Profile *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__CreateProfileResponse() { }
        /// Friend allocator used by soap_new__ns9__CreateProfileResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__CreateProfileResponse * SOAP_FMAC2 soap_instantiate__ns9__CreateProfileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2647 */
#ifndef SOAP_TYPE__ns9__GetProfile
#define SOAP_TYPE__ns9__GetProfile (1033)
/* complex XSD type 'ns9:GetProfile': */
class SOAP_CMAC _ns9__GetProfile {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetProfile
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetProfile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetProfile, default initialized and not managed by a soap context
        virtual _ns9__GetProfile *soap_alloc(void) const { return SOAP_NEW(_ns9__GetProfile); }
      public:
        /// Constructor with initializations
        _ns9__GetProfile()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetProfile() { }
        /// Friend allocator used by soap_new__ns9__GetProfile(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetProfile * SOAP_FMAC2 soap_instantiate__ns9__GetProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2650 */
#ifndef SOAP_TYPE__ns9__GetProfileResponse
#define SOAP_TYPE__ns9__GetProfileResponse (1034)
/* complex XSD type 'ns9:GetProfileResponse': */
class SOAP_CMAC _ns9__GetProfileResponse {
      public:
        /// Required element 'ns9:Profile' of XSD type 'ns2:Profile'
        ns2__Profile *Profile;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetProfileResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetProfileResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetProfileResponse, default initialized and not managed by a soap context
        virtual _ns9__GetProfileResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetProfileResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetProfileResponse()
        {
          Profile = (ns2__Profile *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetProfileResponse() { }
        /// Friend allocator used by soap_new__ns9__GetProfileResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetProfileResponse * SOAP_FMAC2 soap_instantiate__ns9__GetProfileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2653 */
#ifndef SOAP_TYPE__ns9__GetProfiles
#define SOAP_TYPE__ns9__GetProfiles (1035)
/* complex XSD type 'ns9:GetProfiles': */
class SOAP_CMAC _ns9__GetProfiles {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetProfiles
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetProfiles; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetProfiles, default initialized and not managed by a soap context
        virtual _ns9__GetProfiles *soap_alloc(void) const { return SOAP_NEW(_ns9__GetProfiles); }
      public:
        /// Constructor with initializations
        _ns9__GetProfiles()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetProfiles() { }
        /// Friend allocator used by soap_new__ns9__GetProfiles(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetProfiles * SOAP_FMAC2 soap_instantiate__ns9__GetProfiles(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2656 */
#ifndef SOAP_TYPE__ns9__GetProfilesResponse
#define SOAP_TYPE__ns9__GetProfilesResponse (1036)
/* complex XSD type 'ns9:GetProfilesResponse': */
class SOAP_CMAC _ns9__GetProfilesResponse {
      public:
        /// Optional element 'ns9:Profiles' of XSD type 'ns2:Profile'
        std::vector<ns2__Profile *> Profiles;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetProfilesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetProfilesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetProfilesResponse, default initialized and not managed by a soap context
        virtual _ns9__GetProfilesResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetProfilesResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetProfilesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetProfilesResponse() { }
        /// Friend allocator used by soap_new__ns9__GetProfilesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetProfilesResponse * SOAP_FMAC2 soap_instantiate__ns9__GetProfilesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2659 */
#ifndef SOAP_TYPE__ns9__AddVideoEncoderConfiguration
#define SOAP_TYPE__ns9__AddVideoEncoderConfiguration (1037)
/* complex XSD type 'ns9:AddVideoEncoderConfiguration': */
class SOAP_CMAC _ns9__AddVideoEncoderConfiguration {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__AddVideoEncoderConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__AddVideoEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__AddVideoEncoderConfiguration, default initialized and not managed by a soap context
        virtual _ns9__AddVideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__AddVideoEncoderConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__AddVideoEncoderConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__AddVideoEncoderConfiguration() { }
        /// Friend allocator used by soap_new__ns9__AddVideoEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__AddVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate__ns9__AddVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2662 */
#ifndef SOAP_TYPE__ns9__AddVideoEncoderConfigurationResponse
#define SOAP_TYPE__ns9__AddVideoEncoderConfigurationResponse (1038)
/* complex XSD type 'ns9:AddVideoEncoderConfigurationResponse': */
class SOAP_CMAC _ns9__AddVideoEncoderConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__AddVideoEncoderConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__AddVideoEncoderConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__AddVideoEncoderConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__AddVideoEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__AddVideoEncoderConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__AddVideoEncoderConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__AddVideoEncoderConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__AddVideoEncoderConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__AddVideoEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__AddVideoEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2665 */
#ifndef SOAP_TYPE__ns9__RemoveVideoEncoderConfiguration
#define SOAP_TYPE__ns9__RemoveVideoEncoderConfiguration (1039)
/* complex XSD type 'ns9:RemoveVideoEncoderConfiguration': */
class SOAP_CMAC _ns9__RemoveVideoEncoderConfiguration {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__RemoveVideoEncoderConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__RemoveVideoEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__RemoveVideoEncoderConfiguration, default initialized and not managed by a soap context
        virtual _ns9__RemoveVideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__RemoveVideoEncoderConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__RemoveVideoEncoderConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__RemoveVideoEncoderConfiguration() { }
        /// Friend allocator used by soap_new__ns9__RemoveVideoEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__RemoveVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate__ns9__RemoveVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2668 */
#ifndef SOAP_TYPE__ns9__RemoveVideoEncoderConfigurationResponse
#define SOAP_TYPE__ns9__RemoveVideoEncoderConfigurationResponse (1040)
/* complex XSD type 'ns9:RemoveVideoEncoderConfigurationResponse': */
class SOAP_CMAC _ns9__RemoveVideoEncoderConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__RemoveVideoEncoderConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__RemoveVideoEncoderConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__RemoveVideoEncoderConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__RemoveVideoEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__RemoveVideoEncoderConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__RemoveVideoEncoderConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__RemoveVideoEncoderConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__RemoveVideoEncoderConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__RemoveVideoEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__RemoveVideoEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2671 */
#ifndef SOAP_TYPE__ns9__AddVideoSourceConfiguration
#define SOAP_TYPE__ns9__AddVideoSourceConfiguration (1041)
/* complex XSD type 'ns9:AddVideoSourceConfiguration': */
class SOAP_CMAC _ns9__AddVideoSourceConfiguration {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__AddVideoSourceConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__AddVideoSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__AddVideoSourceConfiguration, default initialized and not managed by a soap context
        virtual _ns9__AddVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__AddVideoSourceConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__AddVideoSourceConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__AddVideoSourceConfiguration() { }
        /// Friend allocator used by soap_new__ns9__AddVideoSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__AddVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate__ns9__AddVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2674 */
#ifndef SOAP_TYPE__ns9__AddVideoSourceConfigurationResponse
#define SOAP_TYPE__ns9__AddVideoSourceConfigurationResponse (1042)
/* complex XSD type 'ns9:AddVideoSourceConfigurationResponse': */
class SOAP_CMAC _ns9__AddVideoSourceConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__AddVideoSourceConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__AddVideoSourceConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__AddVideoSourceConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__AddVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__AddVideoSourceConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__AddVideoSourceConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__AddVideoSourceConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__AddVideoSourceConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__AddVideoSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__AddVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2677 */
#ifndef SOAP_TYPE__ns9__RemoveVideoSourceConfiguration
#define SOAP_TYPE__ns9__RemoveVideoSourceConfiguration (1043)
/* complex XSD type 'ns9:RemoveVideoSourceConfiguration': */
class SOAP_CMAC _ns9__RemoveVideoSourceConfiguration {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__RemoveVideoSourceConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__RemoveVideoSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__RemoveVideoSourceConfiguration, default initialized and not managed by a soap context
        virtual _ns9__RemoveVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__RemoveVideoSourceConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__RemoveVideoSourceConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__RemoveVideoSourceConfiguration() { }
        /// Friend allocator used by soap_new__ns9__RemoveVideoSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__RemoveVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate__ns9__RemoveVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2680 */
#ifndef SOAP_TYPE__ns9__RemoveVideoSourceConfigurationResponse
#define SOAP_TYPE__ns9__RemoveVideoSourceConfigurationResponse (1044)
/* complex XSD type 'ns9:RemoveVideoSourceConfigurationResponse': */
class SOAP_CMAC _ns9__RemoveVideoSourceConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__RemoveVideoSourceConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__RemoveVideoSourceConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__RemoveVideoSourceConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__RemoveVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__RemoveVideoSourceConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__RemoveVideoSourceConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__RemoveVideoSourceConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__RemoveVideoSourceConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__RemoveVideoSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__RemoveVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2683 */
#ifndef SOAP_TYPE__ns9__AddAudioEncoderConfiguration
#define SOAP_TYPE__ns9__AddAudioEncoderConfiguration (1045)
/* complex XSD type 'ns9:AddAudioEncoderConfiguration': */
class SOAP_CMAC _ns9__AddAudioEncoderConfiguration {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__AddAudioEncoderConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__AddAudioEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__AddAudioEncoderConfiguration, default initialized and not managed by a soap context
        virtual _ns9__AddAudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__AddAudioEncoderConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__AddAudioEncoderConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__AddAudioEncoderConfiguration() { }
        /// Friend allocator used by soap_new__ns9__AddAudioEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__AddAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate__ns9__AddAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2686 */
#ifndef SOAP_TYPE__ns9__AddAudioEncoderConfigurationResponse
#define SOAP_TYPE__ns9__AddAudioEncoderConfigurationResponse (1046)
/* complex XSD type 'ns9:AddAudioEncoderConfigurationResponse': */
class SOAP_CMAC _ns9__AddAudioEncoderConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__AddAudioEncoderConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__AddAudioEncoderConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__AddAudioEncoderConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__AddAudioEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__AddAudioEncoderConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__AddAudioEncoderConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__AddAudioEncoderConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__AddAudioEncoderConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__AddAudioEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__AddAudioEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2689 */
#ifndef SOAP_TYPE__ns9__RemoveAudioEncoderConfiguration
#define SOAP_TYPE__ns9__RemoveAudioEncoderConfiguration (1047)
/* complex XSD type 'ns9:RemoveAudioEncoderConfiguration': */
class SOAP_CMAC _ns9__RemoveAudioEncoderConfiguration {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__RemoveAudioEncoderConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__RemoveAudioEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__RemoveAudioEncoderConfiguration, default initialized and not managed by a soap context
        virtual _ns9__RemoveAudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__RemoveAudioEncoderConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__RemoveAudioEncoderConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__RemoveAudioEncoderConfiguration() { }
        /// Friend allocator used by soap_new__ns9__RemoveAudioEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__RemoveAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate__ns9__RemoveAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2692 */
#ifndef SOAP_TYPE__ns9__RemoveAudioEncoderConfigurationResponse
#define SOAP_TYPE__ns9__RemoveAudioEncoderConfigurationResponse (1048)
/* complex XSD type 'ns9:RemoveAudioEncoderConfigurationResponse': */
class SOAP_CMAC _ns9__RemoveAudioEncoderConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__RemoveAudioEncoderConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__RemoveAudioEncoderConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__RemoveAudioEncoderConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__RemoveAudioEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__RemoveAudioEncoderConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__RemoveAudioEncoderConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__RemoveAudioEncoderConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__RemoveAudioEncoderConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__RemoveAudioEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__RemoveAudioEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2695 */
#ifndef SOAP_TYPE__ns9__AddAudioSourceConfiguration
#define SOAP_TYPE__ns9__AddAudioSourceConfiguration (1049)
/* complex XSD type 'ns9:AddAudioSourceConfiguration': */
class SOAP_CMAC _ns9__AddAudioSourceConfiguration {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__AddAudioSourceConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__AddAudioSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__AddAudioSourceConfiguration, default initialized and not managed by a soap context
        virtual _ns9__AddAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__AddAudioSourceConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__AddAudioSourceConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__AddAudioSourceConfiguration() { }
        /// Friend allocator used by soap_new__ns9__AddAudioSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__AddAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate__ns9__AddAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2698 */
#ifndef SOAP_TYPE__ns9__AddAudioSourceConfigurationResponse
#define SOAP_TYPE__ns9__AddAudioSourceConfigurationResponse (1050)
/* complex XSD type 'ns9:AddAudioSourceConfigurationResponse': */
class SOAP_CMAC _ns9__AddAudioSourceConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__AddAudioSourceConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__AddAudioSourceConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__AddAudioSourceConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__AddAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__AddAudioSourceConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__AddAudioSourceConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__AddAudioSourceConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__AddAudioSourceConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__AddAudioSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__AddAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2701 */
#ifndef SOAP_TYPE__ns9__RemoveAudioSourceConfiguration
#define SOAP_TYPE__ns9__RemoveAudioSourceConfiguration (1051)
/* complex XSD type 'ns9:RemoveAudioSourceConfiguration': */
class SOAP_CMAC _ns9__RemoveAudioSourceConfiguration {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__RemoveAudioSourceConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__RemoveAudioSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__RemoveAudioSourceConfiguration, default initialized and not managed by a soap context
        virtual _ns9__RemoveAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__RemoveAudioSourceConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__RemoveAudioSourceConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__RemoveAudioSourceConfiguration() { }
        /// Friend allocator used by soap_new__ns9__RemoveAudioSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__RemoveAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate__ns9__RemoveAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2704 */
#ifndef SOAP_TYPE__ns9__RemoveAudioSourceConfigurationResponse
#define SOAP_TYPE__ns9__RemoveAudioSourceConfigurationResponse (1052)
/* complex XSD type 'ns9:RemoveAudioSourceConfigurationResponse': */
class SOAP_CMAC _ns9__RemoveAudioSourceConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__RemoveAudioSourceConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__RemoveAudioSourceConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__RemoveAudioSourceConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__RemoveAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__RemoveAudioSourceConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__RemoveAudioSourceConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__RemoveAudioSourceConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__RemoveAudioSourceConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__RemoveAudioSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__RemoveAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2707 */
#ifndef SOAP_TYPE__ns9__AddPTZConfiguration
#define SOAP_TYPE__ns9__AddPTZConfiguration (1053)
/* complex XSD type 'ns9:AddPTZConfiguration': */
class SOAP_CMAC _ns9__AddPTZConfiguration {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__AddPTZConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__AddPTZConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__AddPTZConfiguration, default initialized and not managed by a soap context
        virtual _ns9__AddPTZConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__AddPTZConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__AddPTZConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__AddPTZConfiguration() { }
        /// Friend allocator used by soap_new__ns9__AddPTZConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__AddPTZConfiguration * SOAP_FMAC2 soap_instantiate__ns9__AddPTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2710 */
#ifndef SOAP_TYPE__ns9__AddPTZConfigurationResponse
#define SOAP_TYPE__ns9__AddPTZConfigurationResponse (1054)
/* complex XSD type 'ns9:AddPTZConfigurationResponse': */
class SOAP_CMAC _ns9__AddPTZConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__AddPTZConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__AddPTZConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__AddPTZConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__AddPTZConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__AddPTZConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__AddPTZConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__AddPTZConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__AddPTZConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__AddPTZConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__AddPTZConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2713 */
#ifndef SOAP_TYPE__ns9__RemovePTZConfiguration
#define SOAP_TYPE__ns9__RemovePTZConfiguration (1055)
/* complex XSD type 'ns9:RemovePTZConfiguration': */
class SOAP_CMAC _ns9__RemovePTZConfiguration {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__RemovePTZConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__RemovePTZConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__RemovePTZConfiguration, default initialized and not managed by a soap context
        virtual _ns9__RemovePTZConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__RemovePTZConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__RemovePTZConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__RemovePTZConfiguration() { }
        /// Friend allocator used by soap_new__ns9__RemovePTZConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__RemovePTZConfiguration * SOAP_FMAC2 soap_instantiate__ns9__RemovePTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2716 */
#ifndef SOAP_TYPE__ns9__RemovePTZConfigurationResponse
#define SOAP_TYPE__ns9__RemovePTZConfigurationResponse (1056)
/* complex XSD type 'ns9:RemovePTZConfigurationResponse': */
class SOAP_CMAC _ns9__RemovePTZConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__RemovePTZConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__RemovePTZConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__RemovePTZConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__RemovePTZConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__RemovePTZConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__RemovePTZConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__RemovePTZConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__RemovePTZConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__RemovePTZConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__RemovePTZConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2719 */
#ifndef SOAP_TYPE__ns9__AddVideoAnalyticsConfiguration
#define SOAP_TYPE__ns9__AddVideoAnalyticsConfiguration (1057)
/* complex XSD type 'ns9:AddVideoAnalyticsConfiguration': */
class SOAP_CMAC _ns9__AddVideoAnalyticsConfiguration {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__AddVideoAnalyticsConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__AddVideoAnalyticsConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__AddVideoAnalyticsConfiguration, default initialized and not managed by a soap context
        virtual _ns9__AddVideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__AddVideoAnalyticsConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__AddVideoAnalyticsConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__AddVideoAnalyticsConfiguration() { }
        /// Friend allocator used by soap_new__ns9__AddVideoAnalyticsConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__AddVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate__ns9__AddVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2722 */
#ifndef SOAP_TYPE__ns9__AddVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__ns9__AddVideoAnalyticsConfigurationResponse (1058)
/* complex XSD type 'ns9:AddVideoAnalyticsConfigurationResponse': */
class SOAP_CMAC _ns9__AddVideoAnalyticsConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__AddVideoAnalyticsConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__AddVideoAnalyticsConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__AddVideoAnalyticsConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__AddVideoAnalyticsConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__AddVideoAnalyticsConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__AddVideoAnalyticsConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__AddVideoAnalyticsConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__AddVideoAnalyticsConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__AddVideoAnalyticsConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__AddVideoAnalyticsConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2725 */
#ifndef SOAP_TYPE__ns9__RemoveVideoAnalyticsConfiguration
#define SOAP_TYPE__ns9__RemoveVideoAnalyticsConfiguration (1059)
/* complex XSD type 'ns9:RemoveVideoAnalyticsConfiguration': */
class SOAP_CMAC _ns9__RemoveVideoAnalyticsConfiguration {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__RemoveVideoAnalyticsConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__RemoveVideoAnalyticsConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__RemoveVideoAnalyticsConfiguration, default initialized and not managed by a soap context
        virtual _ns9__RemoveVideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__RemoveVideoAnalyticsConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__RemoveVideoAnalyticsConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__RemoveVideoAnalyticsConfiguration() { }
        /// Friend allocator used by soap_new__ns9__RemoveVideoAnalyticsConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__RemoveVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate__ns9__RemoveVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2728 */
#ifndef SOAP_TYPE__ns9__RemoveVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__ns9__RemoveVideoAnalyticsConfigurationResponse (1060)
/* complex XSD type 'ns9:RemoveVideoAnalyticsConfigurationResponse': */
class SOAP_CMAC _ns9__RemoveVideoAnalyticsConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__RemoveVideoAnalyticsConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__RemoveVideoAnalyticsConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__RemoveVideoAnalyticsConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__RemoveVideoAnalyticsConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__RemoveVideoAnalyticsConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__RemoveVideoAnalyticsConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__RemoveVideoAnalyticsConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__RemoveVideoAnalyticsConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__RemoveVideoAnalyticsConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__RemoveVideoAnalyticsConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2731 */
#ifndef SOAP_TYPE__ns9__AddMetadataConfiguration
#define SOAP_TYPE__ns9__AddMetadataConfiguration (1061)
/* complex XSD type 'ns9:AddMetadataConfiguration': */
class SOAP_CMAC _ns9__AddMetadataConfiguration {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__AddMetadataConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__AddMetadataConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__AddMetadataConfiguration, default initialized and not managed by a soap context
        virtual _ns9__AddMetadataConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__AddMetadataConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__AddMetadataConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__AddMetadataConfiguration() { }
        /// Friend allocator used by soap_new__ns9__AddMetadataConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__AddMetadataConfiguration * SOAP_FMAC2 soap_instantiate__ns9__AddMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2734 */
#ifndef SOAP_TYPE__ns9__AddMetadataConfigurationResponse
#define SOAP_TYPE__ns9__AddMetadataConfigurationResponse (1062)
/* complex XSD type 'ns9:AddMetadataConfigurationResponse': */
class SOAP_CMAC _ns9__AddMetadataConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__AddMetadataConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__AddMetadataConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__AddMetadataConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__AddMetadataConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__AddMetadataConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__AddMetadataConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__AddMetadataConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__AddMetadataConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__AddMetadataConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__AddMetadataConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2737 */
#ifndef SOAP_TYPE__ns9__RemoveMetadataConfiguration
#define SOAP_TYPE__ns9__RemoveMetadataConfiguration (1063)
/* complex XSD type 'ns9:RemoveMetadataConfiguration': */
class SOAP_CMAC _ns9__RemoveMetadataConfiguration {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__RemoveMetadataConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__RemoveMetadataConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__RemoveMetadataConfiguration, default initialized and not managed by a soap context
        virtual _ns9__RemoveMetadataConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__RemoveMetadataConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__RemoveMetadataConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__RemoveMetadataConfiguration() { }
        /// Friend allocator used by soap_new__ns9__RemoveMetadataConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__RemoveMetadataConfiguration * SOAP_FMAC2 soap_instantiate__ns9__RemoveMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2740 */
#ifndef SOAP_TYPE__ns9__RemoveMetadataConfigurationResponse
#define SOAP_TYPE__ns9__RemoveMetadataConfigurationResponse (1064)
/* complex XSD type 'ns9:RemoveMetadataConfigurationResponse': */
class SOAP_CMAC _ns9__RemoveMetadataConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__RemoveMetadataConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__RemoveMetadataConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__RemoveMetadataConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__RemoveMetadataConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__RemoveMetadataConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__RemoveMetadataConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__RemoveMetadataConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__RemoveMetadataConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__RemoveMetadataConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__RemoveMetadataConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2743 */
#ifndef SOAP_TYPE__ns9__AddAudioOutputConfiguration
#define SOAP_TYPE__ns9__AddAudioOutputConfiguration (1065)
/* complex XSD type 'ns9:AddAudioOutputConfiguration': */
class SOAP_CMAC _ns9__AddAudioOutputConfiguration {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__AddAudioOutputConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__AddAudioOutputConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__AddAudioOutputConfiguration, default initialized and not managed by a soap context
        virtual _ns9__AddAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__AddAudioOutputConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__AddAudioOutputConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__AddAudioOutputConfiguration() { }
        /// Friend allocator used by soap_new__ns9__AddAudioOutputConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__AddAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate__ns9__AddAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2746 */
#ifndef SOAP_TYPE__ns9__AddAudioOutputConfigurationResponse
#define SOAP_TYPE__ns9__AddAudioOutputConfigurationResponse (1066)
/* complex XSD type 'ns9:AddAudioOutputConfigurationResponse': */
class SOAP_CMAC _ns9__AddAudioOutputConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__AddAudioOutputConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__AddAudioOutputConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__AddAudioOutputConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__AddAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__AddAudioOutputConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__AddAudioOutputConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__AddAudioOutputConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__AddAudioOutputConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__AddAudioOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__AddAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2749 */
#ifndef SOAP_TYPE__ns9__RemoveAudioOutputConfiguration
#define SOAP_TYPE__ns9__RemoveAudioOutputConfiguration (1067)
/* complex XSD type 'ns9:RemoveAudioOutputConfiguration': */
class SOAP_CMAC _ns9__RemoveAudioOutputConfiguration {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__RemoveAudioOutputConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__RemoveAudioOutputConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__RemoveAudioOutputConfiguration, default initialized and not managed by a soap context
        virtual _ns9__RemoveAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__RemoveAudioOutputConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__RemoveAudioOutputConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__RemoveAudioOutputConfiguration() { }
        /// Friend allocator used by soap_new__ns9__RemoveAudioOutputConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__RemoveAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate__ns9__RemoveAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2752 */
#ifndef SOAP_TYPE__ns9__RemoveAudioOutputConfigurationResponse
#define SOAP_TYPE__ns9__RemoveAudioOutputConfigurationResponse (1068)
/* complex XSD type 'ns9:RemoveAudioOutputConfigurationResponse': */
class SOAP_CMAC _ns9__RemoveAudioOutputConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__RemoveAudioOutputConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__RemoveAudioOutputConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__RemoveAudioOutputConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__RemoveAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__RemoveAudioOutputConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__RemoveAudioOutputConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__RemoveAudioOutputConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__RemoveAudioOutputConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__RemoveAudioOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__RemoveAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2755 */
#ifndef SOAP_TYPE__ns9__AddAudioDecoderConfiguration
#define SOAP_TYPE__ns9__AddAudioDecoderConfiguration (1069)
/* complex XSD type 'ns9:AddAudioDecoderConfiguration': */
class SOAP_CMAC _ns9__AddAudioDecoderConfiguration {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__AddAudioDecoderConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__AddAudioDecoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__AddAudioDecoderConfiguration, default initialized and not managed by a soap context
        virtual _ns9__AddAudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__AddAudioDecoderConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__AddAudioDecoderConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__AddAudioDecoderConfiguration() { }
        /// Friend allocator used by soap_new__ns9__AddAudioDecoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__AddAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate__ns9__AddAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2758 */
#ifndef SOAP_TYPE__ns9__AddAudioDecoderConfigurationResponse
#define SOAP_TYPE__ns9__AddAudioDecoderConfigurationResponse (1070)
/* complex XSD type 'ns9:AddAudioDecoderConfigurationResponse': */
class SOAP_CMAC _ns9__AddAudioDecoderConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__AddAudioDecoderConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__AddAudioDecoderConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__AddAudioDecoderConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__AddAudioDecoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__AddAudioDecoderConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__AddAudioDecoderConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__AddAudioDecoderConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__AddAudioDecoderConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__AddAudioDecoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__AddAudioDecoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2761 */
#ifndef SOAP_TYPE__ns9__RemoveAudioDecoderConfiguration
#define SOAP_TYPE__ns9__RemoveAudioDecoderConfiguration (1071)
/* complex XSD type 'ns9:RemoveAudioDecoderConfiguration': */
class SOAP_CMAC _ns9__RemoveAudioDecoderConfiguration {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__RemoveAudioDecoderConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__RemoveAudioDecoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__RemoveAudioDecoderConfiguration, default initialized and not managed by a soap context
        virtual _ns9__RemoveAudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__RemoveAudioDecoderConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__RemoveAudioDecoderConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__RemoveAudioDecoderConfiguration() { }
        /// Friend allocator used by soap_new__ns9__RemoveAudioDecoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__RemoveAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate__ns9__RemoveAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2764 */
#ifndef SOAP_TYPE__ns9__RemoveAudioDecoderConfigurationResponse
#define SOAP_TYPE__ns9__RemoveAudioDecoderConfigurationResponse (1072)
/* complex XSD type 'ns9:RemoveAudioDecoderConfigurationResponse': */
class SOAP_CMAC _ns9__RemoveAudioDecoderConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__RemoveAudioDecoderConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__RemoveAudioDecoderConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__RemoveAudioDecoderConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__RemoveAudioDecoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__RemoveAudioDecoderConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__RemoveAudioDecoderConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__RemoveAudioDecoderConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__RemoveAudioDecoderConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__RemoveAudioDecoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__RemoveAudioDecoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2767 */
#ifndef SOAP_TYPE__ns9__DeleteProfile
#define SOAP_TYPE__ns9__DeleteProfile (1073)
/* complex XSD type 'ns9:DeleteProfile': */
class SOAP_CMAC _ns9__DeleteProfile {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__DeleteProfile
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__DeleteProfile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__DeleteProfile, default initialized and not managed by a soap context
        virtual _ns9__DeleteProfile *soap_alloc(void) const { return SOAP_NEW(_ns9__DeleteProfile); }
      public:
        /// Constructor with initializations
        _ns9__DeleteProfile()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__DeleteProfile() { }
        /// Friend allocator used by soap_new__ns9__DeleteProfile(struct soap*, int)
        friend SOAP_FMAC1 _ns9__DeleteProfile * SOAP_FMAC2 soap_instantiate__ns9__DeleteProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2770 */
#ifndef SOAP_TYPE__ns9__DeleteProfileResponse
#define SOAP_TYPE__ns9__DeleteProfileResponse (1074)
/* complex XSD type 'ns9:DeleteProfileResponse': */
class SOAP_CMAC _ns9__DeleteProfileResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__DeleteProfileResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__DeleteProfileResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__DeleteProfileResponse, default initialized and not managed by a soap context
        virtual _ns9__DeleteProfileResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__DeleteProfileResponse); }
      public:
        /// Constructor with initializations
        _ns9__DeleteProfileResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__DeleteProfileResponse() { }
        /// Friend allocator used by soap_new__ns9__DeleteProfileResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__DeleteProfileResponse * SOAP_FMAC2 soap_instantiate__ns9__DeleteProfileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2773 */
#ifndef SOAP_TYPE__ns9__GetVideoEncoderConfigurations
#define SOAP_TYPE__ns9__GetVideoEncoderConfigurations (1075)
/* complex XSD type 'ns9:GetVideoEncoderConfigurations': */
class SOAP_CMAC _ns9__GetVideoEncoderConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetVideoEncoderConfigurations
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetVideoEncoderConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetVideoEncoderConfigurations, default initialized and not managed by a soap context
        virtual _ns9__GetVideoEncoderConfigurations *soap_alloc(void) const { return SOAP_NEW(_ns9__GetVideoEncoderConfigurations); }
      public:
        /// Constructor with initializations
        _ns9__GetVideoEncoderConfigurations()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetVideoEncoderConfigurations() { }
        /// Friend allocator used by soap_new__ns9__GetVideoEncoderConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetVideoEncoderConfigurations * SOAP_FMAC2 soap_instantiate__ns9__GetVideoEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2776 */
#ifndef SOAP_TYPE__ns9__GetVideoEncoderConfigurationsResponse
#define SOAP_TYPE__ns9__GetVideoEncoderConfigurationsResponse (1076)
/* complex XSD type 'ns9:GetVideoEncoderConfigurationsResponse': */
class SOAP_CMAC _ns9__GetVideoEncoderConfigurationsResponse {
      public:
        /// Optional element 'ns9:Configurations' of XSD type 'ns2:VideoEncoderConfiguration'
        std::vector<ns2__VideoEncoderConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetVideoEncoderConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetVideoEncoderConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetVideoEncoderConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetVideoEncoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetVideoEncoderConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetVideoEncoderConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetVideoEncoderConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetVideoEncoderConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetVideoEncoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetVideoEncoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2779 */
#ifndef SOAP_TYPE__ns9__GetVideoSourceConfigurations
#define SOAP_TYPE__ns9__GetVideoSourceConfigurations (1077)
/* complex XSD type 'ns9:GetVideoSourceConfigurations': */
class SOAP_CMAC _ns9__GetVideoSourceConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetVideoSourceConfigurations
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetVideoSourceConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetVideoSourceConfigurations, default initialized and not managed by a soap context
        virtual _ns9__GetVideoSourceConfigurations *soap_alloc(void) const { return SOAP_NEW(_ns9__GetVideoSourceConfigurations); }
      public:
        /// Constructor with initializations
        _ns9__GetVideoSourceConfigurations()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetVideoSourceConfigurations() { }
        /// Friend allocator used by soap_new__ns9__GetVideoSourceConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetVideoSourceConfigurations * SOAP_FMAC2 soap_instantiate__ns9__GetVideoSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2782 */
#ifndef SOAP_TYPE__ns9__GetVideoSourceConfigurationsResponse
#define SOAP_TYPE__ns9__GetVideoSourceConfigurationsResponse (1078)
/* complex XSD type 'ns9:GetVideoSourceConfigurationsResponse': */
class SOAP_CMAC _ns9__GetVideoSourceConfigurationsResponse {
      public:
        /// Optional element 'ns9:Configurations' of XSD type 'ns2:VideoSourceConfiguration'
        std::vector<ns2__VideoSourceConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetVideoSourceConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetVideoSourceConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetVideoSourceConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetVideoSourceConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetVideoSourceConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetVideoSourceConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetVideoSourceConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetVideoSourceConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetVideoSourceConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetVideoSourceConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2785 */
#ifndef SOAP_TYPE__ns9__GetAudioEncoderConfigurations
#define SOAP_TYPE__ns9__GetAudioEncoderConfigurations (1079)
/* complex XSD type 'ns9:GetAudioEncoderConfigurations': */
class SOAP_CMAC _ns9__GetAudioEncoderConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioEncoderConfigurations
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioEncoderConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioEncoderConfigurations, default initialized and not managed by a soap context
        virtual _ns9__GetAudioEncoderConfigurations *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioEncoderConfigurations); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioEncoderConfigurations()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioEncoderConfigurations() { }
        /// Friend allocator used by soap_new__ns9__GetAudioEncoderConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioEncoderConfigurations * SOAP_FMAC2 soap_instantiate__ns9__GetAudioEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2788 */
#ifndef SOAP_TYPE__ns9__GetAudioEncoderConfigurationsResponse
#define SOAP_TYPE__ns9__GetAudioEncoderConfigurationsResponse (1080)
/* complex XSD type 'ns9:GetAudioEncoderConfigurationsResponse': */
class SOAP_CMAC _ns9__GetAudioEncoderConfigurationsResponse {
      public:
        /// Optional element 'ns9:Configurations' of XSD type 'ns2:AudioEncoderConfiguration'
        std::vector<ns2__AudioEncoderConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioEncoderConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioEncoderConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioEncoderConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetAudioEncoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioEncoderConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioEncoderConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioEncoderConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetAudioEncoderConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioEncoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetAudioEncoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2791 */
#ifndef SOAP_TYPE__ns9__GetAudioSourceConfigurations
#define SOAP_TYPE__ns9__GetAudioSourceConfigurations (1081)
/* complex XSD type 'ns9:GetAudioSourceConfigurations': */
class SOAP_CMAC _ns9__GetAudioSourceConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioSourceConfigurations
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioSourceConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioSourceConfigurations, default initialized and not managed by a soap context
        virtual _ns9__GetAudioSourceConfigurations *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioSourceConfigurations); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioSourceConfigurations()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioSourceConfigurations() { }
        /// Friend allocator used by soap_new__ns9__GetAudioSourceConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioSourceConfigurations * SOAP_FMAC2 soap_instantiate__ns9__GetAudioSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2794 */
#ifndef SOAP_TYPE__ns9__GetAudioSourceConfigurationsResponse
#define SOAP_TYPE__ns9__GetAudioSourceConfigurationsResponse (1082)
/* complex XSD type 'ns9:GetAudioSourceConfigurationsResponse': */
class SOAP_CMAC _ns9__GetAudioSourceConfigurationsResponse {
      public:
        /// Optional element 'ns9:Configurations' of XSD type 'ns2:AudioSourceConfiguration'
        std::vector<ns2__AudioSourceConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioSourceConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioSourceConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioSourceConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetAudioSourceConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioSourceConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioSourceConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioSourceConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetAudioSourceConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioSourceConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetAudioSourceConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2797 */
#ifndef SOAP_TYPE__ns9__GetVideoAnalyticsConfigurations
#define SOAP_TYPE__ns9__GetVideoAnalyticsConfigurations (1083)
/* complex XSD type 'ns9:GetVideoAnalyticsConfigurations': */
class SOAP_CMAC _ns9__GetVideoAnalyticsConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetVideoAnalyticsConfigurations
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetVideoAnalyticsConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetVideoAnalyticsConfigurations, default initialized and not managed by a soap context
        virtual _ns9__GetVideoAnalyticsConfigurations *soap_alloc(void) const { return SOAP_NEW(_ns9__GetVideoAnalyticsConfigurations); }
      public:
        /// Constructor with initializations
        _ns9__GetVideoAnalyticsConfigurations()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetVideoAnalyticsConfigurations() { }
        /// Friend allocator used by soap_new__ns9__GetVideoAnalyticsConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetVideoAnalyticsConfigurations * SOAP_FMAC2 soap_instantiate__ns9__GetVideoAnalyticsConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2800 */
#ifndef SOAP_TYPE__ns9__GetVideoAnalyticsConfigurationsResponse
#define SOAP_TYPE__ns9__GetVideoAnalyticsConfigurationsResponse (1084)
/* complex XSD type 'ns9:GetVideoAnalyticsConfigurationsResponse': */
class SOAP_CMAC _ns9__GetVideoAnalyticsConfigurationsResponse {
      public:
        /// Optional element 'ns9:Configurations' of XSD type 'ns2:VideoAnalyticsConfiguration'
        std::vector<ns2__VideoAnalyticsConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetVideoAnalyticsConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetVideoAnalyticsConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetVideoAnalyticsConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetVideoAnalyticsConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetVideoAnalyticsConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetVideoAnalyticsConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetVideoAnalyticsConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetVideoAnalyticsConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetVideoAnalyticsConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetVideoAnalyticsConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2803 */
#ifndef SOAP_TYPE__ns9__GetMetadataConfigurations
#define SOAP_TYPE__ns9__GetMetadataConfigurations (1085)
/* complex XSD type 'ns9:GetMetadataConfigurations': */
class SOAP_CMAC _ns9__GetMetadataConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetMetadataConfigurations
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetMetadataConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetMetadataConfigurations, default initialized and not managed by a soap context
        virtual _ns9__GetMetadataConfigurations *soap_alloc(void) const { return SOAP_NEW(_ns9__GetMetadataConfigurations); }
      public:
        /// Constructor with initializations
        _ns9__GetMetadataConfigurations()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetMetadataConfigurations() { }
        /// Friend allocator used by soap_new__ns9__GetMetadataConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetMetadataConfigurations * SOAP_FMAC2 soap_instantiate__ns9__GetMetadataConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2806 */
#ifndef SOAP_TYPE__ns9__GetMetadataConfigurationsResponse
#define SOAP_TYPE__ns9__GetMetadataConfigurationsResponse (1086)
/* complex XSD type 'ns9:GetMetadataConfigurationsResponse': */
class SOAP_CMAC _ns9__GetMetadataConfigurationsResponse {
      public:
        /// Optional element 'ns9:Configurations' of XSD type 'ns2:MetadataConfiguration'
        std::vector<ns2__MetadataConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetMetadataConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetMetadataConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetMetadataConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetMetadataConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetMetadataConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetMetadataConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetMetadataConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetMetadataConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetMetadataConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetMetadataConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2809 */
#ifndef SOAP_TYPE__ns9__GetAudioOutputConfigurations
#define SOAP_TYPE__ns9__GetAudioOutputConfigurations (1087)
/* complex XSD type 'ns9:GetAudioOutputConfigurations': */
class SOAP_CMAC _ns9__GetAudioOutputConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioOutputConfigurations
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioOutputConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioOutputConfigurations, default initialized and not managed by a soap context
        virtual _ns9__GetAudioOutputConfigurations *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioOutputConfigurations); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioOutputConfigurations()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioOutputConfigurations() { }
        /// Friend allocator used by soap_new__ns9__GetAudioOutputConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioOutputConfigurations * SOAP_FMAC2 soap_instantiate__ns9__GetAudioOutputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2812 */
#ifndef SOAP_TYPE__ns9__GetAudioOutputConfigurationsResponse
#define SOAP_TYPE__ns9__GetAudioOutputConfigurationsResponse (1088)
/* complex XSD type 'ns9:GetAudioOutputConfigurationsResponse': */
class SOAP_CMAC _ns9__GetAudioOutputConfigurationsResponse {
      public:
        /// Optional element 'ns9:Configurations' of XSD type 'ns2:AudioOutputConfiguration'
        std::vector<ns2__AudioOutputConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioOutputConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioOutputConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioOutputConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetAudioOutputConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioOutputConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioOutputConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioOutputConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetAudioOutputConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioOutputConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetAudioOutputConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2815 */
#ifndef SOAP_TYPE__ns9__GetAudioDecoderConfigurations
#define SOAP_TYPE__ns9__GetAudioDecoderConfigurations (1089)
/* complex XSD type 'ns9:GetAudioDecoderConfigurations': */
class SOAP_CMAC _ns9__GetAudioDecoderConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioDecoderConfigurations
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioDecoderConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioDecoderConfigurations, default initialized and not managed by a soap context
        virtual _ns9__GetAudioDecoderConfigurations *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioDecoderConfigurations); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioDecoderConfigurations()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioDecoderConfigurations() { }
        /// Friend allocator used by soap_new__ns9__GetAudioDecoderConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioDecoderConfigurations * SOAP_FMAC2 soap_instantiate__ns9__GetAudioDecoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2818 */
#ifndef SOAP_TYPE__ns9__GetAudioDecoderConfigurationsResponse
#define SOAP_TYPE__ns9__GetAudioDecoderConfigurationsResponse (1090)
/* complex XSD type 'ns9:GetAudioDecoderConfigurationsResponse': */
class SOAP_CMAC _ns9__GetAudioDecoderConfigurationsResponse {
      public:
        /// Optional element 'ns9:Configurations' of XSD type 'ns2:AudioDecoderConfiguration'
        std::vector<ns2__AudioDecoderConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioDecoderConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioDecoderConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioDecoderConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetAudioDecoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioDecoderConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioDecoderConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioDecoderConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetAudioDecoderConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioDecoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetAudioDecoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2821 */
#ifndef SOAP_TYPE__ns9__GetVideoSourceConfiguration
#define SOAP_TYPE__ns9__GetVideoSourceConfiguration (1091)
/* complex XSD type 'ns9:GetVideoSourceConfiguration': */
class SOAP_CMAC _ns9__GetVideoSourceConfiguration {
      public:
        /// Required element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetVideoSourceConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetVideoSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetVideoSourceConfiguration, default initialized and not managed by a soap context
        virtual _ns9__GetVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__GetVideoSourceConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__GetVideoSourceConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetVideoSourceConfiguration() { }
        /// Friend allocator used by soap_new__ns9__GetVideoSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate__ns9__GetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2824 */
#ifndef SOAP_TYPE__ns9__GetVideoSourceConfigurationResponse
#define SOAP_TYPE__ns9__GetVideoSourceConfigurationResponse (1092)
/* complex XSD type 'ns9:GetVideoSourceConfigurationResponse': */
class SOAP_CMAC _ns9__GetVideoSourceConfigurationResponse {
      public:
        /// Required element 'ns9:Configuration' of XSD type 'ns2:VideoSourceConfiguration'
        ns2__VideoSourceConfiguration *Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetVideoSourceConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetVideoSourceConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetVideoSourceConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__GetVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetVideoSourceConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetVideoSourceConfigurationResponse()
        {
          Configuration = (ns2__VideoSourceConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetVideoSourceConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__GetVideoSourceConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetVideoSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__GetVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2827 */
#ifndef SOAP_TYPE__ns9__GetVideoEncoderConfiguration
#define SOAP_TYPE__ns9__GetVideoEncoderConfiguration (1093)
/* complex XSD type 'ns9:GetVideoEncoderConfiguration': */
class SOAP_CMAC _ns9__GetVideoEncoderConfiguration {
      public:
        /// Required element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetVideoEncoderConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetVideoEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetVideoEncoderConfiguration, default initialized and not managed by a soap context
        virtual _ns9__GetVideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__GetVideoEncoderConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__GetVideoEncoderConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetVideoEncoderConfiguration() { }
        /// Friend allocator used by soap_new__ns9__GetVideoEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate__ns9__GetVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2830 */
#ifndef SOAP_TYPE__ns9__GetVideoEncoderConfigurationResponse
#define SOAP_TYPE__ns9__GetVideoEncoderConfigurationResponse (1094)
/* complex XSD type 'ns9:GetVideoEncoderConfigurationResponse': */
class SOAP_CMAC _ns9__GetVideoEncoderConfigurationResponse {
      public:
        /// Required element 'ns9:Configuration' of XSD type 'ns2:VideoEncoderConfiguration'
        ns2__VideoEncoderConfiguration *Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetVideoEncoderConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetVideoEncoderConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetVideoEncoderConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__GetVideoEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetVideoEncoderConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetVideoEncoderConfigurationResponse()
        {
          Configuration = (ns2__VideoEncoderConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetVideoEncoderConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__GetVideoEncoderConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetVideoEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__GetVideoEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2833 */
#ifndef SOAP_TYPE__ns9__GetAudioSourceConfiguration
#define SOAP_TYPE__ns9__GetAudioSourceConfiguration (1095)
/* complex XSD type 'ns9:GetAudioSourceConfiguration': */
class SOAP_CMAC _ns9__GetAudioSourceConfiguration {
      public:
        /// Required element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioSourceConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioSourceConfiguration, default initialized and not managed by a soap context
        virtual _ns9__GetAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioSourceConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioSourceConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioSourceConfiguration() { }
        /// Friend allocator used by soap_new__ns9__GetAudioSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate__ns9__GetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2836 */
#ifndef SOAP_TYPE__ns9__GetAudioSourceConfigurationResponse
#define SOAP_TYPE__ns9__GetAudioSourceConfigurationResponse (1096)
/* complex XSD type 'ns9:GetAudioSourceConfigurationResponse': */
class SOAP_CMAC _ns9__GetAudioSourceConfigurationResponse {
      public:
        /// Required element 'ns9:Configuration' of XSD type 'ns2:AudioSourceConfiguration'
        ns2__AudioSourceConfiguration *Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioSourceConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioSourceConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioSourceConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__GetAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioSourceConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioSourceConfigurationResponse()
        {
          Configuration = (ns2__AudioSourceConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioSourceConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__GetAudioSourceConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__GetAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2839 */
#ifndef SOAP_TYPE__ns9__GetAudioEncoderConfiguration
#define SOAP_TYPE__ns9__GetAudioEncoderConfiguration (1097)
/* complex XSD type 'ns9:GetAudioEncoderConfiguration': */
class SOAP_CMAC _ns9__GetAudioEncoderConfiguration {
      public:
        /// Required element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioEncoderConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioEncoderConfiguration, default initialized and not managed by a soap context
        virtual _ns9__GetAudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioEncoderConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioEncoderConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioEncoderConfiguration() { }
        /// Friend allocator used by soap_new__ns9__GetAudioEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate__ns9__GetAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2842 */
#ifndef SOAP_TYPE__ns9__GetAudioEncoderConfigurationResponse
#define SOAP_TYPE__ns9__GetAudioEncoderConfigurationResponse (1098)
/* complex XSD type 'ns9:GetAudioEncoderConfigurationResponse': */
class SOAP_CMAC _ns9__GetAudioEncoderConfigurationResponse {
      public:
        /// Required element 'ns9:Configuration' of XSD type 'ns2:AudioEncoderConfiguration'
        ns2__AudioEncoderConfiguration *Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioEncoderConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioEncoderConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioEncoderConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__GetAudioEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioEncoderConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioEncoderConfigurationResponse()
        {
          Configuration = (ns2__AudioEncoderConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioEncoderConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__GetAudioEncoderConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__GetAudioEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2845 */
#ifndef SOAP_TYPE__ns9__GetVideoAnalyticsConfiguration
#define SOAP_TYPE__ns9__GetVideoAnalyticsConfiguration (1099)
/* complex XSD type 'ns9:GetVideoAnalyticsConfiguration': */
class SOAP_CMAC _ns9__GetVideoAnalyticsConfiguration {
      public:
        /// Required element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetVideoAnalyticsConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetVideoAnalyticsConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetVideoAnalyticsConfiguration, default initialized and not managed by a soap context
        virtual _ns9__GetVideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__GetVideoAnalyticsConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__GetVideoAnalyticsConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetVideoAnalyticsConfiguration() { }
        /// Friend allocator used by soap_new__ns9__GetVideoAnalyticsConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate__ns9__GetVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2848 */
#ifndef SOAP_TYPE__ns9__GetVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__ns9__GetVideoAnalyticsConfigurationResponse (1100)
/* complex XSD type 'ns9:GetVideoAnalyticsConfigurationResponse': */
class SOAP_CMAC _ns9__GetVideoAnalyticsConfigurationResponse {
      public:
        /// Required element 'ns9:Configuration' of XSD type 'ns2:VideoAnalyticsConfiguration'
        ns2__VideoAnalyticsConfiguration *Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetVideoAnalyticsConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetVideoAnalyticsConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetVideoAnalyticsConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__GetVideoAnalyticsConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetVideoAnalyticsConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetVideoAnalyticsConfigurationResponse()
        {
          Configuration = (ns2__VideoAnalyticsConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetVideoAnalyticsConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__GetVideoAnalyticsConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetVideoAnalyticsConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__GetVideoAnalyticsConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2851 */
#ifndef SOAP_TYPE__ns9__GetMetadataConfiguration
#define SOAP_TYPE__ns9__GetMetadataConfiguration (1101)
/* complex XSD type 'ns9:GetMetadataConfiguration': */
class SOAP_CMAC _ns9__GetMetadataConfiguration {
      public:
        /// Required element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetMetadataConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetMetadataConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetMetadataConfiguration, default initialized and not managed by a soap context
        virtual _ns9__GetMetadataConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__GetMetadataConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__GetMetadataConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetMetadataConfiguration() { }
        /// Friend allocator used by soap_new__ns9__GetMetadataConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetMetadataConfiguration * SOAP_FMAC2 soap_instantiate__ns9__GetMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2854 */
#ifndef SOAP_TYPE__ns9__GetMetadataConfigurationResponse
#define SOAP_TYPE__ns9__GetMetadataConfigurationResponse (1102)
/* complex XSD type 'ns9:GetMetadataConfigurationResponse': */
class SOAP_CMAC _ns9__GetMetadataConfigurationResponse {
      public:
        /// Required element 'ns9:Configuration' of XSD type 'ns2:MetadataConfiguration'
        ns2__MetadataConfiguration *Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetMetadataConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetMetadataConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetMetadataConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__GetMetadataConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetMetadataConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetMetadataConfigurationResponse()
        {
          Configuration = (ns2__MetadataConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetMetadataConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__GetMetadataConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetMetadataConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__GetMetadataConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2857 */
#ifndef SOAP_TYPE__ns9__GetAudioOutputConfiguration
#define SOAP_TYPE__ns9__GetAudioOutputConfiguration (1103)
/* complex XSD type 'ns9:GetAudioOutputConfiguration': */
class SOAP_CMAC _ns9__GetAudioOutputConfiguration {
      public:
        /// Required element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioOutputConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioOutputConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioOutputConfiguration, default initialized and not managed by a soap context
        virtual _ns9__GetAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioOutputConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioOutputConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioOutputConfiguration() { }
        /// Friend allocator used by soap_new__ns9__GetAudioOutputConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate__ns9__GetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2860 */
#ifndef SOAP_TYPE__ns9__GetAudioOutputConfigurationResponse
#define SOAP_TYPE__ns9__GetAudioOutputConfigurationResponse (1104)
/* complex XSD type 'ns9:GetAudioOutputConfigurationResponse': */
class SOAP_CMAC _ns9__GetAudioOutputConfigurationResponse {
      public:
        /// Required element 'ns9:Configuration' of XSD type 'ns2:AudioOutputConfiguration'
        ns2__AudioOutputConfiguration *Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioOutputConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioOutputConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioOutputConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__GetAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioOutputConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioOutputConfigurationResponse()
        {
          Configuration = (ns2__AudioOutputConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioOutputConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__GetAudioOutputConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__GetAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2863 */
#ifndef SOAP_TYPE__ns9__GetAudioDecoderConfiguration
#define SOAP_TYPE__ns9__GetAudioDecoderConfiguration (1105)
/* complex XSD type 'ns9:GetAudioDecoderConfiguration': */
class SOAP_CMAC _ns9__GetAudioDecoderConfiguration {
      public:
        /// Required element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioDecoderConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioDecoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioDecoderConfiguration, default initialized and not managed by a soap context
        virtual _ns9__GetAudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioDecoderConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioDecoderConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioDecoderConfiguration() { }
        /// Friend allocator used by soap_new__ns9__GetAudioDecoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate__ns9__GetAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2866 */
#ifndef SOAP_TYPE__ns9__GetAudioDecoderConfigurationResponse
#define SOAP_TYPE__ns9__GetAudioDecoderConfigurationResponse (1106)
/* complex XSD type 'ns9:GetAudioDecoderConfigurationResponse': */
class SOAP_CMAC _ns9__GetAudioDecoderConfigurationResponse {
      public:
        /// Required element 'ns9:Configuration' of XSD type 'ns2:AudioDecoderConfiguration'
        ns2__AudioDecoderConfiguration *Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioDecoderConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioDecoderConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioDecoderConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__GetAudioDecoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioDecoderConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioDecoderConfigurationResponse()
        {
          Configuration = (ns2__AudioDecoderConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioDecoderConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__GetAudioDecoderConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioDecoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__GetAudioDecoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2869 */
#ifndef SOAP_TYPE__ns9__GetCompatibleVideoEncoderConfigurations
#define SOAP_TYPE__ns9__GetCompatibleVideoEncoderConfigurations (1107)
/* complex XSD type 'ns9:GetCompatibleVideoEncoderConfigurations': */
class SOAP_CMAC _ns9__GetCompatibleVideoEncoderConfigurations {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetCompatibleVideoEncoderConfigurations
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetCompatibleVideoEncoderConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetCompatibleVideoEncoderConfigurations, default initialized and not managed by a soap context
        virtual _ns9__GetCompatibleVideoEncoderConfigurations *soap_alloc(void) const { return SOAP_NEW(_ns9__GetCompatibleVideoEncoderConfigurations); }
      public:
        /// Constructor with initializations
        _ns9__GetCompatibleVideoEncoderConfigurations()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetCompatibleVideoEncoderConfigurations() { }
        /// Friend allocator used by soap_new__ns9__GetCompatibleVideoEncoderConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetCompatibleVideoEncoderConfigurations * SOAP_FMAC2 soap_instantiate__ns9__GetCompatibleVideoEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2872 */
#ifndef SOAP_TYPE__ns9__GetCompatibleVideoEncoderConfigurationsResponse
#define SOAP_TYPE__ns9__GetCompatibleVideoEncoderConfigurationsResponse (1108)
/* complex XSD type 'ns9:GetCompatibleVideoEncoderConfigurationsResponse': */
class SOAP_CMAC _ns9__GetCompatibleVideoEncoderConfigurationsResponse {
      public:
        /// Optional element 'ns9:Configurations' of XSD type 'ns2:VideoEncoderConfiguration'
        std::vector<ns2__VideoEncoderConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetCompatibleVideoEncoderConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetCompatibleVideoEncoderConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetCompatibleVideoEncoderConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetCompatibleVideoEncoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetCompatibleVideoEncoderConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetCompatibleVideoEncoderConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetCompatibleVideoEncoderConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetCompatibleVideoEncoderConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetCompatibleVideoEncoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetCompatibleVideoEncoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2875 */
#ifndef SOAP_TYPE__ns9__GetCompatibleVideoSourceConfigurations
#define SOAP_TYPE__ns9__GetCompatibleVideoSourceConfigurations (1109)
/* complex XSD type 'ns9:GetCompatibleVideoSourceConfigurations': */
class SOAP_CMAC _ns9__GetCompatibleVideoSourceConfigurations {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetCompatibleVideoSourceConfigurations
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetCompatibleVideoSourceConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetCompatibleVideoSourceConfigurations, default initialized and not managed by a soap context
        virtual _ns9__GetCompatibleVideoSourceConfigurations *soap_alloc(void) const { return SOAP_NEW(_ns9__GetCompatibleVideoSourceConfigurations); }
      public:
        /// Constructor with initializations
        _ns9__GetCompatibleVideoSourceConfigurations()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetCompatibleVideoSourceConfigurations() { }
        /// Friend allocator used by soap_new__ns9__GetCompatibleVideoSourceConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetCompatibleVideoSourceConfigurations * SOAP_FMAC2 soap_instantiate__ns9__GetCompatibleVideoSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2878 */
#ifndef SOAP_TYPE__ns9__GetCompatibleVideoSourceConfigurationsResponse
#define SOAP_TYPE__ns9__GetCompatibleVideoSourceConfigurationsResponse (1110)
/* complex XSD type 'ns9:GetCompatibleVideoSourceConfigurationsResponse': */
class SOAP_CMAC _ns9__GetCompatibleVideoSourceConfigurationsResponse {
      public:
        /// Optional element 'ns9:Configurations' of XSD type 'ns2:VideoSourceConfiguration'
        std::vector<ns2__VideoSourceConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetCompatibleVideoSourceConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetCompatibleVideoSourceConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetCompatibleVideoSourceConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetCompatibleVideoSourceConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetCompatibleVideoSourceConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetCompatibleVideoSourceConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetCompatibleVideoSourceConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetCompatibleVideoSourceConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetCompatibleVideoSourceConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetCompatibleVideoSourceConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2881 */
#ifndef SOAP_TYPE__ns9__GetCompatibleAudioEncoderConfigurations
#define SOAP_TYPE__ns9__GetCompatibleAudioEncoderConfigurations (1111)
/* complex XSD type 'ns9:GetCompatibleAudioEncoderConfigurations': */
class SOAP_CMAC _ns9__GetCompatibleAudioEncoderConfigurations {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetCompatibleAudioEncoderConfigurations
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetCompatibleAudioEncoderConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetCompatibleAudioEncoderConfigurations, default initialized and not managed by a soap context
        virtual _ns9__GetCompatibleAudioEncoderConfigurations *soap_alloc(void) const { return SOAP_NEW(_ns9__GetCompatibleAudioEncoderConfigurations); }
      public:
        /// Constructor with initializations
        _ns9__GetCompatibleAudioEncoderConfigurations()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetCompatibleAudioEncoderConfigurations() { }
        /// Friend allocator used by soap_new__ns9__GetCompatibleAudioEncoderConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetCompatibleAudioEncoderConfigurations * SOAP_FMAC2 soap_instantiate__ns9__GetCompatibleAudioEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2884 */
#ifndef SOAP_TYPE__ns9__GetCompatibleAudioEncoderConfigurationsResponse
#define SOAP_TYPE__ns9__GetCompatibleAudioEncoderConfigurationsResponse (1112)
/* complex XSD type 'ns9:GetCompatibleAudioEncoderConfigurationsResponse': */
class SOAP_CMAC _ns9__GetCompatibleAudioEncoderConfigurationsResponse {
      public:
        /// Optional element 'ns9:Configurations' of XSD type 'ns2:AudioEncoderConfiguration'
        std::vector<ns2__AudioEncoderConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetCompatibleAudioEncoderConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetCompatibleAudioEncoderConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetCompatibleAudioEncoderConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetCompatibleAudioEncoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetCompatibleAudioEncoderConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetCompatibleAudioEncoderConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetCompatibleAudioEncoderConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetCompatibleAudioEncoderConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetCompatibleAudioEncoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetCompatibleAudioEncoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2887 */
#ifndef SOAP_TYPE__ns9__GetCompatibleAudioSourceConfigurations
#define SOAP_TYPE__ns9__GetCompatibleAudioSourceConfigurations (1113)
/* complex XSD type 'ns9:GetCompatibleAudioSourceConfigurations': */
class SOAP_CMAC _ns9__GetCompatibleAudioSourceConfigurations {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetCompatibleAudioSourceConfigurations
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetCompatibleAudioSourceConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetCompatibleAudioSourceConfigurations, default initialized and not managed by a soap context
        virtual _ns9__GetCompatibleAudioSourceConfigurations *soap_alloc(void) const { return SOAP_NEW(_ns9__GetCompatibleAudioSourceConfigurations); }
      public:
        /// Constructor with initializations
        _ns9__GetCompatibleAudioSourceConfigurations()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetCompatibleAudioSourceConfigurations() { }
        /// Friend allocator used by soap_new__ns9__GetCompatibleAudioSourceConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetCompatibleAudioSourceConfigurations * SOAP_FMAC2 soap_instantiate__ns9__GetCompatibleAudioSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2890 */
#ifndef SOAP_TYPE__ns9__GetCompatibleAudioSourceConfigurationsResponse
#define SOAP_TYPE__ns9__GetCompatibleAudioSourceConfigurationsResponse (1114)
/* complex XSD type 'ns9:GetCompatibleAudioSourceConfigurationsResponse': */
class SOAP_CMAC _ns9__GetCompatibleAudioSourceConfigurationsResponse {
      public:
        /// Optional element 'ns9:Configurations' of XSD type 'ns2:AudioSourceConfiguration'
        std::vector<ns2__AudioSourceConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetCompatibleAudioSourceConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetCompatibleAudioSourceConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetCompatibleAudioSourceConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetCompatibleAudioSourceConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetCompatibleAudioSourceConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetCompatibleAudioSourceConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetCompatibleAudioSourceConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetCompatibleAudioSourceConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetCompatibleAudioSourceConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetCompatibleAudioSourceConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2893 */
#ifndef SOAP_TYPE__ns9__GetCompatibleVideoAnalyticsConfigurations
#define SOAP_TYPE__ns9__GetCompatibleVideoAnalyticsConfigurations (1115)
/* complex XSD type 'ns9:GetCompatibleVideoAnalyticsConfigurations': */
class SOAP_CMAC _ns9__GetCompatibleVideoAnalyticsConfigurations {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetCompatibleVideoAnalyticsConfigurations
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetCompatibleVideoAnalyticsConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetCompatibleVideoAnalyticsConfigurations, default initialized and not managed by a soap context
        virtual _ns9__GetCompatibleVideoAnalyticsConfigurations *soap_alloc(void) const { return SOAP_NEW(_ns9__GetCompatibleVideoAnalyticsConfigurations); }
      public:
        /// Constructor with initializations
        _ns9__GetCompatibleVideoAnalyticsConfigurations()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetCompatibleVideoAnalyticsConfigurations() { }
        /// Friend allocator used by soap_new__ns9__GetCompatibleVideoAnalyticsConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetCompatibleVideoAnalyticsConfigurations * SOAP_FMAC2 soap_instantiate__ns9__GetCompatibleVideoAnalyticsConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2896 */
#ifndef SOAP_TYPE__ns9__GetCompatibleVideoAnalyticsConfigurationsResponse
#define SOAP_TYPE__ns9__GetCompatibleVideoAnalyticsConfigurationsResponse (1116)
/* complex XSD type 'ns9:GetCompatibleVideoAnalyticsConfigurationsResponse': */
class SOAP_CMAC _ns9__GetCompatibleVideoAnalyticsConfigurationsResponse {
      public:
        /// Optional element 'ns9:Configurations' of XSD type 'ns2:VideoAnalyticsConfiguration'
        std::vector<ns2__VideoAnalyticsConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetCompatibleVideoAnalyticsConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetCompatibleVideoAnalyticsConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetCompatibleVideoAnalyticsConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetCompatibleVideoAnalyticsConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetCompatibleVideoAnalyticsConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetCompatibleVideoAnalyticsConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetCompatibleVideoAnalyticsConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetCompatibleVideoAnalyticsConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2899 */
#ifndef SOAP_TYPE__ns9__GetCompatibleMetadataConfigurations
#define SOAP_TYPE__ns9__GetCompatibleMetadataConfigurations (1117)
/* complex XSD type 'ns9:GetCompatibleMetadataConfigurations': */
class SOAP_CMAC _ns9__GetCompatibleMetadataConfigurations {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetCompatibleMetadataConfigurations
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetCompatibleMetadataConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetCompatibleMetadataConfigurations, default initialized and not managed by a soap context
        virtual _ns9__GetCompatibleMetadataConfigurations *soap_alloc(void) const { return SOAP_NEW(_ns9__GetCompatibleMetadataConfigurations); }
      public:
        /// Constructor with initializations
        _ns9__GetCompatibleMetadataConfigurations()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetCompatibleMetadataConfigurations() { }
        /// Friend allocator used by soap_new__ns9__GetCompatibleMetadataConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetCompatibleMetadataConfigurations * SOAP_FMAC2 soap_instantiate__ns9__GetCompatibleMetadataConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2902 */
#ifndef SOAP_TYPE__ns9__GetCompatibleMetadataConfigurationsResponse
#define SOAP_TYPE__ns9__GetCompatibleMetadataConfigurationsResponse (1118)
/* complex XSD type 'ns9:GetCompatibleMetadataConfigurationsResponse': */
class SOAP_CMAC _ns9__GetCompatibleMetadataConfigurationsResponse {
      public:
        /// Optional element 'ns9:Configurations' of XSD type 'ns2:MetadataConfiguration'
        std::vector<ns2__MetadataConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetCompatibleMetadataConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetCompatibleMetadataConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetCompatibleMetadataConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetCompatibleMetadataConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetCompatibleMetadataConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetCompatibleMetadataConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetCompatibleMetadataConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetCompatibleMetadataConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetCompatibleMetadataConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetCompatibleMetadataConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2905 */
#ifndef SOAP_TYPE__ns9__GetCompatibleAudioOutputConfigurations
#define SOAP_TYPE__ns9__GetCompatibleAudioOutputConfigurations (1119)
/* complex XSD type 'ns9:GetCompatibleAudioOutputConfigurations': */
class SOAP_CMAC _ns9__GetCompatibleAudioOutputConfigurations {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetCompatibleAudioOutputConfigurations
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetCompatibleAudioOutputConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetCompatibleAudioOutputConfigurations, default initialized and not managed by a soap context
        virtual _ns9__GetCompatibleAudioOutputConfigurations *soap_alloc(void) const { return SOAP_NEW(_ns9__GetCompatibleAudioOutputConfigurations); }
      public:
        /// Constructor with initializations
        _ns9__GetCompatibleAudioOutputConfigurations()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetCompatibleAudioOutputConfigurations() { }
        /// Friend allocator used by soap_new__ns9__GetCompatibleAudioOutputConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetCompatibleAudioOutputConfigurations * SOAP_FMAC2 soap_instantiate__ns9__GetCompatibleAudioOutputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2908 */
#ifndef SOAP_TYPE__ns9__GetCompatibleAudioOutputConfigurationsResponse
#define SOAP_TYPE__ns9__GetCompatibleAudioOutputConfigurationsResponse (1120)
/* complex XSD type 'ns9:GetCompatibleAudioOutputConfigurationsResponse': */
class SOAP_CMAC _ns9__GetCompatibleAudioOutputConfigurationsResponse {
      public:
        /// Optional element 'ns9:Configurations' of XSD type 'ns2:AudioOutputConfiguration'
        std::vector<ns2__AudioOutputConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetCompatibleAudioOutputConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetCompatibleAudioOutputConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetCompatibleAudioOutputConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetCompatibleAudioOutputConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetCompatibleAudioOutputConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetCompatibleAudioOutputConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetCompatibleAudioOutputConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetCompatibleAudioOutputConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetCompatibleAudioOutputConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetCompatibleAudioOutputConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2911 */
#ifndef SOAP_TYPE__ns9__GetCompatibleAudioDecoderConfigurations
#define SOAP_TYPE__ns9__GetCompatibleAudioDecoderConfigurations (1121)
/* complex XSD type 'ns9:GetCompatibleAudioDecoderConfigurations': */
class SOAP_CMAC _ns9__GetCompatibleAudioDecoderConfigurations {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetCompatibleAudioDecoderConfigurations
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetCompatibleAudioDecoderConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetCompatibleAudioDecoderConfigurations, default initialized and not managed by a soap context
        virtual _ns9__GetCompatibleAudioDecoderConfigurations *soap_alloc(void) const { return SOAP_NEW(_ns9__GetCompatibleAudioDecoderConfigurations); }
      public:
        /// Constructor with initializations
        _ns9__GetCompatibleAudioDecoderConfigurations()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetCompatibleAudioDecoderConfigurations() { }
        /// Friend allocator used by soap_new__ns9__GetCompatibleAudioDecoderConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetCompatibleAudioDecoderConfigurations * SOAP_FMAC2 soap_instantiate__ns9__GetCompatibleAudioDecoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2914 */
#ifndef SOAP_TYPE__ns9__GetCompatibleAudioDecoderConfigurationsResponse
#define SOAP_TYPE__ns9__GetCompatibleAudioDecoderConfigurationsResponse (1122)
/* complex XSD type 'ns9:GetCompatibleAudioDecoderConfigurationsResponse': */
class SOAP_CMAC _ns9__GetCompatibleAudioDecoderConfigurationsResponse {
      public:
        /// Optional element 'ns9:Configurations' of XSD type 'ns2:AudioDecoderConfiguration'
        std::vector<ns2__AudioDecoderConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetCompatibleAudioDecoderConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetCompatibleAudioDecoderConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetCompatibleAudioDecoderConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetCompatibleAudioDecoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetCompatibleAudioDecoderConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetCompatibleAudioDecoderConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetCompatibleAudioDecoderConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetCompatibleAudioDecoderConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetCompatibleAudioDecoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetCompatibleAudioDecoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2917 */
#ifndef SOAP_TYPE__ns9__SetVideoEncoderConfiguration
#define SOAP_TYPE__ns9__SetVideoEncoderConfiguration (1123)
/* complex XSD type 'ns9:SetVideoEncoderConfiguration': */
class SOAP_CMAC _ns9__SetVideoEncoderConfiguration {
      public:
        /// Required element 'ns9:Configuration' of XSD type 'ns2:VideoEncoderConfiguration'
        ns2__VideoEncoderConfiguration *Configuration;
        /// Required element 'ns9:ForcePersistence' of XSD type 'xsd:boolean'
        bool ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__SetVideoEncoderConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__SetVideoEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__SetVideoEncoderConfiguration, default initialized and not managed by a soap context
        virtual _ns9__SetVideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__SetVideoEncoderConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__SetVideoEncoderConfiguration()
        {
          Configuration = (ns2__VideoEncoderConfiguration *)0;
          ForcePersistence = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__SetVideoEncoderConfiguration() { }
        /// Friend allocator used by soap_new__ns9__SetVideoEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__SetVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate__ns9__SetVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2920 */
#ifndef SOAP_TYPE__ns9__SetVideoEncoderConfigurationResponse
#define SOAP_TYPE__ns9__SetVideoEncoderConfigurationResponse (1124)
/* complex XSD type 'ns9:SetVideoEncoderConfigurationResponse': */
class SOAP_CMAC _ns9__SetVideoEncoderConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__SetVideoEncoderConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__SetVideoEncoderConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__SetVideoEncoderConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__SetVideoEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__SetVideoEncoderConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__SetVideoEncoderConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__SetVideoEncoderConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__SetVideoEncoderConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__SetVideoEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__SetVideoEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2923 */
#ifndef SOAP_TYPE__ns9__SetVideoSourceConfiguration
#define SOAP_TYPE__ns9__SetVideoSourceConfiguration (1125)
/* complex XSD type 'ns9:SetVideoSourceConfiguration': */
class SOAP_CMAC _ns9__SetVideoSourceConfiguration {
      public:
        /// Required element 'ns9:Configuration' of XSD type 'ns2:VideoSourceConfiguration'
        ns2__VideoSourceConfiguration *Configuration;
        /// Required element 'ns9:ForcePersistence' of XSD type 'xsd:boolean'
        bool ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__SetVideoSourceConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__SetVideoSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__SetVideoSourceConfiguration, default initialized and not managed by a soap context
        virtual _ns9__SetVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__SetVideoSourceConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__SetVideoSourceConfiguration()
        {
          Configuration = (ns2__VideoSourceConfiguration *)0;
          ForcePersistence = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__SetVideoSourceConfiguration() { }
        /// Friend allocator used by soap_new__ns9__SetVideoSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__SetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate__ns9__SetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2926 */
#ifndef SOAP_TYPE__ns9__SetVideoSourceConfigurationResponse
#define SOAP_TYPE__ns9__SetVideoSourceConfigurationResponse (1126)
/* complex XSD type 'ns9:SetVideoSourceConfigurationResponse': */
class SOAP_CMAC _ns9__SetVideoSourceConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__SetVideoSourceConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__SetVideoSourceConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__SetVideoSourceConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__SetVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__SetVideoSourceConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__SetVideoSourceConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__SetVideoSourceConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__SetVideoSourceConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__SetVideoSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__SetVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2929 */
#ifndef SOAP_TYPE__ns9__SetAudioEncoderConfiguration
#define SOAP_TYPE__ns9__SetAudioEncoderConfiguration (1127)
/* complex XSD type 'ns9:SetAudioEncoderConfiguration': */
class SOAP_CMAC _ns9__SetAudioEncoderConfiguration {
      public:
        /// Required element 'ns9:Configuration' of XSD type 'ns2:AudioEncoderConfiguration'
        ns2__AudioEncoderConfiguration *Configuration;
        /// Required element 'ns9:ForcePersistence' of XSD type 'xsd:boolean'
        bool ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__SetAudioEncoderConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__SetAudioEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__SetAudioEncoderConfiguration, default initialized and not managed by a soap context
        virtual _ns9__SetAudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__SetAudioEncoderConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__SetAudioEncoderConfiguration()
        {
          Configuration = (ns2__AudioEncoderConfiguration *)0;
          ForcePersistence = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__SetAudioEncoderConfiguration() { }
        /// Friend allocator used by soap_new__ns9__SetAudioEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__SetAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate__ns9__SetAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2932 */
#ifndef SOAP_TYPE__ns9__SetAudioEncoderConfigurationResponse
#define SOAP_TYPE__ns9__SetAudioEncoderConfigurationResponse (1128)
/* complex XSD type 'ns9:SetAudioEncoderConfigurationResponse': */
class SOAP_CMAC _ns9__SetAudioEncoderConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__SetAudioEncoderConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__SetAudioEncoderConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__SetAudioEncoderConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__SetAudioEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__SetAudioEncoderConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__SetAudioEncoderConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__SetAudioEncoderConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__SetAudioEncoderConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__SetAudioEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__SetAudioEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2935 */
#ifndef SOAP_TYPE__ns9__SetAudioSourceConfiguration
#define SOAP_TYPE__ns9__SetAudioSourceConfiguration (1129)
/* complex XSD type 'ns9:SetAudioSourceConfiguration': */
class SOAP_CMAC _ns9__SetAudioSourceConfiguration {
      public:
        /// Required element 'ns9:Configuration' of XSD type 'ns2:AudioSourceConfiguration'
        ns2__AudioSourceConfiguration *Configuration;
        /// Required element 'ns9:ForcePersistence' of XSD type 'xsd:boolean'
        bool ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__SetAudioSourceConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__SetAudioSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__SetAudioSourceConfiguration, default initialized and not managed by a soap context
        virtual _ns9__SetAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__SetAudioSourceConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__SetAudioSourceConfiguration()
        {
          Configuration = (ns2__AudioSourceConfiguration *)0;
          ForcePersistence = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__SetAudioSourceConfiguration() { }
        /// Friend allocator used by soap_new__ns9__SetAudioSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__SetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate__ns9__SetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2938 */
#ifndef SOAP_TYPE__ns9__SetAudioSourceConfigurationResponse
#define SOAP_TYPE__ns9__SetAudioSourceConfigurationResponse (1130)
/* complex XSD type 'ns9:SetAudioSourceConfigurationResponse': */
class SOAP_CMAC _ns9__SetAudioSourceConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__SetAudioSourceConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__SetAudioSourceConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__SetAudioSourceConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__SetAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__SetAudioSourceConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__SetAudioSourceConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__SetAudioSourceConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__SetAudioSourceConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__SetAudioSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__SetAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2941 */
#ifndef SOAP_TYPE__ns9__SetVideoAnalyticsConfiguration
#define SOAP_TYPE__ns9__SetVideoAnalyticsConfiguration (1131)
/* complex XSD type 'ns9:SetVideoAnalyticsConfiguration': */
class SOAP_CMAC _ns9__SetVideoAnalyticsConfiguration {
      public:
        /// Required element 'ns9:Configuration' of XSD type 'ns2:VideoAnalyticsConfiguration'
        ns2__VideoAnalyticsConfiguration *Configuration;
        /// Required element 'ns9:ForcePersistence' of XSD type 'xsd:boolean'
        bool ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__SetVideoAnalyticsConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__SetVideoAnalyticsConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__SetVideoAnalyticsConfiguration, default initialized and not managed by a soap context
        virtual _ns9__SetVideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__SetVideoAnalyticsConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__SetVideoAnalyticsConfiguration()
        {
          Configuration = (ns2__VideoAnalyticsConfiguration *)0;
          ForcePersistence = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__SetVideoAnalyticsConfiguration() { }
        /// Friend allocator used by soap_new__ns9__SetVideoAnalyticsConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__SetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate__ns9__SetVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2944 */
#ifndef SOAP_TYPE__ns9__SetVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__ns9__SetVideoAnalyticsConfigurationResponse (1132)
/* complex XSD type 'ns9:SetVideoAnalyticsConfigurationResponse': */
class SOAP_CMAC _ns9__SetVideoAnalyticsConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__SetVideoAnalyticsConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__SetVideoAnalyticsConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__SetVideoAnalyticsConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__SetVideoAnalyticsConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__SetVideoAnalyticsConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__SetVideoAnalyticsConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__SetVideoAnalyticsConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__SetVideoAnalyticsConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__SetVideoAnalyticsConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__SetVideoAnalyticsConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2947 */
#ifndef SOAP_TYPE__ns9__SetMetadataConfiguration
#define SOAP_TYPE__ns9__SetMetadataConfiguration (1133)
/* complex XSD type 'ns9:SetMetadataConfiguration': */
class SOAP_CMAC _ns9__SetMetadataConfiguration {
      public:
        /// Required element 'ns9:Configuration' of XSD type 'ns2:MetadataConfiguration'
        ns2__MetadataConfiguration *Configuration;
        /// Required element 'ns9:ForcePersistence' of XSD type 'xsd:boolean'
        bool ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__SetMetadataConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__SetMetadataConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__SetMetadataConfiguration, default initialized and not managed by a soap context
        virtual _ns9__SetMetadataConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__SetMetadataConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__SetMetadataConfiguration()
        {
          Configuration = (ns2__MetadataConfiguration *)0;
          ForcePersistence = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__SetMetadataConfiguration() { }
        /// Friend allocator used by soap_new__ns9__SetMetadataConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__SetMetadataConfiguration * SOAP_FMAC2 soap_instantiate__ns9__SetMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2950 */
#ifndef SOAP_TYPE__ns9__SetMetadataConfigurationResponse
#define SOAP_TYPE__ns9__SetMetadataConfigurationResponse (1134)
/* complex XSD type 'ns9:SetMetadataConfigurationResponse': */
class SOAP_CMAC _ns9__SetMetadataConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__SetMetadataConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__SetMetadataConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__SetMetadataConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__SetMetadataConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__SetMetadataConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__SetMetadataConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__SetMetadataConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__SetMetadataConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__SetMetadataConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__SetMetadataConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2953 */
#ifndef SOAP_TYPE__ns9__SetAudioOutputConfiguration
#define SOAP_TYPE__ns9__SetAudioOutputConfiguration (1135)
/* complex XSD type 'ns9:SetAudioOutputConfiguration': */
class SOAP_CMAC _ns9__SetAudioOutputConfiguration {
      public:
        /// Required element 'ns9:Configuration' of XSD type 'ns2:AudioOutputConfiguration'
        ns2__AudioOutputConfiguration *Configuration;
        /// Required element 'ns9:ForcePersistence' of XSD type 'xsd:boolean'
        bool ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__SetAudioOutputConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__SetAudioOutputConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__SetAudioOutputConfiguration, default initialized and not managed by a soap context
        virtual _ns9__SetAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__SetAudioOutputConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__SetAudioOutputConfiguration()
        {
          Configuration = (ns2__AudioOutputConfiguration *)0;
          ForcePersistence = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__SetAudioOutputConfiguration() { }
        /// Friend allocator used by soap_new__ns9__SetAudioOutputConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__SetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate__ns9__SetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2956 */
#ifndef SOAP_TYPE__ns9__SetAudioOutputConfigurationResponse
#define SOAP_TYPE__ns9__SetAudioOutputConfigurationResponse (1136)
/* complex XSD type 'ns9:SetAudioOutputConfigurationResponse': */
class SOAP_CMAC _ns9__SetAudioOutputConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__SetAudioOutputConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__SetAudioOutputConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__SetAudioOutputConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__SetAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__SetAudioOutputConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__SetAudioOutputConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__SetAudioOutputConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__SetAudioOutputConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__SetAudioOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__SetAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2959 */
#ifndef SOAP_TYPE__ns9__SetAudioDecoderConfiguration
#define SOAP_TYPE__ns9__SetAudioDecoderConfiguration (1137)
/* complex XSD type 'ns9:SetAudioDecoderConfiguration': */
class SOAP_CMAC _ns9__SetAudioDecoderConfiguration {
      public:
        /// Required element 'ns9:Configuration' of XSD type 'ns2:AudioDecoderConfiguration'
        ns2__AudioDecoderConfiguration *Configuration;
        /// Required element 'ns9:ForcePersistence' of XSD type 'xsd:boolean'
        bool ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__SetAudioDecoderConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__SetAudioDecoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__SetAudioDecoderConfiguration, default initialized and not managed by a soap context
        virtual _ns9__SetAudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns9__SetAudioDecoderConfiguration); }
      public:
        /// Constructor with initializations
        _ns9__SetAudioDecoderConfiguration()
        {
          Configuration = (ns2__AudioDecoderConfiguration *)0;
          ForcePersistence = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__SetAudioDecoderConfiguration() { }
        /// Friend allocator used by soap_new__ns9__SetAudioDecoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns9__SetAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate__ns9__SetAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2962 */
#ifndef SOAP_TYPE__ns9__SetAudioDecoderConfigurationResponse
#define SOAP_TYPE__ns9__SetAudioDecoderConfigurationResponse (1138)
/* complex XSD type 'ns9:SetAudioDecoderConfigurationResponse': */
class SOAP_CMAC _ns9__SetAudioDecoderConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__SetAudioDecoderConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__SetAudioDecoderConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__SetAudioDecoderConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns9__SetAudioDecoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__SetAudioDecoderConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns9__SetAudioDecoderConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__SetAudioDecoderConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns9__SetAudioDecoderConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__SetAudioDecoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns9__SetAudioDecoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2965 */
#ifndef SOAP_TYPE__ns9__GetVideoSourceConfigurationOptions
#define SOAP_TYPE__ns9__GetVideoSourceConfigurationOptions (1139)
/* complex XSD type 'ns9:GetVideoSourceConfigurationOptions': */
class SOAP_CMAC _ns9__GetVideoSourceConfigurationOptions {
      public:
        /// Optional element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string *ConfigurationToken;
        /// Optional element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string *ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetVideoSourceConfigurationOptions
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetVideoSourceConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetVideoSourceConfigurationOptions, default initialized and not managed by a soap context
        virtual _ns9__GetVideoSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_ns9__GetVideoSourceConfigurationOptions); }
      public:
        /// Constructor with initializations
        _ns9__GetVideoSourceConfigurationOptions()
        {
          ConfigurationToken = (std::string *)0;
          ProfileToken = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetVideoSourceConfigurationOptions() { }
        /// Friend allocator used by soap_new__ns9__GetVideoSourceConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetVideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate__ns9__GetVideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2968 */
#ifndef SOAP_TYPE__ns9__GetVideoSourceConfigurationOptionsResponse
#define SOAP_TYPE__ns9__GetVideoSourceConfigurationOptionsResponse (1140)
/* complex XSD type 'ns9:GetVideoSourceConfigurationOptionsResponse': */
class SOAP_CMAC _ns9__GetVideoSourceConfigurationOptionsResponse {
      public:
        /// Required element 'ns9:Options' of XSD type 'ns2:VideoSourceConfigurationOptions'
        ns2__VideoSourceConfigurationOptions *Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetVideoSourceConfigurationOptionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetVideoSourceConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetVideoSourceConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetVideoSourceConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetVideoSourceConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetVideoSourceConfigurationOptionsResponse()
        {
          Options = (ns2__VideoSourceConfigurationOptions *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetVideoSourceConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetVideoSourceConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetVideoSourceConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetVideoSourceConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2971 */
#ifndef SOAP_TYPE__ns9__GetVideoEncoderConfigurationOptions
#define SOAP_TYPE__ns9__GetVideoEncoderConfigurationOptions (1141)
/* complex XSD type 'ns9:GetVideoEncoderConfigurationOptions': */
class SOAP_CMAC _ns9__GetVideoEncoderConfigurationOptions {
      public:
        /// Optional element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string *ConfigurationToken;
        /// Optional element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string *ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetVideoEncoderConfigurationOptions
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetVideoEncoderConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetVideoEncoderConfigurationOptions, default initialized and not managed by a soap context
        virtual _ns9__GetVideoEncoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_ns9__GetVideoEncoderConfigurationOptions); }
      public:
        /// Constructor with initializations
        _ns9__GetVideoEncoderConfigurationOptions()
        {
          ConfigurationToken = (std::string *)0;
          ProfileToken = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetVideoEncoderConfigurationOptions() { }
        /// Friend allocator used by soap_new__ns9__GetVideoEncoderConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetVideoEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate__ns9__GetVideoEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2974 */
#ifndef SOAP_TYPE__ns9__GetVideoEncoderConfigurationOptionsResponse
#define SOAP_TYPE__ns9__GetVideoEncoderConfigurationOptionsResponse (1142)
/* complex XSD type 'ns9:GetVideoEncoderConfigurationOptionsResponse': */
class SOAP_CMAC _ns9__GetVideoEncoderConfigurationOptionsResponse {
      public:
        /// Required element 'ns9:Options' of XSD type 'ns2:VideoEncoderConfigurationOptions'
        ns2__VideoEncoderConfigurationOptions *Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetVideoEncoderConfigurationOptionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetVideoEncoderConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetVideoEncoderConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetVideoEncoderConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetVideoEncoderConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetVideoEncoderConfigurationOptionsResponse()
        {
          Options = (ns2__VideoEncoderConfigurationOptions *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetVideoEncoderConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetVideoEncoderConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetVideoEncoderConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetVideoEncoderConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2977 */
#ifndef SOAP_TYPE__ns9__GetAudioSourceConfigurationOptions
#define SOAP_TYPE__ns9__GetAudioSourceConfigurationOptions (1143)
/* complex XSD type 'ns9:GetAudioSourceConfigurationOptions': */
class SOAP_CMAC _ns9__GetAudioSourceConfigurationOptions {
      public:
        /// Optional element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string *ConfigurationToken;
        /// Optional element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string *ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioSourceConfigurationOptions
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioSourceConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioSourceConfigurationOptions, default initialized and not managed by a soap context
        virtual _ns9__GetAudioSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioSourceConfigurationOptions); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioSourceConfigurationOptions()
        {
          ConfigurationToken = (std::string *)0;
          ProfileToken = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioSourceConfigurationOptions() { }
        /// Friend allocator used by soap_new__ns9__GetAudioSourceConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate__ns9__GetAudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2980 */
#ifndef SOAP_TYPE__ns9__GetAudioSourceConfigurationOptionsResponse
#define SOAP_TYPE__ns9__GetAudioSourceConfigurationOptionsResponse (1144)
/* complex XSD type 'ns9:GetAudioSourceConfigurationOptionsResponse': */
class SOAP_CMAC _ns9__GetAudioSourceConfigurationOptionsResponse {
      public:
        /// Required element 'ns9:Options' of XSD type 'ns2:AudioSourceConfigurationOptions'
        ns2__AudioSourceConfigurationOptions *Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioSourceConfigurationOptionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioSourceConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioSourceConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetAudioSourceConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioSourceConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioSourceConfigurationOptionsResponse()
        {
          Options = (ns2__AudioSourceConfigurationOptions *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioSourceConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetAudioSourceConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioSourceConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetAudioSourceConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2983 */
#ifndef SOAP_TYPE__ns9__GetAudioEncoderConfigurationOptions
#define SOAP_TYPE__ns9__GetAudioEncoderConfigurationOptions (1145)
/* complex XSD type 'ns9:GetAudioEncoderConfigurationOptions': */
class SOAP_CMAC _ns9__GetAudioEncoderConfigurationOptions {
      public:
        /// Optional element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string *ConfigurationToken;
        /// Optional element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string *ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioEncoderConfigurationOptions
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioEncoderConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioEncoderConfigurationOptions, default initialized and not managed by a soap context
        virtual _ns9__GetAudioEncoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioEncoderConfigurationOptions); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioEncoderConfigurationOptions()
        {
          ConfigurationToken = (std::string *)0;
          ProfileToken = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioEncoderConfigurationOptions() { }
        /// Friend allocator used by soap_new__ns9__GetAudioEncoderConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate__ns9__GetAudioEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2986 */
#ifndef SOAP_TYPE__ns9__GetAudioEncoderConfigurationOptionsResponse
#define SOAP_TYPE__ns9__GetAudioEncoderConfigurationOptionsResponse (1146)
/* complex XSD type 'ns9:GetAudioEncoderConfigurationOptionsResponse': */
class SOAP_CMAC _ns9__GetAudioEncoderConfigurationOptionsResponse {
      public:
        /// Required element 'ns9:Options' of XSD type 'ns2:AudioEncoderConfigurationOptions'
        ns2__AudioEncoderConfigurationOptions *Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioEncoderConfigurationOptionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioEncoderConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioEncoderConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetAudioEncoderConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioEncoderConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioEncoderConfigurationOptionsResponse()
        {
          Options = (ns2__AudioEncoderConfigurationOptions *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioEncoderConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetAudioEncoderConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioEncoderConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetAudioEncoderConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2989 */
#ifndef SOAP_TYPE__ns9__GetMetadataConfigurationOptions
#define SOAP_TYPE__ns9__GetMetadataConfigurationOptions (1147)
/* complex XSD type 'ns9:GetMetadataConfigurationOptions': */
class SOAP_CMAC _ns9__GetMetadataConfigurationOptions {
      public:
        /// Optional element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string *ConfigurationToken;
        /// Optional element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string *ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetMetadataConfigurationOptions
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetMetadataConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetMetadataConfigurationOptions, default initialized and not managed by a soap context
        virtual _ns9__GetMetadataConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_ns9__GetMetadataConfigurationOptions); }
      public:
        /// Constructor with initializations
        _ns9__GetMetadataConfigurationOptions()
        {
          ConfigurationToken = (std::string *)0;
          ProfileToken = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetMetadataConfigurationOptions() { }
        /// Friend allocator used by soap_new__ns9__GetMetadataConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetMetadataConfigurationOptions * SOAP_FMAC2 soap_instantiate__ns9__GetMetadataConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2992 */
#ifndef SOAP_TYPE__ns9__GetMetadataConfigurationOptionsResponse
#define SOAP_TYPE__ns9__GetMetadataConfigurationOptionsResponse (1148)
/* complex XSD type 'ns9:GetMetadataConfigurationOptionsResponse': */
class SOAP_CMAC _ns9__GetMetadataConfigurationOptionsResponse {
      public:
        /// Required element 'ns9:Options' of XSD type 'ns2:MetadataConfigurationOptions'
        ns2__MetadataConfigurationOptions *Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetMetadataConfigurationOptionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetMetadataConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetMetadataConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetMetadataConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetMetadataConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetMetadataConfigurationOptionsResponse()
        {
          Options = (ns2__MetadataConfigurationOptions *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetMetadataConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetMetadataConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetMetadataConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetMetadataConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2995 */
#ifndef SOAP_TYPE__ns9__GetAudioOutputConfigurationOptions
#define SOAP_TYPE__ns9__GetAudioOutputConfigurationOptions (1149)
/* complex XSD type 'ns9:GetAudioOutputConfigurationOptions': */
class SOAP_CMAC _ns9__GetAudioOutputConfigurationOptions {
      public:
        /// Optional element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string *ConfigurationToken;
        /// Optional element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string *ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioOutputConfigurationOptions
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioOutputConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioOutputConfigurationOptions, default initialized and not managed by a soap context
        virtual _ns9__GetAudioOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioOutputConfigurationOptions); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioOutputConfigurationOptions()
        {
          ConfigurationToken = (std::string *)0;
          ProfileToken = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioOutputConfigurationOptions() { }
        /// Friend allocator used by soap_new__ns9__GetAudioOutputConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate__ns9__GetAudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2998 */
#ifndef SOAP_TYPE__ns9__GetAudioOutputConfigurationOptionsResponse
#define SOAP_TYPE__ns9__GetAudioOutputConfigurationOptionsResponse (1150)
/* complex XSD type 'ns9:GetAudioOutputConfigurationOptionsResponse': */
class SOAP_CMAC _ns9__GetAudioOutputConfigurationOptionsResponse {
      public:
        /// Required element 'ns9:Options' of XSD type 'ns2:AudioOutputConfigurationOptions'
        ns2__AudioOutputConfigurationOptions *Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioOutputConfigurationOptionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioOutputConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioOutputConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetAudioOutputConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioOutputConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioOutputConfigurationOptionsResponse()
        {
          Options = (ns2__AudioOutputConfigurationOptions *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioOutputConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetAudioOutputConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioOutputConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetAudioOutputConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3001 */
#ifndef SOAP_TYPE__ns9__GetAudioDecoderConfigurationOptions
#define SOAP_TYPE__ns9__GetAudioDecoderConfigurationOptions (1151)
/* complex XSD type 'ns9:GetAudioDecoderConfigurationOptions': */
class SOAP_CMAC _ns9__GetAudioDecoderConfigurationOptions {
      public:
        /// Optional element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string *ConfigurationToken;
        /// Optional element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string *ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioDecoderConfigurationOptions
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioDecoderConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioDecoderConfigurationOptions, default initialized and not managed by a soap context
        virtual _ns9__GetAudioDecoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioDecoderConfigurationOptions); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioDecoderConfigurationOptions()
        {
          ConfigurationToken = (std::string *)0;
          ProfileToken = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioDecoderConfigurationOptions() { }
        /// Friend allocator used by soap_new__ns9__GetAudioDecoderConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioDecoderConfigurationOptions * SOAP_FMAC2 soap_instantiate__ns9__GetAudioDecoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3004 */
#ifndef SOAP_TYPE__ns9__GetAudioDecoderConfigurationOptionsResponse
#define SOAP_TYPE__ns9__GetAudioDecoderConfigurationOptionsResponse (1152)
/* complex XSD type 'ns9:GetAudioDecoderConfigurationOptionsResponse': */
class SOAP_CMAC _ns9__GetAudioDecoderConfigurationOptionsResponse {
      public:
        /// Required element 'ns9:Options' of XSD type 'ns2:AudioDecoderConfigurationOptions'
        ns2__AudioDecoderConfigurationOptions *Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetAudioDecoderConfigurationOptionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetAudioDecoderConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetAudioDecoderConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetAudioDecoderConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetAudioDecoderConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetAudioDecoderConfigurationOptionsResponse()
        {
          Options = (ns2__AudioDecoderConfigurationOptions *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetAudioDecoderConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetAudioDecoderConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetAudioDecoderConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetAudioDecoderConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3007 */
#ifndef SOAP_TYPE__ns9__GetGuaranteedNumberOfVideoEncoderInstances
#define SOAP_TYPE__ns9__GetGuaranteedNumberOfVideoEncoderInstances (1153)
/* complex XSD type 'ns9:GetGuaranteedNumberOfVideoEncoderInstances': */
class SOAP_CMAC _ns9__GetGuaranteedNumberOfVideoEncoderInstances {
      public:
        /// Required element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetGuaranteedNumberOfVideoEncoderInstances
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetGuaranteedNumberOfVideoEncoderInstances; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetGuaranteedNumberOfVideoEncoderInstances, default initialized and not managed by a soap context
        virtual _ns9__GetGuaranteedNumberOfVideoEncoderInstances *soap_alloc(void) const { return SOAP_NEW(_ns9__GetGuaranteedNumberOfVideoEncoderInstances); }
      public:
        /// Constructor with initializations
        _ns9__GetGuaranteedNumberOfVideoEncoderInstances()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetGuaranteedNumberOfVideoEncoderInstances() { }
        /// Friend allocator used by soap_new__ns9__GetGuaranteedNumberOfVideoEncoderInstances(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetGuaranteedNumberOfVideoEncoderInstances * SOAP_FMAC2 soap_instantiate__ns9__GetGuaranteedNumberOfVideoEncoderInstances(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3010 */
#ifndef SOAP_TYPE__ns9__GetGuaranteedNumberOfVideoEncoderInstancesResponse
#define SOAP_TYPE__ns9__GetGuaranteedNumberOfVideoEncoderInstancesResponse (1154)
/* complex XSD type 'ns9:GetGuaranteedNumberOfVideoEncoderInstancesResponse': */
class SOAP_CMAC _ns9__GetGuaranteedNumberOfVideoEncoderInstancesResponse {
      public:
        /// Required element 'ns9:TotalNumber' of XSD type 'xsd:int'
        int TotalNumber;
        /// Optional element 'ns9:JPEG' of XSD type 'xsd:int'
        int *JPEG;
        /// Optional element 'ns9:H264' of XSD type 'xsd:int'
        int *H264;
        /// Optional element 'ns9:MPEG4' of XSD type 'xsd:int'
        int *MPEG4;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetGuaranteedNumberOfVideoEncoderInstancesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetGuaranteedNumberOfVideoEncoderInstancesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetGuaranteedNumberOfVideoEncoderInstancesResponse, default initialized and not managed by a soap context
        virtual _ns9__GetGuaranteedNumberOfVideoEncoderInstancesResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetGuaranteedNumberOfVideoEncoderInstancesResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetGuaranteedNumberOfVideoEncoderInstancesResponse()
        {
          TotalNumber = (int)0;
          JPEG = (int *)0;
          H264 = (int *)0;
          MPEG4 = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetGuaranteedNumberOfVideoEncoderInstancesResponse() { }
        /// Friend allocator used by soap_new__ns9__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetGuaranteedNumberOfVideoEncoderInstancesResponse * SOAP_FMAC2 soap_instantiate__ns9__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3013 */
#ifndef SOAP_TYPE__ns9__GetStreamUri
#define SOAP_TYPE__ns9__GetStreamUri (1155)
/* complex XSD type 'ns9:GetStreamUri': */
class SOAP_CMAC _ns9__GetStreamUri {
      public:
        /// Required element 'ns9:StreamSetup' of XSD type 'ns2:StreamSetup'
        ns2__StreamSetup *StreamSetup;
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetStreamUri
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetStreamUri; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetStreamUri, default initialized and not managed by a soap context
        virtual _ns9__GetStreamUri *soap_alloc(void) const { return SOAP_NEW(_ns9__GetStreamUri); }
      public:
        /// Constructor with initializations
        _ns9__GetStreamUri()
        {
          StreamSetup = (ns2__StreamSetup *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetStreamUri() { }
        /// Friend allocator used by soap_new__ns9__GetStreamUri(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetStreamUri * SOAP_FMAC2 soap_instantiate__ns9__GetStreamUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3016 */
#ifndef SOAP_TYPE__ns9__GetStreamUriResponse
#define SOAP_TYPE__ns9__GetStreamUriResponse (1156)
/* complex XSD type 'ns9:GetStreamUriResponse': */
class SOAP_CMAC _ns9__GetStreamUriResponse {
      public:
        /// Required element 'ns9:MediaUri' of XSD type 'ns2:MediaUri'
        ns2__MediaUri *MediaUri;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetStreamUriResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetStreamUriResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetStreamUriResponse, default initialized and not managed by a soap context
        virtual _ns9__GetStreamUriResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetStreamUriResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetStreamUriResponse()
        {
          MediaUri = (ns2__MediaUri *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetStreamUriResponse() { }
        /// Friend allocator used by soap_new__ns9__GetStreamUriResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetStreamUriResponse * SOAP_FMAC2 soap_instantiate__ns9__GetStreamUriResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3019 */
#ifndef SOAP_TYPE__ns9__StartMulticastStreaming
#define SOAP_TYPE__ns9__StartMulticastStreaming (1157)
/* complex XSD type 'ns9:StartMulticastStreaming': */
class SOAP_CMAC _ns9__StartMulticastStreaming {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__StartMulticastStreaming
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__StartMulticastStreaming; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__StartMulticastStreaming, default initialized and not managed by a soap context
        virtual _ns9__StartMulticastStreaming *soap_alloc(void) const { return SOAP_NEW(_ns9__StartMulticastStreaming); }
      public:
        /// Constructor with initializations
        _ns9__StartMulticastStreaming()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__StartMulticastStreaming() { }
        /// Friend allocator used by soap_new__ns9__StartMulticastStreaming(struct soap*, int)
        friend SOAP_FMAC1 _ns9__StartMulticastStreaming * SOAP_FMAC2 soap_instantiate__ns9__StartMulticastStreaming(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3022 */
#ifndef SOAP_TYPE__ns9__StartMulticastStreamingResponse
#define SOAP_TYPE__ns9__StartMulticastStreamingResponse (1158)
/* complex XSD type 'ns9:StartMulticastStreamingResponse': */
class SOAP_CMAC _ns9__StartMulticastStreamingResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__StartMulticastStreamingResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__StartMulticastStreamingResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__StartMulticastStreamingResponse, default initialized and not managed by a soap context
        virtual _ns9__StartMulticastStreamingResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__StartMulticastStreamingResponse); }
      public:
        /// Constructor with initializations
        _ns9__StartMulticastStreamingResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__StartMulticastStreamingResponse() { }
        /// Friend allocator used by soap_new__ns9__StartMulticastStreamingResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__StartMulticastStreamingResponse * SOAP_FMAC2 soap_instantiate__ns9__StartMulticastStreamingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3025 */
#ifndef SOAP_TYPE__ns9__StopMulticastStreaming
#define SOAP_TYPE__ns9__StopMulticastStreaming (1159)
/* complex XSD type 'ns9:StopMulticastStreaming': */
class SOAP_CMAC _ns9__StopMulticastStreaming {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__StopMulticastStreaming
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__StopMulticastStreaming; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__StopMulticastStreaming, default initialized and not managed by a soap context
        virtual _ns9__StopMulticastStreaming *soap_alloc(void) const { return SOAP_NEW(_ns9__StopMulticastStreaming); }
      public:
        /// Constructor with initializations
        _ns9__StopMulticastStreaming()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__StopMulticastStreaming() { }
        /// Friend allocator used by soap_new__ns9__StopMulticastStreaming(struct soap*, int)
        friend SOAP_FMAC1 _ns9__StopMulticastStreaming * SOAP_FMAC2 soap_instantiate__ns9__StopMulticastStreaming(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3028 */
#ifndef SOAP_TYPE__ns9__StopMulticastStreamingResponse
#define SOAP_TYPE__ns9__StopMulticastStreamingResponse (1160)
/* complex XSD type 'ns9:StopMulticastStreamingResponse': */
class SOAP_CMAC _ns9__StopMulticastStreamingResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__StopMulticastStreamingResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__StopMulticastStreamingResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__StopMulticastStreamingResponse, default initialized and not managed by a soap context
        virtual _ns9__StopMulticastStreamingResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__StopMulticastStreamingResponse); }
      public:
        /// Constructor with initializations
        _ns9__StopMulticastStreamingResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__StopMulticastStreamingResponse() { }
        /// Friend allocator used by soap_new__ns9__StopMulticastStreamingResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__StopMulticastStreamingResponse * SOAP_FMAC2 soap_instantiate__ns9__StopMulticastStreamingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3031 */
#ifndef SOAP_TYPE__ns9__SetSynchronizationPoint
#define SOAP_TYPE__ns9__SetSynchronizationPoint (1161)
/* complex XSD type 'ns9:SetSynchronizationPoint': */
class SOAP_CMAC _ns9__SetSynchronizationPoint {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__SetSynchronizationPoint
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__SetSynchronizationPoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__SetSynchronizationPoint, default initialized and not managed by a soap context
        virtual _ns9__SetSynchronizationPoint *soap_alloc(void) const { return SOAP_NEW(_ns9__SetSynchronizationPoint); }
      public:
        /// Constructor with initializations
        _ns9__SetSynchronizationPoint()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__SetSynchronizationPoint() { }
        /// Friend allocator used by soap_new__ns9__SetSynchronizationPoint(struct soap*, int)
        friend SOAP_FMAC1 _ns9__SetSynchronizationPoint * SOAP_FMAC2 soap_instantiate__ns9__SetSynchronizationPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3034 */
#ifndef SOAP_TYPE__ns9__SetSynchronizationPointResponse
#define SOAP_TYPE__ns9__SetSynchronizationPointResponse (1162)
/* complex XSD type 'ns9:SetSynchronizationPointResponse': */
class SOAP_CMAC _ns9__SetSynchronizationPointResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__SetSynchronizationPointResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__SetSynchronizationPointResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__SetSynchronizationPointResponse, default initialized and not managed by a soap context
        virtual _ns9__SetSynchronizationPointResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__SetSynchronizationPointResponse); }
      public:
        /// Constructor with initializations
        _ns9__SetSynchronizationPointResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__SetSynchronizationPointResponse() { }
        /// Friend allocator used by soap_new__ns9__SetSynchronizationPointResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__SetSynchronizationPointResponse * SOAP_FMAC2 soap_instantiate__ns9__SetSynchronizationPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3037 */
#ifndef SOAP_TYPE__ns9__GetSnapshotUri
#define SOAP_TYPE__ns9__GetSnapshotUri (1163)
/* complex XSD type 'ns9:GetSnapshotUri': */
class SOAP_CMAC _ns9__GetSnapshotUri {
      public:
        /// Required element 'ns9:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetSnapshotUri
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetSnapshotUri; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetSnapshotUri, default initialized and not managed by a soap context
        virtual _ns9__GetSnapshotUri *soap_alloc(void) const { return SOAP_NEW(_ns9__GetSnapshotUri); }
      public:
        /// Constructor with initializations
        _ns9__GetSnapshotUri()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetSnapshotUri() { }
        /// Friend allocator used by soap_new__ns9__GetSnapshotUri(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetSnapshotUri * SOAP_FMAC2 soap_instantiate__ns9__GetSnapshotUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3040 */
#ifndef SOAP_TYPE__ns9__GetSnapshotUriResponse
#define SOAP_TYPE__ns9__GetSnapshotUriResponse (1164)
/* complex XSD type 'ns9:GetSnapshotUriResponse': */
class SOAP_CMAC _ns9__GetSnapshotUriResponse {
      public:
        /// Required element 'ns9:MediaUri' of XSD type 'ns2:MediaUri'
        ns2__MediaUri *MediaUri;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetSnapshotUriResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetSnapshotUriResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetSnapshotUriResponse, default initialized and not managed by a soap context
        virtual _ns9__GetSnapshotUriResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetSnapshotUriResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetSnapshotUriResponse()
        {
          MediaUri = (ns2__MediaUri *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetSnapshotUriResponse() { }
        /// Friend allocator used by soap_new__ns9__GetSnapshotUriResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetSnapshotUriResponse * SOAP_FMAC2 soap_instantiate__ns9__GetSnapshotUriResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3043 */
#ifndef SOAP_TYPE__ns9__GetVideoSourceModes
#define SOAP_TYPE__ns9__GetVideoSourceModes (1165)
/* complex XSD type 'ns9:GetVideoSourceModes': */
class SOAP_CMAC _ns9__GetVideoSourceModes {
      public:
        /// Required element 'ns9:VideoSourceToken' of XSD type 'ns2:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetVideoSourceModes
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetVideoSourceModes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetVideoSourceModes, default initialized and not managed by a soap context
        virtual _ns9__GetVideoSourceModes *soap_alloc(void) const { return SOAP_NEW(_ns9__GetVideoSourceModes); }
      public:
        /// Constructor with initializations
        _ns9__GetVideoSourceModes()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetVideoSourceModes() { }
        /// Friend allocator used by soap_new__ns9__GetVideoSourceModes(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetVideoSourceModes * SOAP_FMAC2 soap_instantiate__ns9__GetVideoSourceModes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3046 */
#ifndef SOAP_TYPE__ns9__GetVideoSourceModesResponse
#define SOAP_TYPE__ns9__GetVideoSourceModesResponse (1166)
/* complex XSD type 'ns9:GetVideoSourceModesResponse': */
class SOAP_CMAC _ns9__GetVideoSourceModesResponse {
      public:
        /// Required element 'ns9:VideoSourceModes' of XSD type 'ns9:VideoSourceMode'
        std::vector<ns9__VideoSourceMode *> VideoSourceModes;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetVideoSourceModesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetVideoSourceModesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetVideoSourceModesResponse, default initialized and not managed by a soap context
        virtual _ns9__GetVideoSourceModesResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetVideoSourceModesResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetVideoSourceModesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetVideoSourceModesResponse() { }
        /// Friend allocator used by soap_new__ns9__GetVideoSourceModesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetVideoSourceModesResponse * SOAP_FMAC2 soap_instantiate__ns9__GetVideoSourceModesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3049 */
#ifndef SOAP_TYPE__ns9__SetVideoSourceMode
#define SOAP_TYPE__ns9__SetVideoSourceMode (1167)
/* complex XSD type 'ns9:SetVideoSourceMode': */
class SOAP_CMAC _ns9__SetVideoSourceMode {
      public:
        /// Required element 'ns9:VideoSourceToken' of XSD type 'ns2:ReferenceToken'
        std::string VideoSourceToken;
        /// Required element 'ns9:VideoSourceModeToken' of XSD type 'ns2:ReferenceToken'
        std::string VideoSourceModeToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__SetVideoSourceMode
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__SetVideoSourceMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__SetVideoSourceMode, default initialized and not managed by a soap context
        virtual _ns9__SetVideoSourceMode *soap_alloc(void) const { return SOAP_NEW(_ns9__SetVideoSourceMode); }
      public:
        /// Constructor with initializations
        _ns9__SetVideoSourceMode()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__SetVideoSourceMode() { }
        /// Friend allocator used by soap_new__ns9__SetVideoSourceMode(struct soap*, int)
        friend SOAP_FMAC1 _ns9__SetVideoSourceMode * SOAP_FMAC2 soap_instantiate__ns9__SetVideoSourceMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3052 */
#ifndef SOAP_TYPE__ns9__SetVideoSourceModeResponse
#define SOAP_TYPE__ns9__SetVideoSourceModeResponse (1168)
/* complex XSD type 'ns9:SetVideoSourceModeResponse': */
class SOAP_CMAC _ns9__SetVideoSourceModeResponse {
      public:
        /// Required element 'ns9:Reboot' of XSD type 'xsd:boolean'
        bool Reboot;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__SetVideoSourceModeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__SetVideoSourceModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__SetVideoSourceModeResponse, default initialized and not managed by a soap context
        virtual _ns9__SetVideoSourceModeResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__SetVideoSourceModeResponse); }
      public:
        /// Constructor with initializations
        _ns9__SetVideoSourceModeResponse()
        {
          Reboot = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__SetVideoSourceModeResponse() { }
        /// Friend allocator used by soap_new__ns9__SetVideoSourceModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__SetVideoSourceModeResponse * SOAP_FMAC2 soap_instantiate__ns9__SetVideoSourceModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3055 */
#ifndef SOAP_TYPE__ns9__GetOSDs
#define SOAP_TYPE__ns9__GetOSDs (1169)
/* complex XSD type 'ns9:GetOSDs': */
class SOAP_CMAC _ns9__GetOSDs {
      public:
        /// Optional element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string *ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetOSDs
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetOSDs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetOSDs, default initialized and not managed by a soap context
        virtual _ns9__GetOSDs *soap_alloc(void) const { return SOAP_NEW(_ns9__GetOSDs); }
      public:
        /// Constructor with initializations
        _ns9__GetOSDs()
        {
          ConfigurationToken = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetOSDs() { }
        /// Friend allocator used by soap_new__ns9__GetOSDs(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetOSDs * SOAP_FMAC2 soap_instantiate__ns9__GetOSDs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3058 */
#ifndef SOAP_TYPE__ns9__GetOSDsResponse
#define SOAP_TYPE__ns9__GetOSDsResponse (1170)
/* complex XSD type 'ns9:GetOSDsResponse': */
class SOAP_CMAC _ns9__GetOSDsResponse {
      public:
        /// Optional element 'ns9:OSDs' of XSD type 'ns2:OSDConfiguration'
        std::vector<ns2__OSDConfiguration *> OSDs;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetOSDsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetOSDsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetOSDsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetOSDsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetOSDsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetOSDsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetOSDsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetOSDsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetOSDsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetOSDsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3061 */
#ifndef SOAP_TYPE__ns9__GetOSD
#define SOAP_TYPE__ns9__GetOSD (1171)
/* complex XSD type 'ns9:GetOSD': */
class SOAP_CMAC _ns9__GetOSD {
      public:
        /// Required element 'ns9:OSDToken' of XSD type 'ns2:ReferenceToken'
        std::string OSDToken;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetOSD
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetOSD; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetOSD, default initialized and not managed by a soap context
        virtual _ns9__GetOSD *soap_alloc(void) const { return SOAP_NEW(_ns9__GetOSD); }
      public:
        /// Constructor with initializations
        _ns9__GetOSD()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetOSD() { }
        /// Friend allocator used by soap_new__ns9__GetOSD(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetOSD * SOAP_FMAC2 soap_instantiate__ns9__GetOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3064 */
#ifndef SOAP_TYPE__ns9__GetOSDResponse
#define SOAP_TYPE__ns9__GetOSDResponse (1172)
/* complex XSD type 'ns9:GetOSDResponse': */
class SOAP_CMAC _ns9__GetOSDResponse {
      public:
        /// Required element 'ns9:OSD' of XSD type 'ns2:OSDConfiguration'
        ns2__OSDConfiguration *OSD;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetOSDResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetOSDResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetOSDResponse, default initialized and not managed by a soap context
        virtual _ns9__GetOSDResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetOSDResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetOSDResponse()
        {
          OSD = (ns2__OSDConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetOSDResponse() { }
        /// Friend allocator used by soap_new__ns9__GetOSDResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetOSDResponse * SOAP_FMAC2 soap_instantiate__ns9__GetOSDResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3067 */
#ifndef SOAP_TYPE__ns9__SetOSD
#define SOAP_TYPE__ns9__SetOSD (1173)
/* complex XSD type 'ns9:SetOSD': */
class SOAP_CMAC _ns9__SetOSD {
      public:
        /// Required element 'ns9:OSD' of XSD type 'ns2:OSDConfiguration'
        ns2__OSDConfiguration *OSD;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__SetOSD
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__SetOSD; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__SetOSD, default initialized and not managed by a soap context
        virtual _ns9__SetOSD *soap_alloc(void) const { return SOAP_NEW(_ns9__SetOSD); }
      public:
        /// Constructor with initializations
        _ns9__SetOSD()
        {
          OSD = (ns2__OSDConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__SetOSD() { }
        /// Friend allocator used by soap_new__ns9__SetOSD(struct soap*, int)
        friend SOAP_FMAC1 _ns9__SetOSD * SOAP_FMAC2 soap_instantiate__ns9__SetOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3070 */
#ifndef SOAP_TYPE__ns9__SetOSDResponse
#define SOAP_TYPE__ns9__SetOSDResponse (1174)
/* complex XSD type 'ns9:SetOSDResponse': */
class SOAP_CMAC _ns9__SetOSDResponse {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__SetOSDResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__SetOSDResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__SetOSDResponse, default initialized and not managed by a soap context
        virtual _ns9__SetOSDResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__SetOSDResponse); }
      public:
        /// Constructor with initializations
        _ns9__SetOSDResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__SetOSDResponse() { }
        /// Friend allocator used by soap_new__ns9__SetOSDResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__SetOSDResponse * SOAP_FMAC2 soap_instantiate__ns9__SetOSDResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3073 */
#ifndef SOAP_TYPE__ns9__GetOSDOptions
#define SOAP_TYPE__ns9__GetOSDOptions (1175)
/* complex XSD type 'ns9:GetOSDOptions': */
class SOAP_CMAC _ns9__GetOSDOptions {
      public:
        /// Required element 'ns9:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string ConfigurationToken;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetOSDOptions
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetOSDOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetOSDOptions, default initialized and not managed by a soap context
        virtual _ns9__GetOSDOptions *soap_alloc(void) const { return SOAP_NEW(_ns9__GetOSDOptions); }
      public:
        /// Constructor with initializations
        _ns9__GetOSDOptions()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetOSDOptions() { }
        /// Friend allocator used by soap_new__ns9__GetOSDOptions(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetOSDOptions * SOAP_FMAC2 soap_instantiate__ns9__GetOSDOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3076 */
#ifndef SOAP_TYPE__ns9__GetOSDOptionsResponse
#define SOAP_TYPE__ns9__GetOSDOptionsResponse (1176)
/* complex XSD type 'ns9:GetOSDOptionsResponse': */
class SOAP_CMAC _ns9__GetOSDOptionsResponse {
      public:
        /// Required element 'ns9:OSDOptions' of XSD type 'ns2:OSDConfigurationOptions'
        ns2__OSDConfigurationOptions *OSDOptions;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__GetOSDOptionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__GetOSDOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__GetOSDOptionsResponse, default initialized and not managed by a soap context
        virtual _ns9__GetOSDOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__GetOSDOptionsResponse); }
      public:
        /// Constructor with initializations
        _ns9__GetOSDOptionsResponse()
        {
          OSDOptions = (ns2__OSDConfigurationOptions *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__GetOSDOptionsResponse() { }
        /// Friend allocator used by soap_new__ns9__GetOSDOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__GetOSDOptionsResponse * SOAP_FMAC2 soap_instantiate__ns9__GetOSDOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3079 */
#ifndef SOAP_TYPE__ns9__CreateOSD
#define SOAP_TYPE__ns9__CreateOSD (1177)
/* complex XSD type 'ns9:CreateOSD': */
class SOAP_CMAC _ns9__CreateOSD {
      public:
        /// Required element 'ns9:OSD' of XSD type 'ns2:OSDConfiguration'
        ns2__OSDConfiguration *OSD;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__CreateOSD
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__CreateOSD; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__CreateOSD, default initialized and not managed by a soap context
        virtual _ns9__CreateOSD *soap_alloc(void) const { return SOAP_NEW(_ns9__CreateOSD); }
      public:
        /// Constructor with initializations
        _ns9__CreateOSD()
        {
          OSD = (ns2__OSDConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns9__CreateOSD() { }
        /// Friend allocator used by soap_new__ns9__CreateOSD(struct soap*, int)
        friend SOAP_FMAC1 _ns9__CreateOSD * SOAP_FMAC2 soap_instantiate__ns9__CreateOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3082 */
#ifndef SOAP_TYPE__ns9__CreateOSDResponse
#define SOAP_TYPE__ns9__CreateOSDResponse (1178)
/* complex XSD type 'ns9:CreateOSDResponse': */
class SOAP_CMAC _ns9__CreateOSDResponse {
      public:
        /// Required element 'ns9:OSDToken' of XSD type 'ns2:ReferenceToken'
        std::string OSDToken;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__CreateOSDResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__CreateOSDResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__CreateOSDResponse, default initialized and not managed by a soap context
        virtual _ns9__CreateOSDResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__CreateOSDResponse); }
      public:
        /// Constructor with initializations
        _ns9__CreateOSDResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__CreateOSDResponse() { }
        /// Friend allocator used by soap_new__ns9__CreateOSDResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__CreateOSDResponse * SOAP_FMAC2 soap_instantiate__ns9__CreateOSDResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3085 */
#ifndef SOAP_TYPE__ns9__DeleteOSD
#define SOAP_TYPE__ns9__DeleteOSD (1179)
/* complex XSD type 'ns9:DeleteOSD': */
class SOAP_CMAC _ns9__DeleteOSD {
      public:
        /// Required element 'ns9:OSDToken' of XSD type 'ns2:ReferenceToken'
        std::string OSDToken;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__DeleteOSD
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__DeleteOSD; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__DeleteOSD, default initialized and not managed by a soap context
        virtual _ns9__DeleteOSD *soap_alloc(void) const { return SOAP_NEW(_ns9__DeleteOSD); }
      public:
        /// Constructor with initializations
        _ns9__DeleteOSD()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__DeleteOSD() { }
        /// Friend allocator used by soap_new__ns9__DeleteOSD(struct soap*, int)
        friend SOAP_FMAC1 _ns9__DeleteOSD * SOAP_FMAC2 soap_instantiate__ns9__DeleteOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3088 */
#ifndef SOAP_TYPE__ns9__DeleteOSDResponse
#define SOAP_TYPE__ns9__DeleteOSDResponse (1180)
/* complex XSD type 'ns9:DeleteOSDResponse': */
class SOAP_CMAC _ns9__DeleteOSDResponse {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns9__DeleteOSDResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns9__DeleteOSDResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns9__DeleteOSDResponse, default initialized and not managed by a soap context
        virtual _ns9__DeleteOSDResponse *soap_alloc(void) const { return SOAP_NEW(_ns9__DeleteOSDResponse); }
      public:
        /// Constructor with initializations
        _ns9__DeleteOSDResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns9__DeleteOSDResponse() { }
        /// Friend allocator used by soap_new__ns9__DeleteOSDResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns9__DeleteOSDResponse * SOAP_FMAC2 soap_instantiate__ns9__DeleteOSDResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3091 */
#ifndef SOAP_TYPE_ns10__Capabilities2
#define SOAP_TYPE_ns10__Capabilities2 (1181)
/* complex XSD type 'ns10:Capabilities2': */
class SOAP_CMAC ns10__Capabilities2 {
      public:
        /// Required element 'ns10:ProfileCapabilities' of XSD type 'ns10:ProfileCapabilities'
        ns10__ProfileCapabilities *ProfileCapabilities;
        /// Required element 'ns10:StreamingCapabilities' of XSD type 'ns10:StreamingCapabilities'
        ns10__StreamingCapabilities *StreamingCapabilities;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// optional attribute 'SnapshotUri' of XSD type 'xsd:boolean'
        bool *SnapshotUri;
        /// optional attribute 'Rotation' of XSD type 'xsd:boolean'
        bool *Rotation;
        /// optional attribute 'VideoSourceMode' of XSD type 'xsd:boolean'
        bool *VideoSourceMode;
        /// optional attribute 'OSD' of XSD type 'xsd:boolean'
        bool *OSD;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns10__Capabilities2
        virtual int soap_type(void) const { return SOAP_TYPE_ns10__Capabilities2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns10__Capabilities2, default initialized and not managed by a soap context
        virtual ns10__Capabilities2 *soap_alloc(void) const { return SOAP_NEW(ns10__Capabilities2); }
      public:
        /// Constructor with initializations
        ns10__Capabilities2()
        {
          ProfileCapabilities = (ns10__ProfileCapabilities *)0;
          StreamingCapabilities = (ns10__StreamingCapabilities *)0;
          SnapshotUri = (bool *)0;
          Rotation = (bool *)0;
          VideoSourceMode = (bool *)0;
          OSD = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns10__Capabilities2() { }
        /// Friend allocator used by soap_new_ns10__Capabilities2(struct soap*, int)
        friend SOAP_FMAC1 ns10__Capabilities2 * SOAP_FMAC2 soap_instantiate_ns10__Capabilities2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3094 */
#ifndef SOAP_TYPE_ns10__ProfileCapabilities
#define SOAP_TYPE_ns10__ProfileCapabilities (1182)
/* complex XSD type 'ns10:ProfileCapabilities': */
class SOAP_CMAC ns10__ProfileCapabilities {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// optional attribute 'MaximumNumberOfProfiles' of XSD type 'xsd:int'
        int *MaximumNumberOfProfiles;
        /// optional attribute 'ConfigurationsSupported' of XSD type 'ns2:StringAttrList'
        std::string *ConfigurationsSupported;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns10__ProfileCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns10__ProfileCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns10__ProfileCapabilities, default initialized and not managed by a soap context
        virtual ns10__ProfileCapabilities *soap_alloc(void) const { return SOAP_NEW(ns10__ProfileCapabilities); }
      public:
        /// Constructor with initializations
        ns10__ProfileCapabilities()
        {
          MaximumNumberOfProfiles = (int *)0;
          ConfigurationsSupported = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns10__ProfileCapabilities() { }
        /// Friend allocator used by soap_new_ns10__ProfileCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns10__ProfileCapabilities * SOAP_FMAC2 soap_instantiate_ns10__ProfileCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3097 */
#ifndef SOAP_TYPE_ns10__StreamingCapabilities
#define SOAP_TYPE_ns10__StreamingCapabilities (1183)
/* complex XSD type 'ns10:StreamingCapabilities': */
class SOAP_CMAC ns10__StreamingCapabilities {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// optional attribute 'RTSPStreaming' of XSD type 'xsd:boolean'
        bool *RTSPStreaming;
        /// optional attribute 'RTPMulticast' of XSD type 'xsd:boolean'
        bool *RTPMulticast;
        /// optional attribute 'RTP_RTSP_TCP' of XSD type 'xsd:boolean'
        bool *RTP_USCORERTSP_USCORETCP;
        /// optional attribute 'NonAggregateControl' of XSD type 'xsd:boolean'
        bool *NonAggregateControl;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns10__StreamingCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns10__StreamingCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns10__StreamingCapabilities, default initialized and not managed by a soap context
        virtual ns10__StreamingCapabilities *soap_alloc(void) const { return SOAP_NEW(ns10__StreamingCapabilities); }
      public:
        /// Constructor with initializations
        ns10__StreamingCapabilities()
        {
          RTSPStreaming = (bool *)0;
          RTPMulticast = (bool *)0;
          RTP_USCORERTSP_USCORETCP = (bool *)0;
          NonAggregateControl = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns10__StreamingCapabilities() { }
        /// Friend allocator used by soap_new_ns10__StreamingCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns10__StreamingCapabilities * SOAP_FMAC2 soap_instantiate_ns10__StreamingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3100 */
#ifndef SOAP_TYPE_ns10__ConfigurationRef
#define SOAP_TYPE_ns10__ConfigurationRef (1184)
/* complex XSD type 'ns10:ConfigurationRef': */
class SOAP_CMAC ns10__ConfigurationRef {
      public:
        /// Required element 'ns10:Type' of XSD type 'xsd:string'
        std::string Type;
        /// Optional element 'ns10:Token' of XSD type 'ns2:ReferenceToken'
        std::string *Token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns10__ConfigurationRef
        virtual int soap_type(void) const { return SOAP_TYPE_ns10__ConfigurationRef; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns10__ConfigurationRef, default initialized and not managed by a soap context
        virtual ns10__ConfigurationRef *soap_alloc(void) const { return SOAP_NEW(ns10__ConfigurationRef); }
      public:
        /// Constructor with initializations
        ns10__ConfigurationRef()
        {
          Token = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns10__ConfigurationRef() { }
        /// Friend allocator used by soap_new_ns10__ConfigurationRef(struct soap*, int)
        friend SOAP_FMAC1 ns10__ConfigurationRef * SOAP_FMAC2 soap_instantiate_ns10__ConfigurationRef(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3103 */
#ifndef SOAP_TYPE_ns10__ConfigurationSet
#define SOAP_TYPE_ns10__ConfigurationSet (1185)
/* complex XSD type 'ns10:ConfigurationSet': */
class SOAP_CMAC ns10__ConfigurationSet {
      public:
        /// Optional element 'ns10:VideoSource' of XSD type 'ns2:VideoSourceConfiguration'
        ns2__VideoSourceConfiguration *VideoSource;
        /// Optional element 'ns10:AudioSource' of XSD type 'ns2:AudioSourceConfiguration'
        ns2__AudioSourceConfiguration *AudioSource;
        /// Optional element 'ns10:VideoEncoder' of XSD type 'ns2:VideoEncoder2Configuration'
        ns2__VideoEncoder2Configuration *VideoEncoder;
        /// Optional element 'ns10:AudioEncoder' of XSD type 'ns2:AudioEncoder2Configuration'
        ns2__AudioEncoder2Configuration *AudioEncoder;
        /// Optional element 'ns10:Analytics' of XSD type 'ns2:ConfigurationEntity'
        ns2__ConfigurationEntity *Analytics;
        /// Optional element 'ns10:PTZ' of XSD type 'ns2:PTZConfiguration'
        ns2__PTZConfiguration *PTZ;
        /// Optional element 'ns10:Metadata' of XSD type 'ns2:MetadataConfiguration'
        ns2__MetadataConfiguration *Metadata;
        /// Optional element 'ns10:AudioOutput' of XSD type 'ns2:AudioOutputConfiguration'
        ns2__AudioOutputConfiguration *AudioOutput;
        /// Optional element 'ns10:AudioDecoder' of XSD type 'ns2:AudioDecoderConfiguration'
        ns2__AudioDecoderConfiguration *AudioDecoder;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns10__ConfigurationSet
        virtual int soap_type(void) const { return SOAP_TYPE_ns10__ConfigurationSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns10__ConfigurationSet, default initialized and not managed by a soap context
        virtual ns10__ConfigurationSet *soap_alloc(void) const { return SOAP_NEW(ns10__ConfigurationSet); }
      public:
        /// Constructor with initializations
        ns10__ConfigurationSet()
        {
          VideoSource = (ns2__VideoSourceConfiguration *)0;
          AudioSource = (ns2__AudioSourceConfiguration *)0;
          VideoEncoder = (ns2__VideoEncoder2Configuration *)0;
          AudioEncoder = (ns2__AudioEncoder2Configuration *)0;
          Analytics = (ns2__ConfigurationEntity *)0;
          PTZ = (ns2__PTZConfiguration *)0;
          Metadata = (ns2__MetadataConfiguration *)0;
          AudioOutput = (ns2__AudioOutputConfiguration *)0;
          AudioDecoder = (ns2__AudioDecoderConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns10__ConfigurationSet() { }
        /// Friend allocator used by soap_new_ns10__ConfigurationSet(struct soap*, int)
        friend SOAP_FMAC1 ns10__ConfigurationSet * SOAP_FMAC2 soap_instantiate_ns10__ConfigurationSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3106 */
#ifndef SOAP_TYPE_ns10__MediaProfile
#define SOAP_TYPE_ns10__MediaProfile (1186)
/* complex XSD type 'ns10:MediaProfile': */
class SOAP_CMAC ns10__MediaProfile {
      public:
        /// Required element 'ns10:Name' of XSD type 'ns2:Name'
        std::string Name;
        /// Optional element 'ns10:Configurations' of XSD type 'ns10:ConfigurationSet'
        ns10__ConfigurationSet *Configurations;
        /// required attribute 'token' of XSD type 'ns2:ReferenceToken'
        std::string token;
        /// optional attribute 'fixed' of XSD type 'xsd:boolean'
        bool *fixed;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns10__MediaProfile
        virtual int soap_type(void) const { return SOAP_TYPE_ns10__MediaProfile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns10__MediaProfile, default initialized and not managed by a soap context
        virtual ns10__MediaProfile *soap_alloc(void) const { return SOAP_NEW(ns10__MediaProfile); }
      public:
        /// Constructor with initializations
        ns10__MediaProfile()
        {
          Configurations = (ns10__ConfigurationSet *)0;
          fixed = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns10__MediaProfile() { }
        /// Friend allocator used by soap_new_ns10__MediaProfile(struct soap*, int)
        friend SOAP_FMAC1 ns10__MediaProfile * SOAP_FMAC2 soap_instantiate_ns10__MediaProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3109 */
#ifndef SOAP_TYPE_ns10__GetConfiguration
#define SOAP_TYPE_ns10__GetConfiguration (1187)
/* complex XSD type 'ns10:GetConfiguration': */
class SOAP_CMAC ns10__GetConfiguration {
      public:
        /// Optional element 'ns10:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string *ConfigurationToken;
        /// Optional element 'ns10:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string *ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns10__GetConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns10__GetConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns10__GetConfiguration, default initialized and not managed by a soap context
        virtual ns10__GetConfiguration *soap_alloc(void) const { return SOAP_NEW(ns10__GetConfiguration); }
      public:
        /// Constructor with initializations
        ns10__GetConfiguration()
        {
          ConfigurationToken = (std::string *)0;
          ProfileToken = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns10__GetConfiguration() { }
        /// Friend allocator used by soap_new_ns10__GetConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns10__GetConfiguration * SOAP_FMAC2 soap_instantiate_ns10__GetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3112 */
#ifndef SOAP_TYPE_ns10__EncoderInstance
#define SOAP_TYPE_ns10__EncoderInstance (1188)
/* complex XSD type 'ns10:EncoderInstance': */
class SOAP_CMAC ns10__EncoderInstance {
      public:
        /// Required element 'ns10:Encoding' of XSD type 'xsd:string'
        std::string Encoding;
        /// Required element 'ns10:Number' of XSD type 'xsd:int'
        int Number;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns10__EncoderInstance
        virtual int soap_type(void) const { return SOAP_TYPE_ns10__EncoderInstance; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns10__EncoderInstance, default initialized and not managed by a soap context
        virtual ns10__EncoderInstance *soap_alloc(void) const { return SOAP_NEW(ns10__EncoderInstance); }
      public:
        /// Constructor with initializations
        ns10__EncoderInstance()
        {
          Number = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~ns10__EncoderInstance() { }
        /// Friend allocator used by soap_new_ns10__EncoderInstance(struct soap*, int)
        friend SOAP_FMAC1 ns10__EncoderInstance * SOAP_FMAC2 soap_instantiate_ns10__EncoderInstance(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3115 */
#ifndef SOAP_TYPE_ns10__EncoderInstanceInfo
#define SOAP_TYPE_ns10__EncoderInstanceInfo (1189)
/* complex XSD type 'ns10:EncoderInstanceInfo': */
class SOAP_CMAC ns10__EncoderInstanceInfo {
      public:
        /// Optional element 'ns10:Codec' of XSD type 'ns10:EncoderInstance'
        std::vector<ns10__EncoderInstance *> Codec;
        /// Required element 'ns10:Total' of XSD type 'xsd:int'
        int Total;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns10__EncoderInstanceInfo
        virtual int soap_type(void) const { return SOAP_TYPE_ns10__EncoderInstanceInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns10__EncoderInstanceInfo, default initialized and not managed by a soap context
        virtual ns10__EncoderInstanceInfo *soap_alloc(void) const { return SOAP_NEW(ns10__EncoderInstanceInfo); }
      public:
        /// Constructor with initializations
        ns10__EncoderInstanceInfo()
        {
          Total = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~ns10__EncoderInstanceInfo() { }
        /// Friend allocator used by soap_new_ns10__EncoderInstanceInfo(struct soap*, int)
        friend SOAP_FMAC1 ns10__EncoderInstanceInfo * SOAP_FMAC2 soap_instantiate_ns10__EncoderInstanceInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3118 */
#ifndef SOAP_TYPE_ns10__StartStopMulticastStreaming
#define SOAP_TYPE_ns10__StartStopMulticastStreaming (1190)
/* complex XSD type 'ns10:StartStopMulticastStreaming': */
class SOAP_CMAC ns10__StartStopMulticastStreaming {
      public:
        /// Required element 'ns10:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns10__StartStopMulticastStreaming
        virtual int soap_type(void) const { return SOAP_TYPE_ns10__StartStopMulticastStreaming; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns10__StartStopMulticastStreaming, default initialized and not managed by a soap context
        virtual ns10__StartStopMulticastStreaming *soap_alloc(void) const { return SOAP_NEW(ns10__StartStopMulticastStreaming); }
      public:
        /// Constructor with initializations
        ns10__StartStopMulticastStreaming()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns10__StartStopMulticastStreaming() { }
        /// Friend allocator used by soap_new_ns10__StartStopMulticastStreaming(struct soap*, int)
        friend SOAP_FMAC1 ns10__StartStopMulticastStreaming * SOAP_FMAC2 soap_instantiate_ns10__StartStopMulticastStreaming(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3121 */
#ifndef SOAP_TYPE_ns10__VideoSourceMode
#define SOAP_TYPE_ns10__VideoSourceMode (1191)
/* complex XSD type 'ns10:VideoSourceMode': */
class SOAP_CMAC ns10__VideoSourceMode {
      public:
        /// Required element 'ns10:MaxFramerate' of XSD type 'xsd:float'
        float MaxFramerate;
        /// Required element 'ns10:MaxResolution' of XSD type 'ns2:VideoResolution'
        ns2__VideoResolution *MaxResolution;
        /// Required element 'ns10:Encodings' of XSD type 'ns10:EncodingTypes'
        std::string Encodings;
        /// Required element 'ns10:Reboot' of XSD type 'xsd:boolean'
        bool Reboot;
        /// Optional element 'ns10:Description' of XSD type 'ns2:Description'
        std::string *Description;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// required attribute 'token' of XSD type 'ns2:ReferenceToken'
        std::string token;
        /// optional attribute 'Enabled' of XSD type 'xsd:boolean'
        bool *Enabled;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns10__VideoSourceMode
        virtual int soap_type(void) const { return SOAP_TYPE_ns10__VideoSourceMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns10__VideoSourceMode, default initialized and not managed by a soap context
        virtual ns10__VideoSourceMode *soap_alloc(void) const { return SOAP_NEW(ns10__VideoSourceMode); }
      public:
        /// Constructor with initializations
        ns10__VideoSourceMode()
        {
          MaxFramerate = (float)0;
          MaxResolution = (ns2__VideoResolution *)0;
          Reboot = (bool)0;
          Description = (std::string *)0;
          Enabled = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns10__VideoSourceMode() { }
        /// Friend allocator used by soap_new_ns10__VideoSourceMode(struct soap*, int)
        friend SOAP_FMAC1 ns10__VideoSourceMode * SOAP_FMAC2 soap_instantiate_ns10__VideoSourceMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3124 */
#ifndef SOAP_TYPE__ns10__GetServiceCapabilities
#define SOAP_TYPE__ns10__GetServiceCapabilities (1192)
/* complex XSD type 'ns10:GetServiceCapabilities': */
class SOAP_CMAC _ns10__GetServiceCapabilities {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetServiceCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetServiceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetServiceCapabilities, default initialized and not managed by a soap context
        virtual _ns10__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_ns10__GetServiceCapabilities); }
      public:
        /// Constructor with initializations
        _ns10__GetServiceCapabilities()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetServiceCapabilities() { }
        /// Friend allocator used by soap_new__ns10__GetServiceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__ns10__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3127 */
#ifndef SOAP_TYPE__ns10__GetServiceCapabilitiesResponse2
#define SOAP_TYPE__ns10__GetServiceCapabilitiesResponse2 (1193)
/* complex XSD type 'ns10:GetServiceCapabilitiesResponse2': */
class SOAP_CMAC _ns10__GetServiceCapabilitiesResponse2 {
      public:
        /// Required element 'ns10:Capabilities' of XSD type 'ns10:Capabilities2'
        ns10__Capabilities2 *Capabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetServiceCapabilitiesResponse2
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetServiceCapabilitiesResponse2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetServiceCapabilitiesResponse2, default initialized and not managed by a soap context
        virtual _ns10__GetServiceCapabilitiesResponse2 *soap_alloc(void) const { return SOAP_NEW(_ns10__GetServiceCapabilitiesResponse2); }
      public:
        /// Constructor with initializations
        _ns10__GetServiceCapabilitiesResponse2()
        {
          Capabilities = (ns10__Capabilities2 *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetServiceCapabilitiesResponse2() { }
        /// Friend allocator used by soap_new__ns10__GetServiceCapabilitiesResponse2(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetServiceCapabilitiesResponse2 * SOAP_FMAC2 soap_instantiate__ns10__GetServiceCapabilitiesResponse2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3130 */
#ifndef SOAP_TYPE__ns10__CreateProfile
#define SOAP_TYPE__ns10__CreateProfile (1194)
/* complex XSD type 'ns10:CreateProfile': */
class SOAP_CMAC _ns10__CreateProfile {
      public:
        /// Required element 'ns10:Name' of XSD type 'ns2:Name'
        std::string Name;
        /// Optional element 'ns10:Configuration' of XSD type 'ns10:ConfigurationRef'
        std::vector<ns10__ConfigurationRef *> Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__CreateProfile
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__CreateProfile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__CreateProfile, default initialized and not managed by a soap context
        virtual _ns10__CreateProfile *soap_alloc(void) const { return SOAP_NEW(_ns10__CreateProfile); }
      public:
        /// Constructor with initializations
        _ns10__CreateProfile()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__CreateProfile() { }
        /// Friend allocator used by soap_new__ns10__CreateProfile(struct soap*, int)
        friend SOAP_FMAC1 _ns10__CreateProfile * SOAP_FMAC2 soap_instantiate__ns10__CreateProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3133 */
#ifndef SOAP_TYPE__ns10__CreateProfileResponse
#define SOAP_TYPE__ns10__CreateProfileResponse (1195)
/* complex XSD type 'ns10:CreateProfileResponse': */
class SOAP_CMAC _ns10__CreateProfileResponse {
      public:
        /// Required element 'ns10:Token' of XSD type 'ns2:ReferenceToken'
        std::string Token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__CreateProfileResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__CreateProfileResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__CreateProfileResponse, default initialized and not managed by a soap context
        virtual _ns10__CreateProfileResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__CreateProfileResponse); }
      public:
        /// Constructor with initializations
        _ns10__CreateProfileResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__CreateProfileResponse() { }
        /// Friend allocator used by soap_new__ns10__CreateProfileResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__CreateProfileResponse * SOAP_FMAC2 soap_instantiate__ns10__CreateProfileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3136 */
#ifndef SOAP_TYPE__ns10__GetProfiles
#define SOAP_TYPE__ns10__GetProfiles (1196)
/* complex XSD type 'ns10:GetProfiles': */
class SOAP_CMAC _ns10__GetProfiles {
      public:
        /// Optional element 'ns10:Token' of XSD type 'ns2:ReferenceToken'
        std::string *Token;
        /// Optional element 'ns10:Type' of XSD type 'xsd:string'
        std::vector<std::string> Type;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetProfiles
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetProfiles; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetProfiles, default initialized and not managed by a soap context
        virtual _ns10__GetProfiles *soap_alloc(void) const { return SOAP_NEW(_ns10__GetProfiles); }
      public:
        /// Constructor with initializations
        _ns10__GetProfiles()
        {
          Token = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetProfiles() { }
        /// Friend allocator used by soap_new__ns10__GetProfiles(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetProfiles * SOAP_FMAC2 soap_instantiate__ns10__GetProfiles(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3139 */
#ifndef SOAP_TYPE__ns10__GetProfilesResponse
#define SOAP_TYPE__ns10__GetProfilesResponse (1197)
/* complex XSD type 'ns10:GetProfilesResponse': */
class SOAP_CMAC _ns10__GetProfilesResponse {
      public:
        /// Optional element 'ns10:Profiles' of XSD type 'ns10:MediaProfile'
        std::vector<ns10__MediaProfile *> Profiles;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetProfilesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetProfilesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetProfilesResponse, default initialized and not managed by a soap context
        virtual _ns10__GetProfilesResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__GetProfilesResponse); }
      public:
        /// Constructor with initializations
        _ns10__GetProfilesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetProfilesResponse() { }
        /// Friend allocator used by soap_new__ns10__GetProfilesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetProfilesResponse * SOAP_FMAC2 soap_instantiate__ns10__GetProfilesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3142 */
#ifndef SOAP_TYPE__ns10__AddConfiguration
#define SOAP_TYPE__ns10__AddConfiguration (1198)
/* complex XSD type 'ns10:AddConfiguration': */
class SOAP_CMAC _ns10__AddConfiguration {
      public:
        /// Required element 'ns10:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Optional element 'ns10:Name' of XSD type 'ns2:Name'
        std::string *Name;
        /// Optional element 'ns10:Configuration' of XSD type 'ns10:ConfigurationRef'
        std::vector<ns10__ConfigurationRef *> Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__AddConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__AddConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__AddConfiguration, default initialized and not managed by a soap context
        virtual _ns10__AddConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns10__AddConfiguration); }
      public:
        /// Constructor with initializations
        _ns10__AddConfiguration()
        {
          Name = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns10__AddConfiguration() { }
        /// Friend allocator used by soap_new__ns10__AddConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns10__AddConfiguration * SOAP_FMAC2 soap_instantiate__ns10__AddConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3145 */
#ifndef SOAP_TYPE__ns10__AddConfigurationResponse
#define SOAP_TYPE__ns10__AddConfigurationResponse (1199)
/* complex XSD type 'ns10:AddConfigurationResponse': */
class SOAP_CMAC _ns10__AddConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__AddConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__AddConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__AddConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns10__AddConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__AddConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns10__AddConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__AddConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns10__AddConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__AddConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns10__AddConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3148 */
#ifndef SOAP_TYPE__ns10__RemoveConfiguration
#define SOAP_TYPE__ns10__RemoveConfiguration (1200)
/* complex XSD type 'ns10:RemoveConfiguration': */
class SOAP_CMAC _ns10__RemoveConfiguration {
      public:
        /// Required element 'ns10:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'ns10:Configuration' of XSD type 'ns10:ConfigurationRef'
        std::vector<ns10__ConfigurationRef *> Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__RemoveConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__RemoveConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__RemoveConfiguration, default initialized and not managed by a soap context
        virtual _ns10__RemoveConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns10__RemoveConfiguration); }
      public:
        /// Constructor with initializations
        _ns10__RemoveConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__RemoveConfiguration() { }
        /// Friend allocator used by soap_new__ns10__RemoveConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns10__RemoveConfiguration * SOAP_FMAC2 soap_instantiate__ns10__RemoveConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3151 */
#ifndef SOAP_TYPE__ns10__RemoveConfigurationResponse
#define SOAP_TYPE__ns10__RemoveConfigurationResponse (1201)
/* complex XSD type 'ns10:RemoveConfigurationResponse': */
class SOAP_CMAC _ns10__RemoveConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__RemoveConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__RemoveConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__RemoveConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns10__RemoveConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__RemoveConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns10__RemoveConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__RemoveConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns10__RemoveConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__RemoveConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns10__RemoveConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3154 */
#ifndef SOAP_TYPE__ns10__DeleteProfile
#define SOAP_TYPE__ns10__DeleteProfile (1202)
/* complex XSD type 'ns10:DeleteProfile': */
class SOAP_CMAC _ns10__DeleteProfile {
      public:
        /// Required element 'ns10:Token' of XSD type 'ns2:ReferenceToken'
        std::string Token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__DeleteProfile
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__DeleteProfile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__DeleteProfile, default initialized and not managed by a soap context
        virtual _ns10__DeleteProfile *soap_alloc(void) const { return SOAP_NEW(_ns10__DeleteProfile); }
      public:
        /// Constructor with initializations
        _ns10__DeleteProfile()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__DeleteProfile() { }
        /// Friend allocator used by soap_new__ns10__DeleteProfile(struct soap*, int)
        friend SOAP_FMAC1 _ns10__DeleteProfile * SOAP_FMAC2 soap_instantiate__ns10__DeleteProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3157 */
#ifndef SOAP_TYPE__ns10__DeleteProfileResponse
#define SOAP_TYPE__ns10__DeleteProfileResponse (1203)
/* complex XSD type 'ns10:DeleteProfileResponse': */
class SOAP_CMAC _ns10__DeleteProfileResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__DeleteProfileResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__DeleteProfileResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__DeleteProfileResponse, default initialized and not managed by a soap context
        virtual _ns10__DeleteProfileResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__DeleteProfileResponse); }
      public:
        /// Constructor with initializations
        _ns10__DeleteProfileResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__DeleteProfileResponse() { }
        /// Friend allocator used by soap_new__ns10__DeleteProfileResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__DeleteProfileResponse * SOAP_FMAC2 soap_instantiate__ns10__DeleteProfileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3160 */
#ifndef SOAP_TYPE__ns10__GetVideoEncoderConfigurationsResponse
#define SOAP_TYPE__ns10__GetVideoEncoderConfigurationsResponse (1204)
/* complex XSD type 'ns10:GetVideoEncoderConfigurationsResponse': */
class SOAP_CMAC _ns10__GetVideoEncoderConfigurationsResponse {
      public:
        /// Optional element 'ns10:Configurations' of XSD type 'ns2:VideoEncoder2Configuration'
        std::vector<ns2__VideoEncoder2Configuration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetVideoEncoderConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetVideoEncoderConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetVideoEncoderConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns10__GetVideoEncoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__GetVideoEncoderConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns10__GetVideoEncoderConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetVideoEncoderConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns10__GetVideoEncoderConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetVideoEncoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns10__GetVideoEncoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3163 */
#ifndef SOAP_TYPE__ns10__GetVideoSourceConfigurationsResponse
#define SOAP_TYPE__ns10__GetVideoSourceConfigurationsResponse (1205)
/* complex XSD type 'ns10:GetVideoSourceConfigurationsResponse': */
class SOAP_CMAC _ns10__GetVideoSourceConfigurationsResponse {
      public:
        /// Optional element 'ns10:Configurations' of XSD type 'ns2:VideoSourceConfiguration'
        std::vector<ns2__VideoSourceConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetVideoSourceConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetVideoSourceConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetVideoSourceConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns10__GetVideoSourceConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__GetVideoSourceConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns10__GetVideoSourceConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetVideoSourceConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns10__GetVideoSourceConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetVideoSourceConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns10__GetVideoSourceConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3166 */
#ifndef SOAP_TYPE__ns10__GetAudioEncoderConfigurationsResponse
#define SOAP_TYPE__ns10__GetAudioEncoderConfigurationsResponse (1206)
/* complex XSD type 'ns10:GetAudioEncoderConfigurationsResponse': */
class SOAP_CMAC _ns10__GetAudioEncoderConfigurationsResponse {
      public:
        /// Optional element 'ns10:Configurations' of XSD type 'ns2:AudioEncoder2Configuration'
        std::vector<ns2__AudioEncoder2Configuration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetAudioEncoderConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetAudioEncoderConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetAudioEncoderConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns10__GetAudioEncoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__GetAudioEncoderConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns10__GetAudioEncoderConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetAudioEncoderConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns10__GetAudioEncoderConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetAudioEncoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns10__GetAudioEncoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3169 */
#ifndef SOAP_TYPE__ns10__GetAudioSourceConfigurationsResponse
#define SOAP_TYPE__ns10__GetAudioSourceConfigurationsResponse (1207)
/* complex XSD type 'ns10:GetAudioSourceConfigurationsResponse': */
class SOAP_CMAC _ns10__GetAudioSourceConfigurationsResponse {
      public:
        /// Optional element 'ns10:Configurations' of XSD type 'ns2:AudioSourceConfiguration'
        std::vector<ns2__AudioSourceConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetAudioSourceConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetAudioSourceConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetAudioSourceConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns10__GetAudioSourceConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__GetAudioSourceConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns10__GetAudioSourceConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetAudioSourceConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns10__GetAudioSourceConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetAudioSourceConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns10__GetAudioSourceConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3172 */
#ifndef SOAP_TYPE__ns10__GetAnalyticsConfigurationsResponse
#define SOAP_TYPE__ns10__GetAnalyticsConfigurationsResponse (1208)
/* complex XSD type 'ns10:GetAnalyticsConfigurationsResponse': */
class SOAP_CMAC _ns10__GetAnalyticsConfigurationsResponse {
      public:
        /// Optional element 'ns10:Configurations' of XSD type 'ns2:VideoAnalyticsConfiguration'
        std::vector<ns2__VideoAnalyticsConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetAnalyticsConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetAnalyticsConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetAnalyticsConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns10__GetAnalyticsConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__GetAnalyticsConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns10__GetAnalyticsConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetAnalyticsConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns10__GetAnalyticsConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetAnalyticsConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns10__GetAnalyticsConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3175 */
#ifndef SOAP_TYPE__ns10__GetMetadataConfigurationsResponse
#define SOAP_TYPE__ns10__GetMetadataConfigurationsResponse (1209)
/* complex XSD type 'ns10:GetMetadataConfigurationsResponse': */
class SOAP_CMAC _ns10__GetMetadataConfigurationsResponse {
      public:
        /// Optional element 'ns10:Configurations' of XSD type 'ns2:MetadataConfiguration'
        std::vector<ns2__MetadataConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetMetadataConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetMetadataConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetMetadataConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns10__GetMetadataConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__GetMetadataConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns10__GetMetadataConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetMetadataConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns10__GetMetadataConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetMetadataConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns10__GetMetadataConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3178 */
#ifndef SOAP_TYPE__ns10__GetAudioOutputConfigurationsResponse
#define SOAP_TYPE__ns10__GetAudioOutputConfigurationsResponse (1210)
/* complex XSD type 'ns10:GetAudioOutputConfigurationsResponse': */
class SOAP_CMAC _ns10__GetAudioOutputConfigurationsResponse {
      public:
        /// Optional element 'ns10:Configurations' of XSD type 'ns2:AudioOutputConfiguration'
        std::vector<ns2__AudioOutputConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetAudioOutputConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetAudioOutputConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetAudioOutputConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns10__GetAudioOutputConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__GetAudioOutputConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns10__GetAudioOutputConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetAudioOutputConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns10__GetAudioOutputConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetAudioOutputConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns10__GetAudioOutputConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3181 */
#ifndef SOAP_TYPE__ns10__GetAudioDecoderConfigurationsResponse
#define SOAP_TYPE__ns10__GetAudioDecoderConfigurationsResponse (1211)
/* complex XSD type 'ns10:GetAudioDecoderConfigurationsResponse': */
class SOAP_CMAC _ns10__GetAudioDecoderConfigurationsResponse {
      public:
        /// Optional element 'ns10:Configurations' of XSD type 'ns2:AudioDecoderConfiguration'
        std::vector<ns2__AudioDecoderConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetAudioDecoderConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetAudioDecoderConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetAudioDecoderConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns10__GetAudioDecoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__GetAudioDecoderConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns10__GetAudioDecoderConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetAudioDecoderConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns10__GetAudioDecoderConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetAudioDecoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns10__GetAudioDecoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3184 */
#ifndef SOAP_TYPE__ns10__SetVideoEncoderConfiguration
#define SOAP_TYPE__ns10__SetVideoEncoderConfiguration (1212)
/* complex XSD type 'ns10:SetVideoEncoderConfiguration': */
class SOAP_CMAC _ns10__SetVideoEncoderConfiguration {
      public:
        /// Required element 'ns10:Configuration' of XSD type 'ns2:VideoEncoder2Configuration'
        ns2__VideoEncoder2Configuration *Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__SetVideoEncoderConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__SetVideoEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__SetVideoEncoderConfiguration, default initialized and not managed by a soap context
        virtual _ns10__SetVideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns10__SetVideoEncoderConfiguration); }
      public:
        /// Constructor with initializations
        _ns10__SetVideoEncoderConfiguration()
        {
          Configuration = (ns2__VideoEncoder2Configuration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns10__SetVideoEncoderConfiguration() { }
        /// Friend allocator used by soap_new__ns10__SetVideoEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns10__SetVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate__ns10__SetVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3187 */
#ifndef SOAP_TYPE__ns10__SetConfigurationResponse
#define SOAP_TYPE__ns10__SetConfigurationResponse (1213)
/* complex XSD type 'ns10:SetConfigurationResponse': */
class SOAP_CMAC _ns10__SetConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__SetConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__SetConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__SetConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns10__SetConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__SetConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns10__SetConfigurationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__SetConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns10__SetConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__SetConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns10__SetConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3190 */
#ifndef SOAP_TYPE__ns10__SetVideoSourceConfiguration
#define SOAP_TYPE__ns10__SetVideoSourceConfiguration (1214)
/* complex XSD type 'ns10:SetVideoSourceConfiguration': */
class SOAP_CMAC _ns10__SetVideoSourceConfiguration {
      public:
        /// Required element 'ns10:Configuration' of XSD type 'ns2:VideoSourceConfiguration'
        ns2__VideoSourceConfiguration *Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__SetVideoSourceConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__SetVideoSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__SetVideoSourceConfiguration, default initialized and not managed by a soap context
        virtual _ns10__SetVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns10__SetVideoSourceConfiguration); }
      public:
        /// Constructor with initializations
        _ns10__SetVideoSourceConfiguration()
        {
          Configuration = (ns2__VideoSourceConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns10__SetVideoSourceConfiguration() { }
        /// Friend allocator used by soap_new__ns10__SetVideoSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns10__SetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate__ns10__SetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3193 */
#ifndef SOAP_TYPE__ns10__SetAudioEncoderConfiguration
#define SOAP_TYPE__ns10__SetAudioEncoderConfiguration (1215)
/* complex XSD type 'ns10:SetAudioEncoderConfiguration': */
class SOAP_CMAC _ns10__SetAudioEncoderConfiguration {
      public:
        /// Required element 'ns10:Configuration' of XSD type 'ns2:AudioEncoder2Configuration'
        ns2__AudioEncoder2Configuration *Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__SetAudioEncoderConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__SetAudioEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__SetAudioEncoderConfiguration, default initialized and not managed by a soap context
        virtual _ns10__SetAudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns10__SetAudioEncoderConfiguration); }
      public:
        /// Constructor with initializations
        _ns10__SetAudioEncoderConfiguration()
        {
          Configuration = (ns2__AudioEncoder2Configuration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns10__SetAudioEncoderConfiguration() { }
        /// Friend allocator used by soap_new__ns10__SetAudioEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns10__SetAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate__ns10__SetAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3196 */
#ifndef SOAP_TYPE__ns10__SetAudioSourceConfiguration
#define SOAP_TYPE__ns10__SetAudioSourceConfiguration (1216)
/* complex XSD type 'ns10:SetAudioSourceConfiguration': */
class SOAP_CMAC _ns10__SetAudioSourceConfiguration {
      public:
        /// Required element 'ns10:Configuration' of XSD type 'ns2:AudioSourceConfiguration'
        ns2__AudioSourceConfiguration *Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__SetAudioSourceConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__SetAudioSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__SetAudioSourceConfiguration, default initialized and not managed by a soap context
        virtual _ns10__SetAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns10__SetAudioSourceConfiguration); }
      public:
        /// Constructor with initializations
        _ns10__SetAudioSourceConfiguration()
        {
          Configuration = (ns2__AudioSourceConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns10__SetAudioSourceConfiguration() { }
        /// Friend allocator used by soap_new__ns10__SetAudioSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns10__SetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate__ns10__SetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3199 */
#ifndef SOAP_TYPE__ns10__SetMetadataConfiguration
#define SOAP_TYPE__ns10__SetMetadataConfiguration (1217)
/* complex XSD type 'ns10:SetMetadataConfiguration': */
class SOAP_CMAC _ns10__SetMetadataConfiguration {
      public:
        /// Required element 'ns10:Configuration' of XSD type 'ns2:MetadataConfiguration'
        ns2__MetadataConfiguration *Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__SetMetadataConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__SetMetadataConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__SetMetadataConfiguration, default initialized and not managed by a soap context
        virtual _ns10__SetMetadataConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns10__SetMetadataConfiguration); }
      public:
        /// Constructor with initializations
        _ns10__SetMetadataConfiguration()
        {
          Configuration = (ns2__MetadataConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns10__SetMetadataConfiguration() { }
        /// Friend allocator used by soap_new__ns10__SetMetadataConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns10__SetMetadataConfiguration * SOAP_FMAC2 soap_instantiate__ns10__SetMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3202 */
#ifndef SOAP_TYPE__ns10__SetAudioOutputConfiguration
#define SOAP_TYPE__ns10__SetAudioOutputConfiguration (1218)
/* complex XSD type 'ns10:SetAudioOutputConfiguration': */
class SOAP_CMAC _ns10__SetAudioOutputConfiguration {
      public:
        /// Required element 'ns10:Configuration' of XSD type 'ns2:AudioOutputConfiguration'
        ns2__AudioOutputConfiguration *Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__SetAudioOutputConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__SetAudioOutputConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__SetAudioOutputConfiguration, default initialized and not managed by a soap context
        virtual _ns10__SetAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns10__SetAudioOutputConfiguration); }
      public:
        /// Constructor with initializations
        _ns10__SetAudioOutputConfiguration()
        {
          Configuration = (ns2__AudioOutputConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns10__SetAudioOutputConfiguration() { }
        /// Friend allocator used by soap_new__ns10__SetAudioOutputConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns10__SetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate__ns10__SetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3205 */
#ifndef SOAP_TYPE__ns10__SetAudioDecoderConfiguration
#define SOAP_TYPE__ns10__SetAudioDecoderConfiguration (1219)
/* complex XSD type 'ns10:SetAudioDecoderConfiguration': */
class SOAP_CMAC _ns10__SetAudioDecoderConfiguration {
      public:
        /// Required element 'ns10:Configuration' of XSD type 'ns2:AudioDecoderConfiguration'
        ns2__AudioDecoderConfiguration *Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__SetAudioDecoderConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__SetAudioDecoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__SetAudioDecoderConfiguration, default initialized and not managed by a soap context
        virtual _ns10__SetAudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns10__SetAudioDecoderConfiguration); }
      public:
        /// Constructor with initializations
        _ns10__SetAudioDecoderConfiguration()
        {
          Configuration = (ns2__AudioDecoderConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns10__SetAudioDecoderConfiguration() { }
        /// Friend allocator used by soap_new__ns10__SetAudioDecoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns10__SetAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate__ns10__SetAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3208 */
#ifndef SOAP_TYPE__ns10__GetVideoSourceConfigurationOptionsResponse
#define SOAP_TYPE__ns10__GetVideoSourceConfigurationOptionsResponse (1220)
/* complex XSD type 'ns10:GetVideoSourceConfigurationOptionsResponse': */
class SOAP_CMAC _ns10__GetVideoSourceConfigurationOptionsResponse {
      public:
        /// Required element 'ns10:Options' of XSD type 'ns2:VideoSourceConfigurationOptions'
        ns2__VideoSourceConfigurationOptions *Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetVideoSourceConfigurationOptionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetVideoSourceConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetVideoSourceConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _ns10__GetVideoSourceConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__GetVideoSourceConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _ns10__GetVideoSourceConfigurationOptionsResponse()
        {
          Options = (ns2__VideoSourceConfigurationOptions *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetVideoSourceConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__ns10__GetVideoSourceConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetVideoSourceConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__ns10__GetVideoSourceConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3211 */
#ifndef SOAP_TYPE__ns10__GetVideoEncoderConfigurationOptionsResponse
#define SOAP_TYPE__ns10__GetVideoEncoderConfigurationOptionsResponse (1221)
/* complex XSD type 'ns10:GetVideoEncoderConfigurationOptionsResponse': */
class SOAP_CMAC _ns10__GetVideoEncoderConfigurationOptionsResponse {
      public:
        /// Required element 'ns10:Options' of XSD type 'ns2:VideoEncoder2ConfigurationOptions'
        std::vector<ns2__VideoEncoder2ConfigurationOptions *> Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetVideoEncoderConfigurationOptionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetVideoEncoderConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetVideoEncoderConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _ns10__GetVideoEncoderConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__GetVideoEncoderConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _ns10__GetVideoEncoderConfigurationOptionsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetVideoEncoderConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__ns10__GetVideoEncoderConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetVideoEncoderConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__ns10__GetVideoEncoderConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3214 */
#ifndef SOAP_TYPE__ns10__GetAudioSourceConfigurationOptionsResponse
#define SOAP_TYPE__ns10__GetAudioSourceConfigurationOptionsResponse (1222)
/* complex XSD type 'ns10:GetAudioSourceConfigurationOptionsResponse': */
class SOAP_CMAC _ns10__GetAudioSourceConfigurationOptionsResponse {
      public:
        /// Required element 'ns10:Options' of XSD type 'ns2:AudioSourceConfigurationOptions'
        ns2__AudioSourceConfigurationOptions *Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetAudioSourceConfigurationOptionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetAudioSourceConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetAudioSourceConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _ns10__GetAudioSourceConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__GetAudioSourceConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _ns10__GetAudioSourceConfigurationOptionsResponse()
        {
          Options = (ns2__AudioSourceConfigurationOptions *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetAudioSourceConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__ns10__GetAudioSourceConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetAudioSourceConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__ns10__GetAudioSourceConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3217 */
#ifndef SOAP_TYPE__ns10__GetAudioEncoderConfigurationOptionsResponse
#define SOAP_TYPE__ns10__GetAudioEncoderConfigurationOptionsResponse (1223)
/* complex XSD type 'ns10:GetAudioEncoderConfigurationOptionsResponse': */
class SOAP_CMAC _ns10__GetAudioEncoderConfigurationOptionsResponse {
      public:
        /// Required element 'ns10:Options' of XSD type 'ns2:AudioEncoder2ConfigurationOptions'
        std::vector<ns2__AudioEncoder2ConfigurationOptions *> Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetAudioEncoderConfigurationOptionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetAudioEncoderConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetAudioEncoderConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _ns10__GetAudioEncoderConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__GetAudioEncoderConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _ns10__GetAudioEncoderConfigurationOptionsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetAudioEncoderConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__ns10__GetAudioEncoderConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetAudioEncoderConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__ns10__GetAudioEncoderConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3220 */
#ifndef SOAP_TYPE__ns10__GetMetadataConfigurationOptionsResponse
#define SOAP_TYPE__ns10__GetMetadataConfigurationOptionsResponse (1224)
/* complex XSD type 'ns10:GetMetadataConfigurationOptionsResponse': */
class SOAP_CMAC _ns10__GetMetadataConfigurationOptionsResponse {
      public:
        /// Required element 'ns10:Options' of XSD type 'ns2:MetadataConfigurationOptions'
        ns2__MetadataConfigurationOptions *Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetMetadataConfigurationOptionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetMetadataConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetMetadataConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _ns10__GetMetadataConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__GetMetadataConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _ns10__GetMetadataConfigurationOptionsResponse()
        {
          Options = (ns2__MetadataConfigurationOptions *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetMetadataConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__ns10__GetMetadataConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetMetadataConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__ns10__GetMetadataConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3223 */
#ifndef SOAP_TYPE__ns10__GetAudioOutputConfigurationOptionsResponse
#define SOAP_TYPE__ns10__GetAudioOutputConfigurationOptionsResponse (1225)
/* complex XSD type 'ns10:GetAudioOutputConfigurationOptionsResponse': */
class SOAP_CMAC _ns10__GetAudioOutputConfigurationOptionsResponse {
      public:
        /// Required element 'ns10:Options' of XSD type 'ns2:AudioOutputConfigurationOptions'
        ns2__AudioOutputConfigurationOptions *Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetAudioOutputConfigurationOptionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetAudioOutputConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetAudioOutputConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _ns10__GetAudioOutputConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__GetAudioOutputConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _ns10__GetAudioOutputConfigurationOptionsResponse()
        {
          Options = (ns2__AudioOutputConfigurationOptions *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetAudioOutputConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__ns10__GetAudioOutputConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetAudioOutputConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__ns10__GetAudioOutputConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3226 */
#ifndef SOAP_TYPE__ns10__GetAudioDecoderConfigurationOptionsResponse
#define SOAP_TYPE__ns10__GetAudioDecoderConfigurationOptionsResponse (1226)
/* complex XSD type 'ns10:GetAudioDecoderConfigurationOptionsResponse': */
class SOAP_CMAC _ns10__GetAudioDecoderConfigurationOptionsResponse {
      public:
        /// Required element 'ns10:Options' of XSD type 'ns2:AudioEncoder2ConfigurationOptions'
        std::vector<ns2__AudioEncoder2ConfigurationOptions *> Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetAudioDecoderConfigurationOptionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetAudioDecoderConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetAudioDecoderConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _ns10__GetAudioDecoderConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__GetAudioDecoderConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _ns10__GetAudioDecoderConfigurationOptionsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetAudioDecoderConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__ns10__GetAudioDecoderConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetAudioDecoderConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__ns10__GetAudioDecoderConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3229 */
#ifndef SOAP_TYPE__ns10__GetVideoEncoderInstances
#define SOAP_TYPE__ns10__GetVideoEncoderInstances (1227)
/* complex XSD type 'ns10:GetVideoEncoderInstances': */
class SOAP_CMAC _ns10__GetVideoEncoderInstances {
      public:
        /// Required element 'ns10:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetVideoEncoderInstances
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetVideoEncoderInstances; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetVideoEncoderInstances, default initialized and not managed by a soap context
        virtual _ns10__GetVideoEncoderInstances *soap_alloc(void) const { return SOAP_NEW(_ns10__GetVideoEncoderInstances); }
      public:
        /// Constructor with initializations
        _ns10__GetVideoEncoderInstances()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetVideoEncoderInstances() { }
        /// Friend allocator used by soap_new__ns10__GetVideoEncoderInstances(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetVideoEncoderInstances * SOAP_FMAC2 soap_instantiate__ns10__GetVideoEncoderInstances(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3232 */
#ifndef SOAP_TYPE__ns10__GetVideoEncoderInstancesResponse
#define SOAP_TYPE__ns10__GetVideoEncoderInstancesResponse (1228)
/* complex XSD type 'ns10:GetVideoEncoderInstancesResponse': */
class SOAP_CMAC _ns10__GetVideoEncoderInstancesResponse {
      public:
        /// Required element 'ns10:Info' of XSD type 'ns10:EncoderInstanceInfo'
        ns10__EncoderInstanceInfo *Info;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetVideoEncoderInstancesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetVideoEncoderInstancesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetVideoEncoderInstancesResponse, default initialized and not managed by a soap context
        virtual _ns10__GetVideoEncoderInstancesResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__GetVideoEncoderInstancesResponse); }
      public:
        /// Constructor with initializations
        _ns10__GetVideoEncoderInstancesResponse()
        {
          Info = (ns10__EncoderInstanceInfo *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetVideoEncoderInstancesResponse() { }
        /// Friend allocator used by soap_new__ns10__GetVideoEncoderInstancesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetVideoEncoderInstancesResponse * SOAP_FMAC2 soap_instantiate__ns10__GetVideoEncoderInstancesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3235 */
#ifndef SOAP_TYPE__ns10__GetStreamUri
#define SOAP_TYPE__ns10__GetStreamUri (1229)
/* complex XSD type 'ns10:GetStreamUri': */
class SOAP_CMAC _ns10__GetStreamUri {
      public:
        /// Required element 'ns10:Protocol' of XSD type 'xsd:string'
        std::string Protocol;
        /// Required element 'ns10:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetStreamUri
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetStreamUri; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetStreamUri, default initialized and not managed by a soap context
        virtual _ns10__GetStreamUri *soap_alloc(void) const { return SOAP_NEW(_ns10__GetStreamUri); }
      public:
        /// Constructor with initializations
        _ns10__GetStreamUri()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetStreamUri() { }
        /// Friend allocator used by soap_new__ns10__GetStreamUri(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetStreamUri * SOAP_FMAC2 soap_instantiate__ns10__GetStreamUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3238 */
#ifndef SOAP_TYPE__ns10__GetStreamUriResponse
#define SOAP_TYPE__ns10__GetStreamUriResponse (1230)
/* complex XSD type 'ns10:GetStreamUriResponse': */
class SOAP_CMAC _ns10__GetStreamUriResponse {
      public:
        /// Required element 'ns10:Uri' of XSD type 'xsd:anyURI'
        std::string Uri;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetStreamUriResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetStreamUriResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetStreamUriResponse, default initialized and not managed by a soap context
        virtual _ns10__GetStreamUriResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__GetStreamUriResponse); }
      public:
        /// Constructor with initializations
        _ns10__GetStreamUriResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetStreamUriResponse() { }
        /// Friend allocator used by soap_new__ns10__GetStreamUriResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetStreamUriResponse * SOAP_FMAC2 soap_instantiate__ns10__GetStreamUriResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3241 */
#ifndef SOAP_TYPE__ns10__SetSynchronizationPoint
#define SOAP_TYPE__ns10__SetSynchronizationPoint (1231)
/* complex XSD type 'ns10:SetSynchronizationPoint': */
class SOAP_CMAC _ns10__SetSynchronizationPoint {
      public:
        /// Required element 'ns10:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__SetSynchronizationPoint
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__SetSynchronizationPoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__SetSynchronizationPoint, default initialized and not managed by a soap context
        virtual _ns10__SetSynchronizationPoint *soap_alloc(void) const { return SOAP_NEW(_ns10__SetSynchronizationPoint); }
      public:
        /// Constructor with initializations
        _ns10__SetSynchronizationPoint()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__SetSynchronizationPoint() { }
        /// Friend allocator used by soap_new__ns10__SetSynchronizationPoint(struct soap*, int)
        friend SOAP_FMAC1 _ns10__SetSynchronizationPoint * SOAP_FMAC2 soap_instantiate__ns10__SetSynchronizationPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3244 */
#ifndef SOAP_TYPE__ns10__SetSynchronizationPointResponse
#define SOAP_TYPE__ns10__SetSynchronizationPointResponse (1232)
/* complex XSD type 'ns10:SetSynchronizationPointResponse': */
class SOAP_CMAC _ns10__SetSynchronizationPointResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__SetSynchronizationPointResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__SetSynchronizationPointResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__SetSynchronizationPointResponse, default initialized and not managed by a soap context
        virtual _ns10__SetSynchronizationPointResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__SetSynchronizationPointResponse); }
      public:
        /// Constructor with initializations
        _ns10__SetSynchronizationPointResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__SetSynchronizationPointResponse() { }
        /// Friend allocator used by soap_new__ns10__SetSynchronizationPointResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__SetSynchronizationPointResponse * SOAP_FMAC2 soap_instantiate__ns10__SetSynchronizationPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3247 */
#ifndef SOAP_TYPE__ns10__GetSnapshotUri
#define SOAP_TYPE__ns10__GetSnapshotUri (1233)
/* complex XSD type 'ns10:GetSnapshotUri': */
class SOAP_CMAC _ns10__GetSnapshotUri {
      public:
        /// Required element 'ns10:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetSnapshotUri
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetSnapshotUri; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetSnapshotUri, default initialized and not managed by a soap context
        virtual _ns10__GetSnapshotUri *soap_alloc(void) const { return SOAP_NEW(_ns10__GetSnapshotUri); }
      public:
        /// Constructor with initializations
        _ns10__GetSnapshotUri()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetSnapshotUri() { }
        /// Friend allocator used by soap_new__ns10__GetSnapshotUri(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetSnapshotUri * SOAP_FMAC2 soap_instantiate__ns10__GetSnapshotUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3250 */
#ifndef SOAP_TYPE__ns10__GetSnapshotUriResponse
#define SOAP_TYPE__ns10__GetSnapshotUriResponse (1234)
/* complex XSD type 'ns10:GetSnapshotUriResponse': */
class SOAP_CMAC _ns10__GetSnapshotUriResponse {
      public:
        /// Required element 'ns10:Uri' of XSD type 'xsd:anyURI'
        std::string Uri;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetSnapshotUriResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetSnapshotUriResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetSnapshotUriResponse, default initialized and not managed by a soap context
        virtual _ns10__GetSnapshotUriResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__GetSnapshotUriResponse); }
      public:
        /// Constructor with initializations
        _ns10__GetSnapshotUriResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetSnapshotUriResponse() { }
        /// Friend allocator used by soap_new__ns10__GetSnapshotUriResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetSnapshotUriResponse * SOAP_FMAC2 soap_instantiate__ns10__GetSnapshotUriResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3253 */
#ifndef SOAP_TYPE__ns10__StartStopMulticastStreamingResponse
#define SOAP_TYPE__ns10__StartStopMulticastStreamingResponse (1235)
/* complex XSD type 'ns10:StartStopMulticastStreamingResponse': */
class SOAP_CMAC _ns10__StartStopMulticastStreamingResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__StartStopMulticastStreamingResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__StartStopMulticastStreamingResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__StartStopMulticastStreamingResponse, default initialized and not managed by a soap context
        virtual _ns10__StartStopMulticastStreamingResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__StartStopMulticastStreamingResponse); }
      public:
        /// Constructor with initializations
        _ns10__StartStopMulticastStreamingResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__StartStopMulticastStreamingResponse() { }
        /// Friend allocator used by soap_new__ns10__StartStopMulticastStreamingResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__StartStopMulticastStreamingResponse * SOAP_FMAC2 soap_instantiate__ns10__StartStopMulticastStreamingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3256 */
#ifndef SOAP_TYPE__ns10__GetVideoSourceModes
#define SOAP_TYPE__ns10__GetVideoSourceModes (1236)
/* complex XSD type 'ns10:GetVideoSourceModes': */
class SOAP_CMAC _ns10__GetVideoSourceModes {
      public:
        /// Required element 'ns10:VideoSourceToken' of XSD type 'ns2:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetVideoSourceModes
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetVideoSourceModes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetVideoSourceModes, default initialized and not managed by a soap context
        virtual _ns10__GetVideoSourceModes *soap_alloc(void) const { return SOAP_NEW(_ns10__GetVideoSourceModes); }
      public:
        /// Constructor with initializations
        _ns10__GetVideoSourceModes()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetVideoSourceModes() { }
        /// Friend allocator used by soap_new__ns10__GetVideoSourceModes(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetVideoSourceModes * SOAP_FMAC2 soap_instantiate__ns10__GetVideoSourceModes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3259 */
#ifndef SOAP_TYPE__ns10__GetVideoSourceModesResponse
#define SOAP_TYPE__ns10__GetVideoSourceModesResponse (1237)
/* complex XSD type 'ns10:GetVideoSourceModesResponse': */
class SOAP_CMAC _ns10__GetVideoSourceModesResponse {
      public:
        /// Required element 'ns10:VideoSourceModes' of XSD type 'ns10:VideoSourceMode'
        std::vector<ns10__VideoSourceMode *> VideoSourceModes;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetVideoSourceModesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetVideoSourceModesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetVideoSourceModesResponse, default initialized and not managed by a soap context
        virtual _ns10__GetVideoSourceModesResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__GetVideoSourceModesResponse); }
      public:
        /// Constructor with initializations
        _ns10__GetVideoSourceModesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetVideoSourceModesResponse() { }
        /// Friend allocator used by soap_new__ns10__GetVideoSourceModesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetVideoSourceModesResponse * SOAP_FMAC2 soap_instantiate__ns10__GetVideoSourceModesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3262 */
#ifndef SOAP_TYPE__ns10__SetVideoSourceMode
#define SOAP_TYPE__ns10__SetVideoSourceMode (1238)
/* complex XSD type 'ns10:SetVideoSourceMode': */
class SOAP_CMAC _ns10__SetVideoSourceMode {
      public:
        /// Required element 'ns10:VideoSourceToken' of XSD type 'ns2:ReferenceToken'
        std::string VideoSourceToken;
        /// Required element 'ns10:VideoSourceModeToken' of XSD type 'ns2:ReferenceToken'
        std::string VideoSourceModeToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__SetVideoSourceMode
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__SetVideoSourceMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__SetVideoSourceMode, default initialized and not managed by a soap context
        virtual _ns10__SetVideoSourceMode *soap_alloc(void) const { return SOAP_NEW(_ns10__SetVideoSourceMode); }
      public:
        /// Constructor with initializations
        _ns10__SetVideoSourceMode()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__SetVideoSourceMode() { }
        /// Friend allocator used by soap_new__ns10__SetVideoSourceMode(struct soap*, int)
        friend SOAP_FMAC1 _ns10__SetVideoSourceMode * SOAP_FMAC2 soap_instantiate__ns10__SetVideoSourceMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3265 */
#ifndef SOAP_TYPE__ns10__SetVideoSourceModeResponse
#define SOAP_TYPE__ns10__SetVideoSourceModeResponse (1239)
/* complex XSD type 'ns10:SetVideoSourceModeResponse': */
class SOAP_CMAC _ns10__SetVideoSourceModeResponse {
      public:
        /// Required element 'ns10:Reboot' of XSD type 'xsd:boolean'
        bool Reboot;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__SetVideoSourceModeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__SetVideoSourceModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__SetVideoSourceModeResponse, default initialized and not managed by a soap context
        virtual _ns10__SetVideoSourceModeResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__SetVideoSourceModeResponse); }
      public:
        /// Constructor with initializations
        _ns10__SetVideoSourceModeResponse()
        {
          Reboot = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns10__SetVideoSourceModeResponse() { }
        /// Friend allocator used by soap_new__ns10__SetVideoSourceModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__SetVideoSourceModeResponse * SOAP_FMAC2 soap_instantiate__ns10__SetVideoSourceModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3268 */
#ifndef SOAP_TYPE__ns10__GetOSDs
#define SOAP_TYPE__ns10__GetOSDs (1240)
/* complex XSD type 'ns10:GetOSDs': */
class SOAP_CMAC _ns10__GetOSDs {
      public:
        /// Optional element 'ns10:OSDToken' of XSD type 'ns2:ReferenceToken'
        std::string *OSDToken;
        /// Optional element 'ns10:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string *ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetOSDs
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetOSDs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetOSDs, default initialized and not managed by a soap context
        virtual _ns10__GetOSDs *soap_alloc(void) const { return SOAP_NEW(_ns10__GetOSDs); }
      public:
        /// Constructor with initializations
        _ns10__GetOSDs()
        {
          OSDToken = (std::string *)0;
          ConfigurationToken = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetOSDs() { }
        /// Friend allocator used by soap_new__ns10__GetOSDs(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetOSDs * SOAP_FMAC2 soap_instantiate__ns10__GetOSDs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3271 */
#ifndef SOAP_TYPE__ns10__GetOSDsResponse
#define SOAP_TYPE__ns10__GetOSDsResponse (1241)
/* complex XSD type 'ns10:GetOSDsResponse': */
class SOAP_CMAC _ns10__GetOSDsResponse {
      public:
        /// Optional element 'ns10:OSDs' of XSD type 'ns2:OSDConfiguration'
        std::vector<ns2__OSDConfiguration *> OSDs;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetOSDsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetOSDsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetOSDsResponse, default initialized and not managed by a soap context
        virtual _ns10__GetOSDsResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__GetOSDsResponse); }
      public:
        /// Constructor with initializations
        _ns10__GetOSDsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetOSDsResponse() { }
        /// Friend allocator used by soap_new__ns10__GetOSDsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetOSDsResponse * SOAP_FMAC2 soap_instantiate__ns10__GetOSDsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3274 */
#ifndef SOAP_TYPE__ns10__SetOSD
#define SOAP_TYPE__ns10__SetOSD (1242)
/* complex XSD type 'ns10:SetOSD': */
class SOAP_CMAC _ns10__SetOSD {
      public:
        /// Required element 'ns10:OSD' of XSD type 'ns2:OSDConfiguration'
        ns2__OSDConfiguration *OSD;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__SetOSD
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__SetOSD; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__SetOSD, default initialized and not managed by a soap context
        virtual _ns10__SetOSD *soap_alloc(void) const { return SOAP_NEW(_ns10__SetOSD); }
      public:
        /// Constructor with initializations
        _ns10__SetOSD()
        {
          OSD = (ns2__OSDConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns10__SetOSD() { }
        /// Friend allocator used by soap_new__ns10__SetOSD(struct soap*, int)
        friend SOAP_FMAC1 _ns10__SetOSD * SOAP_FMAC2 soap_instantiate__ns10__SetOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3277 */
#ifndef SOAP_TYPE__ns10__GetOSDOptions
#define SOAP_TYPE__ns10__GetOSDOptions (1243)
/* complex XSD type 'ns10:GetOSDOptions': */
class SOAP_CMAC _ns10__GetOSDOptions {
      public:
        /// Required element 'ns10:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetOSDOptions
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetOSDOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetOSDOptions, default initialized and not managed by a soap context
        virtual _ns10__GetOSDOptions *soap_alloc(void) const { return SOAP_NEW(_ns10__GetOSDOptions); }
      public:
        /// Constructor with initializations
        _ns10__GetOSDOptions()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetOSDOptions() { }
        /// Friend allocator used by soap_new__ns10__GetOSDOptions(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetOSDOptions * SOAP_FMAC2 soap_instantiate__ns10__GetOSDOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3280 */
#ifndef SOAP_TYPE__ns10__GetOSDOptionsResponse
#define SOAP_TYPE__ns10__GetOSDOptionsResponse (1244)
/* complex XSD type 'ns10:GetOSDOptionsResponse': */
class SOAP_CMAC _ns10__GetOSDOptionsResponse {
      public:
        /// Required element 'ns10:OSDOptions' of XSD type 'ns2:OSDConfigurationOptions'
        ns2__OSDConfigurationOptions *OSDOptions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__GetOSDOptionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__GetOSDOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__GetOSDOptionsResponse, default initialized and not managed by a soap context
        virtual _ns10__GetOSDOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__GetOSDOptionsResponse); }
      public:
        /// Constructor with initializations
        _ns10__GetOSDOptionsResponse()
        {
          OSDOptions = (ns2__OSDConfigurationOptions *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns10__GetOSDOptionsResponse() { }
        /// Friend allocator used by soap_new__ns10__GetOSDOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__GetOSDOptionsResponse * SOAP_FMAC2 soap_instantiate__ns10__GetOSDOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3283 */
#ifndef SOAP_TYPE__ns10__CreateOSD
#define SOAP_TYPE__ns10__CreateOSD (1245)
/* complex XSD type 'ns10:CreateOSD': */
class SOAP_CMAC _ns10__CreateOSD {
      public:
        /// Required element 'ns10:OSD' of XSD type 'ns2:OSDConfiguration'
        ns2__OSDConfiguration *OSD;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__CreateOSD
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__CreateOSD; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__CreateOSD, default initialized and not managed by a soap context
        virtual _ns10__CreateOSD *soap_alloc(void) const { return SOAP_NEW(_ns10__CreateOSD); }
      public:
        /// Constructor with initializations
        _ns10__CreateOSD()
        {
          OSD = (ns2__OSDConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns10__CreateOSD() { }
        /// Friend allocator used by soap_new__ns10__CreateOSD(struct soap*, int)
        friend SOAP_FMAC1 _ns10__CreateOSD * SOAP_FMAC2 soap_instantiate__ns10__CreateOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3286 */
#ifndef SOAP_TYPE__ns10__CreateOSDResponse
#define SOAP_TYPE__ns10__CreateOSDResponse (1246)
/* complex XSD type 'ns10:CreateOSDResponse': */
class SOAP_CMAC _ns10__CreateOSDResponse {
      public:
        /// Required element 'ns10:OSDToken' of XSD type 'ns2:ReferenceToken'
        std::string OSDToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__CreateOSDResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__CreateOSDResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__CreateOSDResponse, default initialized and not managed by a soap context
        virtual _ns10__CreateOSDResponse *soap_alloc(void) const { return SOAP_NEW(_ns10__CreateOSDResponse); }
      public:
        /// Constructor with initializations
        _ns10__CreateOSDResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__CreateOSDResponse() { }
        /// Friend allocator used by soap_new__ns10__CreateOSDResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns10__CreateOSDResponse * SOAP_FMAC2 soap_instantiate__ns10__CreateOSDResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3289 */
#ifndef SOAP_TYPE__ns10__DeleteOSD
#define SOAP_TYPE__ns10__DeleteOSD (1247)
/* complex XSD type 'ns10:DeleteOSD': */
class SOAP_CMAC _ns10__DeleteOSD {
      public:
        /// Required element 'ns10:OSDToken' of XSD type 'ns2:ReferenceToken'
        std::string OSDToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns10__DeleteOSD
        virtual int soap_type(void) const { return SOAP_TYPE__ns10__DeleteOSD; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns10__DeleteOSD, default initialized and not managed by a soap context
        virtual _ns10__DeleteOSD *soap_alloc(void) const { return SOAP_NEW(_ns10__DeleteOSD); }
      public:
        /// Constructor with initializations
        _ns10__DeleteOSD()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns10__DeleteOSD() { }
        /// Friend allocator used by soap_new__ns10__DeleteOSD(struct soap*, int)
        friend SOAP_FMAC1 _ns10__DeleteOSD * SOAP_FMAC2 soap_instantiate__ns10__DeleteOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3292 */
#ifndef SOAP_TYPE_ns11__Capabilities
#define SOAP_TYPE_ns11__Capabilities (1248)
/* complex XSD type 'ns11:Capabilities': */
class SOAP_CMAC ns11__Capabilities {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// optional attribute 'EFlip' of XSD type 'xsd:boolean'
        bool *EFlip;
        /// optional attribute 'Reverse' of XSD type 'xsd:boolean'
        bool *Reverse;
        /// optional attribute 'GetCompatibleConfigurations' of XSD type 'xsd:boolean'
        bool *GetCompatibleConfigurations;
        /// optional attribute 'MoveStatus' of XSD type 'xsd:boolean'
        bool *MoveStatus;
        /// optional attribute 'StatusPosition' of XSD type 'xsd:boolean'
        bool *StatusPosition;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns11__Capabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns11__Capabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns11__Capabilities, default initialized and not managed by a soap context
        virtual ns11__Capabilities *soap_alloc(void) const { return SOAP_NEW(ns11__Capabilities); }
      public:
        /// Constructor with initializations
        ns11__Capabilities()
        {
          EFlip = (bool *)0;
          Reverse = (bool *)0;
          GetCompatibleConfigurations = (bool *)0;
          MoveStatus = (bool *)0;
          StatusPosition = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns11__Capabilities() { }
        /// Friend allocator used by soap_new_ns11__Capabilities(struct soap*, int)
        friend SOAP_FMAC1 ns11__Capabilities * SOAP_FMAC2 soap_instantiate_ns11__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3295 */
#ifndef SOAP_TYPE__ns11__GetServiceCapabilities
#define SOAP_TYPE__ns11__GetServiceCapabilities (1249)
/* complex XSD type 'ns11:GetServiceCapabilities': */
class SOAP_CMAC _ns11__GetServiceCapabilities {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GetServiceCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GetServiceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GetServiceCapabilities, default initialized and not managed by a soap context
        virtual _ns11__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_ns11__GetServiceCapabilities); }
      public:
        /// Constructor with initializations
        _ns11__GetServiceCapabilities()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GetServiceCapabilities() { }
        /// Friend allocator used by soap_new__ns11__GetServiceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__ns11__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3298 */
#ifndef SOAP_TYPE__ns11__GetServiceCapabilitiesResponse
#define SOAP_TYPE__ns11__GetServiceCapabilitiesResponse (1250)
/* complex XSD type 'ns11:GetServiceCapabilitiesResponse': */
class SOAP_CMAC _ns11__GetServiceCapabilitiesResponse {
      public:
        /// Required element 'ns11:Capabilities' of XSD type 'ns11:Capabilities'
        ns11__Capabilities *Capabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GetServiceCapabilitiesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GetServiceCapabilitiesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
        virtual _ns11__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__GetServiceCapabilitiesResponse); }
      public:
        /// Constructor with initializations
        _ns11__GetServiceCapabilitiesResponse()
        {
          Capabilities = (ns11__Capabilities *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GetServiceCapabilitiesResponse() { }
        /// Friend allocator used by soap_new__ns11__GetServiceCapabilitiesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__ns11__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3301 */
#ifndef SOAP_TYPE__ns11__GetNodes
#define SOAP_TYPE__ns11__GetNodes (1251)
/* complex XSD type 'ns11:GetNodes': */
class SOAP_CMAC _ns11__GetNodes {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GetNodes
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GetNodes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GetNodes, default initialized and not managed by a soap context
        virtual _ns11__GetNodes *soap_alloc(void) const { return SOAP_NEW(_ns11__GetNodes); }
      public:
        /// Constructor with initializations
        _ns11__GetNodes()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GetNodes() { }
        /// Friend allocator used by soap_new__ns11__GetNodes(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GetNodes * SOAP_FMAC2 soap_instantiate__ns11__GetNodes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3304 */
#ifndef SOAP_TYPE__ns11__GetNodesResponse
#define SOAP_TYPE__ns11__GetNodesResponse (1252)
/* complex XSD type 'ns11:GetNodesResponse': */
class SOAP_CMAC _ns11__GetNodesResponse {
      public:
        /// Optional element 'ns11:PTZNode' of XSD type 'ns2:PTZNode'
        std::vector<ns2__PTZNode *> PTZNode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GetNodesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GetNodesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GetNodesResponse, default initialized and not managed by a soap context
        virtual _ns11__GetNodesResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__GetNodesResponse); }
      public:
        /// Constructor with initializations
        _ns11__GetNodesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GetNodesResponse() { }
        /// Friend allocator used by soap_new__ns11__GetNodesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GetNodesResponse * SOAP_FMAC2 soap_instantiate__ns11__GetNodesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3307 */
#ifndef SOAP_TYPE__ns11__GetNode
#define SOAP_TYPE__ns11__GetNode (1253)
/* complex XSD type 'ns11:GetNode': */
class SOAP_CMAC _ns11__GetNode {
      public:
        /// Required element 'ns11:NodeToken' of XSD type 'ns2:ReferenceToken'
        std::string NodeToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GetNode
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GetNode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GetNode, default initialized and not managed by a soap context
        virtual _ns11__GetNode *soap_alloc(void) const { return SOAP_NEW(_ns11__GetNode); }
      public:
        /// Constructor with initializations
        _ns11__GetNode()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GetNode() { }
        /// Friend allocator used by soap_new__ns11__GetNode(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GetNode * SOAP_FMAC2 soap_instantiate__ns11__GetNode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3310 */
#ifndef SOAP_TYPE__ns11__GetNodeResponse
#define SOAP_TYPE__ns11__GetNodeResponse (1254)
/* complex XSD type 'ns11:GetNodeResponse': */
class SOAP_CMAC _ns11__GetNodeResponse {
      public:
        /// Required element 'ns11:PTZNode' of XSD type 'ns2:PTZNode'
        ns2__PTZNode *PTZNode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GetNodeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GetNodeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GetNodeResponse, default initialized and not managed by a soap context
        virtual _ns11__GetNodeResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__GetNodeResponse); }
      public:
        /// Constructor with initializations
        _ns11__GetNodeResponse()
        {
          PTZNode = (ns2__PTZNode *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GetNodeResponse() { }
        /// Friend allocator used by soap_new__ns11__GetNodeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GetNodeResponse * SOAP_FMAC2 soap_instantiate__ns11__GetNodeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3313 */
#ifndef SOAP_TYPE__ns11__GetConfigurations
#define SOAP_TYPE__ns11__GetConfigurations (1255)
/* complex XSD type 'ns11:GetConfigurations': */
class SOAP_CMAC _ns11__GetConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GetConfigurations
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GetConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GetConfigurations, default initialized and not managed by a soap context
        virtual _ns11__GetConfigurations *soap_alloc(void) const { return SOAP_NEW(_ns11__GetConfigurations); }
      public:
        /// Constructor with initializations
        _ns11__GetConfigurations()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GetConfigurations() { }
        /// Friend allocator used by soap_new__ns11__GetConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GetConfigurations * SOAP_FMAC2 soap_instantiate__ns11__GetConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3316 */
#ifndef SOAP_TYPE__ns11__GetConfigurationsResponse
#define SOAP_TYPE__ns11__GetConfigurationsResponse (1256)
/* complex XSD type 'ns11:GetConfigurationsResponse': */
class SOAP_CMAC _ns11__GetConfigurationsResponse {
      public:
        /// Optional element 'ns11:PTZConfiguration' of XSD type 'ns2:PTZConfiguration'
        std::vector<ns2__PTZConfiguration *> PTZConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GetConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GetConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GetConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns11__GetConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__GetConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns11__GetConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GetConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns11__GetConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GetConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns11__GetConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3319 */
#ifndef SOAP_TYPE__ns11__GetConfiguration
#define SOAP_TYPE__ns11__GetConfiguration (1257)
/* complex XSD type 'ns11:GetConfiguration': */
class SOAP_CMAC _ns11__GetConfiguration {
      public:
        /// Required element 'ns11:PTZConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string PTZConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GetConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GetConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GetConfiguration, default initialized and not managed by a soap context
        virtual _ns11__GetConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns11__GetConfiguration); }
      public:
        /// Constructor with initializations
        _ns11__GetConfiguration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GetConfiguration() { }
        /// Friend allocator used by soap_new__ns11__GetConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GetConfiguration * SOAP_FMAC2 soap_instantiate__ns11__GetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3322 */
#ifndef SOAP_TYPE__ns11__GetConfigurationResponse
#define SOAP_TYPE__ns11__GetConfigurationResponse (1258)
/* complex XSD type 'ns11:GetConfigurationResponse': */
class SOAP_CMAC _ns11__GetConfigurationResponse {
      public:
        /// Required element 'ns11:PTZConfiguration' of XSD type 'ns2:PTZConfiguration'
        ns2__PTZConfiguration *PTZConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GetConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GetConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GetConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns11__GetConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__GetConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns11__GetConfigurationResponse()
        {
          PTZConfiguration = (ns2__PTZConfiguration *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GetConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns11__GetConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GetConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns11__GetConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3325 */
#ifndef SOAP_TYPE__ns11__SetConfiguration
#define SOAP_TYPE__ns11__SetConfiguration (1259)
/* complex XSD type 'ns11:SetConfiguration': */
class SOAP_CMAC _ns11__SetConfiguration {
      public:
        /// Required element 'ns11:PTZConfiguration' of XSD type 'ns2:PTZConfiguration'
        ns2__PTZConfiguration *PTZConfiguration;
        /// Required element 'ns11:ForcePersistence' of XSD type 'xsd:boolean'
        bool ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__SetConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__SetConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__SetConfiguration, default initialized and not managed by a soap context
        virtual _ns11__SetConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns11__SetConfiguration); }
      public:
        /// Constructor with initializations
        _ns11__SetConfiguration()
        {
          PTZConfiguration = (ns2__PTZConfiguration *)0;
          ForcePersistence = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns11__SetConfiguration() { }
        /// Friend allocator used by soap_new__ns11__SetConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns11__SetConfiguration * SOAP_FMAC2 soap_instantiate__ns11__SetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:34470 */
#ifndef SOAP_TYPE___ns11__SetConfigurationResponse_sequence
#define SOAP_TYPE___ns11__SetConfigurationResponse_sequence (2137)
/* Wrapper: */
class SOAP_CMAC __ns11__SetConfigurationResponse_sequence {
      public:
        /// Return unique type id SOAP_TYPE___ns11__SetConfigurationResponse_sequence
        virtual int soap_type(void) const { return SOAP_TYPE___ns11__SetConfigurationResponse_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __ns11__SetConfigurationResponse_sequence, default initialized and not managed by a soap context
        virtual __ns11__SetConfigurationResponse_sequence *soap_alloc(void) const { return SOAP_NEW(__ns11__SetConfigurationResponse_sequence); }
      public:
        /// Constructor with initializations
        __ns11__SetConfigurationResponse_sequence()
        {
        }
        virtual ~__ns11__SetConfigurationResponse_sequence() { }
        /// Friend allocator used by soap_new___ns11__SetConfigurationResponse_sequence(struct soap*, int)
        friend SOAP_FMAC1 __ns11__SetConfigurationResponse_sequence * SOAP_FMAC2 soap_instantiate___ns11__SetConfigurationResponse_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3328 */
#ifndef SOAP_TYPE__ns11__SetConfigurationResponse
#define SOAP_TYPE__ns11__SetConfigurationResponse (1260)
/* complex XSD type 'ns11:SetConfigurationResponse': */
class SOAP_CMAC _ns11__SetConfigurationResponse {
      public:
        __ns11__SetConfigurationResponse_sequence *__SetConfigurationResponse_sequence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__SetConfigurationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__SetConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__SetConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns11__SetConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__SetConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns11__SetConfigurationResponse()
        {
          __SetConfigurationResponse_sequence = (__ns11__SetConfigurationResponse_sequence *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns11__SetConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns11__SetConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__SetConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns11__SetConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3331 */
#ifndef SOAP_TYPE__ns11__GetConfigurationOptions
#define SOAP_TYPE__ns11__GetConfigurationOptions (1261)
/* complex XSD type 'ns11:GetConfigurationOptions': */
class SOAP_CMAC _ns11__GetConfigurationOptions {
      public:
        /// Required element 'ns11:ConfigurationToken' of XSD type 'ns2:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GetConfigurationOptions
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GetConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GetConfigurationOptions, default initialized and not managed by a soap context
        virtual _ns11__GetConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_ns11__GetConfigurationOptions); }
      public:
        /// Constructor with initializations
        _ns11__GetConfigurationOptions()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GetConfigurationOptions() { }
        /// Friend allocator used by soap_new__ns11__GetConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GetConfigurationOptions * SOAP_FMAC2 soap_instantiate__ns11__GetConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3334 */
#ifndef SOAP_TYPE__ns11__GetConfigurationOptionsResponse
#define SOAP_TYPE__ns11__GetConfigurationOptionsResponse (1262)
/* complex XSD type 'ns11:GetConfigurationOptionsResponse': */
class SOAP_CMAC _ns11__GetConfigurationOptionsResponse {
      public:
        /// Required element 'ns11:PTZConfigurationOptions' of XSD type 'ns2:PTZConfigurationOptions'
        ns2__PTZConfigurationOptions *PTZConfigurationOptions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GetConfigurationOptionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GetConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GetConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _ns11__GetConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__GetConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _ns11__GetConfigurationOptionsResponse()
        {
          PTZConfigurationOptions = (ns2__PTZConfigurationOptions *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GetConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__ns11__GetConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GetConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__ns11__GetConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3337 */
#ifndef SOAP_TYPE__ns11__SendAuxiliaryCommand
#define SOAP_TYPE__ns11__SendAuxiliaryCommand (1263)
/* complex XSD type 'ns11:SendAuxiliaryCommand': */
class SOAP_CMAC _ns11__SendAuxiliaryCommand {
      public:
        /// Required element 'ns11:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'ns11:AuxiliaryData' of XSD type 'ns2:AuxiliaryData'
        std::string AuxiliaryData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__SendAuxiliaryCommand
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__SendAuxiliaryCommand; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__SendAuxiliaryCommand, default initialized and not managed by a soap context
        virtual _ns11__SendAuxiliaryCommand *soap_alloc(void) const { return SOAP_NEW(_ns11__SendAuxiliaryCommand); }
      public:
        /// Constructor with initializations
        _ns11__SendAuxiliaryCommand()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__SendAuxiliaryCommand() { }
        /// Friend allocator used by soap_new__ns11__SendAuxiliaryCommand(struct soap*, int)
        friend SOAP_FMAC1 _ns11__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate__ns11__SendAuxiliaryCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3340 */
#ifndef SOAP_TYPE__ns11__SendAuxiliaryCommandResponse
#define SOAP_TYPE__ns11__SendAuxiliaryCommandResponse (1264)
/* complex XSD type 'ns11:SendAuxiliaryCommandResponse': */
class SOAP_CMAC _ns11__SendAuxiliaryCommandResponse {
      public:
        /// Required element 'ns11:AuxiliaryResponse' of XSD type 'ns2:AuxiliaryData'
        std::string AuxiliaryResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__SendAuxiliaryCommandResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__SendAuxiliaryCommandResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__SendAuxiliaryCommandResponse, default initialized and not managed by a soap context
        virtual _ns11__SendAuxiliaryCommandResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__SendAuxiliaryCommandResponse); }
      public:
        /// Constructor with initializations
        _ns11__SendAuxiliaryCommandResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__SendAuxiliaryCommandResponse() { }
        /// Friend allocator used by soap_new__ns11__SendAuxiliaryCommandResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__SendAuxiliaryCommandResponse * SOAP_FMAC2 soap_instantiate__ns11__SendAuxiliaryCommandResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3343 */
#ifndef SOAP_TYPE__ns11__GetPresets
#define SOAP_TYPE__ns11__GetPresets (1265)
/* complex XSD type 'ns11:GetPresets': */
class SOAP_CMAC _ns11__GetPresets {
      public:
        /// Required element 'ns11:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GetPresets
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GetPresets; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GetPresets, default initialized and not managed by a soap context
        virtual _ns11__GetPresets *soap_alloc(void) const { return SOAP_NEW(_ns11__GetPresets); }
      public:
        /// Constructor with initializations
        _ns11__GetPresets()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GetPresets() { }
        /// Friend allocator used by soap_new__ns11__GetPresets(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GetPresets * SOAP_FMAC2 soap_instantiate__ns11__GetPresets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3346 */
#ifndef SOAP_TYPE__ns11__GetPresetsResponse
#define SOAP_TYPE__ns11__GetPresetsResponse (1266)
/* complex XSD type 'ns11:GetPresetsResponse': */
class SOAP_CMAC _ns11__GetPresetsResponse {
      public:
        /// Optional element 'ns11:Preset' of XSD type 'ns2:PTZPreset'
        std::vector<ns2__PTZPreset *> Preset;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GetPresetsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GetPresetsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GetPresetsResponse, default initialized and not managed by a soap context
        virtual _ns11__GetPresetsResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__GetPresetsResponse); }
      public:
        /// Constructor with initializations
        _ns11__GetPresetsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GetPresetsResponse() { }
        /// Friend allocator used by soap_new__ns11__GetPresetsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GetPresetsResponse * SOAP_FMAC2 soap_instantiate__ns11__GetPresetsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3349 */
#ifndef SOAP_TYPE__ns11__SetPreset
#define SOAP_TYPE__ns11__SetPreset (1267)
/* complex XSD type 'ns11:SetPreset': */
class SOAP_CMAC _ns11__SetPreset {
      public:
        /// Required element 'ns11:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Optional element 'ns11:PresetName' of XSD type 'xsd:string'
        std::string *PresetName;
        /// Optional element 'ns11:PresetToken' of XSD type 'ns2:ReferenceToken'
        std::string *PresetToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__SetPreset
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__SetPreset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__SetPreset, default initialized and not managed by a soap context
        virtual _ns11__SetPreset *soap_alloc(void) const { return SOAP_NEW(_ns11__SetPreset); }
      public:
        /// Constructor with initializations
        _ns11__SetPreset()
        {
          PresetName = (std::string *)0;
          PresetToken = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns11__SetPreset() { }
        /// Friend allocator used by soap_new__ns11__SetPreset(struct soap*, int)
        friend SOAP_FMAC1 _ns11__SetPreset * SOAP_FMAC2 soap_instantiate__ns11__SetPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3352 */
#ifndef SOAP_TYPE__ns11__SetPresetResponse
#define SOAP_TYPE__ns11__SetPresetResponse (1268)
/* complex XSD type 'ns11:SetPresetResponse': */
class SOAP_CMAC _ns11__SetPresetResponse {
      public:
        /// Required element 'ns11:PresetToken' of XSD type 'ns2:ReferenceToken'
        std::string PresetToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__SetPresetResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__SetPresetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__SetPresetResponse, default initialized and not managed by a soap context
        virtual _ns11__SetPresetResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__SetPresetResponse); }
      public:
        /// Constructor with initializations
        _ns11__SetPresetResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__SetPresetResponse() { }
        /// Friend allocator used by soap_new__ns11__SetPresetResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__SetPresetResponse * SOAP_FMAC2 soap_instantiate__ns11__SetPresetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3355 */
#ifndef SOAP_TYPE__ns11__RemovePreset
#define SOAP_TYPE__ns11__RemovePreset (1269)
/* complex XSD type 'ns11:RemovePreset': */
class SOAP_CMAC _ns11__RemovePreset {
      public:
        /// Required element 'ns11:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'ns11:PresetToken' of XSD type 'ns2:ReferenceToken'
        std::string PresetToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__RemovePreset
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__RemovePreset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__RemovePreset, default initialized and not managed by a soap context
        virtual _ns11__RemovePreset *soap_alloc(void) const { return SOAP_NEW(_ns11__RemovePreset); }
      public:
        /// Constructor with initializations
        _ns11__RemovePreset()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__RemovePreset() { }
        /// Friend allocator used by soap_new__ns11__RemovePreset(struct soap*, int)
        friend SOAP_FMAC1 _ns11__RemovePreset * SOAP_FMAC2 soap_instantiate__ns11__RemovePreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3358 */
#ifndef SOAP_TYPE__ns11__RemovePresetResponse
#define SOAP_TYPE__ns11__RemovePresetResponse (1270)
/* complex XSD type 'ns11:RemovePresetResponse': */
class SOAP_CMAC _ns11__RemovePresetResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__RemovePresetResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__RemovePresetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__RemovePresetResponse, default initialized and not managed by a soap context
        virtual _ns11__RemovePresetResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__RemovePresetResponse); }
      public:
        /// Constructor with initializations
        _ns11__RemovePresetResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__RemovePresetResponse() { }
        /// Friend allocator used by soap_new__ns11__RemovePresetResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__RemovePresetResponse * SOAP_FMAC2 soap_instantiate__ns11__RemovePresetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3361 */
#ifndef SOAP_TYPE__ns11__GotoPreset
#define SOAP_TYPE__ns11__GotoPreset (1271)
/* complex XSD type 'ns11:GotoPreset': */
class SOAP_CMAC _ns11__GotoPreset {
      public:
        /// Required element 'ns11:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'ns11:PresetToken' of XSD type 'ns2:ReferenceToken'
        std::string PresetToken;
        /// Optional element 'ns11:Speed' of XSD type 'ns2:PTZSpeed'
        ns2__PTZSpeed *Speed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GotoPreset
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GotoPreset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GotoPreset, default initialized and not managed by a soap context
        virtual _ns11__GotoPreset *soap_alloc(void) const { return SOAP_NEW(_ns11__GotoPreset); }
      public:
        /// Constructor with initializations
        _ns11__GotoPreset()
        {
          Speed = (ns2__PTZSpeed *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GotoPreset() { }
        /// Friend allocator used by soap_new__ns11__GotoPreset(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GotoPreset * SOAP_FMAC2 soap_instantiate__ns11__GotoPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3364 */
#ifndef SOAP_TYPE__ns11__GotoPresetResponse
#define SOAP_TYPE__ns11__GotoPresetResponse (1272)
/* complex XSD type 'ns11:GotoPresetResponse': */
class SOAP_CMAC _ns11__GotoPresetResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GotoPresetResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GotoPresetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GotoPresetResponse, default initialized and not managed by a soap context
        virtual _ns11__GotoPresetResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__GotoPresetResponse); }
      public:
        /// Constructor with initializations
        _ns11__GotoPresetResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GotoPresetResponse() { }
        /// Friend allocator used by soap_new__ns11__GotoPresetResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GotoPresetResponse * SOAP_FMAC2 soap_instantiate__ns11__GotoPresetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3367 */
#ifndef SOAP_TYPE__ns11__GetStatus
#define SOAP_TYPE__ns11__GetStatus (1273)
/* complex XSD type 'ns11:GetStatus': */
class SOAP_CMAC _ns11__GetStatus {
      public:
        /// Required element 'ns11:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GetStatus
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GetStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GetStatus, default initialized and not managed by a soap context
        virtual _ns11__GetStatus *soap_alloc(void) const { return SOAP_NEW(_ns11__GetStatus); }
      public:
        /// Constructor with initializations
        _ns11__GetStatus()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GetStatus() { }
        /// Friend allocator used by soap_new__ns11__GetStatus(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GetStatus * SOAP_FMAC2 soap_instantiate__ns11__GetStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3370 */
#ifndef SOAP_TYPE__ns11__GetStatusResponse
#define SOAP_TYPE__ns11__GetStatusResponse (1274)
/* complex XSD type 'ns11:GetStatusResponse': */
class SOAP_CMAC _ns11__GetStatusResponse {
      public:
        /// Required element 'ns11:PTZStatus' of XSD type 'ns2:PTZStatus'
        ns2__PTZStatus *PTZStatus;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GetStatusResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GetStatusResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GetStatusResponse, default initialized and not managed by a soap context
        virtual _ns11__GetStatusResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__GetStatusResponse); }
      public:
        /// Constructor with initializations
        _ns11__GetStatusResponse()
        {
          PTZStatus = (ns2__PTZStatus *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GetStatusResponse() { }
        /// Friend allocator used by soap_new__ns11__GetStatusResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GetStatusResponse * SOAP_FMAC2 soap_instantiate__ns11__GetStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3373 */
#ifndef SOAP_TYPE__ns11__GotoHomePosition
#define SOAP_TYPE__ns11__GotoHomePosition (1275)
/* complex XSD type 'ns11:GotoHomePosition': */
class SOAP_CMAC _ns11__GotoHomePosition {
      public:
        /// Required element 'ns11:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Optional element 'ns11:Speed' of XSD type 'ns2:PTZSpeed'
        ns2__PTZSpeed *Speed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GotoHomePosition
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GotoHomePosition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GotoHomePosition, default initialized and not managed by a soap context
        virtual _ns11__GotoHomePosition *soap_alloc(void) const { return SOAP_NEW(_ns11__GotoHomePosition); }
      public:
        /// Constructor with initializations
        _ns11__GotoHomePosition()
        {
          Speed = (ns2__PTZSpeed *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GotoHomePosition() { }
        /// Friend allocator used by soap_new__ns11__GotoHomePosition(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GotoHomePosition * SOAP_FMAC2 soap_instantiate__ns11__GotoHomePosition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3376 */
#ifndef SOAP_TYPE__ns11__GotoHomePositionResponse
#define SOAP_TYPE__ns11__GotoHomePositionResponse (1276)
/* complex XSD type 'ns11:GotoHomePositionResponse': */
class SOAP_CMAC _ns11__GotoHomePositionResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GotoHomePositionResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GotoHomePositionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GotoHomePositionResponse, default initialized and not managed by a soap context
        virtual _ns11__GotoHomePositionResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__GotoHomePositionResponse); }
      public:
        /// Constructor with initializations
        _ns11__GotoHomePositionResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GotoHomePositionResponse() { }
        /// Friend allocator used by soap_new__ns11__GotoHomePositionResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GotoHomePositionResponse * SOAP_FMAC2 soap_instantiate__ns11__GotoHomePositionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3379 */
#ifndef SOAP_TYPE__ns11__SetHomePosition
#define SOAP_TYPE__ns11__SetHomePosition (1277)
/* complex XSD type 'ns11:SetHomePosition': */
class SOAP_CMAC _ns11__SetHomePosition {
      public:
        /// Required element 'ns11:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__SetHomePosition
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__SetHomePosition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__SetHomePosition, default initialized and not managed by a soap context
        virtual _ns11__SetHomePosition *soap_alloc(void) const { return SOAP_NEW(_ns11__SetHomePosition); }
      public:
        /// Constructor with initializations
        _ns11__SetHomePosition()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__SetHomePosition() { }
        /// Friend allocator used by soap_new__ns11__SetHomePosition(struct soap*, int)
        friend SOAP_FMAC1 _ns11__SetHomePosition * SOAP_FMAC2 soap_instantiate__ns11__SetHomePosition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3382 */
#ifndef SOAP_TYPE__ns11__SetHomePositionResponse
#define SOAP_TYPE__ns11__SetHomePositionResponse (1278)
/* complex XSD type 'ns11:SetHomePositionResponse': */
class SOAP_CMAC _ns11__SetHomePositionResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__SetHomePositionResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__SetHomePositionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__SetHomePositionResponse, default initialized and not managed by a soap context
        virtual _ns11__SetHomePositionResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__SetHomePositionResponse); }
      public:
        /// Constructor with initializations
        _ns11__SetHomePositionResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__SetHomePositionResponse() { }
        /// Friend allocator used by soap_new__ns11__SetHomePositionResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__SetHomePositionResponse * SOAP_FMAC2 soap_instantiate__ns11__SetHomePositionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3385 */
#ifndef SOAP_TYPE__ns11__ContinuousMove
#define SOAP_TYPE__ns11__ContinuousMove (1279)
/* complex XSD type 'ns11:ContinuousMove': */
class SOAP_CMAC _ns11__ContinuousMove {
      public:
        /// Required element 'ns11:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'ns11:Velocity' of XSD type 'ns2:PTZSpeed'
        ns2__PTZSpeed *Velocity;
        /// Optional element 'ns11:Timeout' of XSD type 'xsd:duration'
        std::string *Timeout;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__ContinuousMove
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__ContinuousMove; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__ContinuousMove, default initialized and not managed by a soap context
        virtual _ns11__ContinuousMove *soap_alloc(void) const { return SOAP_NEW(_ns11__ContinuousMove); }
      public:
        /// Constructor with initializations
        _ns11__ContinuousMove()
        {
          Velocity = (ns2__PTZSpeed *)0;
          Timeout = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns11__ContinuousMove() { }
        /// Friend allocator used by soap_new__ns11__ContinuousMove(struct soap*, int)
        friend SOAP_FMAC1 _ns11__ContinuousMove * SOAP_FMAC2 soap_instantiate__ns11__ContinuousMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3388 */
#ifndef SOAP_TYPE__ns11__ContinuousMoveResponse
#define SOAP_TYPE__ns11__ContinuousMoveResponse (1280)
/* complex XSD type 'ns11:ContinuousMoveResponse': */
class SOAP_CMAC _ns11__ContinuousMoveResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__ContinuousMoveResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__ContinuousMoveResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__ContinuousMoveResponse, default initialized and not managed by a soap context
        virtual _ns11__ContinuousMoveResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__ContinuousMoveResponse); }
      public:
        /// Constructor with initializations
        _ns11__ContinuousMoveResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__ContinuousMoveResponse() { }
        /// Friend allocator used by soap_new__ns11__ContinuousMoveResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__ContinuousMoveResponse * SOAP_FMAC2 soap_instantiate__ns11__ContinuousMoveResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3391 */
#ifndef SOAP_TYPE__ns11__RelativeMove
#define SOAP_TYPE__ns11__RelativeMove (1281)
/* complex XSD type 'ns11:RelativeMove': */
class SOAP_CMAC _ns11__RelativeMove {
      public:
        /// Required element 'ns11:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'ns11:Translation' of XSD type 'ns2:PTZVector'
        ns2__PTZVector *Translation;
        /// Optional element 'ns11:Speed' of XSD type 'ns2:PTZSpeed'
        ns2__PTZSpeed *Speed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__RelativeMove
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__RelativeMove; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__RelativeMove, default initialized and not managed by a soap context
        virtual _ns11__RelativeMove *soap_alloc(void) const { return SOAP_NEW(_ns11__RelativeMove); }
      public:
        /// Constructor with initializations
        _ns11__RelativeMove()
        {
          Translation = (ns2__PTZVector *)0;
          Speed = (ns2__PTZSpeed *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns11__RelativeMove() { }
        /// Friend allocator used by soap_new__ns11__RelativeMove(struct soap*, int)
        friend SOAP_FMAC1 _ns11__RelativeMove * SOAP_FMAC2 soap_instantiate__ns11__RelativeMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3394 */
#ifndef SOAP_TYPE__ns11__RelativeMoveResponse
#define SOAP_TYPE__ns11__RelativeMoveResponse (1282)
/* complex XSD type 'ns11:RelativeMoveResponse': */
class SOAP_CMAC _ns11__RelativeMoveResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__RelativeMoveResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__RelativeMoveResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__RelativeMoveResponse, default initialized and not managed by a soap context
        virtual _ns11__RelativeMoveResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__RelativeMoveResponse); }
      public:
        /// Constructor with initializations
        _ns11__RelativeMoveResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__RelativeMoveResponse() { }
        /// Friend allocator used by soap_new__ns11__RelativeMoveResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__RelativeMoveResponse * SOAP_FMAC2 soap_instantiate__ns11__RelativeMoveResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3397 */
#ifndef SOAP_TYPE__ns11__AbsoluteMove
#define SOAP_TYPE__ns11__AbsoluteMove (1283)
/* complex XSD type 'ns11:AbsoluteMove': */
class SOAP_CMAC _ns11__AbsoluteMove {
      public:
        /// Required element 'ns11:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'ns11:Position' of XSD type 'ns2:PTZVector'
        ns2__PTZVector *Position;
        /// Optional element 'ns11:Speed' of XSD type 'ns2:PTZSpeed'
        ns2__PTZSpeed *Speed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__AbsoluteMove
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__AbsoluteMove; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__AbsoluteMove, default initialized and not managed by a soap context
        virtual _ns11__AbsoluteMove *soap_alloc(void) const { return SOAP_NEW(_ns11__AbsoluteMove); }
      public:
        /// Constructor with initializations
        _ns11__AbsoluteMove()
        {
          Position = (ns2__PTZVector *)0;
          Speed = (ns2__PTZSpeed *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns11__AbsoluteMove() { }
        /// Friend allocator used by soap_new__ns11__AbsoluteMove(struct soap*, int)
        friend SOAP_FMAC1 _ns11__AbsoluteMove * SOAP_FMAC2 soap_instantiate__ns11__AbsoluteMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3400 */
#ifndef SOAP_TYPE__ns11__AbsoluteMoveResponse
#define SOAP_TYPE__ns11__AbsoluteMoveResponse (1284)
/* complex XSD type 'ns11:AbsoluteMoveResponse': */
class SOAP_CMAC _ns11__AbsoluteMoveResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__AbsoluteMoveResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__AbsoluteMoveResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__AbsoluteMoveResponse, default initialized and not managed by a soap context
        virtual _ns11__AbsoluteMoveResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__AbsoluteMoveResponse); }
      public:
        /// Constructor with initializations
        _ns11__AbsoluteMoveResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__AbsoluteMoveResponse() { }
        /// Friend allocator used by soap_new__ns11__AbsoluteMoveResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__AbsoluteMoveResponse * SOAP_FMAC2 soap_instantiate__ns11__AbsoluteMoveResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3403 */
#ifndef SOAP_TYPE__ns11__Stop
#define SOAP_TYPE__ns11__Stop (1285)
/* complex XSD type 'ns11:Stop': */
class SOAP_CMAC _ns11__Stop {
      public:
        /// Required element 'ns11:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Optional element 'ns11:PanTilt' of XSD type 'xsd:boolean'
        bool *PanTilt;
        /// Optional element 'ns11:Zoom' of XSD type 'xsd:boolean'
        bool *Zoom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__Stop
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__Stop; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__Stop, default initialized and not managed by a soap context
        virtual _ns11__Stop *soap_alloc(void) const { return SOAP_NEW(_ns11__Stop); }
      public:
        /// Constructor with initializations
        _ns11__Stop()
        {
          PanTilt = (bool *)0;
          Zoom = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns11__Stop() { }
        /// Friend allocator used by soap_new__ns11__Stop(struct soap*, int)
        friend SOAP_FMAC1 _ns11__Stop * SOAP_FMAC2 soap_instantiate__ns11__Stop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3406 */
#ifndef SOAP_TYPE__ns11__StopResponse
#define SOAP_TYPE__ns11__StopResponse (1286)
/* complex XSD type 'ns11:StopResponse': */
class SOAP_CMAC _ns11__StopResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__StopResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__StopResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__StopResponse, default initialized and not managed by a soap context
        virtual _ns11__StopResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__StopResponse); }
      public:
        /// Constructor with initializations
        _ns11__StopResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__StopResponse() { }
        /// Friend allocator used by soap_new__ns11__StopResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__StopResponse * SOAP_FMAC2 soap_instantiate__ns11__StopResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3409 */
#ifndef SOAP_TYPE__ns11__GetPresetTours
#define SOAP_TYPE__ns11__GetPresetTours (1287)
/* complex XSD type 'ns11:GetPresetTours': */
class SOAP_CMAC _ns11__GetPresetTours {
      public:
        /// Required element 'ns11:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GetPresetTours
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GetPresetTours; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GetPresetTours, default initialized and not managed by a soap context
        virtual _ns11__GetPresetTours *soap_alloc(void) const { return SOAP_NEW(_ns11__GetPresetTours); }
      public:
        /// Constructor with initializations
        _ns11__GetPresetTours()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GetPresetTours() { }
        /// Friend allocator used by soap_new__ns11__GetPresetTours(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GetPresetTours * SOAP_FMAC2 soap_instantiate__ns11__GetPresetTours(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3412 */
#ifndef SOAP_TYPE__ns11__GetPresetToursResponse
#define SOAP_TYPE__ns11__GetPresetToursResponse (1288)
/* complex XSD type 'ns11:GetPresetToursResponse': */
class SOAP_CMAC _ns11__GetPresetToursResponse {
      public:
        /// Optional element 'ns11:PresetTour' of XSD type 'ns2:PresetTour'
        std::vector<ns2__PresetTour *> PresetTour;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GetPresetToursResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GetPresetToursResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GetPresetToursResponse, default initialized and not managed by a soap context
        virtual _ns11__GetPresetToursResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__GetPresetToursResponse); }
      public:
        /// Constructor with initializations
        _ns11__GetPresetToursResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GetPresetToursResponse() { }
        /// Friend allocator used by soap_new__ns11__GetPresetToursResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GetPresetToursResponse * SOAP_FMAC2 soap_instantiate__ns11__GetPresetToursResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3415 */
#ifndef SOAP_TYPE__ns11__GetPresetTour
#define SOAP_TYPE__ns11__GetPresetTour (1289)
/* complex XSD type 'ns11:GetPresetTour': */
class SOAP_CMAC _ns11__GetPresetTour {
      public:
        /// Required element 'ns11:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'ns11:PresetTourToken' of XSD type 'ns2:ReferenceToken'
        std::string PresetTourToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GetPresetTour
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GetPresetTour; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GetPresetTour, default initialized and not managed by a soap context
        virtual _ns11__GetPresetTour *soap_alloc(void) const { return SOAP_NEW(_ns11__GetPresetTour); }
      public:
        /// Constructor with initializations
        _ns11__GetPresetTour()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GetPresetTour() { }
        /// Friend allocator used by soap_new__ns11__GetPresetTour(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GetPresetTour * SOAP_FMAC2 soap_instantiate__ns11__GetPresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3418 */
#ifndef SOAP_TYPE__ns11__GetPresetTourResponse
#define SOAP_TYPE__ns11__GetPresetTourResponse (1290)
/* complex XSD type 'ns11:GetPresetTourResponse': */
class SOAP_CMAC _ns11__GetPresetTourResponse {
      public:
        /// Required element 'ns11:PresetTour' of XSD type 'ns2:PresetTour'
        ns2__PresetTour *PresetTour;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GetPresetTourResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GetPresetTourResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GetPresetTourResponse, default initialized and not managed by a soap context
        virtual _ns11__GetPresetTourResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__GetPresetTourResponse); }
      public:
        /// Constructor with initializations
        _ns11__GetPresetTourResponse()
        {
          PresetTour = (ns2__PresetTour *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GetPresetTourResponse() { }
        /// Friend allocator used by soap_new__ns11__GetPresetTourResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GetPresetTourResponse * SOAP_FMAC2 soap_instantiate__ns11__GetPresetTourResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3421 */
#ifndef SOAP_TYPE__ns11__GetPresetTourOptions
#define SOAP_TYPE__ns11__GetPresetTourOptions (1291)
/* complex XSD type 'ns11:GetPresetTourOptions': */
class SOAP_CMAC _ns11__GetPresetTourOptions {
      public:
        /// Required element 'ns11:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Optional element 'ns11:PresetTourToken' of XSD type 'ns2:ReferenceToken'
        std::string *PresetTourToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GetPresetTourOptions
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GetPresetTourOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GetPresetTourOptions, default initialized and not managed by a soap context
        virtual _ns11__GetPresetTourOptions *soap_alloc(void) const { return SOAP_NEW(_ns11__GetPresetTourOptions); }
      public:
        /// Constructor with initializations
        _ns11__GetPresetTourOptions()
        {
          PresetTourToken = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GetPresetTourOptions() { }
        /// Friend allocator used by soap_new__ns11__GetPresetTourOptions(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GetPresetTourOptions * SOAP_FMAC2 soap_instantiate__ns11__GetPresetTourOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3424 */
#ifndef SOAP_TYPE__ns11__GetPresetTourOptionsResponse
#define SOAP_TYPE__ns11__GetPresetTourOptionsResponse (1292)
/* complex XSD type 'ns11:GetPresetTourOptionsResponse': */
class SOAP_CMAC _ns11__GetPresetTourOptionsResponse {
      public:
        /// Required element 'ns11:Options' of XSD type 'ns2:PTZPresetTourOptions'
        ns2__PTZPresetTourOptions *Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GetPresetTourOptionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GetPresetTourOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GetPresetTourOptionsResponse, default initialized and not managed by a soap context
        virtual _ns11__GetPresetTourOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__GetPresetTourOptionsResponse); }
      public:
        /// Constructor with initializations
        _ns11__GetPresetTourOptionsResponse()
        {
          Options = (ns2__PTZPresetTourOptions *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GetPresetTourOptionsResponse() { }
        /// Friend allocator used by soap_new__ns11__GetPresetTourOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GetPresetTourOptionsResponse * SOAP_FMAC2 soap_instantiate__ns11__GetPresetTourOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3427 */
#ifndef SOAP_TYPE__ns11__CreatePresetTour
#define SOAP_TYPE__ns11__CreatePresetTour (1293)
/* complex XSD type 'ns11:CreatePresetTour': */
class SOAP_CMAC _ns11__CreatePresetTour {
      public:
        /// Required element 'ns11:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__CreatePresetTour
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__CreatePresetTour; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__CreatePresetTour, default initialized and not managed by a soap context
        virtual _ns11__CreatePresetTour *soap_alloc(void) const { return SOAP_NEW(_ns11__CreatePresetTour); }
      public:
        /// Constructor with initializations
        _ns11__CreatePresetTour()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__CreatePresetTour() { }
        /// Friend allocator used by soap_new__ns11__CreatePresetTour(struct soap*, int)
        friend SOAP_FMAC1 _ns11__CreatePresetTour * SOAP_FMAC2 soap_instantiate__ns11__CreatePresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3430 */
#ifndef SOAP_TYPE__ns11__CreatePresetTourResponse
#define SOAP_TYPE__ns11__CreatePresetTourResponse (1294)
/* complex XSD type 'ns11:CreatePresetTourResponse': */
class SOAP_CMAC _ns11__CreatePresetTourResponse {
      public:
        /// Required element 'ns11:PresetTourToken' of XSD type 'ns2:ReferenceToken'
        std::string PresetTourToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__CreatePresetTourResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__CreatePresetTourResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__CreatePresetTourResponse, default initialized and not managed by a soap context
        virtual _ns11__CreatePresetTourResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__CreatePresetTourResponse); }
      public:
        /// Constructor with initializations
        _ns11__CreatePresetTourResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__CreatePresetTourResponse() { }
        /// Friend allocator used by soap_new__ns11__CreatePresetTourResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__CreatePresetTourResponse * SOAP_FMAC2 soap_instantiate__ns11__CreatePresetTourResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3433 */
#ifndef SOAP_TYPE__ns11__ModifyPresetTour
#define SOAP_TYPE__ns11__ModifyPresetTour (1295)
/* complex XSD type 'ns11:ModifyPresetTour': */
class SOAP_CMAC _ns11__ModifyPresetTour {
      public:
        /// Required element 'ns11:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'ns11:PresetTour' of XSD type 'ns2:PresetTour'
        ns2__PresetTour *PresetTour;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__ModifyPresetTour
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__ModifyPresetTour; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__ModifyPresetTour, default initialized and not managed by a soap context
        virtual _ns11__ModifyPresetTour *soap_alloc(void) const { return SOAP_NEW(_ns11__ModifyPresetTour); }
      public:
        /// Constructor with initializations
        _ns11__ModifyPresetTour()
        {
          PresetTour = (ns2__PresetTour *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns11__ModifyPresetTour() { }
        /// Friend allocator used by soap_new__ns11__ModifyPresetTour(struct soap*, int)
        friend SOAP_FMAC1 _ns11__ModifyPresetTour * SOAP_FMAC2 soap_instantiate__ns11__ModifyPresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3436 */
#ifndef SOAP_TYPE__ns11__ModifyPresetTourResponse
#define SOAP_TYPE__ns11__ModifyPresetTourResponse (1296)
/* complex XSD type 'ns11:ModifyPresetTourResponse': */
class SOAP_CMAC _ns11__ModifyPresetTourResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__ModifyPresetTourResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__ModifyPresetTourResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__ModifyPresetTourResponse, default initialized and not managed by a soap context
        virtual _ns11__ModifyPresetTourResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__ModifyPresetTourResponse); }
      public:
        /// Constructor with initializations
        _ns11__ModifyPresetTourResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__ModifyPresetTourResponse() { }
        /// Friend allocator used by soap_new__ns11__ModifyPresetTourResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__ModifyPresetTourResponse * SOAP_FMAC2 soap_instantiate__ns11__ModifyPresetTourResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3439 */
#ifndef SOAP_TYPE__ns11__OperatePresetTour
#define SOAP_TYPE__ns11__OperatePresetTour (1297)
/* complex XSD type 'ns11:OperatePresetTour': */
class SOAP_CMAC _ns11__OperatePresetTour {
      public:
        /// Required element 'ns11:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'ns11:PresetTourToken' of XSD type 'ns2:ReferenceToken'
        std::string PresetTourToken;
        /// Required element 'ns11:Operation' of XSD type 'ns2:PTZPresetTourOperation'
        ns2__PTZPresetTourOperation Operation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__OperatePresetTour
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__OperatePresetTour; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__OperatePresetTour, default initialized and not managed by a soap context
        virtual _ns11__OperatePresetTour *soap_alloc(void) const { return SOAP_NEW(_ns11__OperatePresetTour); }
      public:
        /// Constructor with initializations
        _ns11__OperatePresetTour()
        {
          Operation = (ns2__PTZPresetTourOperation)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns11__OperatePresetTour() { }
        /// Friend allocator used by soap_new__ns11__OperatePresetTour(struct soap*, int)
        friend SOAP_FMAC1 _ns11__OperatePresetTour * SOAP_FMAC2 soap_instantiate__ns11__OperatePresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3442 */
#ifndef SOAP_TYPE__ns11__OperatePresetTourResponse
#define SOAP_TYPE__ns11__OperatePresetTourResponse (1298)
/* complex XSD type 'ns11:OperatePresetTourResponse': */
class SOAP_CMAC _ns11__OperatePresetTourResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__OperatePresetTourResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__OperatePresetTourResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__OperatePresetTourResponse, default initialized and not managed by a soap context
        virtual _ns11__OperatePresetTourResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__OperatePresetTourResponse); }
      public:
        /// Constructor with initializations
        _ns11__OperatePresetTourResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__OperatePresetTourResponse() { }
        /// Friend allocator used by soap_new__ns11__OperatePresetTourResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__OperatePresetTourResponse * SOAP_FMAC2 soap_instantiate__ns11__OperatePresetTourResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3445 */
#ifndef SOAP_TYPE__ns11__RemovePresetTour
#define SOAP_TYPE__ns11__RemovePresetTour (1299)
/* complex XSD type 'ns11:RemovePresetTour': */
class SOAP_CMAC _ns11__RemovePresetTour {
      public:
        /// Required element 'ns11:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'ns11:PresetTourToken' of XSD type 'ns2:ReferenceToken'
        std::string PresetTourToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__RemovePresetTour
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__RemovePresetTour; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__RemovePresetTour, default initialized and not managed by a soap context
        virtual _ns11__RemovePresetTour *soap_alloc(void) const { return SOAP_NEW(_ns11__RemovePresetTour); }
      public:
        /// Constructor with initializations
        _ns11__RemovePresetTour()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__RemovePresetTour() { }
        /// Friend allocator used by soap_new__ns11__RemovePresetTour(struct soap*, int)
        friend SOAP_FMAC1 _ns11__RemovePresetTour * SOAP_FMAC2 soap_instantiate__ns11__RemovePresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3448 */
#ifndef SOAP_TYPE__ns11__RemovePresetTourResponse
#define SOAP_TYPE__ns11__RemovePresetTourResponse (1300)
/* complex XSD type 'ns11:RemovePresetTourResponse': */
class SOAP_CMAC _ns11__RemovePresetTourResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__RemovePresetTourResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__RemovePresetTourResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__RemovePresetTourResponse, default initialized and not managed by a soap context
        virtual _ns11__RemovePresetTourResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__RemovePresetTourResponse); }
      public:
        /// Constructor with initializations
        _ns11__RemovePresetTourResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__RemovePresetTourResponse() { }
        /// Friend allocator used by soap_new__ns11__RemovePresetTourResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__RemovePresetTourResponse * SOAP_FMAC2 soap_instantiate__ns11__RemovePresetTourResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3451 */
#ifndef SOAP_TYPE__ns11__GetCompatibleConfigurations
#define SOAP_TYPE__ns11__GetCompatibleConfigurations (1301)
/* complex XSD type 'ns11:GetCompatibleConfigurations': */
class SOAP_CMAC _ns11__GetCompatibleConfigurations {
      public:
        /// Required element 'ns11:ProfileToken' of XSD type 'ns2:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GetCompatibleConfigurations
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GetCompatibleConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GetCompatibleConfigurations, default initialized and not managed by a soap context
        virtual _ns11__GetCompatibleConfigurations *soap_alloc(void) const { return SOAP_NEW(_ns11__GetCompatibleConfigurations); }
      public:
        /// Constructor with initializations
        _ns11__GetCompatibleConfigurations()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GetCompatibleConfigurations() { }
        /// Friend allocator used by soap_new__ns11__GetCompatibleConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GetCompatibleConfigurations * SOAP_FMAC2 soap_instantiate__ns11__GetCompatibleConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3454 */
#ifndef SOAP_TYPE__ns11__GetCompatibleConfigurationsResponse
#define SOAP_TYPE__ns11__GetCompatibleConfigurationsResponse (1302)
/* complex XSD type 'ns11:GetCompatibleConfigurationsResponse': */
class SOAP_CMAC _ns11__GetCompatibleConfigurationsResponse {
      public:
        /// Optional element 'ns11:PTZConfiguration' of XSD type 'ns2:PTZConfiguration'
        std::vector<ns2__PTZConfiguration *> PTZConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns11__GetCompatibleConfigurationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns11__GetCompatibleConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns11__GetCompatibleConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns11__GetCompatibleConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns11__GetCompatibleConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns11__GetCompatibleConfigurationsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns11__GetCompatibleConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns11__GetCompatibleConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns11__GetCompatibleConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns11__GetCompatibleConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3457 */
#ifndef SOAP_TYPE_ns12__ServiceCapabilities
#define SOAP_TYPE_ns12__ServiceCapabilities (1303)
/* complex XSD type 'ns12:ServiceCapabilities': */
class SOAP_CMAC ns12__ServiceCapabilities {
      public:
        /// Required element 'ns12:SupportedIdentifierType' of XSD type 'ns13:Name'
        std::vector<std::string> SupportedIdentifierType;
        /// Optional element 'ns12:Extension' of XSD type 'ns12:ServiceCapabilitiesExtension'
        ns12__ServiceCapabilitiesExtension *Extension;
        /// required attribute 'MaxLimit' of XSD type 'ns13:PositiveInteger'
        unsigned int MaxLimit;
        /// required attribute 'CredentialValiditySupported' of XSD type 'xsd:boolean'
        bool CredentialValiditySupported;
        /// required attribute 'CredentialAccessProfileValiditySupported' of XSD type 'xsd:boolean'
        bool CredentialAccessProfileValiditySupported;
        /// required attribute 'ValiditySupportsTimeValue' of XSD type 'xsd:boolean'
        bool ValiditySupportsTimeValue;
        /// required attribute 'MaxCredentials' of XSD type 'ns13:PositiveInteger'
        unsigned int MaxCredentials;
        /// required attribute 'MaxAccessProfilesPerCredential' of XSD type 'ns13:PositiveInteger'
        unsigned int MaxAccessProfilesPerCredential;
        /// required attribute 'ResetAntipassbackSupported' of XSD type 'xsd:boolean'
        bool ResetAntipassbackSupported;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns12__ServiceCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE_ns12__ServiceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns12__ServiceCapabilities, default initialized and not managed by a soap context
        virtual ns12__ServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(ns12__ServiceCapabilities); }
      public:
        /// Constructor with initializations
        ns12__ServiceCapabilities()
        {
          Extension = (ns12__ServiceCapabilitiesExtension *)0;
          MaxLimit = (unsigned int)0;
          CredentialValiditySupported = (bool)0;
          CredentialAccessProfileValiditySupported = (bool)0;
          ValiditySupportsTimeValue = (bool)0;
          MaxCredentials = (unsigned int)0;
          MaxAccessProfilesPerCredential = (unsigned int)0;
          ResetAntipassbackSupported = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~ns12__ServiceCapabilities() { }
        /// Friend allocator used by soap_new_ns12__ServiceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 ns12__ServiceCapabilities * SOAP_FMAC2 soap_instantiate_ns12__ServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3460 */
#ifndef SOAP_TYPE_ns12__ServiceCapabilitiesExtension
#define SOAP_TYPE_ns12__ServiceCapabilitiesExtension (1304)
/* complex XSD type 'ns12:ServiceCapabilitiesExtension': */
class SOAP_CMAC ns12__ServiceCapabilitiesExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns12__ServiceCapabilitiesExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns12__ServiceCapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns12__ServiceCapabilitiesExtension, default initialized and not managed by a soap context
        virtual ns12__ServiceCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(ns12__ServiceCapabilitiesExtension); }
      public:
        /// Constructor with initializations
        ns12__ServiceCapabilitiesExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns12__ServiceCapabilitiesExtension() { }
        /// Friend allocator used by soap_new_ns12__ServiceCapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 ns12__ServiceCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_ns12__ServiceCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3469 */
#ifndef SOAP_TYPE_ns12__CredentialExtension
#define SOAP_TYPE_ns12__CredentialExtension (1307)
/* complex XSD type 'ns12:CredentialExtension': */
class SOAP_CMAC ns12__CredentialExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns12__CredentialExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns12__CredentialExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns12__CredentialExtension, default initialized and not managed by a soap context
        virtual ns12__CredentialExtension *soap_alloc(void) const { return SOAP_NEW(ns12__CredentialExtension); }
      public:
        /// Constructor with initializations
        ns12__CredentialExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns12__CredentialExtension() { }
        /// Friend allocator used by soap_new_ns12__CredentialExtension(struct soap*, int)
        friend SOAP_FMAC1 ns12__CredentialExtension * SOAP_FMAC2 soap_instantiate_ns12__CredentialExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3472 */
#ifndef SOAP_TYPE_ns12__CredentialIdentifier
#define SOAP_TYPE_ns12__CredentialIdentifier (1308)
/* complex XSD type 'ns12:CredentialIdentifier': */
class SOAP_CMAC ns12__CredentialIdentifier {
      public:
        /// Required element 'ns12:Type' of XSD type 'ns12:CredentialIdentifierType'
        ns12__CredentialIdentifierType *Type;
        /// Required element 'ns12:ExemptedFromAuthentication' of XSD type 'xsd:boolean'
        bool ExemptedFromAuthentication;
        /// Required element 'ns12:Value' of XSD type 'xsd:hexBinary'
        xsd__hexBinary Value;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns12__CredentialIdentifier
        virtual int soap_type(void) const { return SOAP_TYPE_ns12__CredentialIdentifier; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns12__CredentialIdentifier, default initialized and not managed by a soap context
        virtual ns12__CredentialIdentifier *soap_alloc(void) const { return SOAP_NEW(ns12__CredentialIdentifier); }
      public:
        /// Constructor with initializations
        ns12__CredentialIdentifier()
        {
          Type = (ns12__CredentialIdentifierType *)0;
          ExemptedFromAuthentication = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~ns12__CredentialIdentifier() { }
        /// Friend allocator used by soap_new_ns12__CredentialIdentifier(struct soap*, int)
        friend SOAP_FMAC1 ns12__CredentialIdentifier * SOAP_FMAC2 soap_instantiate_ns12__CredentialIdentifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3475 */
#ifndef SOAP_TYPE_ns12__CredentialIdentifierType
#define SOAP_TYPE_ns12__CredentialIdentifierType (1309)
/* complex XSD type 'ns12:CredentialIdentifierType': */
class SOAP_CMAC ns12__CredentialIdentifierType {
      public:
        /// Required element 'ns12:Name' of XSD type 'ns13:Name'
        std::string Name;
        /// Required element 'ns12:FormatType' of XSD type 'xsd:string'
        std::string FormatType;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns12__CredentialIdentifierType
        virtual int soap_type(void) const { return SOAP_TYPE_ns12__CredentialIdentifierType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns12__CredentialIdentifierType, default initialized and not managed by a soap context
        virtual ns12__CredentialIdentifierType *soap_alloc(void) const { return SOAP_NEW(ns12__CredentialIdentifierType); }
      public:
        /// Constructor with initializations
        ns12__CredentialIdentifierType()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns12__CredentialIdentifierType() { }
        /// Friend allocator used by soap_new_ns12__CredentialIdentifierType(struct soap*, int)
        friend SOAP_FMAC1 ns12__CredentialIdentifierType * SOAP_FMAC2 soap_instantiate_ns12__CredentialIdentifierType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3478 */
#ifndef SOAP_TYPE_ns12__CredentialAccessProfile
#define SOAP_TYPE_ns12__CredentialAccessProfile (1310)
/* complex XSD type 'ns12:CredentialAccessProfile': */
class SOAP_CMAC ns12__CredentialAccessProfile {
      public:
        /// Required element 'ns12:AccessProfileToken' of XSD type 'ns13:ReferenceToken'
        std::string AccessProfileToken;
        /// Optional element 'ns12:ValidFrom' of XSD type 'xsd:dateTime'
        time_t *ValidFrom;
        /// Optional element 'ns12:ValidTo' of XSD type 'xsd:dateTime'
        time_t *ValidTo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns12__CredentialAccessProfile
        virtual int soap_type(void) const { return SOAP_TYPE_ns12__CredentialAccessProfile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns12__CredentialAccessProfile, default initialized and not managed by a soap context
        virtual ns12__CredentialAccessProfile *soap_alloc(void) const { return SOAP_NEW(ns12__CredentialAccessProfile); }
      public:
        /// Constructor with initializations
        ns12__CredentialAccessProfile()
        {
          ValidFrom = (time_t *)0;
          ValidTo = (time_t *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns12__CredentialAccessProfile() { }
        /// Friend allocator used by soap_new_ns12__CredentialAccessProfile(struct soap*, int)
        friend SOAP_FMAC1 ns12__CredentialAccessProfile * SOAP_FMAC2 soap_instantiate_ns12__CredentialAccessProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3481 */
#ifndef SOAP_TYPE_ns12__CredentialState
#define SOAP_TYPE_ns12__CredentialState (1311)
/* complex XSD type 'ns12:CredentialState': */
class SOAP_CMAC ns12__CredentialState {
      public:
        /// Required element 'ns12:Enabled' of XSD type 'xsd:boolean'
        bool Enabled;
        /// Optional element 'ns12:Reason' of XSD type 'ns13:Name'
        std::string *Reason;
        /// Optional element 'ns12:AntipassbackState' of XSD type 'ns12:AntipassbackState'
        ns12__AntipassbackState *AntipassbackState;
        /// Optional element 'ns12:Extension' of XSD type 'ns12:CredentialExtension'
        ns12__CredentialExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns12__CredentialState
        virtual int soap_type(void) const { return SOAP_TYPE_ns12__CredentialState; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns12__CredentialState, default initialized and not managed by a soap context
        virtual ns12__CredentialState *soap_alloc(void) const { return SOAP_NEW(ns12__CredentialState); }
      public:
        /// Constructor with initializations
        ns12__CredentialState()
        {
          Enabled = (bool)0;
          Reason = (std::string *)0;
          AntipassbackState = (ns12__AntipassbackState *)0;
          Extension = (ns12__CredentialExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns12__CredentialState() { }
        /// Friend allocator used by soap_new_ns12__CredentialState(struct soap*, int)
        friend SOAP_FMAC1 ns12__CredentialState * SOAP_FMAC2 soap_instantiate_ns12__CredentialState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3484 */
#ifndef SOAP_TYPE_ns12__CredentialStateExtension
#define SOAP_TYPE_ns12__CredentialStateExtension (1312)
/* complex XSD type 'ns12:CredentialStateExtension': */
class SOAP_CMAC ns12__CredentialStateExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns12__CredentialStateExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns12__CredentialStateExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns12__CredentialStateExtension, default initialized and not managed by a soap context
        virtual ns12__CredentialStateExtension *soap_alloc(void) const { return SOAP_NEW(ns12__CredentialStateExtension); }
      public:
        /// Constructor with initializations
        ns12__CredentialStateExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns12__CredentialStateExtension() { }
        /// Friend allocator used by soap_new_ns12__CredentialStateExtension(struct soap*, int)
        friend SOAP_FMAC1 ns12__CredentialStateExtension * SOAP_FMAC2 soap_instantiate_ns12__CredentialStateExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3487 */
#ifndef SOAP_TYPE_ns12__AntipassbackState
#define SOAP_TYPE_ns12__AntipassbackState (1313)
/* complex XSD type 'ns12:AntipassbackState': */
class SOAP_CMAC ns12__AntipassbackState {
      public:
        /// Required element 'ns12:AntipassbackViolated' of XSD type 'xsd:boolean'
        bool AntipassbackViolated;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns12__AntipassbackState
        virtual int soap_type(void) const { return SOAP_TYPE_ns12__AntipassbackState; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns12__AntipassbackState, default initialized and not managed by a soap context
        virtual ns12__AntipassbackState *soap_alloc(void) const { return SOAP_NEW(ns12__AntipassbackState); }
      public:
        /// Constructor with initializations
        ns12__AntipassbackState()
        {
          AntipassbackViolated = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~ns12__AntipassbackState() { }
        /// Friend allocator used by soap_new_ns12__AntipassbackState(struct soap*, int)
        friend SOAP_FMAC1 ns12__AntipassbackState * SOAP_FMAC2 soap_instantiate_ns12__AntipassbackState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3490 */
#ifndef SOAP_TYPE_ns12__CredentialIdentifierFormatTypeInfo
#define SOAP_TYPE_ns12__CredentialIdentifierFormatTypeInfo (1314)
/* complex XSD type 'ns12:CredentialIdentifierFormatTypeInfo': */
class SOAP_CMAC ns12__CredentialIdentifierFormatTypeInfo {
      public:
        /// Required element 'ns12:FormatType' of XSD type 'xsd:string'
        std::string FormatType;
        /// Required element 'ns12:Description' of XSD type 'ns13:Description'
        std::string Description;
        /// Optional element 'ns12:Extension' of XSD type 'ns12:CredentialIdentifierFormatTypeInfoExtension'
        ns12__CredentialIdentifierFormatTypeInfoExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns12__CredentialIdentifierFormatTypeInfo
        virtual int soap_type(void) const { return SOAP_TYPE_ns12__CredentialIdentifierFormatTypeInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns12__CredentialIdentifierFormatTypeInfo, default initialized and not managed by a soap context
        virtual ns12__CredentialIdentifierFormatTypeInfo *soap_alloc(void) const { return SOAP_NEW(ns12__CredentialIdentifierFormatTypeInfo); }
      public:
        /// Constructor with initializations
        ns12__CredentialIdentifierFormatTypeInfo()
        {
          Extension = (ns12__CredentialIdentifierFormatTypeInfoExtension *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns12__CredentialIdentifierFormatTypeInfo() { }
        /// Friend allocator used by soap_new_ns12__CredentialIdentifierFormatTypeInfo(struct soap*, int)
        friend SOAP_FMAC1 ns12__CredentialIdentifierFormatTypeInfo * SOAP_FMAC2 soap_instantiate_ns12__CredentialIdentifierFormatTypeInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3493 */
#ifndef SOAP_TYPE_ns12__CredentialIdentifierFormatTypeInfoExtension
#define SOAP_TYPE_ns12__CredentialIdentifierFormatTypeInfoExtension (1315)
/* complex XSD type 'ns12:CredentialIdentifierFormatTypeInfoExtension': */
class SOAP_CMAC ns12__CredentialIdentifierFormatTypeInfoExtension {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns12__CredentialIdentifierFormatTypeInfoExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns12__CredentialIdentifierFormatTypeInfoExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns12__CredentialIdentifierFormatTypeInfoExtension, default initialized and not managed by a soap context
        virtual ns12__CredentialIdentifierFormatTypeInfoExtension *soap_alloc(void) const { return SOAP_NEW(ns12__CredentialIdentifierFormatTypeInfoExtension); }
      public:
        /// Constructor with initializations
        ns12__CredentialIdentifierFormatTypeInfoExtension()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns12__CredentialIdentifierFormatTypeInfoExtension() { }
        /// Friend allocator used by soap_new_ns12__CredentialIdentifierFormatTypeInfoExtension(struct soap*, int)
        friend SOAP_FMAC1 ns12__CredentialIdentifierFormatTypeInfoExtension * SOAP_FMAC2 soap_instantiate_ns12__CredentialIdentifierFormatTypeInfoExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3496 */
#ifndef SOAP_TYPE__ns12__GetServiceCapabilities
#define SOAP_TYPE__ns12__GetServiceCapabilities (1316)
/* complex XSD type 'ns12:GetServiceCapabilities': */
class SOAP_CMAC _ns12__GetServiceCapabilities {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__GetServiceCapabilities
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__GetServiceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__GetServiceCapabilities, default initialized and not managed by a soap context
        virtual _ns12__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_ns12__GetServiceCapabilities); }
      public:
        /// Constructor with initializations
        _ns12__GetServiceCapabilities()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__GetServiceCapabilities() { }
        /// Friend allocator used by soap_new__ns12__GetServiceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 _ns12__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__ns12__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3499 */
#ifndef SOAP_TYPE__ns12__GetServiceCapabilitiesResponse
#define SOAP_TYPE__ns12__GetServiceCapabilitiesResponse (1317)
/* complex XSD type 'ns12:GetServiceCapabilitiesResponse': */
class SOAP_CMAC _ns12__GetServiceCapabilitiesResponse {
      public:
        /// Required element 'ns12:Capabilities' of XSD type 'ns12:ServiceCapabilities'
        ns12__ServiceCapabilities *Capabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__GetServiceCapabilitiesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__GetServiceCapabilitiesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
        virtual _ns12__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_ns12__GetServiceCapabilitiesResponse); }
      public:
        /// Constructor with initializations
        _ns12__GetServiceCapabilitiesResponse()
        {
          Capabilities = (ns12__ServiceCapabilities *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns12__GetServiceCapabilitiesResponse() { }
        /// Friend allocator used by soap_new__ns12__GetServiceCapabilitiesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns12__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__ns12__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3502 */
#ifndef SOAP_TYPE__ns12__GetSupportedFormatTypes
#define SOAP_TYPE__ns12__GetSupportedFormatTypes (1318)
/* complex XSD type 'ns12:GetSupportedFormatTypes': */
class SOAP_CMAC _ns12__GetSupportedFormatTypes {
      public:
        /// Required element 'ns12:CredentialIdentifierTypeName' of XSD type 'xsd:string'
        std::string CredentialIdentifierTypeName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__GetSupportedFormatTypes
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__GetSupportedFormatTypes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__GetSupportedFormatTypes, default initialized and not managed by a soap context
        virtual _ns12__GetSupportedFormatTypes *soap_alloc(void) const { return SOAP_NEW(_ns12__GetSupportedFormatTypes); }
      public:
        /// Constructor with initializations
        _ns12__GetSupportedFormatTypes()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__GetSupportedFormatTypes() { }
        /// Friend allocator used by soap_new__ns12__GetSupportedFormatTypes(struct soap*, int)
        friend SOAP_FMAC1 _ns12__GetSupportedFormatTypes * SOAP_FMAC2 soap_instantiate__ns12__GetSupportedFormatTypes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3505 */
#ifndef SOAP_TYPE__ns12__GetSupportedFormatTypesResponse
#define SOAP_TYPE__ns12__GetSupportedFormatTypesResponse (1319)
/* complex XSD type 'ns12:GetSupportedFormatTypesResponse': */
class SOAP_CMAC _ns12__GetSupportedFormatTypesResponse {
      public:
        /// Required element 'ns12:FormatTypeInfo' of XSD type 'ns12:CredentialIdentifierFormatTypeInfo'
        std::vector<ns12__CredentialIdentifierFormatTypeInfo *> FormatTypeInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__GetSupportedFormatTypesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__GetSupportedFormatTypesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__GetSupportedFormatTypesResponse, default initialized and not managed by a soap context
        virtual _ns12__GetSupportedFormatTypesResponse *soap_alloc(void) const { return SOAP_NEW(_ns12__GetSupportedFormatTypesResponse); }
      public:
        /// Constructor with initializations
        _ns12__GetSupportedFormatTypesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__GetSupportedFormatTypesResponse() { }
        /// Friend allocator used by soap_new__ns12__GetSupportedFormatTypesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns12__GetSupportedFormatTypesResponse * SOAP_FMAC2 soap_instantiate__ns12__GetSupportedFormatTypesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3508 */
#ifndef SOAP_TYPE__ns12__GetCredentialInfo
#define SOAP_TYPE__ns12__GetCredentialInfo (1320)
/* complex XSD type 'ns12:GetCredentialInfo': */
class SOAP_CMAC _ns12__GetCredentialInfo {
      public:
        /// Required element 'ns12:Token' of XSD type 'ns13:ReferenceToken'
        std::vector<std::string> Token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__GetCredentialInfo
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__GetCredentialInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__GetCredentialInfo, default initialized and not managed by a soap context
        virtual _ns12__GetCredentialInfo *soap_alloc(void) const { return SOAP_NEW(_ns12__GetCredentialInfo); }
      public:
        /// Constructor with initializations
        _ns12__GetCredentialInfo()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__GetCredentialInfo() { }
        /// Friend allocator used by soap_new__ns12__GetCredentialInfo(struct soap*, int)
        friend SOAP_FMAC1 _ns12__GetCredentialInfo * SOAP_FMAC2 soap_instantiate__ns12__GetCredentialInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3511 */
#ifndef SOAP_TYPE__ns12__GetCredentialInfoResponse
#define SOAP_TYPE__ns12__GetCredentialInfoResponse (1321)
/* complex XSD type 'ns12:GetCredentialInfoResponse': */
class SOAP_CMAC _ns12__GetCredentialInfoResponse {
      public:
        /// Optional element 'ns12:CredentialInfo' of XSD type 'ns12:CredentialInfo'
        std::vector<ns12__CredentialInfo *> CredentialInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__GetCredentialInfoResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__GetCredentialInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__GetCredentialInfoResponse, default initialized and not managed by a soap context
        virtual _ns12__GetCredentialInfoResponse *soap_alloc(void) const { return SOAP_NEW(_ns12__GetCredentialInfoResponse); }
      public:
        /// Constructor with initializations
        _ns12__GetCredentialInfoResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__GetCredentialInfoResponse() { }
        /// Friend allocator used by soap_new__ns12__GetCredentialInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns12__GetCredentialInfoResponse * SOAP_FMAC2 soap_instantiate__ns12__GetCredentialInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3514 */
#ifndef SOAP_TYPE__ns12__GetCredentialInfoList
#define SOAP_TYPE__ns12__GetCredentialInfoList (1322)
/* complex XSD type 'ns12:GetCredentialInfoList': */
class SOAP_CMAC _ns12__GetCredentialInfoList {
      public:
        /// Optional element 'ns12:Limit' of XSD type 'xsd:int'
        int *Limit;
        /// Optional element 'ns12:StartReference' of XSD type 'xsd:string'
        std::string *StartReference;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__GetCredentialInfoList
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__GetCredentialInfoList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__GetCredentialInfoList, default initialized and not managed by a soap context
        virtual _ns12__GetCredentialInfoList *soap_alloc(void) const { return SOAP_NEW(_ns12__GetCredentialInfoList); }
      public:
        /// Constructor with initializations
        _ns12__GetCredentialInfoList()
        {
          Limit = (int *)0;
          StartReference = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns12__GetCredentialInfoList() { }
        /// Friend allocator used by soap_new__ns12__GetCredentialInfoList(struct soap*, int)
        friend SOAP_FMAC1 _ns12__GetCredentialInfoList * SOAP_FMAC2 soap_instantiate__ns12__GetCredentialInfoList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3517 */
#ifndef SOAP_TYPE__ns12__GetCredentialInfoListResponse
#define SOAP_TYPE__ns12__GetCredentialInfoListResponse (1323)
/* complex XSD type 'ns12:GetCredentialInfoListResponse': */
class SOAP_CMAC _ns12__GetCredentialInfoListResponse {
      public:
        /// Optional element 'ns12:NextStartReference' of XSD type 'xsd:string'
        std::string *NextStartReference;
        /// Optional element 'ns12:CredentialInfo' of XSD type 'ns12:CredentialInfo'
        std::vector<ns12__CredentialInfo *> CredentialInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__GetCredentialInfoListResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__GetCredentialInfoListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__GetCredentialInfoListResponse, default initialized and not managed by a soap context
        virtual _ns12__GetCredentialInfoListResponse *soap_alloc(void) const { return SOAP_NEW(_ns12__GetCredentialInfoListResponse); }
      public:
        /// Constructor with initializations
        _ns12__GetCredentialInfoListResponse()
        {
          NextStartReference = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns12__GetCredentialInfoListResponse() { }
        /// Friend allocator used by soap_new__ns12__GetCredentialInfoListResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns12__GetCredentialInfoListResponse * SOAP_FMAC2 soap_instantiate__ns12__GetCredentialInfoListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3520 */
#ifndef SOAP_TYPE__ns12__GetCredentials
#define SOAP_TYPE__ns12__GetCredentials (1324)
/* complex XSD type 'ns12:GetCredentials': */
class SOAP_CMAC _ns12__GetCredentials {
      public:
        /// Required element 'ns12:Token' of XSD type 'ns13:ReferenceToken'
        std::vector<std::string> Token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__GetCredentials
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__GetCredentials; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__GetCredentials, default initialized and not managed by a soap context
        virtual _ns12__GetCredentials *soap_alloc(void) const { return SOAP_NEW(_ns12__GetCredentials); }
      public:
        /// Constructor with initializations
        _ns12__GetCredentials()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__GetCredentials() { }
        /// Friend allocator used by soap_new__ns12__GetCredentials(struct soap*, int)
        friend SOAP_FMAC1 _ns12__GetCredentials * SOAP_FMAC2 soap_instantiate__ns12__GetCredentials(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3523 */
#ifndef SOAP_TYPE__ns12__GetCredentialsResponse
#define SOAP_TYPE__ns12__GetCredentialsResponse (1325)
/* complex XSD type 'ns12:GetCredentialsResponse': */
class SOAP_CMAC _ns12__GetCredentialsResponse {
      public:
        /// Optional element 'ns12:Credential' of XSD type 'ns12:Credential'
        std::vector<ns12__Credential *> Credential;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__GetCredentialsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__GetCredentialsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__GetCredentialsResponse, default initialized and not managed by a soap context
        virtual _ns12__GetCredentialsResponse *soap_alloc(void) const { return SOAP_NEW(_ns12__GetCredentialsResponse); }
      public:
        /// Constructor with initializations
        _ns12__GetCredentialsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__GetCredentialsResponse() { }
        /// Friend allocator used by soap_new__ns12__GetCredentialsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns12__GetCredentialsResponse * SOAP_FMAC2 soap_instantiate__ns12__GetCredentialsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3526 */
#ifndef SOAP_TYPE__ns12__GetCredentialList
#define SOAP_TYPE__ns12__GetCredentialList (1326)
/* complex XSD type 'ns12:GetCredentialList': */
class SOAP_CMAC _ns12__GetCredentialList {
      public:
        /// Optional element 'ns12:Limit' of XSD type 'xsd:int'
        int *Limit;
        /// Optional element 'ns12:StartReference' of XSD type 'xsd:string'
        std::string *StartReference;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__GetCredentialList
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__GetCredentialList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__GetCredentialList, default initialized and not managed by a soap context
        virtual _ns12__GetCredentialList *soap_alloc(void) const { return SOAP_NEW(_ns12__GetCredentialList); }
      public:
        /// Constructor with initializations
        _ns12__GetCredentialList()
        {
          Limit = (int *)0;
          StartReference = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns12__GetCredentialList() { }
        /// Friend allocator used by soap_new__ns12__GetCredentialList(struct soap*, int)
        friend SOAP_FMAC1 _ns12__GetCredentialList * SOAP_FMAC2 soap_instantiate__ns12__GetCredentialList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3529 */
#ifndef SOAP_TYPE__ns12__GetCredentialListResponse
#define SOAP_TYPE__ns12__GetCredentialListResponse (1327)
/* complex XSD type 'ns12:GetCredentialListResponse': */
class SOAP_CMAC _ns12__GetCredentialListResponse {
      public:
        /// Optional element 'ns12:NextStartReference' of XSD type 'xsd:string'
        std::string *NextStartReference;
        /// Optional element 'ns12:Credential' of XSD type 'ns12:Credential'
        std::vector<ns12__Credential *> Credential;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__GetCredentialListResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__GetCredentialListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__GetCredentialListResponse, default initialized and not managed by a soap context
        virtual _ns12__GetCredentialListResponse *soap_alloc(void) const { return SOAP_NEW(_ns12__GetCredentialListResponse); }
      public:
        /// Constructor with initializations
        _ns12__GetCredentialListResponse()
        {
          NextStartReference = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns12__GetCredentialListResponse() { }
        /// Friend allocator used by soap_new__ns12__GetCredentialListResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns12__GetCredentialListResponse * SOAP_FMAC2 soap_instantiate__ns12__GetCredentialListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3532 */
#ifndef SOAP_TYPE__ns12__CreateCredential
#define SOAP_TYPE__ns12__CreateCredential (1328)
/* complex XSD type 'ns12:CreateCredential': */
class SOAP_CMAC _ns12__CreateCredential {
      public:
        /// Required element 'ns12:Credential' of XSD type 'ns12:Credential'
        ns12__Credential *Credential;
        /// Required element 'ns12:State' of XSD type 'ns12:CredentialState'
        ns12__CredentialState *State;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__CreateCredential
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__CreateCredential; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__CreateCredential, default initialized and not managed by a soap context
        virtual _ns12__CreateCredential *soap_alloc(void) const { return SOAP_NEW(_ns12__CreateCredential); }
      public:
        /// Constructor with initializations
        _ns12__CreateCredential()
        {
          Credential = (ns12__Credential *)0;
          State = (ns12__CredentialState *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns12__CreateCredential() { }
        /// Friend allocator used by soap_new__ns12__CreateCredential(struct soap*, int)
        friend SOAP_FMAC1 _ns12__CreateCredential * SOAP_FMAC2 soap_instantiate__ns12__CreateCredential(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3535 */
#ifndef SOAP_TYPE__ns12__CreateCredentialResponse
#define SOAP_TYPE__ns12__CreateCredentialResponse (1329)
/* complex XSD type 'ns12:CreateCredentialResponse': */
class SOAP_CMAC _ns12__CreateCredentialResponse {
      public:
        /// Required element 'ns12:Token' of XSD type 'ns13:ReferenceToken'
        std::string Token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__CreateCredentialResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__CreateCredentialResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__CreateCredentialResponse, default initialized and not managed by a soap context
        virtual _ns12__CreateCredentialResponse *soap_alloc(void) const { return SOAP_NEW(_ns12__CreateCredentialResponse); }
      public:
        /// Constructor with initializations
        _ns12__CreateCredentialResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__CreateCredentialResponse() { }
        /// Friend allocator used by soap_new__ns12__CreateCredentialResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns12__CreateCredentialResponse * SOAP_FMAC2 soap_instantiate__ns12__CreateCredentialResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3538 */
#ifndef SOAP_TYPE__ns12__ModifyCredential
#define SOAP_TYPE__ns12__ModifyCredential (1330)
/* complex XSD type 'ns12:ModifyCredential': */
class SOAP_CMAC _ns12__ModifyCredential {
      public:
        /// Required element 'ns12:Credential' of XSD type 'ns12:Credential'
        ns12__Credential *Credential;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__ModifyCredential
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__ModifyCredential; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__ModifyCredential, default initialized and not managed by a soap context
        virtual _ns12__ModifyCredential *soap_alloc(void) const { return SOAP_NEW(_ns12__ModifyCredential); }
      public:
        /// Constructor with initializations
        _ns12__ModifyCredential()
        {
          Credential = (ns12__Credential *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns12__ModifyCredential() { }
        /// Friend allocator used by soap_new__ns12__ModifyCredential(struct soap*, int)
        friend SOAP_FMAC1 _ns12__ModifyCredential * SOAP_FMAC2 soap_instantiate__ns12__ModifyCredential(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3541 */
#ifndef SOAP_TYPE__ns12__ModifyCredentialResponse
#define SOAP_TYPE__ns12__ModifyCredentialResponse (1331)
/* complex XSD type 'ns12:ModifyCredentialResponse': */
class SOAP_CMAC _ns12__ModifyCredentialResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__ModifyCredentialResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__ModifyCredentialResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__ModifyCredentialResponse, default initialized and not managed by a soap context
        virtual _ns12__ModifyCredentialResponse *soap_alloc(void) const { return SOAP_NEW(_ns12__ModifyCredentialResponse); }
      public:
        /// Constructor with initializations
        _ns12__ModifyCredentialResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__ModifyCredentialResponse() { }
        /// Friend allocator used by soap_new__ns12__ModifyCredentialResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns12__ModifyCredentialResponse * SOAP_FMAC2 soap_instantiate__ns12__ModifyCredentialResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3544 */
#ifndef SOAP_TYPE__ns12__DeleteCredential
#define SOAP_TYPE__ns12__DeleteCredential (1332)
/* complex XSD type 'ns12:DeleteCredential': */
class SOAP_CMAC _ns12__DeleteCredential {
      public:
        /// Required element 'ns12:Token' of XSD type 'ns13:ReferenceToken'
        std::string Token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__DeleteCredential
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__DeleteCredential; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__DeleteCredential, default initialized and not managed by a soap context
        virtual _ns12__DeleteCredential *soap_alloc(void) const { return SOAP_NEW(_ns12__DeleteCredential); }
      public:
        /// Constructor with initializations
        _ns12__DeleteCredential()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__DeleteCredential() { }
        /// Friend allocator used by soap_new__ns12__DeleteCredential(struct soap*, int)
        friend SOAP_FMAC1 _ns12__DeleteCredential * SOAP_FMAC2 soap_instantiate__ns12__DeleteCredential(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3547 */
#ifndef SOAP_TYPE__ns12__DeleteCredentialResponse
#define SOAP_TYPE__ns12__DeleteCredentialResponse (1333)
/* complex XSD type 'ns12:DeleteCredentialResponse': */
class SOAP_CMAC _ns12__DeleteCredentialResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__DeleteCredentialResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__DeleteCredentialResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__DeleteCredentialResponse, default initialized and not managed by a soap context
        virtual _ns12__DeleteCredentialResponse *soap_alloc(void) const { return SOAP_NEW(_ns12__DeleteCredentialResponse); }
      public:
        /// Constructor with initializations
        _ns12__DeleteCredentialResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__DeleteCredentialResponse() { }
        /// Friend allocator used by soap_new__ns12__DeleteCredentialResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns12__DeleteCredentialResponse * SOAP_FMAC2 soap_instantiate__ns12__DeleteCredentialResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3550 */
#ifndef SOAP_TYPE__ns12__GetCredentialState
#define SOAP_TYPE__ns12__GetCredentialState (1334)
/* complex XSD type 'ns12:GetCredentialState': */
class SOAP_CMAC _ns12__GetCredentialState {
      public:
        /// Required element 'ns12:Token' of XSD type 'ns13:ReferenceToken'
        std::string Token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__GetCredentialState
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__GetCredentialState; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__GetCredentialState, default initialized and not managed by a soap context
        virtual _ns12__GetCredentialState *soap_alloc(void) const { return SOAP_NEW(_ns12__GetCredentialState); }
      public:
        /// Constructor with initializations
        _ns12__GetCredentialState()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__GetCredentialState() { }
        /// Friend allocator used by soap_new__ns12__GetCredentialState(struct soap*, int)
        friend SOAP_FMAC1 _ns12__GetCredentialState * SOAP_FMAC2 soap_instantiate__ns12__GetCredentialState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3553 */
#ifndef SOAP_TYPE__ns12__GetCredentialStateResponse
#define SOAP_TYPE__ns12__GetCredentialStateResponse (1335)
/* complex XSD type 'ns12:GetCredentialStateResponse': */
class SOAP_CMAC _ns12__GetCredentialStateResponse {
      public:
        /// Required element 'ns12:State' of XSD type 'ns12:CredentialState'
        ns12__CredentialState *State;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__GetCredentialStateResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__GetCredentialStateResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__GetCredentialStateResponse, default initialized and not managed by a soap context
        virtual _ns12__GetCredentialStateResponse *soap_alloc(void) const { return SOAP_NEW(_ns12__GetCredentialStateResponse); }
      public:
        /// Constructor with initializations
        _ns12__GetCredentialStateResponse()
        {
          State = (ns12__CredentialState *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns12__GetCredentialStateResponse() { }
        /// Friend allocator used by soap_new__ns12__GetCredentialStateResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns12__GetCredentialStateResponse * SOAP_FMAC2 soap_instantiate__ns12__GetCredentialStateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3556 */
#ifndef SOAP_TYPE__ns12__EnableCredential
#define SOAP_TYPE__ns12__EnableCredential (1336)
/* complex XSD type 'ns12:EnableCredential': */
class SOAP_CMAC _ns12__EnableCredential {
      public:
        /// Required element 'ns12:Token' of XSD type 'ns13:ReferenceToken'
        std::string Token;
        /// Optional element 'ns12:Reason' of XSD type 'ns13:Name'
        std::string *Reason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__EnableCredential
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__EnableCredential; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__EnableCredential, default initialized and not managed by a soap context
        virtual _ns12__EnableCredential *soap_alloc(void) const { return SOAP_NEW(_ns12__EnableCredential); }
      public:
        /// Constructor with initializations
        _ns12__EnableCredential()
        {
          Reason = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns12__EnableCredential() { }
        /// Friend allocator used by soap_new__ns12__EnableCredential(struct soap*, int)
        friend SOAP_FMAC1 _ns12__EnableCredential * SOAP_FMAC2 soap_instantiate__ns12__EnableCredential(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3559 */
#ifndef SOAP_TYPE__ns12__EnableCredentialResponse
#define SOAP_TYPE__ns12__EnableCredentialResponse (1337)
/* complex XSD type 'ns12:EnableCredentialResponse': */
class SOAP_CMAC _ns12__EnableCredentialResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__EnableCredentialResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__EnableCredentialResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__EnableCredentialResponse, default initialized and not managed by a soap context
        virtual _ns12__EnableCredentialResponse *soap_alloc(void) const { return SOAP_NEW(_ns12__EnableCredentialResponse); }
      public:
        /// Constructor with initializations
        _ns12__EnableCredentialResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__EnableCredentialResponse() { }
        /// Friend allocator used by soap_new__ns12__EnableCredentialResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns12__EnableCredentialResponse * SOAP_FMAC2 soap_instantiate__ns12__EnableCredentialResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3562 */
#ifndef SOAP_TYPE__ns12__DisableCredential
#define SOAP_TYPE__ns12__DisableCredential (1338)
/* complex XSD type 'ns12:DisableCredential': */
class SOAP_CMAC _ns12__DisableCredential {
      public:
        /// Required element 'ns12:Token' of XSD type 'ns13:ReferenceToken'
        std::string Token;
        /// Optional element 'ns12:Reason' of XSD type 'ns13:Name'
        std::string *Reason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__DisableCredential
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__DisableCredential; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__DisableCredential, default initialized and not managed by a soap context
        virtual _ns12__DisableCredential *soap_alloc(void) const { return SOAP_NEW(_ns12__DisableCredential); }
      public:
        /// Constructor with initializations
        _ns12__DisableCredential()
        {
          Reason = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns12__DisableCredential() { }
        /// Friend allocator used by soap_new__ns12__DisableCredential(struct soap*, int)
        friend SOAP_FMAC1 _ns12__DisableCredential * SOAP_FMAC2 soap_instantiate__ns12__DisableCredential(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3565 */
#ifndef SOAP_TYPE__ns12__DisableCredentialResponse
#define SOAP_TYPE__ns12__DisableCredentialResponse (1339)
/* complex XSD type 'ns12:DisableCredentialResponse': */
class SOAP_CMAC _ns12__DisableCredentialResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__DisableCredentialResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__DisableCredentialResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__DisableCredentialResponse, default initialized and not managed by a soap context
        virtual _ns12__DisableCredentialResponse *soap_alloc(void) const { return SOAP_NEW(_ns12__DisableCredentialResponse); }
      public:
        /// Constructor with initializations
        _ns12__DisableCredentialResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__DisableCredentialResponse() { }
        /// Friend allocator used by soap_new__ns12__DisableCredentialResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns12__DisableCredentialResponse * SOAP_FMAC2 soap_instantiate__ns12__DisableCredentialResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3568 */
#ifndef SOAP_TYPE__ns12__ResetAntipassbackViolation
#define SOAP_TYPE__ns12__ResetAntipassbackViolation (1340)
/* complex XSD type 'ns12:ResetAntipassbackViolation': */
class SOAP_CMAC _ns12__ResetAntipassbackViolation {
      public:
        /// Required element 'ns12:CredentialToken' of XSD type 'ns13:ReferenceToken'
        std::string CredentialToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__ResetAntipassbackViolation
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__ResetAntipassbackViolation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__ResetAntipassbackViolation, default initialized and not managed by a soap context
        virtual _ns12__ResetAntipassbackViolation *soap_alloc(void) const { return SOAP_NEW(_ns12__ResetAntipassbackViolation); }
      public:
        /// Constructor with initializations
        _ns12__ResetAntipassbackViolation()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__ResetAntipassbackViolation() { }
        /// Friend allocator used by soap_new__ns12__ResetAntipassbackViolation(struct soap*, int)
        friend SOAP_FMAC1 _ns12__ResetAntipassbackViolation * SOAP_FMAC2 soap_instantiate__ns12__ResetAntipassbackViolation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3571 */
#ifndef SOAP_TYPE__ns12__ResetAntipassbackViolationResponse
#define SOAP_TYPE__ns12__ResetAntipassbackViolationResponse (1341)
/* complex XSD type 'ns12:ResetAntipassbackViolationResponse': */
class SOAP_CMAC _ns12__ResetAntipassbackViolationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__ResetAntipassbackViolationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__ResetAntipassbackViolationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__ResetAntipassbackViolationResponse, default initialized and not managed by a soap context
        virtual _ns12__ResetAntipassbackViolationResponse *soap_alloc(void) const { return SOAP_NEW(_ns12__ResetAntipassbackViolationResponse); }
      public:
        /// Constructor with initializations
        _ns12__ResetAntipassbackViolationResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__ResetAntipassbackViolationResponse() { }
        /// Friend allocator used by soap_new__ns12__ResetAntipassbackViolationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns12__ResetAntipassbackViolationResponse * SOAP_FMAC2 soap_instantiate__ns12__ResetAntipassbackViolationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3574 */
#ifndef SOAP_TYPE__ns12__GetCredentialIdentifiers
#define SOAP_TYPE__ns12__GetCredentialIdentifiers (1342)
/* complex XSD type 'ns12:GetCredentialIdentifiers': */
class SOAP_CMAC _ns12__GetCredentialIdentifiers {
      public:
        /// Required element 'ns12:CredentialToken' of XSD type 'ns13:ReferenceToken'
        std::string CredentialToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__GetCredentialIdentifiers
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__GetCredentialIdentifiers; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__GetCredentialIdentifiers, default initialized and not managed by a soap context
        virtual _ns12__GetCredentialIdentifiers *soap_alloc(void) const { return SOAP_NEW(_ns12__GetCredentialIdentifiers); }
      public:
        /// Constructor with initializations
        _ns12__GetCredentialIdentifiers()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__GetCredentialIdentifiers() { }
        /// Friend allocator used by soap_new__ns12__GetCredentialIdentifiers(struct soap*, int)
        friend SOAP_FMAC1 _ns12__GetCredentialIdentifiers * SOAP_FMAC2 soap_instantiate__ns12__GetCredentialIdentifiers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3577 */
#ifndef SOAP_TYPE__ns12__GetCredentialIdentifiersResponse
#define SOAP_TYPE__ns12__GetCredentialIdentifiersResponse (1343)
/* complex XSD type 'ns12:GetCredentialIdentifiersResponse': */
class SOAP_CMAC _ns12__GetCredentialIdentifiersResponse {
      public:
        /// Optional element 'ns12:CredentialIdentifier' of XSD type 'ns12:CredentialIdentifier'
        std::vector<ns12__CredentialIdentifier *> CredentialIdentifier;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__GetCredentialIdentifiersResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__GetCredentialIdentifiersResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__GetCredentialIdentifiersResponse, default initialized and not managed by a soap context
        virtual _ns12__GetCredentialIdentifiersResponse *soap_alloc(void) const { return SOAP_NEW(_ns12__GetCredentialIdentifiersResponse); }
      public:
        /// Constructor with initializations
        _ns12__GetCredentialIdentifiersResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__GetCredentialIdentifiersResponse() { }
        /// Friend allocator used by soap_new__ns12__GetCredentialIdentifiersResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns12__GetCredentialIdentifiersResponse * SOAP_FMAC2 soap_instantiate__ns12__GetCredentialIdentifiersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3580 */
#ifndef SOAP_TYPE__ns12__SetCredentialIdentifier
#define SOAP_TYPE__ns12__SetCredentialIdentifier (1344)
/* complex XSD type 'ns12:SetCredentialIdentifier': */
class SOAP_CMAC _ns12__SetCredentialIdentifier {
      public:
        /// Required element 'ns12:CredentialToken' of XSD type 'ns13:ReferenceToken'
        std::string CredentialToken;
        /// Required element 'ns12:CredentialIdentifier' of XSD type 'ns12:CredentialIdentifier'
        ns12__CredentialIdentifier *CredentialIdentifier;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__SetCredentialIdentifier
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__SetCredentialIdentifier; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__SetCredentialIdentifier, default initialized and not managed by a soap context
        virtual _ns12__SetCredentialIdentifier *soap_alloc(void) const { return SOAP_NEW(_ns12__SetCredentialIdentifier); }
      public:
        /// Constructor with initializations
        _ns12__SetCredentialIdentifier()
        {
          CredentialIdentifier = (ns12__CredentialIdentifier *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns12__SetCredentialIdentifier() { }
        /// Friend allocator used by soap_new__ns12__SetCredentialIdentifier(struct soap*, int)
        friend SOAP_FMAC1 _ns12__SetCredentialIdentifier * SOAP_FMAC2 soap_instantiate__ns12__SetCredentialIdentifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3583 */
#ifndef SOAP_TYPE__ns12__SetCredentialIdentifierResponse
#define SOAP_TYPE__ns12__SetCredentialIdentifierResponse (1345)
/* complex XSD type 'ns12:SetCredentialIdentifierResponse': */
class SOAP_CMAC _ns12__SetCredentialIdentifierResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__SetCredentialIdentifierResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__SetCredentialIdentifierResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__SetCredentialIdentifierResponse, default initialized and not managed by a soap context
        virtual _ns12__SetCredentialIdentifierResponse *soap_alloc(void) const { return SOAP_NEW(_ns12__SetCredentialIdentifierResponse); }
      public:
        /// Constructor with initializations
        _ns12__SetCredentialIdentifierResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__SetCredentialIdentifierResponse() { }
        /// Friend allocator used by soap_new__ns12__SetCredentialIdentifierResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns12__SetCredentialIdentifierResponse * SOAP_FMAC2 soap_instantiate__ns12__SetCredentialIdentifierResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3586 */
#ifndef SOAP_TYPE__ns12__DeleteCredentialIdentifier
#define SOAP_TYPE__ns12__DeleteCredentialIdentifier (1346)
/* complex XSD type 'ns12:DeleteCredentialIdentifier': */
class SOAP_CMAC _ns12__DeleteCredentialIdentifier {
      public:
        /// Required element 'ns12:CredentialToken' of XSD type 'ns13:ReferenceToken'
        std::string CredentialToken;
        /// Required element 'ns12:CredentialIdentifierTypeName' of XSD type 'ns13:Name'
        std::string CredentialIdentifierTypeName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__DeleteCredentialIdentifier
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__DeleteCredentialIdentifier; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__DeleteCredentialIdentifier, default initialized and not managed by a soap context
        virtual _ns12__DeleteCredentialIdentifier *soap_alloc(void) const { return SOAP_NEW(_ns12__DeleteCredentialIdentifier); }
      public:
        /// Constructor with initializations
        _ns12__DeleteCredentialIdentifier()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__DeleteCredentialIdentifier() { }
        /// Friend allocator used by soap_new__ns12__DeleteCredentialIdentifier(struct soap*, int)
        friend SOAP_FMAC1 _ns12__DeleteCredentialIdentifier * SOAP_FMAC2 soap_instantiate__ns12__DeleteCredentialIdentifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3589 */
#ifndef SOAP_TYPE__ns12__DeleteCredentialIdentifierResponse
#define SOAP_TYPE__ns12__DeleteCredentialIdentifierResponse (1347)
/* complex XSD type 'ns12:DeleteCredentialIdentifierResponse': */
class SOAP_CMAC _ns12__DeleteCredentialIdentifierResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__DeleteCredentialIdentifierResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__DeleteCredentialIdentifierResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__DeleteCredentialIdentifierResponse, default initialized and not managed by a soap context
        virtual _ns12__DeleteCredentialIdentifierResponse *soap_alloc(void) const { return SOAP_NEW(_ns12__DeleteCredentialIdentifierResponse); }
      public:
        /// Constructor with initializations
        _ns12__DeleteCredentialIdentifierResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__DeleteCredentialIdentifierResponse() { }
        /// Friend allocator used by soap_new__ns12__DeleteCredentialIdentifierResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns12__DeleteCredentialIdentifierResponse * SOAP_FMAC2 soap_instantiate__ns12__DeleteCredentialIdentifierResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3592 */
#ifndef SOAP_TYPE__ns12__GetCredentialAccessProfiles
#define SOAP_TYPE__ns12__GetCredentialAccessProfiles (1348)
/* complex XSD type 'ns12:GetCredentialAccessProfiles': */
class SOAP_CMAC _ns12__GetCredentialAccessProfiles {
      public:
        /// Required element 'ns12:CredentialToken' of XSD type 'ns13:ReferenceToken'
        std::string CredentialToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__GetCredentialAccessProfiles
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__GetCredentialAccessProfiles; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__GetCredentialAccessProfiles, default initialized and not managed by a soap context
        virtual _ns12__GetCredentialAccessProfiles *soap_alloc(void) const { return SOAP_NEW(_ns12__GetCredentialAccessProfiles); }
      public:
        /// Constructor with initializations
        _ns12__GetCredentialAccessProfiles()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__GetCredentialAccessProfiles() { }
        /// Friend allocator used by soap_new__ns12__GetCredentialAccessProfiles(struct soap*, int)
        friend SOAP_FMAC1 _ns12__GetCredentialAccessProfiles * SOAP_FMAC2 soap_instantiate__ns12__GetCredentialAccessProfiles(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3595 */
#ifndef SOAP_TYPE__ns12__GetCredentialAccessProfilesResponse
#define SOAP_TYPE__ns12__GetCredentialAccessProfilesResponse (1349)
/* complex XSD type 'ns12:GetCredentialAccessProfilesResponse': */
class SOAP_CMAC _ns12__GetCredentialAccessProfilesResponse {
      public:
        /// Optional element 'ns12:CredentialAccessProfile' of XSD type 'ns12:CredentialAccessProfile'
        std::vector<ns12__CredentialAccessProfile *> CredentialAccessProfile;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__GetCredentialAccessProfilesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__GetCredentialAccessProfilesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__GetCredentialAccessProfilesResponse, default initialized and not managed by a soap context
        virtual _ns12__GetCredentialAccessProfilesResponse *soap_alloc(void) const { return SOAP_NEW(_ns12__GetCredentialAccessProfilesResponse); }
      public:
        /// Constructor with initializations
        _ns12__GetCredentialAccessProfilesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__GetCredentialAccessProfilesResponse() { }
        /// Friend allocator used by soap_new__ns12__GetCredentialAccessProfilesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns12__GetCredentialAccessProfilesResponse * SOAP_FMAC2 soap_instantiate__ns12__GetCredentialAccessProfilesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3598 */
#ifndef SOAP_TYPE__ns12__SetCredentialAccessProfiles
#define SOAP_TYPE__ns12__SetCredentialAccessProfiles (1350)
/* complex XSD type 'ns12:SetCredentialAccessProfiles': */
class SOAP_CMAC _ns12__SetCredentialAccessProfiles {
      public:
        /// Required element 'ns12:CredentialToken' of XSD type 'ns13:ReferenceToken'
        std::string CredentialToken;
        /// Required element 'ns12:CredentialAccessProfile' of XSD type 'ns12:CredentialAccessProfile'
        std::vector<ns12__CredentialAccessProfile *> CredentialAccessProfile;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__SetCredentialAccessProfiles
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__SetCredentialAccessProfiles; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__SetCredentialAccessProfiles, default initialized and not managed by a soap context
        virtual _ns12__SetCredentialAccessProfiles *soap_alloc(void) const { return SOAP_NEW(_ns12__SetCredentialAccessProfiles); }
      public:
        /// Constructor with initializations
        _ns12__SetCredentialAccessProfiles()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__SetCredentialAccessProfiles() { }
        /// Friend allocator used by soap_new__ns12__SetCredentialAccessProfiles(struct soap*, int)
        friend SOAP_FMAC1 _ns12__SetCredentialAccessProfiles * SOAP_FMAC2 soap_instantiate__ns12__SetCredentialAccessProfiles(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3601 */
#ifndef SOAP_TYPE__ns12__SetCredentialAccessProfilesResponse
#define SOAP_TYPE__ns12__SetCredentialAccessProfilesResponse (1351)
/* complex XSD type 'ns12:SetCredentialAccessProfilesResponse': */
class SOAP_CMAC _ns12__SetCredentialAccessProfilesResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__SetCredentialAccessProfilesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__SetCredentialAccessProfilesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__SetCredentialAccessProfilesResponse, default initialized and not managed by a soap context
        virtual _ns12__SetCredentialAccessProfilesResponse *soap_alloc(void) const { return SOAP_NEW(_ns12__SetCredentialAccessProfilesResponse); }
      public:
        /// Constructor with initializations
        _ns12__SetCredentialAccessProfilesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__SetCredentialAccessProfilesResponse() { }
        /// Friend allocator used by soap_new__ns12__SetCredentialAccessProfilesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns12__SetCredentialAccessProfilesResponse * SOAP_FMAC2 soap_instantiate__ns12__SetCredentialAccessProfilesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3604 */
#ifndef SOAP_TYPE__ns12__DeleteCredentialAccessProfiles
#define SOAP_TYPE__ns12__DeleteCredentialAccessProfiles (1352)
/* complex XSD type 'ns12:DeleteCredentialAccessProfiles': */
class SOAP_CMAC _ns12__DeleteCredentialAccessProfiles {
      public:
        /// Required element 'ns12:CredentialToken' of XSD type 'ns13:ReferenceToken'
        std::string CredentialToken;
        /// Required element 'ns12:AccessProfileToken' of XSD type 'ns13:ReferenceToken'
        std::vector<std::string> AccessProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__DeleteCredentialAccessProfiles
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__DeleteCredentialAccessProfiles; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__DeleteCredentialAccessProfiles, default initialized and not managed by a soap context
        virtual _ns12__DeleteCredentialAccessProfiles *soap_alloc(void) const { return SOAP_NEW(_ns12__DeleteCredentialAccessProfiles); }
      public:
        /// Constructor with initializations
        _ns12__DeleteCredentialAccessProfiles()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__DeleteCredentialAccessProfiles() { }
        /// Friend allocator used by soap_new__ns12__DeleteCredentialAccessProfiles(struct soap*, int)
        friend SOAP_FMAC1 _ns12__DeleteCredentialAccessProfiles * SOAP_FMAC2 soap_instantiate__ns12__DeleteCredentialAccessProfiles(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3607 */
#ifndef SOAP_TYPE__ns12__DeleteCredentialAccessProfilesResponse
#define SOAP_TYPE__ns12__DeleteCredentialAccessProfilesResponse (1353)
/* complex XSD type 'ns12:DeleteCredentialAccessProfilesResponse': */
class SOAP_CMAC _ns12__DeleteCredentialAccessProfilesResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns12__DeleteCredentialAccessProfilesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns12__DeleteCredentialAccessProfilesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns12__DeleteCredentialAccessProfilesResponse, default initialized and not managed by a soap context
        virtual _ns12__DeleteCredentialAccessProfilesResponse *soap_alloc(void) const { return SOAP_NEW(_ns12__DeleteCredentialAccessProfilesResponse); }
      public:
        /// Constructor with initializations
        _ns12__DeleteCredentialAccessProfilesResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns12__DeleteCredentialAccessProfilesResponse() { }
        /// Friend allocator used by soap_new__ns12__DeleteCredentialAccessProfilesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns12__DeleteCredentialAccessProfilesResponse * SOAP_FMAC2 soap_instantiate__ns12__DeleteCredentialAccessProfilesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3610 */
#ifndef SOAP_TYPE_ns13__DataEntity
#define SOAP_TYPE_ns13__DataEntity (1354)
/* complex XSD type 'ns13:DataEntity': */
class SOAP_CMAC ns13__DataEntity {
      public:
        /// required attribute 'token' of XSD type 'ns13:ReferenceToken'
        std::string token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns13__DataEntity
        virtual int soap_type(void) const { return SOAP_TYPE_ns13__DataEntity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns13__DataEntity, default initialized and not managed by a soap context
        virtual ns13__DataEntity *soap_alloc(void) const { return SOAP_NEW(ns13__DataEntity); }
      public:
        /// Constructor with initializations
        ns13__DataEntity()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns13__DataEntity() { }
        /// Friend allocator used by soap_new_ns13__DataEntity(struct soap*, int)
        friend SOAP_FMAC1 ns13__DataEntity * SOAP_FMAC2 soap_instantiate_ns13__DataEntity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3613 */
#ifndef SOAP_TYPE_ns13__Attribute
#define SOAP_TYPE_ns13__Attribute (1355)
/* complex XSD type 'ns13:Attribute': */
class SOAP_CMAC ns13__Attribute {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// required attribute 'Name' of XSD type 'xsd:string'
        std::string Name;
        /// optional attribute 'Value' of XSD type 'xsd:string'
        std::string *Value;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns13__Attribute
        virtual int soap_type(void) const { return SOAP_TYPE_ns13__Attribute; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns13__Attribute, default initialized and not managed by a soap context
        virtual ns13__Attribute *soap_alloc(void) const { return SOAP_NEW(ns13__Attribute); }
      public:
        /// Constructor with initializations
        ns13__Attribute()
        {
          Value = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns13__Attribute() { }
        /// Friend allocator used by soap_new_ns13__Attribute(struct soap*, int)
        friend SOAP_FMAC1 ns13__Attribute * SOAP_FMAC2 soap_instantiate_ns13__Attribute(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3616 */
#ifndef SOAP_TYPE_ns14__EndpointReferenceType
#define SOAP_TYPE_ns14__EndpointReferenceType (1356)
/* complex XSD type 'ns14:EndpointReferenceType': */
class SOAP_CMAC ns14__EndpointReferenceType {
      public:
        /// Required element 'ns14:Address' of XSD type 'ns14:AttributedURIType'
        ns14__AttributedURIType *Address;
        /// Optional element 'ns14:ReferenceParameters' of XSD type 'ns14:ReferenceParametersType'
        ns14__ReferenceParametersType *ReferenceParameters;
        /// Optional element 'ns14:Metadata' of XSD type 'ns14:MetadataType'
        ns14__MetadataType *Metadata;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns14__EndpointReferenceType
        virtual int soap_type(void) const { return SOAP_TYPE_ns14__EndpointReferenceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns14__EndpointReferenceType, default initialized and not managed by a soap context
        virtual ns14__EndpointReferenceType *soap_alloc(void) const { return SOAP_NEW(ns14__EndpointReferenceType); }
      public:
        /// Constructor with initializations
        ns14__EndpointReferenceType()
        {
          Address = (ns14__AttributedURIType *)0;
          ReferenceParameters = (ns14__ReferenceParametersType *)0;
          Metadata = (ns14__MetadataType *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns14__EndpointReferenceType() { }
        /// Friend allocator used by soap_new_ns14__EndpointReferenceType(struct soap*, int)
        friend SOAP_FMAC1 ns14__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_ns14__EndpointReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3619 */
#ifndef SOAP_TYPE_ns14__ReferenceParametersType
#define SOAP_TYPE_ns14__ReferenceParametersType (1357)
/* complex XSD type 'ns14:ReferenceParametersType': */
class SOAP_CMAC ns14__ReferenceParametersType {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns14__ReferenceParametersType
        virtual int soap_type(void) const { return SOAP_TYPE_ns14__ReferenceParametersType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns14__ReferenceParametersType, default initialized and not managed by a soap context
        virtual ns14__ReferenceParametersType *soap_alloc(void) const { return SOAP_NEW(ns14__ReferenceParametersType); }
      public:
        /// Constructor with initializations
        ns14__ReferenceParametersType()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns14__ReferenceParametersType() { }
        /// Friend allocator used by soap_new_ns14__ReferenceParametersType(struct soap*, int)
        friend SOAP_FMAC1 ns14__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_ns14__ReferenceParametersType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3622 */
#ifndef SOAP_TYPE_ns14__MetadataType
#define SOAP_TYPE_ns14__MetadataType (1358)
/* complex XSD type 'ns14:MetadataType': */
class SOAP_CMAC ns14__MetadataType {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns14__MetadataType
        virtual int soap_type(void) const { return SOAP_TYPE_ns14__MetadataType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns14__MetadataType, default initialized and not managed by a soap context
        virtual ns14__MetadataType *soap_alloc(void) const { return SOAP_NEW(ns14__MetadataType); }
      public:
        /// Constructor with initializations
        ns14__MetadataType()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns14__MetadataType() { }
        /// Friend allocator used by soap_new_ns14__MetadataType(struct soap*, int)
        friend SOAP_FMAC1 ns14__MetadataType * SOAP_FMAC2 soap_instantiate_ns14__MetadataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3637 */
#ifndef SOAP_TYPE_ns14__ProblemActionType
#define SOAP_TYPE_ns14__ProblemActionType (1363)
/* complex XSD type 'ns14:ProblemActionType': */
class SOAP_CMAC ns14__ProblemActionType {
      public:
        /// Optional element 'ns14:Action' of XSD type 'ns14:AttributedURIType'
        ns14__AttributedURIType *Action;
        /// Optional element 'ns14:SoapAction' of XSD type 'xsd:anyURI'
        std::string *SoapAction;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns14__ProblemActionType
        virtual int soap_type(void) const { return SOAP_TYPE_ns14__ProblemActionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns14__ProblemActionType, default initialized and not managed by a soap context
        virtual ns14__ProblemActionType *soap_alloc(void) const { return SOAP_NEW(ns14__ProblemActionType); }
      public:
        /// Constructor with initializations
        ns14__ProblemActionType()
        {
          Action = (ns14__AttributedURIType *)0;
          SoapAction = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns14__ProblemActionType() { }
        /// Friend allocator used by soap_new_ns14__ProblemActionType(struct soap*, int)
        friend SOAP_FMAC1 ns14__ProblemActionType * SOAP_FMAC2 soap_instantiate_ns14__ProblemActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:298 */
#ifndef SOAP_TYPE_ns1__StorageConfiguration
#define SOAP_TYPE_ns1__StorageConfiguration (250)
/* Type ns1__StorageConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:StorageConfiguration': */
class SOAP_CMAC ns1__StorageConfiguration : public ns2__DeviceEntity {
      public:
        /// Required element 'ns1:Data' of XSD type 'ns1:StorageConfigurationData'
        ns1__StorageConfigurationData *Data;
      public:
        /// Return unique type id SOAP_TYPE_ns1__StorageConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__StorageConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__StorageConfiguration, default initialized and not managed by a soap context
        virtual ns1__StorageConfiguration *soap_alloc(void) const { return SOAP_NEW(ns1__StorageConfiguration); }
      public:
        /// Constructor with initializations
        ns1__StorageConfiguration()
        {
          Data = (ns1__StorageConfigurationData *)0;
        }
        virtual ~ns1__StorageConfiguration() { }
        /// Friend allocator used by soap_new_ns1__StorageConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns1__StorageConfiguration * SOAP_FMAC2 soap_instantiate_ns1__StorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:850 */
#ifndef SOAP_TYPE_ns2__VideoSource
#define SOAP_TYPE_ns2__VideoSource (434)
/* Type ns2__VideoSource is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:VideoSource': */
class SOAP_CMAC ns2__VideoSource : public ns2__DeviceEntity {
      public:
        /// Required element 'ns2:Framerate' of XSD type 'xsd:float'
        float Framerate;
        /// Required element 'ns2:Resolution' of XSD type 'ns2:VideoResolution'
        ns2__VideoResolution *Resolution;
        /// Optional element 'ns2:Imaging' of XSD type 'ns2:ImagingSettings'
        ns2__ImagingSettings *Imaging;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:VideoSourceExtension'
        ns2__VideoSourceExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoSource
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoSource; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoSource, default initialized and not managed by a soap context
        virtual ns2__VideoSource *soap_alloc(void) const { return SOAP_NEW(ns2__VideoSource); }
      public:
        /// Constructor with initializations
        ns2__VideoSource()
        {
          Framerate = (float)0;
          Resolution = (ns2__VideoResolution *)0;
          Imaging = (ns2__ImagingSettings *)0;
          Extension = (ns2__VideoSourceExtension *)0;
        }
        virtual ~ns2__VideoSource() { }
        /// Friend allocator used by soap_new_ns2__VideoSource(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoSource * SOAP_FMAC2 soap_instantiate_ns2__VideoSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:859 */
#ifndef SOAP_TYPE_ns2__AudioSource
#define SOAP_TYPE_ns2__AudioSource (437)
/* Type ns2__AudioSource is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:AudioSource': */
class SOAP_CMAC ns2__AudioSource : public ns2__DeviceEntity {
      public:
        /// Required element 'ns2:Channels' of XSD type 'xsd:int'
        int Channels;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AudioSource
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AudioSource; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AudioSource, default initialized and not managed by a soap context
        virtual ns2__AudioSource *soap_alloc(void) const { return SOAP_NEW(ns2__AudioSource); }
      public:
        /// Constructor with initializations
        ns2__AudioSource()
        {
          Channels = (int)0;
        }
        virtual ~ns2__AudioSource() { }
        /// Friend allocator used by soap_new_ns2__AudioSource(struct soap*, int)
        friend SOAP_FMAC1 ns2__AudioSource * SOAP_FMAC2 soap_instantiate_ns2__AudioSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:874 */
#ifndef SOAP_TYPE_ns2__VideoSourceConfiguration
#define SOAP_TYPE_ns2__VideoSourceConfiguration (442)
/* Type ns2__VideoSourceConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:VideoSourceConfiguration': */
class SOAP_CMAC ns2__VideoSourceConfiguration : public ns2__ConfigurationEntity {
      public:
        /// Required element 'ns2:SourceToken' of XSD type 'ns2:ReferenceToken'
        std::string SourceToken;
        /// Required element 'ns2:Bounds' of XSD type 'ns2:IntRectangle'
        ns2__IntRectangle *Bounds;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:VideoSourceConfigurationExtension'
        ns2__VideoSourceConfigurationExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoSourceConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoSourceConfiguration, default initialized and not managed by a soap context
        virtual ns2__VideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__VideoSourceConfiguration); }
      public:
        /// Constructor with initializations
        ns2__VideoSourceConfiguration()
        {
          Bounds = (ns2__IntRectangle *)0;
          Extension = (ns2__VideoSourceConfigurationExtension *)0;
        }
        virtual ~ns2__VideoSourceConfiguration() { }
        /// Friend allocator used by soap_new_ns2__VideoSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoSourceConfiguration * SOAP_FMAC2 soap_instantiate_ns2__VideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:913 */
#ifndef SOAP_TYPE_ns2__VideoEncoderConfiguration
#define SOAP_TYPE_ns2__VideoEncoderConfiguration (455)
/* Type ns2__VideoEncoderConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:VideoEncoderConfiguration': */
class SOAP_CMAC ns2__VideoEncoderConfiguration : public ns2__ConfigurationEntity {
      public:
        /// Required element 'ns2:Encoding' of XSD type 'ns2:VideoEncoding'
        ns2__VideoEncoding Encoding;
        /// Required element 'ns2:Resolution' of XSD type 'ns2:VideoResolution'
        ns2__VideoResolution *Resolution;
        /// Required element 'ns2:Quality' of XSD type 'xsd:float'
        float Quality;
        /// Optional element 'ns2:RateControl' of XSD type 'ns2:VideoRateControl'
        ns2__VideoRateControl *RateControl;
        /// Optional element 'ns2:MPEG4' of XSD type 'ns2:Mpeg4Configuration'
        ns2__Mpeg4Configuration *MPEG4;
        /// Optional element 'ns2:H264' of XSD type 'ns2:H264Configuration'
        ns2__H264Configuration *H264;
        /// Required element 'ns2:Multicast' of XSD type 'ns2:MulticastConfiguration'
        ns2__MulticastConfiguration *Multicast;
        /// Required element 'ns2:SessionTimeout' of XSD type 'xsd:duration'
        std::string SessionTimeout;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoEncoderConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoEncoderConfiguration, default initialized and not managed by a soap context
        virtual ns2__VideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__VideoEncoderConfiguration); }
      public:
        /// Constructor with initializations
        ns2__VideoEncoderConfiguration()
        {
          Encoding = (ns2__VideoEncoding)0;
          Resolution = (ns2__VideoResolution *)0;
          Quality = (float)0;
          RateControl = (ns2__VideoRateControl *)0;
          MPEG4 = (ns2__Mpeg4Configuration *)0;
          H264 = (ns2__H264Configuration *)0;
          Multicast = (ns2__MulticastConfiguration *)0;
        }
        virtual ~ns2__VideoEncoderConfiguration() { }
        /// Friend allocator used by soap_new_ns2__VideoEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate_ns2__VideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:940 */
#ifndef SOAP_TYPE_ns2__JpegOptions2
#define SOAP_TYPE_ns2__JpegOptions2 (464)
/* Type ns2__JpegOptions2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:JpegOptions2': */
class SOAP_CMAC ns2__JpegOptions2 : public ns2__JpegOptions {
      public:
        /// Required element 'ns2:BitrateRange' of XSD type 'ns2:IntRange'
        ns2__IntRange *BitrateRange;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__JpegOptions2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__JpegOptions2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__JpegOptions2, default initialized and not managed by a soap context
        virtual ns2__JpegOptions2 *soap_alloc(void) const { return SOAP_NEW(ns2__JpegOptions2); }
      public:
        /// Constructor with initializations
        ns2__JpegOptions2()
        {
          BitrateRange = (ns2__IntRange *)0;
        }
        virtual ~ns2__JpegOptions2() { }
        /// Friend allocator used by soap_new_ns2__JpegOptions2(struct soap*, int)
        friend SOAP_FMAC1 ns2__JpegOptions2 * SOAP_FMAC2 soap_instantiate_ns2__JpegOptions2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:946 */
#ifndef SOAP_TYPE_ns2__Mpeg4Options2
#define SOAP_TYPE_ns2__Mpeg4Options2 (466)
/* Type ns2__Mpeg4Options2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:Mpeg4Options2': */
class SOAP_CMAC ns2__Mpeg4Options2 : public ns2__Mpeg4Options {
      public:
        /// Required element 'ns2:BitrateRange' of XSD type 'ns2:IntRange'
        ns2__IntRange *BitrateRange;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Mpeg4Options2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Mpeg4Options2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Mpeg4Options2, default initialized and not managed by a soap context
        virtual ns2__Mpeg4Options2 *soap_alloc(void) const { return SOAP_NEW(ns2__Mpeg4Options2); }
      public:
        /// Constructor with initializations
        ns2__Mpeg4Options2()
        {
          BitrateRange = (ns2__IntRange *)0;
        }
        virtual ~ns2__Mpeg4Options2() { }
        /// Friend allocator used by soap_new_ns2__Mpeg4Options2(struct soap*, int)
        friend SOAP_FMAC1 ns2__Mpeg4Options2 * SOAP_FMAC2 soap_instantiate_ns2__Mpeg4Options2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:952 */
#ifndef SOAP_TYPE_ns2__H264Options2
#define SOAP_TYPE_ns2__H264Options2 (468)
/* Type ns2__H264Options2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:H264Options2': */
class SOAP_CMAC ns2__H264Options2 : public ns2__H264Options {
      public:
        /// Required element 'ns2:BitrateRange' of XSD type 'ns2:IntRange'
        ns2__IntRange *BitrateRange;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__H264Options2
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__H264Options2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__H264Options2, default initialized and not managed by a soap context
        virtual ns2__H264Options2 *soap_alloc(void) const { return SOAP_NEW(ns2__H264Options2); }
      public:
        /// Constructor with initializations
        ns2__H264Options2()
        {
          BitrateRange = (ns2__IntRange *)0;
        }
        virtual ~ns2__H264Options2() { }
        /// Friend allocator used by soap_new_ns2__H264Options2(struct soap*, int)
        friend SOAP_FMAC1 ns2__H264Options2 * SOAP_FMAC2 soap_instantiate_ns2__H264Options2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:955 */
#ifndef SOAP_TYPE_ns2__VideoEncoder2Configuration
#define SOAP_TYPE_ns2__VideoEncoder2Configuration (469)
/* Type ns2__VideoEncoder2Configuration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:VideoEncoder2Configuration': */
class SOAP_CMAC ns2__VideoEncoder2Configuration : public ns2__ConfigurationEntity {
      public:
        /// Required element 'ns2:Encoding' of XSD type 'xsd:string'
        std::string Encoding;
        /// Required element 'ns2:Resolution' of XSD type 'ns2:VideoResolution2'
        ns2__VideoResolution2 *Resolution;
        /// Optional element 'ns2:RateControl' of XSD type 'ns2:VideoRateControl2'
        ns2__VideoRateControl2 *RateControl;
        /// Optional element 'ns2:Multicast' of XSD type 'ns2:MulticastConfiguration'
        ns2__MulticastConfiguration *Multicast;
        /// Required element 'ns2:Quality' of XSD type 'xsd:float'
        float Quality;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// optional attribute 'GovLength' of XSD type 'xsd:int'
        int *GovLength;
        /// optional attribute 'Profile' of XSD type 'xsd:string'
        std::string *Profile;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoEncoder2Configuration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoEncoder2Configuration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoEncoder2Configuration, default initialized and not managed by a soap context
        virtual ns2__VideoEncoder2Configuration *soap_alloc(void) const { return SOAP_NEW(ns2__VideoEncoder2Configuration); }
      public:
        /// Constructor with initializations
        ns2__VideoEncoder2Configuration()
        {
          Resolution = (ns2__VideoResolution2 *)0;
          RateControl = (ns2__VideoRateControl2 *)0;
          Multicast = (ns2__MulticastConfiguration *)0;
          Quality = (float)0;
          GovLength = (int *)0;
          Profile = (std::string *)0;
        }
        virtual ~ns2__VideoEncoder2Configuration() { }
        /// Friend allocator used by soap_new_ns2__VideoEncoder2Configuration(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoEncoder2Configuration * SOAP_FMAC2 soap_instantiate_ns2__VideoEncoder2Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:967 */
#ifndef SOAP_TYPE_ns2__AudioSourceConfiguration
#define SOAP_TYPE_ns2__AudioSourceConfiguration (473)
/* Type ns2__AudioSourceConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:AudioSourceConfiguration': */
class SOAP_CMAC ns2__AudioSourceConfiguration : public ns2__ConfigurationEntity {
      public:
        /// Required element 'ns2:SourceToken' of XSD type 'ns2:ReferenceToken'
        std::string SourceToken;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AudioSourceConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AudioSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AudioSourceConfiguration, default initialized and not managed by a soap context
        virtual ns2__AudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__AudioSourceConfiguration); }
      public:
        /// Constructor with initializations
        ns2__AudioSourceConfiguration()
        {
        }
        virtual ~ns2__AudioSourceConfiguration() { }
        /// Friend allocator used by soap_new_ns2__AudioSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__AudioSourceConfiguration * SOAP_FMAC2 soap_instantiate_ns2__AudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:976 */
#ifndef SOAP_TYPE_ns2__AudioEncoderConfiguration
#define SOAP_TYPE_ns2__AudioEncoderConfiguration (476)
/* Type ns2__AudioEncoderConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:AudioEncoderConfiguration': */
class SOAP_CMAC ns2__AudioEncoderConfiguration : public ns2__ConfigurationEntity {
      public:
        /// Required element 'ns2:Encoding' of XSD type 'ns2:AudioEncoding'
        ns2__AudioEncoding Encoding;
        /// Required element 'ns2:Bitrate' of XSD type 'xsd:int'
        int Bitrate;
        /// Required element 'ns2:SampleRate' of XSD type 'xsd:int'
        int SampleRate;
        /// Required element 'ns2:Multicast' of XSD type 'ns2:MulticastConfiguration'
        ns2__MulticastConfiguration *Multicast;
        /// Required element 'ns2:SessionTimeout' of XSD type 'xsd:duration'
        std::string SessionTimeout;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AudioEncoderConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AudioEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AudioEncoderConfiguration, default initialized and not managed by a soap context
        virtual ns2__AudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__AudioEncoderConfiguration); }
      public:
        /// Constructor with initializations
        ns2__AudioEncoderConfiguration()
        {
          Encoding = (ns2__AudioEncoding)0;
          Bitrate = (int)0;
          SampleRate = (int)0;
          Multicast = (ns2__MulticastConfiguration *)0;
        }
        virtual ~ns2__AudioEncoderConfiguration() { }
        /// Friend allocator used by soap_new_ns2__AudioEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__AudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate_ns2__AudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:985 */
#ifndef SOAP_TYPE_ns2__AudioEncoder2Configuration
#define SOAP_TYPE_ns2__AudioEncoder2Configuration (479)
/* Type ns2__AudioEncoder2Configuration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:AudioEncoder2Configuration': */
class SOAP_CMAC ns2__AudioEncoder2Configuration : public ns2__ConfigurationEntity {
      public:
        /// Required element 'ns2:Encoding' of XSD type 'xsd:string'
        std::string Encoding;
        /// Optional element 'ns2:Multicast' of XSD type 'ns2:MulticastConfiguration'
        ns2__MulticastConfiguration *Multicast;
        /// Required element 'ns2:Bitrate' of XSD type 'xsd:int'
        int Bitrate;
        /// Required element 'ns2:SampleRate' of XSD type 'xsd:int'
        int SampleRate;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AudioEncoder2Configuration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AudioEncoder2Configuration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AudioEncoder2Configuration, default initialized and not managed by a soap context
        virtual ns2__AudioEncoder2Configuration *soap_alloc(void) const { return SOAP_NEW(ns2__AudioEncoder2Configuration); }
      public:
        /// Constructor with initializations
        ns2__AudioEncoder2Configuration()
        {
          Multicast = (ns2__MulticastConfiguration *)0;
          Bitrate = (int)0;
          SampleRate = (int)0;
        }
        virtual ~ns2__AudioEncoder2Configuration() { }
        /// Friend allocator used by soap_new_ns2__AudioEncoder2Configuration(struct soap*, int)
        friend SOAP_FMAC1 ns2__AudioEncoder2Configuration * SOAP_FMAC2 soap_instantiate_ns2__AudioEncoder2Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:991 */
#ifndef SOAP_TYPE_ns2__VideoAnalyticsConfiguration
#define SOAP_TYPE_ns2__VideoAnalyticsConfiguration (481)
/* Type ns2__VideoAnalyticsConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:VideoAnalyticsConfiguration': */
class SOAP_CMAC ns2__VideoAnalyticsConfiguration : public ns2__ConfigurationEntity {
      public:
        /// Required element 'ns2:AnalyticsEngineConfiguration' of XSD type 'ns2:AnalyticsEngineConfiguration'
        ns2__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration;
        /// Required element 'ns2:RuleEngineConfiguration' of XSD type 'ns2:RuleEngineConfiguration'
        ns2__RuleEngineConfiguration *RuleEngineConfiguration;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoAnalyticsConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoAnalyticsConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoAnalyticsConfiguration, default initialized and not managed by a soap context
        virtual ns2__VideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__VideoAnalyticsConfiguration); }
      public:
        /// Constructor with initializations
        ns2__VideoAnalyticsConfiguration()
        {
          AnalyticsEngineConfiguration = (ns2__AnalyticsEngineConfiguration *)0;
          RuleEngineConfiguration = (ns2__RuleEngineConfiguration *)0;
        }
        virtual ~ns2__VideoAnalyticsConfiguration() { }
        /// Friend allocator used by soap_new_ns2__VideoAnalyticsConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate_ns2__VideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:994 */
#ifndef SOAP_TYPE_ns2__MetadataConfiguration
#define SOAP_TYPE_ns2__MetadataConfiguration (482)
/* Type ns2__MetadataConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:MetadataConfiguration': */
class SOAP_CMAC ns2__MetadataConfiguration : public ns2__ConfigurationEntity {
      public:
        /// Optional element 'ns2:PTZStatus' of XSD type 'ns2:PTZFilter'
        ns2__PTZFilter *PTZStatus;
        /// Optional element 'ns2:Events' of XSD type 'ns2:EventSubscription'
        ns2__EventSubscription *Events;
        /// Optional element 'ns2:Analytics' of XSD type 'xsd:boolean'
        bool *Analytics;
        /// Required element 'ns2:Multicast' of XSD type 'ns2:MulticastConfiguration'
        ns2__MulticastConfiguration *Multicast;
        /// Required element 'ns2:SessionTimeout' of XSD type 'xsd:duration'
        std::string SessionTimeout;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional element 'ns2:AnalyticsEngineConfiguration' of XSD type 'ns2:AnalyticsEngineConfiguration'
        ns2__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:MetadataConfigurationExtension'
        ns2__MetadataConfigurationExtension *Extension;
        /// optional attribute 'CompressionType' of XSD type 'xsd:string'
        std::string *CompressionType;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MetadataConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MetadataConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MetadataConfiguration, default initialized and not managed by a soap context
        virtual ns2__MetadataConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__MetadataConfiguration); }
      public:
        /// Constructor with initializations
        ns2__MetadataConfiguration()
        {
          PTZStatus = (ns2__PTZFilter *)0;
          Events = (ns2__EventSubscription *)0;
          Analytics = (bool *)0;
          Multicast = (ns2__MulticastConfiguration *)0;
          AnalyticsEngineConfiguration = (ns2__AnalyticsEngineConfiguration *)0;
          Extension = (ns2__MetadataConfigurationExtension *)0;
          CompressionType = (std::string *)0;
        }
        virtual ~ns2__MetadataConfiguration() { }
        /// Friend allocator used by soap_new_ns2__MetadataConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__MetadataConfiguration * SOAP_FMAC2 soap_instantiate_ns2__MetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1021 */
#ifndef SOAP_TYPE_ns2__VideoOutput
#define SOAP_TYPE_ns2__VideoOutput (491)
/* Type ns2__VideoOutput is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:VideoOutput': */
class SOAP_CMAC ns2__VideoOutput : public ns2__DeviceEntity {
      public:
        /// Required element 'ns2:Layout' of XSD type 'ns2:Layout'
        ns2__Layout *Layout;
        /// Optional element 'ns2:Resolution' of XSD type 'ns2:VideoResolution'
        ns2__VideoResolution *Resolution;
        /// Optional element 'ns2:RefreshRate' of XSD type 'xsd:float'
        float *RefreshRate;
        /// Optional element 'ns2:AspectRatio' of XSD type 'xsd:float'
        float *AspectRatio;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:VideoOutputExtension'
        ns2__VideoOutputExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoOutput
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoOutput; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoOutput, default initialized and not managed by a soap context
        virtual ns2__VideoOutput *soap_alloc(void) const { return SOAP_NEW(ns2__VideoOutput); }
      public:
        /// Constructor with initializations
        ns2__VideoOutput()
        {
          Layout = (ns2__Layout *)0;
          Resolution = (ns2__VideoResolution *)0;
          RefreshRate = (float *)0;
          AspectRatio = (float *)0;
          Extension = (ns2__VideoOutputExtension *)0;
        }
        virtual ~ns2__VideoOutput() { }
        /// Friend allocator used by soap_new_ns2__VideoOutput(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoOutput * SOAP_FMAC2 soap_instantiate_ns2__VideoOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1027 */
#ifndef SOAP_TYPE_ns2__VideoOutputConfiguration
#define SOAP_TYPE_ns2__VideoOutputConfiguration (493)
/* Type ns2__VideoOutputConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:VideoOutputConfiguration': */
class SOAP_CMAC ns2__VideoOutputConfiguration : public ns2__ConfigurationEntity {
      public:
        /// Required element 'ns2:OutputToken' of XSD type 'ns2:ReferenceToken'
        std::string OutputToken;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VideoOutputConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VideoOutputConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VideoOutputConfiguration, default initialized and not managed by a soap context
        virtual ns2__VideoOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__VideoOutputConfiguration); }
      public:
        /// Constructor with initializations
        ns2__VideoOutputConfiguration()
        {
        }
        virtual ~ns2__VideoOutputConfiguration() { }
        /// Friend allocator used by soap_new_ns2__VideoOutputConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__VideoOutputConfiguration * SOAP_FMAC2 soap_instantiate_ns2__VideoOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1048 */
#ifndef SOAP_TYPE_ns2__AudioOutput
#define SOAP_TYPE_ns2__AudioOutput (500)
/* Type ns2__AudioOutput is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:AudioOutput': */
class SOAP_CMAC ns2__AudioOutput : public ns2__DeviceEntity {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AudioOutput
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AudioOutput; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AudioOutput, default initialized and not managed by a soap context
        virtual ns2__AudioOutput *soap_alloc(void) const { return SOAP_NEW(ns2__AudioOutput); }
      public:
        /// Constructor with initializations
        ns2__AudioOutput()
        {
        }
        virtual ~ns2__AudioOutput() { }
        /// Friend allocator used by soap_new_ns2__AudioOutput(struct soap*, int)
        friend SOAP_FMAC1 ns2__AudioOutput * SOAP_FMAC2 soap_instantiate_ns2__AudioOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1051 */
#ifndef SOAP_TYPE_ns2__AudioOutputConfiguration
#define SOAP_TYPE_ns2__AudioOutputConfiguration (501)
/* Type ns2__AudioOutputConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:AudioOutputConfiguration': */
class SOAP_CMAC ns2__AudioOutputConfiguration : public ns2__ConfigurationEntity {
      public:
        /// Required element 'ns2:OutputToken' of XSD type 'ns2:ReferenceToken'
        std::string OutputToken;
        /// Optional element 'ns2:SendPrimacy' of XSD type 'xsd:anyURI'
        std::string *SendPrimacy;
        /// Required element 'ns2:OutputLevel' of XSD type 'xsd:int'
        int OutputLevel;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AudioOutputConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AudioOutputConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AudioOutputConfiguration, default initialized and not managed by a soap context
        virtual ns2__AudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__AudioOutputConfiguration); }
      public:
        /// Constructor with initializations
        ns2__AudioOutputConfiguration()
        {
          SendPrimacy = (std::string *)0;
          OutputLevel = (int)0;
        }
        virtual ~ns2__AudioOutputConfiguration() { }
        /// Friend allocator used by soap_new_ns2__AudioOutputConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__AudioOutputConfiguration * SOAP_FMAC2 soap_instantiate_ns2__AudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1057 */
#ifndef SOAP_TYPE_ns2__AudioDecoderConfiguration
#define SOAP_TYPE_ns2__AudioDecoderConfiguration (503)
/* Type ns2__AudioDecoderConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:AudioDecoderConfiguration': */
class SOAP_CMAC ns2__AudioDecoderConfiguration : public ns2__ConfigurationEntity {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AudioDecoderConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AudioDecoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AudioDecoderConfiguration, default initialized and not managed by a soap context
        virtual ns2__AudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__AudioDecoderConfiguration); }
      public:
        /// Constructor with initializations
        ns2__AudioDecoderConfiguration()
        {
        }
        virtual ~ns2__AudioDecoderConfiguration() { }
        /// Friend allocator used by soap_new_ns2__AudioDecoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__AudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate_ns2__AudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1090 */
#ifndef SOAP_TYPE_ns2__NetworkInterface
#define SOAP_TYPE_ns2__NetworkInterface (514)
/* Type ns2__NetworkInterface is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:NetworkInterface': */
class SOAP_CMAC ns2__NetworkInterface : public ns2__DeviceEntity {
      public:
        /// Required element 'ns2:Enabled' of XSD type 'xsd:boolean'
        bool Enabled;
        /// Optional element 'ns2:Info' of XSD type 'ns2:NetworkInterfaceInfo'
        ns2__NetworkInterfaceInfo *Info;
        /// Optional element 'ns2:Link' of XSD type 'ns2:NetworkInterfaceLink'
        ns2__NetworkInterfaceLink *Link;
        /// Optional element 'ns2:IPv4' of XSD type 'ns2:IPv4NetworkInterface'
        ns2__IPv4NetworkInterface *IPv4;
        /// Optional element 'ns2:IPv6' of XSD type 'ns2:IPv6NetworkInterface'
        ns2__IPv6NetworkInterface *IPv6;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:NetworkInterfaceExtension'
        ns2__NetworkInterfaceExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NetworkInterface
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NetworkInterface; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NetworkInterface, default initialized and not managed by a soap context
        virtual ns2__NetworkInterface *soap_alloc(void) const { return SOAP_NEW(ns2__NetworkInterface); }
      public:
        /// Constructor with initializations
        ns2__NetworkInterface()
        {
          Enabled = (bool)0;
          Info = (ns2__NetworkInterfaceInfo *)0;
          Link = (ns2__NetworkInterfaceLink *)0;
          IPv4 = (ns2__IPv4NetworkInterface *)0;
          IPv6 = (ns2__IPv6NetworkInterface *)0;
          Extension = (ns2__NetworkInterfaceExtension *)0;
        }
        virtual ~ns2__NetworkInterface() { }
        /// Friend allocator used by soap_new_ns2__NetworkInterface(struct soap*, int)
        friend SOAP_FMAC1 ns2__NetworkInterface * SOAP_FMAC2 soap_instantiate_ns2__NetworkInterface(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1402 */
#ifndef SOAP_TYPE_ns2__CertificateUsage
#define SOAP_TYPE_ns2__CertificateUsage (618)
/* simple XSD type 'ns2:CertificateUsage': */
class SOAP_CMAC ns2__CertificateUsage {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        std::string __item;
        /// required attribute 'Critical' of XSD type 'xsd:boolean'
        bool Critical;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CertificateUsage
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CertificateUsage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CertificateUsage, default initialized and not managed by a soap context
        virtual ns2__CertificateUsage *soap_alloc(void) const { return SOAP_NEW(ns2__CertificateUsage); }
      public:
        /// Constructor with initializations
        ns2__CertificateUsage()
        {
          Critical = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CertificateUsage() { }
        /// Friend allocator used by soap_new_ns2__CertificateUsage(struct soap*, int)
        friend SOAP_FMAC1 ns2__CertificateUsage * SOAP_FMAC2 soap_instantiate_ns2__CertificateUsage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1429 */
#ifndef SOAP_TYPE_ns2__RelayOutput
#define SOAP_TYPE_ns2__RelayOutput (627)
/* Type ns2__RelayOutput is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:RelayOutput': */
class SOAP_CMAC ns2__RelayOutput : public ns2__DeviceEntity {
      public:
        /// Required element 'ns2:Properties' of XSD type 'ns2:RelayOutputSettings'
        ns2__RelayOutputSettings *Properties;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RelayOutput
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RelayOutput; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RelayOutput, default initialized and not managed by a soap context
        virtual ns2__RelayOutput *soap_alloc(void) const { return SOAP_NEW(ns2__RelayOutput); }
      public:
        /// Constructor with initializations
        ns2__RelayOutput()
        {
          Properties = (ns2__RelayOutputSettings *)0;
        }
        virtual ~ns2__RelayOutput() { }
        /// Friend allocator used by soap_new_ns2__RelayOutput(struct soap*, int)
        friend SOAP_FMAC1 ns2__RelayOutput * SOAP_FMAC2 soap_instantiate_ns2__RelayOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1432 */
#ifndef SOAP_TYPE_ns2__DigitalInput
#define SOAP_TYPE_ns2__DigitalInput (628)
/* Type ns2__DigitalInput is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:DigitalInput': */
class SOAP_CMAC ns2__DigitalInput : public ns2__DeviceEntity {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// optional attribute 'IdleState' of XSD type 'ns2:DigitalIdleState'
        ns2__DigitalIdleState *IdleState;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DigitalInput
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DigitalInput; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DigitalInput, default initialized and not managed by a soap context
        virtual ns2__DigitalInput *soap_alloc(void) const { return SOAP_NEW(ns2__DigitalInput); }
      public:
        /// Constructor with initializations
        ns2__DigitalInput()
        {
          IdleState = (ns2__DigitalIdleState *)0;
        }
        virtual ~ns2__DigitalInput() { }
        /// Friend allocator used by soap_new_ns2__DigitalInput(struct soap*, int)
        friend SOAP_FMAC1 ns2__DigitalInput * SOAP_FMAC2 soap_instantiate_ns2__DigitalInput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1435 */
#ifndef SOAP_TYPE_ns2__PTZNode
#define SOAP_TYPE_ns2__PTZNode (629)
/* Type ns2__PTZNode is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:PTZNode': */
class SOAP_CMAC ns2__PTZNode : public ns2__DeviceEntity {
      public:
        /// Optional element 'ns2:Name' of XSD type 'ns2:Name'
        std::string *Name;
        /// Required element 'ns2:SupportedPTZSpaces' of XSD type 'ns2:PTZSpaces'
        ns2__PTZSpaces *SupportedPTZSpaces;
        /// Required element 'ns2:MaximumNumberOfPresets' of XSD type 'xsd:int'
        int MaximumNumberOfPresets;
        /// Required element 'ns2:HomeSupported' of XSD type 'xsd:boolean'
        bool HomeSupported;
        /// Optional element 'ns2:AuxiliaryCommands' of XSD type 'ns2:AuxiliaryData'
        std::vector<std::string> AuxiliaryCommands;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:PTZNodeExtension'
        ns2__PTZNodeExtension *Extension;
        /// optional attribute 'FixedHomePosition' of XSD type 'xsd:boolean'
        bool *FixedHomePosition;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZNode
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZNode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZNode, default initialized and not managed by a soap context
        virtual ns2__PTZNode *soap_alloc(void) const { return SOAP_NEW(ns2__PTZNode); }
      public:
        /// Constructor with initializations
        ns2__PTZNode()
        {
          Name = (std::string *)0;
          SupportedPTZSpaces = (ns2__PTZSpaces *)0;
          MaximumNumberOfPresets = (int)0;
          HomeSupported = (bool)0;
          Extension = (ns2__PTZNodeExtension *)0;
          FixedHomePosition = (bool *)0;
        }
        virtual ~ns2__PTZNode() { }
        /// Friend allocator used by soap_new_ns2__PTZNode(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZNode * SOAP_FMAC2 soap_instantiate_ns2__PTZNode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1450 */
#ifndef SOAP_TYPE_ns2__PTZConfiguration
#define SOAP_TYPE_ns2__PTZConfiguration (634)
/* Type ns2__PTZConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:PTZConfiguration': */
class SOAP_CMAC ns2__PTZConfiguration : public ns2__ConfigurationEntity {
      public:
        /// Required element 'ns2:NodeToken' of XSD type 'ns2:ReferenceToken'
        std::string NodeToken;
        /// Optional element 'ns2:DefaultAbsolutePantTiltPositionSpace' of XSD type 'xsd:anyURI'
        std::string *DefaultAbsolutePantTiltPositionSpace;
        /// Optional element 'ns2:DefaultAbsoluteZoomPositionSpace' of XSD type 'xsd:anyURI'
        std::string *DefaultAbsoluteZoomPositionSpace;
        /// Optional element 'ns2:DefaultRelativePanTiltTranslationSpace' of XSD type 'xsd:anyURI'
        std::string *DefaultRelativePanTiltTranslationSpace;
        /// Optional element 'ns2:DefaultRelativeZoomTranslationSpace' of XSD type 'xsd:anyURI'
        std::string *DefaultRelativeZoomTranslationSpace;
        /// Optional element 'ns2:DefaultContinuousPanTiltVelocitySpace' of XSD type 'xsd:anyURI'
        std::string *DefaultContinuousPanTiltVelocitySpace;
        /// Optional element 'ns2:DefaultContinuousZoomVelocitySpace' of XSD type 'xsd:anyURI'
        std::string *DefaultContinuousZoomVelocitySpace;
        /// Optional element 'ns2:DefaultPTZSpeed' of XSD type 'ns2:PTZSpeed'
        ns2__PTZSpeed *DefaultPTZSpeed;
        /// Optional element 'ns2:DefaultPTZTimeout' of XSD type 'xsd:duration'
        std::string *DefaultPTZTimeout;
        /// Optional element 'ns2:PanTiltLimits' of XSD type 'ns2:PanTiltLimits'
        ns2__PanTiltLimits *PanTiltLimits;
        /// Optional element 'ns2:ZoomLimits' of XSD type 'ns2:ZoomLimits'
        ns2__ZoomLimits *ZoomLimits;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:PTZConfigurationExtension'
        ns2__PTZConfigurationExtension *Extension;
        /// optional attribute 'MoveRamp' of XSD type 'xsd:int'
        int *MoveRamp;
        /// optional attribute 'PresetRamp' of XSD type 'xsd:int'
        int *PresetRamp;
        /// optional attribute 'PresetTourRamp' of XSD type 'xsd:int'
        int *PresetTourRamp;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PTZConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PTZConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PTZConfiguration, default initialized and not managed by a soap context
        virtual ns2__PTZConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__PTZConfiguration); }
      public:
        /// Constructor with initializations
        ns2__PTZConfiguration()
        {
          DefaultAbsolutePantTiltPositionSpace = (std::string *)0;
          DefaultAbsoluteZoomPositionSpace = (std::string *)0;
          DefaultRelativePanTiltTranslationSpace = (std::string *)0;
          DefaultRelativeZoomTranslationSpace = (std::string *)0;
          DefaultContinuousPanTiltVelocitySpace = (std::string *)0;
          DefaultContinuousZoomVelocitySpace = (std::string *)0;
          DefaultPTZSpeed = (ns2__PTZSpeed *)0;
          DefaultPTZTimeout = (std::string *)0;
          PanTiltLimits = (ns2__PanTiltLimits *)0;
          ZoomLimits = (ns2__ZoomLimits *)0;
          Extension = (ns2__PTZConfigurationExtension *)0;
          MoveRamp = (int *)0;
          PresetRamp = (int *)0;
          PresetTourRamp = (int *)0;
        }
        virtual ~ns2__PTZConfiguration() { }
        /// Friend allocator used by soap_new_ns2__PTZConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__PTZConfiguration * SOAP_FMAC2 soap_instantiate_ns2__PTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:1858 */
#ifndef SOAP_TYPE_ns2__Object
#define SOAP_TYPE_ns2__Object (770)
/* Type ns2__Object is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:Object': */
class SOAP_CMAC ns2__Object : public ns2__ObjectId {
      public:
        /// Optional element 'ns2:Appearance' of XSD type 'ns2:Appearance'
        ns2__Appearance *Appearance;
        /// Optional element 'ns2:Behaviour' of XSD type 'ns2:Behaviour'
        ns2__Behaviour *Behaviour;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:ObjectExtension'
        ns2__ObjectExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Object
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Object; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Object, default initialized and not managed by a soap context
        virtual ns2__Object *soap_alloc(void) const { return SOAP_NEW(ns2__Object); }
      public:
        /// Constructor with initializations
        ns2__Object()
        {
          Appearance = (ns2__Appearance *)0;
          Behaviour = (ns2__Behaviour *)0;
          Extension = (ns2__ObjectExtension *)0;
        }
        virtual ~ns2__Object() { }
        /// Friend allocator used by soap_new_ns2__Object(struct soap*, int)
        friend SOAP_FMAC1 ns2__Object * SOAP_FMAC2 soap_instantiate_ns2__Object(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2047 */
#ifndef SOAP_TYPE_ns2__EventFilter
#define SOAP_TYPE_ns2__EventFilter (833)
/* Type ns2__EventFilter is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:EventFilter': */
class SOAP_CMAC ns2__EventFilter : public ns3__FilterType {
      public:
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__EventFilter
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__EventFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__EventFilter, default initialized and not managed by a soap context
        virtual ns2__EventFilter *soap_alloc(void) const { return SOAP_NEW(ns2__EventFilter); }
      public:
        /// Constructor with initializations
        ns2__EventFilter()
        {
        }
        virtual ~ns2__EventFilter() { }
        /// Friend allocator used by soap_new_ns2__EventFilter(struct soap*, int)
        friend SOAP_FMAC1 ns2__EventFilter * SOAP_FMAC2 soap_instantiate_ns2__EventFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2155 */
#ifndef SOAP_TYPE_ns2__AnalyticsEngine
#define SOAP_TYPE_ns2__AnalyticsEngine (869)
/* Type ns2__AnalyticsEngine is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:AnalyticsEngine': */
class SOAP_CMAC ns2__AnalyticsEngine : public ns2__ConfigurationEntity {
      public:
        /// Required element 'ns2:AnalyticsEngineConfiguration' of XSD type 'ns2:AnalyticsDeviceEngineConfiguration'
        ns2__AnalyticsDeviceEngineConfiguration *AnalyticsEngineConfiguration;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AnalyticsEngine
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AnalyticsEngine; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AnalyticsEngine, default initialized and not managed by a soap context
        virtual ns2__AnalyticsEngine *soap_alloc(void) const { return SOAP_NEW(ns2__AnalyticsEngine); }
      public:
        /// Constructor with initializations
        ns2__AnalyticsEngine()
        {
          AnalyticsEngineConfiguration = (ns2__AnalyticsDeviceEngineConfiguration *)0;
        }
        virtual ~ns2__AnalyticsEngine() { }
        /// Friend allocator used by soap_new_ns2__AnalyticsEngine(struct soap*, int)
        friend SOAP_FMAC1 ns2__AnalyticsEngine * SOAP_FMAC2 soap_instantiate_ns2__AnalyticsEngine(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2173 */
#ifndef SOAP_TYPE_ns2__AnalyticsEngineInput
#define SOAP_TYPE_ns2__AnalyticsEngineInput (875)
/* Type ns2__AnalyticsEngineInput is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:AnalyticsEngineInput': */
class SOAP_CMAC ns2__AnalyticsEngineInput : public ns2__ConfigurationEntity {
      public:
        /// Required element 'ns2:SourceIdentification' of XSD type 'ns2:SourceIdentification'
        ns2__SourceIdentification *SourceIdentification;
        /// Required element 'ns2:VideoInput' of XSD type 'ns2:VideoEncoderConfiguration'
        ns2__VideoEncoderConfiguration *VideoInput;
        /// Required element 'ns2:MetadataInput' of XSD type 'ns2:MetadataInput'
        ns2__MetadataInput *MetadataInput;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AnalyticsEngineInput
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AnalyticsEngineInput; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AnalyticsEngineInput, default initialized and not managed by a soap context
        virtual ns2__AnalyticsEngineInput *soap_alloc(void) const { return SOAP_NEW(ns2__AnalyticsEngineInput); }
      public:
        /// Constructor with initializations
        ns2__AnalyticsEngineInput()
        {
          SourceIdentification = (ns2__SourceIdentification *)0;
          VideoInput = (ns2__VideoEncoderConfiguration *)0;
          MetadataInput = (ns2__MetadataInput *)0;
        }
        virtual ~ns2__AnalyticsEngineInput() { }
        /// Friend allocator used by soap_new_ns2__AnalyticsEngineInput(struct soap*, int)
        friend SOAP_FMAC1 ns2__AnalyticsEngineInput * SOAP_FMAC2 soap_instantiate_ns2__AnalyticsEngineInput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2188 */
#ifndef SOAP_TYPE_ns2__AnalyticsEngineControl
#define SOAP_TYPE_ns2__AnalyticsEngineControl (880)
/* Type ns2__AnalyticsEngineControl is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:AnalyticsEngineControl': */
class SOAP_CMAC ns2__AnalyticsEngineControl : public ns2__ConfigurationEntity {
      public:
        /// Required element 'ns2:EngineToken' of XSD type 'ns2:ReferenceToken'
        std::string EngineToken;
        /// Required element 'ns2:EngineConfigToken' of XSD type 'ns2:ReferenceToken'
        std::string EngineConfigToken;
        /// Required element 'ns2:InputToken' of XSD type 'ns2:ReferenceToken'
        std::vector<std::string> InputToken;
        /// Required element 'ns2:ReceiverToken' of XSD type 'ns2:ReferenceToken'
        std::vector<std::string> ReceiverToken;
        /// Optional element 'ns2:Multicast' of XSD type 'ns2:MulticastConfiguration'
        ns2__MulticastConfiguration *Multicast;
        /// Required element 'ns2:Subscription' of XSD type 'ns2:Config'
        ns2__Config *Subscription;
        /// Required element 'ns2:Mode' of XSD type 'ns2:ModeOfOperation'
        ns2__ModeOfOperation Mode;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AnalyticsEngineControl
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AnalyticsEngineControl; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AnalyticsEngineControl, default initialized and not managed by a soap context
        virtual ns2__AnalyticsEngineControl *soap_alloc(void) const { return SOAP_NEW(ns2__AnalyticsEngineControl); }
      public:
        /// Constructor with initializations
        ns2__AnalyticsEngineControl()
        {
          Multicast = (ns2__MulticastConfiguration *)0;
          Subscription = (ns2__Config *)0;
          Mode = (ns2__ModeOfOperation)0;
        }
        virtual ~ns2__AnalyticsEngineControl() { }
        /// Friend allocator used by soap_new_ns2__AnalyticsEngineControl(struct soap*, int)
        friend SOAP_FMAC1 ns2__AnalyticsEngineControl * SOAP_FMAC2 soap_instantiate_ns2__AnalyticsEngineControl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2269 */
#ifndef SOAP_TYPE_ns2__OSDConfiguration
#define SOAP_TYPE_ns2__OSDConfiguration (907)
/* Type ns2__OSDConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:OSDConfiguration': */
class SOAP_CMAC ns2__OSDConfiguration : public ns2__DeviceEntity {
      public:
        /// Required element 'ns2:VideoSourceConfigurationToken' of XSD type 'ns2:OSDReference'
        ns2__OSDReference *VideoSourceConfigurationToken;
        /// Required element 'ns2:Type' of XSD type 'ns2:OSDType'
        ns2__OSDType Type;
        /// Required element 'ns2:Position' of XSD type 'ns2:OSDPosConfiguration'
        ns2__OSDPosConfiguration *Position;
        /// Optional element 'ns2:TextString' of XSD type 'ns2:OSDTextConfiguration'
        ns2__OSDTextConfiguration *TextString;
        /// Optional element 'ns2:Image' of XSD type 'ns2:OSDImgConfiguration'
        ns2__OSDImgConfiguration *Image;
        /// Optional element 'ns2:Extension' of XSD type 'ns2:OSDConfigurationExtension'
        ns2__OSDConfigurationExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OSDConfiguration
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__OSDConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OSDConfiguration, default initialized and not managed by a soap context
        virtual ns2__OSDConfiguration *soap_alloc(void) const { return SOAP_NEW(ns2__OSDConfiguration); }
      public:
        /// Constructor with initializations
        ns2__OSDConfiguration()
        {
          VideoSourceConfigurationToken = (ns2__OSDReference *)0;
          Type = (ns2__OSDType)0;
          Position = (ns2__OSDPosConfiguration *)0;
          TextString = (ns2__OSDTextConfiguration *)0;
          Image = (ns2__OSDImgConfiguration *)0;
          Extension = (ns2__OSDConfigurationExtension *)0;
        }
        virtual ~ns2__OSDConfiguration() { }
        /// Friend allocator used by soap_new_ns2__OSDConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns2__OSDConfiguration * SOAP_FMAC2 soap_instantiate_ns2__OSDConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2317 */
#ifndef SOAP_TYPE_ns3__SubscribeCreationFailedFaultType
#define SOAP_TYPE_ns3__SubscribeCreationFailedFaultType (923)
/* Type ns3__SubscribeCreationFailedFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:SubscribeCreationFailedFaultType': */
class SOAP_CMAC ns3__SubscribeCreationFailedFaultType : public ns5__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__SubscribeCreationFailedFaultType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__SubscribeCreationFailedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__SubscribeCreationFailedFaultType, default initialized and not managed by a soap context
        virtual ns3__SubscribeCreationFailedFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__SubscribeCreationFailedFaultType); }
      public:
        /// Constructor with initializations
        ns3__SubscribeCreationFailedFaultType()
        {
        }
        virtual ~ns3__SubscribeCreationFailedFaultType() { }
        /// Friend allocator used by soap_new_ns3__SubscribeCreationFailedFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__SubscribeCreationFailedFaultType * SOAP_FMAC2 soap_instantiate_ns3__SubscribeCreationFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2320 */
#ifndef SOAP_TYPE_ns3__InvalidFilterFaultType
#define SOAP_TYPE_ns3__InvalidFilterFaultType (924)
/* Type ns3__InvalidFilterFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:InvalidFilterFaultType': */
class SOAP_CMAC ns3__InvalidFilterFaultType : public ns5__BaseFaultType {
      public:
        /// Required element 'ns3:UnknownFilter' of XSD type 'xsd:QName'
        std::vector<std::string> UnknownFilter;
      public:
        /// Return unique type id SOAP_TYPE_ns3__InvalidFilterFaultType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__InvalidFilterFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__InvalidFilterFaultType, default initialized and not managed by a soap context
        virtual ns3__InvalidFilterFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__InvalidFilterFaultType); }
      public:
        /// Constructor with initializations
        ns3__InvalidFilterFaultType()
        {
        }
        virtual ~ns3__InvalidFilterFaultType() { }
        /// Friend allocator used by soap_new_ns3__InvalidFilterFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__InvalidFilterFaultType * SOAP_FMAC2 soap_instantiate_ns3__InvalidFilterFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2323 */
#ifndef SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType
#define SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType (925)
/* Type ns3__TopicExpressionDialectUnknownFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:TopicExpressionDialectUnknownFaultType': */
class SOAP_CMAC ns3__TopicExpressionDialectUnknownFaultType : public ns5__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__TopicExpressionDialectUnknownFaultType, default initialized and not managed by a soap context
        virtual ns3__TopicExpressionDialectUnknownFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__TopicExpressionDialectUnknownFaultType); }
      public:
        /// Constructor with initializations
        ns3__TopicExpressionDialectUnknownFaultType()
        {
        }
        virtual ~ns3__TopicExpressionDialectUnknownFaultType() { }
        /// Friend allocator used by soap_new_ns3__TopicExpressionDialectUnknownFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__TopicExpressionDialectUnknownFaultType * SOAP_FMAC2 soap_instantiate_ns3__TopicExpressionDialectUnknownFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2326 */
#ifndef SOAP_TYPE_ns3__InvalidTopicExpressionFaultType
#define SOAP_TYPE_ns3__InvalidTopicExpressionFaultType (926)
/* Type ns3__InvalidTopicExpressionFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:InvalidTopicExpressionFaultType': */
class SOAP_CMAC ns3__InvalidTopicExpressionFaultType : public ns5__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__InvalidTopicExpressionFaultType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__InvalidTopicExpressionFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__InvalidTopicExpressionFaultType, default initialized and not managed by a soap context
        virtual ns3__InvalidTopicExpressionFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__InvalidTopicExpressionFaultType); }
      public:
        /// Constructor with initializations
        ns3__InvalidTopicExpressionFaultType()
        {
        }
        virtual ~ns3__InvalidTopicExpressionFaultType() { }
        /// Friend allocator used by soap_new_ns3__InvalidTopicExpressionFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__InvalidTopicExpressionFaultType * SOAP_FMAC2 soap_instantiate_ns3__InvalidTopicExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2329 */
#ifndef SOAP_TYPE_ns3__TopicNotSupportedFaultType
#define SOAP_TYPE_ns3__TopicNotSupportedFaultType (927)
/* Type ns3__TopicNotSupportedFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:TopicNotSupportedFaultType': */
class SOAP_CMAC ns3__TopicNotSupportedFaultType : public ns5__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__TopicNotSupportedFaultType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__TopicNotSupportedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__TopicNotSupportedFaultType, default initialized and not managed by a soap context
        virtual ns3__TopicNotSupportedFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__TopicNotSupportedFaultType); }
      public:
        /// Constructor with initializations
        ns3__TopicNotSupportedFaultType()
        {
        }
        virtual ~ns3__TopicNotSupportedFaultType() { }
        /// Friend allocator used by soap_new_ns3__TopicNotSupportedFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__TopicNotSupportedFaultType * SOAP_FMAC2 soap_instantiate_ns3__TopicNotSupportedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2332 */
#ifndef SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType
#define SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType (928)
/* Type ns3__MultipleTopicsSpecifiedFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:MultipleTopicsSpecifiedFaultType': */
class SOAP_CMAC ns3__MultipleTopicsSpecifiedFaultType : public ns5__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__MultipleTopicsSpecifiedFaultType, default initialized and not managed by a soap context
        virtual ns3__MultipleTopicsSpecifiedFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__MultipleTopicsSpecifiedFaultType); }
      public:
        /// Constructor with initializations
        ns3__MultipleTopicsSpecifiedFaultType()
        {
        }
        virtual ~ns3__MultipleTopicsSpecifiedFaultType() { }
        /// Friend allocator used by soap_new_ns3__MultipleTopicsSpecifiedFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__MultipleTopicsSpecifiedFaultType * SOAP_FMAC2 soap_instantiate_ns3__MultipleTopicsSpecifiedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2335 */
#ifndef SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType
#define SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType (929)
/* Type ns3__InvalidProducerPropertiesExpressionFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:InvalidProducerPropertiesExpressionFaultType': */
class SOAP_CMAC ns3__InvalidProducerPropertiesExpressionFaultType : public ns5__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__InvalidProducerPropertiesExpressionFaultType, default initialized and not managed by a soap context
        virtual ns3__InvalidProducerPropertiesExpressionFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__InvalidProducerPropertiesExpressionFaultType); }
      public:
        /// Constructor with initializations
        ns3__InvalidProducerPropertiesExpressionFaultType()
        {
        }
        virtual ~ns3__InvalidProducerPropertiesExpressionFaultType() { }
        /// Friend allocator used by soap_new_ns3__InvalidProducerPropertiesExpressionFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC2 soap_instantiate_ns3__InvalidProducerPropertiesExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2338 */
#ifndef SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType
#define SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType (930)
/* Type ns3__InvalidMessageContentExpressionFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:InvalidMessageContentExpressionFaultType': */
class SOAP_CMAC ns3__InvalidMessageContentExpressionFaultType : public ns5__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__InvalidMessageContentExpressionFaultType, default initialized and not managed by a soap context
        virtual ns3__InvalidMessageContentExpressionFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__InvalidMessageContentExpressionFaultType); }
      public:
        /// Constructor with initializations
        ns3__InvalidMessageContentExpressionFaultType()
        {
        }
        virtual ~ns3__InvalidMessageContentExpressionFaultType() { }
        /// Friend allocator used by soap_new_ns3__InvalidMessageContentExpressionFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__InvalidMessageContentExpressionFaultType * SOAP_FMAC2 soap_instantiate_ns3__InvalidMessageContentExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2341 */
#ifndef SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType
#define SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType (931)
/* Type ns3__UnrecognizedPolicyRequestFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:UnrecognizedPolicyRequestFaultType': */
class SOAP_CMAC ns3__UnrecognizedPolicyRequestFaultType : public ns5__BaseFaultType {
      public:
        /// Optional element 'ns3:UnrecognizedPolicy' of XSD type 'xsd:QName'
        std::vector<std::string> UnrecognizedPolicy;
      public:
        /// Return unique type id SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__UnrecognizedPolicyRequestFaultType, default initialized and not managed by a soap context
        virtual ns3__UnrecognizedPolicyRequestFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__UnrecognizedPolicyRequestFaultType); }
      public:
        /// Constructor with initializations
        ns3__UnrecognizedPolicyRequestFaultType()
        {
        }
        virtual ~ns3__UnrecognizedPolicyRequestFaultType() { }
        /// Friend allocator used by soap_new_ns3__UnrecognizedPolicyRequestFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__UnrecognizedPolicyRequestFaultType * SOAP_FMAC2 soap_instantiate_ns3__UnrecognizedPolicyRequestFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2344 */
#ifndef SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType
#define SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType (932)
/* Type ns3__UnsupportedPolicyRequestFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:UnsupportedPolicyRequestFaultType': */
class SOAP_CMAC ns3__UnsupportedPolicyRequestFaultType : public ns5__BaseFaultType {
      public:
        /// Optional element 'ns3:UnsupportedPolicy' of XSD type 'xsd:QName'
        std::vector<std::string> UnsupportedPolicy;
      public:
        /// Return unique type id SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__UnsupportedPolicyRequestFaultType, default initialized and not managed by a soap context
        virtual ns3__UnsupportedPolicyRequestFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__UnsupportedPolicyRequestFaultType); }
      public:
        /// Constructor with initializations
        ns3__UnsupportedPolicyRequestFaultType()
        {
        }
        virtual ~ns3__UnsupportedPolicyRequestFaultType() { }
        /// Friend allocator used by soap_new_ns3__UnsupportedPolicyRequestFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__UnsupportedPolicyRequestFaultType * SOAP_FMAC2 soap_instantiate_ns3__UnsupportedPolicyRequestFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2347 */
#ifndef SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType
#define SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType (933)
/* Type ns3__NotifyMessageNotSupportedFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:NotifyMessageNotSupportedFaultType': */
class SOAP_CMAC ns3__NotifyMessageNotSupportedFaultType : public ns5__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__NotifyMessageNotSupportedFaultType, default initialized and not managed by a soap context
        virtual ns3__NotifyMessageNotSupportedFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__NotifyMessageNotSupportedFaultType); }
      public:
        /// Constructor with initializations
        ns3__NotifyMessageNotSupportedFaultType()
        {
        }
        virtual ~ns3__NotifyMessageNotSupportedFaultType() { }
        /// Friend allocator used by soap_new_ns3__NotifyMessageNotSupportedFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__NotifyMessageNotSupportedFaultType * SOAP_FMAC2 soap_instantiate_ns3__NotifyMessageNotSupportedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2350 */
#ifndef SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType
#define SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType (934)
/* Type ns3__UnacceptableInitialTerminationTimeFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:UnacceptableInitialTerminationTimeFaultType': */
class SOAP_CMAC ns3__UnacceptableInitialTerminationTimeFaultType : public ns5__BaseFaultType {
      public:
        /// Required element 'ns3:MinimumTime' of XSD type 'xsd:dateTime'
        time_t MinimumTime;
        /// Optional element 'ns3:MaximumTime' of XSD type 'xsd:dateTime'
        time_t *MaximumTime;
      public:
        /// Return unique type id SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__UnacceptableInitialTerminationTimeFaultType, default initialized and not managed by a soap context
        virtual ns3__UnacceptableInitialTerminationTimeFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__UnacceptableInitialTerminationTimeFaultType); }
      public:
        /// Constructor with initializations
        ns3__UnacceptableInitialTerminationTimeFaultType()
        {
          MinimumTime = (time_t)0;
          MaximumTime = (time_t *)0;
        }
        virtual ~ns3__UnacceptableInitialTerminationTimeFaultType() { }
        /// Friend allocator used by soap_new_ns3__UnacceptableInitialTerminationTimeFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC2 soap_instantiate_ns3__UnacceptableInitialTerminationTimeFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2353 */
#ifndef SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType
#define SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType (935)
/* Type ns3__NoCurrentMessageOnTopicFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:NoCurrentMessageOnTopicFaultType': */
class SOAP_CMAC ns3__NoCurrentMessageOnTopicFaultType : public ns5__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__NoCurrentMessageOnTopicFaultType, default initialized and not managed by a soap context
        virtual ns3__NoCurrentMessageOnTopicFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__NoCurrentMessageOnTopicFaultType); }
      public:
        /// Constructor with initializations
        ns3__NoCurrentMessageOnTopicFaultType()
        {
        }
        virtual ~ns3__NoCurrentMessageOnTopicFaultType() { }
        /// Friend allocator used by soap_new_ns3__NoCurrentMessageOnTopicFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__NoCurrentMessageOnTopicFaultType * SOAP_FMAC2 soap_instantiate_ns3__NoCurrentMessageOnTopicFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2356 */
#ifndef SOAP_TYPE_ns3__UnableToGetMessagesFaultType
#define SOAP_TYPE_ns3__UnableToGetMessagesFaultType (936)
/* Type ns3__UnableToGetMessagesFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:UnableToGetMessagesFaultType': */
class SOAP_CMAC ns3__UnableToGetMessagesFaultType : public ns5__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__UnableToGetMessagesFaultType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__UnableToGetMessagesFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__UnableToGetMessagesFaultType, default initialized and not managed by a soap context
        virtual ns3__UnableToGetMessagesFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__UnableToGetMessagesFaultType); }
      public:
        /// Constructor with initializations
        ns3__UnableToGetMessagesFaultType()
        {
        }
        virtual ~ns3__UnableToGetMessagesFaultType() { }
        /// Friend allocator used by soap_new_ns3__UnableToGetMessagesFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__UnableToGetMessagesFaultType * SOAP_FMAC2 soap_instantiate_ns3__UnableToGetMessagesFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2359 */
#ifndef SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType
#define SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType (937)
/* Type ns3__UnableToDestroyPullPointFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:UnableToDestroyPullPointFaultType': */
class SOAP_CMAC ns3__UnableToDestroyPullPointFaultType : public ns5__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__UnableToDestroyPullPointFaultType, default initialized and not managed by a soap context
        virtual ns3__UnableToDestroyPullPointFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__UnableToDestroyPullPointFaultType); }
      public:
        /// Constructor with initializations
        ns3__UnableToDestroyPullPointFaultType()
        {
        }
        virtual ~ns3__UnableToDestroyPullPointFaultType() { }
        /// Friend allocator used by soap_new_ns3__UnableToDestroyPullPointFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__UnableToDestroyPullPointFaultType * SOAP_FMAC2 soap_instantiate_ns3__UnableToDestroyPullPointFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2362 */
#ifndef SOAP_TYPE_ns3__UnableToCreatePullPointFaultType
#define SOAP_TYPE_ns3__UnableToCreatePullPointFaultType (938)
/* Type ns3__UnableToCreatePullPointFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:UnableToCreatePullPointFaultType': */
class SOAP_CMAC ns3__UnableToCreatePullPointFaultType : public ns5__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__UnableToCreatePullPointFaultType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__UnableToCreatePullPointFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__UnableToCreatePullPointFaultType, default initialized and not managed by a soap context
        virtual ns3__UnableToCreatePullPointFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__UnableToCreatePullPointFaultType); }
      public:
        /// Constructor with initializations
        ns3__UnableToCreatePullPointFaultType()
        {
        }
        virtual ~ns3__UnableToCreatePullPointFaultType() { }
        /// Friend allocator used by soap_new_ns3__UnableToCreatePullPointFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__UnableToCreatePullPointFaultType * SOAP_FMAC2 soap_instantiate_ns3__UnableToCreatePullPointFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2365 */
#ifndef SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType
#define SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType (939)
/* Type ns3__UnacceptableTerminationTimeFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:UnacceptableTerminationTimeFaultType': */
class SOAP_CMAC ns3__UnacceptableTerminationTimeFaultType : public ns5__BaseFaultType {
      public:
        /// Required element 'ns3:MinimumTime' of XSD type 'xsd:dateTime'
        time_t MinimumTime;
        /// Optional element 'ns3:MaximumTime' of XSD type 'xsd:dateTime'
        time_t *MaximumTime;
      public:
        /// Return unique type id SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__UnacceptableTerminationTimeFaultType, default initialized and not managed by a soap context
        virtual ns3__UnacceptableTerminationTimeFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__UnacceptableTerminationTimeFaultType); }
      public:
        /// Constructor with initializations
        ns3__UnacceptableTerminationTimeFaultType()
        {
          MinimumTime = (time_t)0;
          MaximumTime = (time_t *)0;
        }
        virtual ~ns3__UnacceptableTerminationTimeFaultType() { }
        /// Friend allocator used by soap_new_ns3__UnacceptableTerminationTimeFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__UnacceptableTerminationTimeFaultType * SOAP_FMAC2 soap_instantiate_ns3__UnacceptableTerminationTimeFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2368 */
#ifndef SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType
#define SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType (940)
/* Type ns3__UnableToDestroySubscriptionFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:UnableToDestroySubscriptionFaultType': */
class SOAP_CMAC ns3__UnableToDestroySubscriptionFaultType : public ns5__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__UnableToDestroySubscriptionFaultType, default initialized and not managed by a soap context
        virtual ns3__UnableToDestroySubscriptionFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__UnableToDestroySubscriptionFaultType); }
      public:
        /// Constructor with initializations
        ns3__UnableToDestroySubscriptionFaultType()
        {
        }
        virtual ~ns3__UnableToDestroySubscriptionFaultType() { }
        /// Friend allocator used by soap_new_ns3__UnableToDestroySubscriptionFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__UnableToDestroySubscriptionFaultType * SOAP_FMAC2 soap_instantiate_ns3__UnableToDestroySubscriptionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2371 */
#ifndef SOAP_TYPE_ns3__PauseFailedFaultType
#define SOAP_TYPE_ns3__PauseFailedFaultType (941)
/* Type ns3__PauseFailedFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:PauseFailedFaultType': */
class SOAP_CMAC ns3__PauseFailedFaultType : public ns5__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__PauseFailedFaultType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__PauseFailedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PauseFailedFaultType, default initialized and not managed by a soap context
        virtual ns3__PauseFailedFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__PauseFailedFaultType); }
      public:
        /// Constructor with initializations
        ns3__PauseFailedFaultType()
        {
        }
        virtual ~ns3__PauseFailedFaultType() { }
        /// Friend allocator used by soap_new_ns3__PauseFailedFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__PauseFailedFaultType * SOAP_FMAC2 soap_instantiate_ns3__PauseFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2374 */
#ifndef SOAP_TYPE_ns3__ResumeFailedFaultType
#define SOAP_TYPE_ns3__ResumeFailedFaultType (942)
/* Type ns3__ResumeFailedFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:ResumeFailedFaultType': */
class SOAP_CMAC ns3__ResumeFailedFaultType : public ns5__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__ResumeFailedFaultType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ResumeFailedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ResumeFailedFaultType, default initialized and not managed by a soap context
        virtual ns3__ResumeFailedFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__ResumeFailedFaultType); }
      public:
        /// Constructor with initializations
        ns3__ResumeFailedFaultType()
        {
        }
        virtual ~ns3__ResumeFailedFaultType() { }
        /// Friend allocator used by soap_new_ns3__ResumeFailedFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ResumeFailedFaultType * SOAP_FMAC2 soap_instantiate_ns3__ResumeFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:40768 */
#ifndef SOAP_TYPE__ns6__TopicNamespaceType_Topic
#define SOAP_TYPE__ns6__TopicNamespaceType_Topic (2205)
/* complex XSD type 'ns6:TopicNamespaceType-Topic': */
class SOAP_CMAC _ns6__TopicNamespaceType_Topic {
      public:
        /// Optional element 'ns6:documentation' of XSD type 'ns6:Documentation'
        ns6__Documentation *documentation;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Optional element 'ns6:MessagePattern' of XSD type 'ns6:QueryExpressionType'
        ns6__QueryExpressionType *MessagePattern;
        /// Optional element 'ns6:Topic' of XSD type 'ns6:TopicType'
        std::vector<ns6__TopicType *> Topic;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// required attribute 'name' of XSD type 'xsd:NCName'
        std::string name;
        /// optional attribute 'messageTypes' of XSD type 'xsd:QName'
        std::string *messageTypes;
        /// optional attribute 'final' of XSD type 'xsd:boolean'
        bool final_;	///< default = (bool)0
        /// optional attribute 'parent' of XSD type 'ns6:ConcreteTopicExpression'
        std::string *parent;
      public:
        /// Return unique type id SOAP_TYPE__ns6__TopicNamespaceType_Topic
        virtual int soap_type(void) const { return SOAP_TYPE__ns6__TopicNamespaceType_Topic; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns6__TopicNamespaceType_Topic, default initialized and not managed by a soap context
        virtual _ns6__TopicNamespaceType_Topic *soap_alloc(void) const { return SOAP_NEW(_ns6__TopicNamespaceType_Topic); }
      public:
        /// Constructor with initializations
        _ns6__TopicNamespaceType_Topic()
        {
          documentation = (ns6__Documentation *)0;
          MessagePattern = (ns6__QueryExpressionType *)0;
          messageTypes = (std::string *)0;
          final_ = (bool)0;
          parent = (std::string *)0;
        }
        virtual ~_ns6__TopicNamespaceType_Topic() { }
        /// Friend allocator used by soap_new__ns6__TopicNamespaceType_Topic(struct soap*, int)
        friend SOAP_FMAC1 _ns6__TopicNamespaceType_Topic * SOAP_FMAC2 soap_instantiate__ns6__TopicNamespaceType_Topic(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2458 */
#ifndef SOAP_TYPE_ns6__TopicNamespaceType
#define SOAP_TYPE_ns6__TopicNamespaceType (970)
/* Type ns6__TopicNamespaceType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns6:TopicNamespaceType': */
class SOAP_CMAC ns6__TopicNamespaceType : public ns6__ExtensibleDocumented {
      public:
        /// Optional element 'ns6:Topic' of XSD type 'ns6:TopicNamespaceType-Topic'
        std::vector<_ns6__TopicNamespaceType_Topic> *Topic;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// optional attribute 'name' of XSD type 'xsd:NCName'
        std::string *name;
        /// required attribute 'targetNamespace' of XSD type 'xsd:anyURI'
        std::string targetNamespace;
        /// optional attribute 'final' of XSD type 'xsd:boolean'
        bool final_;	///< default = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_ns6__TopicNamespaceType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__TopicNamespaceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__TopicNamespaceType, default initialized and not managed by a soap context
        virtual ns6__TopicNamespaceType *soap_alloc(void) const { return SOAP_NEW(ns6__TopicNamespaceType); }
      public:
        /// Constructor with initializations
        ns6__TopicNamespaceType()
        {
          Topic = (std::vector<_ns6__TopicNamespaceType_Topic> *)0;
          name = (std::string *)0;
          final_ = (bool)0;
        }
        virtual ~ns6__TopicNamespaceType() { }
        /// Friend allocator used by soap_new_ns6__TopicNamespaceType(struct soap*, int)
        friend SOAP_FMAC1 ns6__TopicNamespaceType * SOAP_FMAC2 soap_instantiate_ns6__TopicNamespaceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2461 */
#ifndef SOAP_TYPE_ns6__TopicType
#define SOAP_TYPE_ns6__TopicType (971)
/* Type ns6__TopicType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns6:TopicType': */
class SOAP_CMAC ns6__TopicType : public ns6__ExtensibleDocumented {
      public:
        /// Optional element 'ns6:MessagePattern' of XSD type 'ns6:QueryExpressionType'
        ns6__QueryExpressionType *MessagePattern;
        /// Optional element 'ns6:Topic' of XSD type 'ns6:TopicType'
        std::vector<ns6__TopicType *> Topic;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// required attribute 'name' of XSD type 'xsd:NCName'
        std::string name;
        /// optional attribute 'messageTypes' of XSD type 'xsd:QName'
        std::string *messageTypes;
        /// optional attribute 'final' of XSD type 'xsd:boolean'
        bool final_;	///< default = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_ns6__TopicType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__TopicType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__TopicType, default initialized and not managed by a soap context
        virtual ns6__TopicType *soap_alloc(void) const { return SOAP_NEW(ns6__TopicType); }
      public:
        /// Constructor with initializations
        ns6__TopicType()
        {
          MessagePattern = (ns6__QueryExpressionType *)0;
          messageTypes = (std::string *)0;
          final_ = (bool)0;
        }
        virtual ~ns6__TopicType() { }
        /// Friend allocator used by soap_new_ns6__TopicType(struct soap*, int)
        friend SOAP_FMAC1 ns6__TopicType * SOAP_FMAC2 soap_instantiate_ns6__TopicType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2464 */
#ifndef SOAP_TYPE_ns6__TopicSetType
#define SOAP_TYPE_ns6__TopicSetType (972)
/* Type ns6__TopicSetType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns6:TopicSetType': */
class SOAP_CMAC ns6__TopicSetType : public ns6__ExtensibleDocumented {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
      public:
        /// Return unique type id SOAP_TYPE_ns6__TopicSetType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__TopicSetType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__TopicSetType, default initialized and not managed by a soap context
        virtual ns6__TopicSetType *soap_alloc(void) const { return SOAP_NEW(ns6__TopicSetType); }
      public:
        /// Constructor with initializations
        ns6__TopicSetType()
        {
        }
        virtual ~ns6__TopicSetType() { }
        /// Friend allocator used by soap_new_ns6__TopicSetType(struct soap*, int)
        friend SOAP_FMAC1 ns6__TopicSetType * SOAP_FMAC2 soap_instantiate_ns6__TopicSetType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3463 */
#ifndef SOAP_TYPE_ns12__CredentialInfo
#define SOAP_TYPE_ns12__CredentialInfo (1305)
/* Type ns12__CredentialInfo is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns12:CredentialInfo': */
class SOAP_CMAC ns12__CredentialInfo : public ns13__DataEntity {
      public:
        /// Optional element 'ns12:Description' of XSD type 'ns13:Description'
        std::string *Description;
        /// Required element 'ns12:CredentialHolderReference' of XSD type 'xsd:string'
        std::string CredentialHolderReference;
        /// Optional element 'ns12:ValidFrom' of XSD type 'xsd:dateTime'
        time_t *ValidFrom;
        /// Optional element 'ns12:ValidTo' of XSD type 'xsd:dateTime'
        time_t *ValidTo;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns12__CredentialInfo
        virtual int soap_type(void) const { return SOAP_TYPE_ns12__CredentialInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns12__CredentialInfo, default initialized and not managed by a soap context
        virtual ns12__CredentialInfo *soap_alloc(void) const { return SOAP_NEW(ns12__CredentialInfo); }
      public:
        /// Constructor with initializations
        ns12__CredentialInfo()
        {
          Description = (std::string *)0;
          ValidFrom = (time_t *)0;
          ValidTo = (time_t *)0;
        }
        virtual ~ns12__CredentialInfo() { }
        /// Friend allocator used by soap_new_ns12__CredentialInfo(struct soap*, int)
        friend SOAP_FMAC1 ns12__CredentialInfo * SOAP_FMAC2 soap_instantiate_ns12__CredentialInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3625 */
#ifndef SOAP_TYPE_ns14__RelatesToType
#define SOAP_TYPE_ns14__RelatesToType (1359)
/* simple XSD type 'ns14:RelatesToType': */
class SOAP_CMAC ns14__RelatesToType {
      public:
        /// Simple content of XSD type 'xsd:anyURI' wrapped by this struct
        std::string __item;
        /// optional attribute 'RelationshipType' of XSD type 'ns14:RelationshipTypeOpenEnum'
        std::string RelationshipType;	///< default = "http://www.w3.org/2005/08/addressing/reply"
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns14__RelatesToType
        virtual int soap_type(void) const { return SOAP_TYPE_ns14__RelatesToType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns14__RelatesToType, default initialized and not managed by a soap context
        virtual ns14__RelatesToType *soap_alloc(void) const { return SOAP_NEW(ns14__RelatesToType); }
      public:
        /// Constructor with initializations
        ns14__RelatesToType()
        {
          RelationshipType = "http://www.w3.org/2005/08/addressing/reply";
          soap = (struct soap *)0;
        }
        virtual ~ns14__RelatesToType() { }
        /// Friend allocator used by soap_new_ns14__RelatesToType(struct soap*, int)
        friend SOAP_FMAC1 ns14__RelatesToType * SOAP_FMAC2 soap_instantiate_ns14__RelatesToType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3628 */
#ifndef SOAP_TYPE_ns14__AttributedURIType
#define SOAP_TYPE_ns14__AttributedURIType (1360)
/* simple XSD type 'ns14:AttributedURIType': */
class SOAP_CMAC ns14__AttributedURIType {
      public:
        /// Simple content of XSD type 'xsd:anyURI' wrapped by this struct
        std::string __item;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns14__AttributedURIType
        virtual int soap_type(void) const { return SOAP_TYPE_ns14__AttributedURIType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns14__AttributedURIType, default initialized and not managed by a soap context
        virtual ns14__AttributedURIType *soap_alloc(void) const { return SOAP_NEW(ns14__AttributedURIType); }
      public:
        /// Constructor with initializations
        ns14__AttributedURIType()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns14__AttributedURIType() { }
        /// Friend allocator used by soap_new_ns14__AttributedURIType(struct soap*, int)
        friend SOAP_FMAC1 ns14__AttributedURIType * SOAP_FMAC2 soap_instantiate_ns14__AttributedURIType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3631 */
#ifndef SOAP_TYPE_ns14__AttributedUnsignedLongType
#define SOAP_TYPE_ns14__AttributedUnsignedLongType (1361)
/* simple XSD type 'ns14:AttributedUnsignedLongType': */
class SOAP_CMAC ns14__AttributedUnsignedLongType {
      public:
        /// Simple content of XSD type 'xsd:unsignedLong' wrapped by this struct
        ULONG64 __item;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns14__AttributedUnsignedLongType
        virtual int soap_type(void) const { return SOAP_TYPE_ns14__AttributedUnsignedLongType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns14__AttributedUnsignedLongType, default initialized and not managed by a soap context
        virtual ns14__AttributedUnsignedLongType *soap_alloc(void) const { return SOAP_NEW(ns14__AttributedUnsignedLongType); }
      public:
        /// Constructor with initializations
        ns14__AttributedUnsignedLongType()
        {
          __item = (ULONG64)0;
          soap = (struct soap *)0;
        }
        virtual ~ns14__AttributedUnsignedLongType() { }
        /// Friend allocator used by soap_new_ns14__AttributedUnsignedLongType(struct soap*, int)
        friend SOAP_FMAC1 ns14__AttributedUnsignedLongType * SOAP_FMAC2 soap_instantiate_ns14__AttributedUnsignedLongType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3634 */
#ifndef SOAP_TYPE_ns14__AttributedQNameType
#define SOAP_TYPE_ns14__AttributedQNameType (1362)
/* simple XSD type 'ns14:AttributedQNameType': */
class SOAP_CMAC ns14__AttributedQNameType {
      public:
        /// Simple content of XSD type 'xsd:QName' wrapped by this struct
        std::string __item;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns14__AttributedQNameType
        virtual int soap_type(void) const { return SOAP_TYPE_ns14__AttributedQNameType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns14__AttributedQNameType, default initialized and not managed by a soap context
        virtual ns14__AttributedQNameType *soap_alloc(void) const { return SOAP_NEW(ns14__AttributedQNameType); }
      public:
        /// Constructor with initializations
        ns14__AttributedQNameType()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns14__AttributedQNameType() { }
        /// Friend allocator used by soap_new_ns14__AttributedQNameType(struct soap*, int)
        friend SOAP_FMAC1 ns14__AttributedQNameType * SOAP_FMAC2 soap_instantiate_ns14__AttributedQNameType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:2221 */
#ifndef SOAP_TYPE_ns2__OSDReference
#define SOAP_TYPE_ns2__OSDReference (891)
/* simple XSD type 'ns2:OSDReference': */
class SOAP_CMAC ns2__OSDReference {
      public:
        /// Simple content of XSD type 'ns2:ReferenceToken' wrapped by this struct
        std::string __item;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OSDReference
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__OSDReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OSDReference, default initialized and not managed by a soap context
        virtual ns2__OSDReference *soap_alloc(void) const { return SOAP_NEW(ns2__OSDReference); }
      public:
        /// Constructor with initializations
        ns2__OSDReference()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__OSDReference() { }
        /// Friend allocator used by soap_new_ns2__OSDReference(struct soap*, int)
        friend SOAP_FMAC1 ns2__OSDReference * SOAP_FMAC2 soap_instantiate_ns2__OSDReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:3466 */
#ifndef SOAP_TYPE_ns12__Credential
#define SOAP_TYPE_ns12__Credential (1306)
/* Type ns12__Credential is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns12:Credential': */
class SOAP_CMAC ns12__Credential : public ns12__CredentialInfo {
      public:
        /// Required element 'ns12:CredentialIdentifier' of XSD type 'ns12:CredentialIdentifier'
        std::vector<ns12__CredentialIdentifier *> CredentialIdentifier;
        /// Optional element 'ns12:CredentialAccessProfile' of XSD type 'ns12:CredentialAccessProfile'
        std::vector<ns12__CredentialAccessProfile *> CredentialAccessProfile;
        /// Optional element 'ns12:Attribute' of XSD type 'ns13:Attribute'
        std::vector<ns13__Attribute *> Attribute;
        /// Optional element 'ns12:Extension' of XSD type 'ns12:CredentialExtension'
        ns12__CredentialExtension *Extension;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns12__Credential
        virtual int soap_type(void) const { return SOAP_TYPE_ns12__Credential; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns12__Credential, default initialized and not managed by a soap context
        virtual ns12__Credential *soap_alloc(void) const { return SOAP_NEW(ns12__Credential); }
      public:
        /// Constructor with initializations
        ns12__Credential()
        {
          Extension = (ns12__CredentialExtension *)0;
        }
        virtual ~ns12__Credential() { }
        /// Friend allocator used by soap_new_ns12__Credential(struct soap*, int)
        friend SOAP_FMAC1 ns12__Credential * SOAP_FMAC2 soap_instantiate_ns12__Credential(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:42480 */
#ifndef SOAP_TYPE___ns1__GetServices
#define SOAP_TYPE___ns1__GetServices (2220)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetServices {
      public:
        /** Optional element 'ns1:GetServices' of XSD type 'ns1:GetServices' */
        _ns1__GetServices *ns1__GetServices;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetServices */
        int soap_type() const { return SOAP_TYPE___ns1__GetServices; }
        /** Constructor with member initializations */
        __ns1__GetServices()
        {
          ns1__GetServices = (_ns1__GetServices *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetServices(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetServices * SOAP_FMAC2 soap_instantiate___ns1__GetServices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:42549 */
#ifndef SOAP_TYPE___ns1__GetServiceCapabilities
#define SOAP_TYPE___ns1__GetServiceCapabilities (2224)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetServiceCapabilities {
      public:
        /** Optional element 'ns1:GetServiceCapabilities' of XSD type 'ns1:GetServiceCapabilities' */
        _ns1__GetServiceCapabilities *ns1__GetServiceCapabilities;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetServiceCapabilities */
        int soap_type() const { return SOAP_TYPE___ns1__GetServiceCapabilities; }
        /** Constructor with member initializations */
        __ns1__GetServiceCapabilities()
        {
          ns1__GetServiceCapabilities = (_ns1__GetServiceCapabilities *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetServiceCapabilities(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___ns1__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:42617 */
#ifndef SOAP_TYPE___ns1__GetDeviceInformation
#define SOAP_TYPE___ns1__GetDeviceInformation (2228)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetDeviceInformation {
      public:
        /** Optional element 'ns1:GetDeviceInformation' of XSD type 'ns1:GetDeviceInformation' */
        _ns1__GetDeviceInformation *ns1__GetDeviceInformation;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetDeviceInformation */
        int soap_type() const { return SOAP_TYPE___ns1__GetDeviceInformation; }
        /** Constructor with member initializations */
        __ns1__GetDeviceInformation()
        {
          ns1__GetDeviceInformation = (_ns1__GetDeviceInformation *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetDeviceInformation(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetDeviceInformation * SOAP_FMAC2 soap_instantiate___ns1__GetDeviceInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:42699 */
#ifndef SOAP_TYPE___ns1__SetSystemDateAndTime
#define SOAP_TYPE___ns1__SetSystemDateAndTime (2232)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetSystemDateAndTime {
      public:
        /** Optional element 'ns1:SetSystemDateAndTime' of XSD type 'ns1:SetSystemDateAndTime' */
        _ns1__SetSystemDateAndTime *ns1__SetSystemDateAndTime;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetSystemDateAndTime */
        int soap_type() const { return SOAP_TYPE___ns1__SetSystemDateAndTime; }
        /** Constructor with member initializations */
        __ns1__SetSystemDateAndTime()
        {
          ns1__SetSystemDateAndTime = (_ns1__SetSystemDateAndTime *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetSystemDateAndTime(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetSystemDateAndTime * SOAP_FMAC2 soap_instantiate___ns1__SetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:42773 */
#ifndef SOAP_TYPE___ns1__GetSystemDateAndTime
#define SOAP_TYPE___ns1__GetSystemDateAndTime (2236)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetSystemDateAndTime {
      public:
        /** Optional element 'ns1:GetSystemDateAndTime' of XSD type 'ns1:GetSystemDateAndTime' */
        _ns1__GetSystemDateAndTime *ns1__GetSystemDateAndTime;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetSystemDateAndTime */
        int soap_type() const { return SOAP_TYPE___ns1__GetSystemDateAndTime; }
        /** Constructor with member initializations */
        __ns1__GetSystemDateAndTime()
        {
          ns1__GetSystemDateAndTime = (_ns1__GetSystemDateAndTime *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetSystemDateAndTime(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetSystemDateAndTime * SOAP_FMAC2 soap_instantiate___ns1__GetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:42841 */
#ifndef SOAP_TYPE___ns1__SetSystemFactoryDefault
#define SOAP_TYPE___ns1__SetSystemFactoryDefault (2240)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetSystemFactoryDefault {
      public:
        /** Optional element 'ns1:SetSystemFactoryDefault' of XSD type 'ns1:SetSystemFactoryDefault' */
        _ns1__SetSystemFactoryDefault *ns1__SetSystemFactoryDefault;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetSystemFactoryDefault */
        int soap_type() const { return SOAP_TYPE___ns1__SetSystemFactoryDefault; }
        /** Constructor with member initializations */
        __ns1__SetSystemFactoryDefault()
        {
          ns1__SetSystemFactoryDefault = (_ns1__SetSystemFactoryDefault *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetSystemFactoryDefault(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetSystemFactoryDefault * SOAP_FMAC2 soap_instantiate___ns1__SetSystemFactoryDefault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:42915 */
#ifndef SOAP_TYPE___ns1__UpgradeSystemFirmware
#define SOAP_TYPE___ns1__UpgradeSystemFirmware (2244)
/* Wrapper: */
struct SOAP_CMAC __ns1__UpgradeSystemFirmware {
      public:
        /** Optional element 'ns1:UpgradeSystemFirmware' of XSD type 'ns1:UpgradeSystemFirmware' */
        _ns1__UpgradeSystemFirmware *ns1__UpgradeSystemFirmware;
      public:
        /** Return unique type id SOAP_TYPE___ns1__UpgradeSystemFirmware */
        int soap_type() const { return SOAP_TYPE___ns1__UpgradeSystemFirmware; }
        /** Constructor with member initializations */
        __ns1__UpgradeSystemFirmware()
        {
          ns1__UpgradeSystemFirmware = (_ns1__UpgradeSystemFirmware *)0;
        }
        /** Friend allocator used by soap_new___ns1__UpgradeSystemFirmware(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__UpgradeSystemFirmware * SOAP_FMAC2 soap_instantiate___ns1__UpgradeSystemFirmware(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:42983 */
#ifndef SOAP_TYPE___ns1__SystemReboot
#define SOAP_TYPE___ns1__SystemReboot (2248)
/* Wrapper: */
struct SOAP_CMAC __ns1__SystemReboot {
      public:
        /** Optional element 'ns1:SystemReboot' of XSD type 'ns1:SystemReboot' */
        _ns1__SystemReboot *ns1__SystemReboot;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SystemReboot */
        int soap_type() const { return SOAP_TYPE___ns1__SystemReboot; }
        /** Constructor with member initializations */
        __ns1__SystemReboot()
        {
          ns1__SystemReboot = (_ns1__SystemReboot *)0;
        }
        /** Friend allocator used by soap_new___ns1__SystemReboot(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SystemReboot * SOAP_FMAC2 soap_instantiate___ns1__SystemReboot(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:43059 */
#ifndef SOAP_TYPE___ns1__RestoreSystem
#define SOAP_TYPE___ns1__RestoreSystem (2252)
/* Wrapper: */
struct SOAP_CMAC __ns1__RestoreSystem {
      public:
        /** Optional element 'ns1:RestoreSystem' of XSD type 'ns1:RestoreSystem' */
        _ns1__RestoreSystem *ns1__RestoreSystem;
      public:
        /** Return unique type id SOAP_TYPE___ns1__RestoreSystem */
        int soap_type() const { return SOAP_TYPE___ns1__RestoreSystem; }
        /** Constructor with member initializations */
        __ns1__RestoreSystem()
        {
          ns1__RestoreSystem = (_ns1__RestoreSystem *)0;
        }
        /** Friend allocator used by soap_new___ns1__RestoreSystem(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__RestoreSystem * SOAP_FMAC2 soap_instantiate___ns1__RestoreSystem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:43134 */
#ifndef SOAP_TYPE___ns1__GetSystemBackup
#define SOAP_TYPE___ns1__GetSystemBackup (2256)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetSystemBackup {
      public:
        /** Optional element 'ns1:GetSystemBackup' of XSD type 'ns1:GetSystemBackup' */
        _ns1__GetSystemBackup *ns1__GetSystemBackup;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetSystemBackup */
        int soap_type() const { return SOAP_TYPE___ns1__GetSystemBackup; }
        /** Constructor with member initializations */
        __ns1__GetSystemBackup()
        {
          ns1__GetSystemBackup = (_ns1__GetSystemBackup *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetSystemBackup(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetSystemBackup * SOAP_FMAC2 soap_instantiate___ns1__GetSystemBackup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:43203 */
#ifndef SOAP_TYPE___ns1__GetSystemLog
#define SOAP_TYPE___ns1__GetSystemLog (2260)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetSystemLog {
      public:
        /** Optional element 'ns1:GetSystemLog' of XSD type 'ns1:GetSystemLog' */
        _ns1__GetSystemLog *ns1__GetSystemLog;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetSystemLog */
        int soap_type() const { return SOAP_TYPE___ns1__GetSystemLog; }
        /** Constructor with member initializations */
        __ns1__GetSystemLog()
        {
          ns1__GetSystemLog = (_ns1__GetSystemLog *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetSystemLog(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetSystemLog * SOAP_FMAC2 soap_instantiate___ns1__GetSystemLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:43271 */
#ifndef SOAP_TYPE___ns1__GetSystemSupportInformation
#define SOAP_TYPE___ns1__GetSystemSupportInformation (2264)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetSystemSupportInformation {
      public:
        /** Optional element 'ns1:GetSystemSupportInformation' of XSD type 'ns1:GetSystemSupportInformation' */
        _ns1__GetSystemSupportInformation *ns1__GetSystemSupportInformation;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetSystemSupportInformation */
        int soap_type() const { return SOAP_TYPE___ns1__GetSystemSupportInformation; }
        /** Constructor with member initializations */
        __ns1__GetSystemSupportInformation()
        {
          ns1__GetSystemSupportInformation = (_ns1__GetSystemSupportInformation *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetSystemSupportInformation(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetSystemSupportInformation * SOAP_FMAC2 soap_instantiate___ns1__GetSystemSupportInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:43354 */
#ifndef SOAP_TYPE___ns1__GetScopes
#define SOAP_TYPE___ns1__GetScopes (2268)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetScopes {
      public:
        /** Optional element 'ns1:GetScopes' of XSD type 'ns1:GetScopes' */
        _ns1__GetScopes *ns1__GetScopes;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetScopes */
        int soap_type() const { return SOAP_TYPE___ns1__GetScopes; }
        /** Constructor with member initializations */
        __ns1__GetScopes()
        {
          ns1__GetScopes = (_ns1__GetScopes *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetScopes(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetScopes * SOAP_FMAC2 soap_instantiate___ns1__GetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:43430 */
#ifndef SOAP_TYPE___ns1__SetScopes
#define SOAP_TYPE___ns1__SetScopes (2272)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetScopes {
      public:
        /** Optional element 'ns1:SetScopes' of XSD type 'ns1:SetScopes' */
        _ns1__SetScopes *ns1__SetScopes;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetScopes */
        int soap_type() const { return SOAP_TYPE___ns1__SetScopes; }
        /** Constructor with member initializations */
        __ns1__SetScopes()
        {
          ns1__SetScopes = (_ns1__SetScopes *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetScopes(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetScopes * SOAP_FMAC2 soap_instantiate___ns1__SetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:43502 */
#ifndef SOAP_TYPE___ns1__AddScopes
#define SOAP_TYPE___ns1__AddScopes (2276)
/* Wrapper: */
struct SOAP_CMAC __ns1__AddScopes {
      public:
        /** Optional element 'ns1:AddScopes' of XSD type 'ns1:AddScopes' */
        _ns1__AddScopes *ns1__AddScopes;
      public:
        /** Return unique type id SOAP_TYPE___ns1__AddScopes */
        int soap_type() const { return SOAP_TYPE___ns1__AddScopes; }
        /** Constructor with member initializations */
        __ns1__AddScopes()
        {
          ns1__AddScopes = (_ns1__AddScopes *)0;
        }
        /** Friend allocator used by soap_new___ns1__AddScopes(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__AddScopes * SOAP_FMAC2 soap_instantiate___ns1__AddScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:43576 */
#ifndef SOAP_TYPE___ns1__RemoveScopes
#define SOAP_TYPE___ns1__RemoveScopes (2280)
/* Wrapper: */
struct SOAP_CMAC __ns1__RemoveScopes {
      public:
        /** Optional element 'ns1:RemoveScopes' of XSD type 'ns1:RemoveScopes' */
        _ns1__RemoveScopes *ns1__RemoveScopes;
      public:
        /** Return unique type id SOAP_TYPE___ns1__RemoveScopes */
        int soap_type() const { return SOAP_TYPE___ns1__RemoveScopes; }
        /** Constructor with member initializations */
        __ns1__RemoveScopes()
        {
          ns1__RemoveScopes = (_ns1__RemoveScopes *)0;
        }
        /** Friend allocator used by soap_new___ns1__RemoveScopes(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__RemoveScopes * SOAP_FMAC2 soap_instantiate___ns1__RemoveScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:43648 */
#ifndef SOAP_TYPE___ns1__GetDiscoveryMode
#define SOAP_TYPE___ns1__GetDiscoveryMode (2284)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetDiscoveryMode {
      public:
        /** Optional element 'ns1:GetDiscoveryMode' of XSD type 'ns1:GetDiscoveryMode' */
        _ns1__GetDiscoveryMode *ns1__GetDiscoveryMode;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetDiscoveryMode */
        int soap_type() const { return SOAP_TYPE___ns1__GetDiscoveryMode; }
        /** Constructor with member initializations */
        __ns1__GetDiscoveryMode()
        {
          ns1__GetDiscoveryMode = (_ns1__GetDiscoveryMode *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetDiscoveryMode(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetDiscoveryMode * SOAP_FMAC2 soap_instantiate___ns1__GetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:43721 */
#ifndef SOAP_TYPE___ns1__SetDiscoveryMode
#define SOAP_TYPE___ns1__SetDiscoveryMode (2288)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetDiscoveryMode {
      public:
        /** Optional element 'ns1:SetDiscoveryMode' of XSD type 'ns1:SetDiscoveryMode' */
        _ns1__SetDiscoveryMode *ns1__SetDiscoveryMode;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetDiscoveryMode */
        int soap_type() const { return SOAP_TYPE___ns1__SetDiscoveryMode; }
        /** Constructor with member initializations */
        __ns1__SetDiscoveryMode()
        {
          ns1__SetDiscoveryMode = (_ns1__SetDiscoveryMode *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetDiscoveryMode(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetDiscoveryMode * SOAP_FMAC2 soap_instantiate___ns1__SetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:43795 */
#ifndef SOAP_TYPE___ns1__GetRemoteDiscoveryMode
#define SOAP_TYPE___ns1__GetRemoteDiscoveryMode (2292)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetRemoteDiscoveryMode {
      public:
        /** Optional element 'ns1:GetRemoteDiscoveryMode' of XSD type 'ns1:GetRemoteDiscoveryMode' */
        _ns1__GetRemoteDiscoveryMode *ns1__GetRemoteDiscoveryMode;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetRemoteDiscoveryMode */
        int soap_type() const { return SOAP_TYPE___ns1__GetRemoteDiscoveryMode; }
        /** Constructor with member initializations */
        __ns1__GetRemoteDiscoveryMode()
        {
          ns1__GetRemoteDiscoveryMode = (_ns1__GetRemoteDiscoveryMode *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetRemoteDiscoveryMode(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate___ns1__GetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:43869 */
#ifndef SOAP_TYPE___ns1__SetRemoteDiscoveryMode
#define SOAP_TYPE___ns1__SetRemoteDiscoveryMode (2296)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetRemoteDiscoveryMode {
      public:
        /** Optional element 'ns1:SetRemoteDiscoveryMode' of XSD type 'ns1:SetRemoteDiscoveryMode' */
        _ns1__SetRemoteDiscoveryMode *ns1__SetRemoteDiscoveryMode;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetRemoteDiscoveryMode */
        int soap_type() const { return SOAP_TYPE___ns1__SetRemoteDiscoveryMode; }
        /** Constructor with member initializations */
        __ns1__SetRemoteDiscoveryMode()
        {
          ns1__SetRemoteDiscoveryMode = (_ns1__SetRemoteDiscoveryMode *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetRemoteDiscoveryMode(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate___ns1__SetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:43941 */
#ifndef SOAP_TYPE___ns1__GetDPAddresses
#define SOAP_TYPE___ns1__GetDPAddresses (2300)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetDPAddresses {
      public:
        /** Optional element 'ns1:GetDPAddresses' of XSD type 'ns1:GetDPAddresses' */
        _ns1__GetDPAddresses *ns1__GetDPAddresses;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetDPAddresses */
        int soap_type() const { return SOAP_TYPE___ns1__GetDPAddresses; }
        /** Constructor with member initializations */
        __ns1__GetDPAddresses()
        {
          ns1__GetDPAddresses = (_ns1__GetDPAddresses *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetDPAddresses(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetDPAddresses * SOAP_FMAC2 soap_instantiate___ns1__GetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:44015 */
#ifndef SOAP_TYPE___ns1__GetEndpointReference
#define SOAP_TYPE___ns1__GetEndpointReference (2304)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetEndpointReference {
      public:
        /** Optional element 'ns1:GetEndpointReference' of XSD type 'ns1:GetEndpointReference' */
        _ns1__GetEndpointReference *ns1__GetEndpointReference;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetEndpointReference */
        int soap_type() const { return SOAP_TYPE___ns1__GetEndpointReference; }
        /** Constructor with member initializations */
        __ns1__GetEndpointReference()
        {
          ns1__GetEndpointReference = (_ns1__GetEndpointReference *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetEndpointReference(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetEndpointReference * SOAP_FMAC2 soap_instantiate___ns1__GetEndpointReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:44089 */
#ifndef SOAP_TYPE___ns1__GetRemoteUser
#define SOAP_TYPE___ns1__GetRemoteUser (2308)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetRemoteUser {
      public:
        /** Optional element 'ns1:GetRemoteUser' of XSD type 'ns1:GetRemoteUser' */
        _ns1__GetRemoteUser *ns1__GetRemoteUser;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetRemoteUser */
        int soap_type() const { return SOAP_TYPE___ns1__GetRemoteUser; }
        /** Constructor with member initializations */
        __ns1__GetRemoteUser()
        {
          ns1__GetRemoteUser = (_ns1__GetRemoteUser *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetRemoteUser(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetRemoteUser * SOAP_FMAC2 soap_instantiate___ns1__GetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:44168 */
#ifndef SOAP_TYPE___ns1__SetRemoteUser
#define SOAP_TYPE___ns1__SetRemoteUser (2312)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetRemoteUser {
      public:
        /** Optional element 'ns1:SetRemoteUser' of XSD type 'ns1:SetRemoteUser' */
        _ns1__SetRemoteUser *ns1__SetRemoteUser;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetRemoteUser */
        int soap_type() const { return SOAP_TYPE___ns1__SetRemoteUser; }
        /** Constructor with member initializations */
        __ns1__SetRemoteUser()
        {
          ns1__SetRemoteUser = (_ns1__SetRemoteUser *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetRemoteUser(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetRemoteUser * SOAP_FMAC2 soap_instantiate___ns1__SetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:44240 */
#ifndef SOAP_TYPE___ns1__GetUsers
#define SOAP_TYPE___ns1__GetUsers (2316)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetUsers {
      public:
        /** Optional element 'ns1:GetUsers' of XSD type 'ns1:GetUsers' */
        _ns1__GetUsers *ns1__GetUsers;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetUsers */
        int soap_type() const { return SOAP_TYPE___ns1__GetUsers; }
        /** Constructor with member initializations */
        __ns1__GetUsers()
        {
          ns1__GetUsers = (_ns1__GetUsers *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetUsers(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetUsers * SOAP_FMAC2 soap_instantiate___ns1__GetUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:44320 */
#ifndef SOAP_TYPE___ns1__CreateUsers
#define SOAP_TYPE___ns1__CreateUsers (2320)
/* Wrapper: */
struct SOAP_CMAC __ns1__CreateUsers {
      public:
        /** Optional element 'ns1:CreateUsers' of XSD type 'ns1:CreateUsers' */
        _ns1__CreateUsers *ns1__CreateUsers;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CreateUsers */
        int soap_type() const { return SOAP_TYPE___ns1__CreateUsers; }
        /** Constructor with member initializations */
        __ns1__CreateUsers()
        {
          ns1__CreateUsers = (_ns1__CreateUsers *)0;
        }
        /** Friend allocator used by soap_new___ns1__CreateUsers(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__CreateUsers * SOAP_FMAC2 soap_instantiate___ns1__CreateUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:44395 */
#ifndef SOAP_TYPE___ns1__DeleteUsers
#define SOAP_TYPE___ns1__DeleteUsers (2324)
/* Wrapper: */
struct SOAP_CMAC __ns1__DeleteUsers {
      public:
        /** Optional element 'ns1:DeleteUsers' of XSD type 'ns1:DeleteUsers' */
        _ns1__DeleteUsers *ns1__DeleteUsers;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DeleteUsers */
        int soap_type() const { return SOAP_TYPE___ns1__DeleteUsers; }
        /** Constructor with member initializations */
        __ns1__DeleteUsers()
        {
          ns1__DeleteUsers = (_ns1__DeleteUsers *)0;
        }
        /** Friend allocator used by soap_new___ns1__DeleteUsers(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__DeleteUsers * SOAP_FMAC2 soap_instantiate___ns1__DeleteUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:44468 */
#ifndef SOAP_TYPE___ns1__SetUser
#define SOAP_TYPE___ns1__SetUser (2328)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetUser {
      public:
        /** Optional element 'ns1:SetUser' of XSD type 'ns1:SetUser' */
        _ns1__SetUser *ns1__SetUser;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetUser */
        int soap_type() const { return SOAP_TYPE___ns1__SetUser; }
        /** Constructor with member initializations */
        __ns1__SetUser()
        {
          ns1__SetUser = (_ns1__SetUser *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetUser(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetUser * SOAP_FMAC2 soap_instantiate___ns1__SetUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:44543 */
#ifndef SOAP_TYPE___ns1__GetWsdlUrl
#define SOAP_TYPE___ns1__GetWsdlUrl (2332)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetWsdlUrl {
      public:
        /** Optional element 'ns1:GetWsdlUrl' of XSD type 'ns1:GetWsdlUrl' */
        _ns1__GetWsdlUrl *ns1__GetWsdlUrl;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetWsdlUrl */
        int soap_type() const { return SOAP_TYPE___ns1__GetWsdlUrl; }
        /** Constructor with member initializations */
        __ns1__GetWsdlUrl()
        {
          ns1__GetWsdlUrl = (_ns1__GetWsdlUrl *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetWsdlUrl(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetWsdlUrl * SOAP_FMAC2 soap_instantiate___ns1__GetWsdlUrl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:44620 */
#ifndef SOAP_TYPE___ns1__GetCapabilities
#define SOAP_TYPE___ns1__GetCapabilities (2336)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetCapabilities {
      public:
        /** Optional element 'ns1:GetCapabilities' of XSD type 'ns1:GetCapabilities' */
        _ns1__GetCapabilities *ns1__GetCapabilities;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetCapabilities */
        int soap_type() const { return SOAP_TYPE___ns1__GetCapabilities; }
        /** Constructor with member initializations */
        __ns1__GetCapabilities()
        {
          ns1__GetCapabilities = (_ns1__GetCapabilities *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetCapabilities(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetCapabilities * SOAP_FMAC2 soap_instantiate___ns1__GetCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:44693 */
#ifndef SOAP_TYPE___ns1__SetDPAddresses
#define SOAP_TYPE___ns1__SetDPAddresses (2340)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetDPAddresses {
      public:
        /** Optional element 'ns1:SetDPAddresses' of XSD type 'ns1:SetDPAddresses' */
        _ns1__SetDPAddresses *ns1__SetDPAddresses;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetDPAddresses */
        int soap_type() const { return SOAP_TYPE___ns1__SetDPAddresses; }
        /** Constructor with member initializations */
        __ns1__SetDPAddresses()
        {
          ns1__SetDPAddresses = (_ns1__SetDPAddresses *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetDPAddresses(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetDPAddresses * SOAP_FMAC2 soap_instantiate___ns1__SetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:44764 */
#ifndef SOAP_TYPE___ns1__GetHostname
#define SOAP_TYPE___ns1__GetHostname (2344)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetHostname {
      public:
        /** Optional element 'ns1:GetHostname' of XSD type 'ns1:GetHostname' */
        _ns1__GetHostname *ns1__GetHostname;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetHostname */
        int soap_type() const { return SOAP_TYPE___ns1__GetHostname; }
        /** Constructor with member initializations */
        __ns1__GetHostname()
        {
          ns1__GetHostname = (_ns1__GetHostname *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetHostname(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetHostname * SOAP_FMAC2 soap_instantiate___ns1__GetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:44839 */
#ifndef SOAP_TYPE___ns1__SetHostname
#define SOAP_TYPE___ns1__SetHostname (2348)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetHostname {
      public:
        /** Optional element 'ns1:SetHostname' of XSD type 'ns1:SetHostname' */
        _ns1__SetHostname *ns1__SetHostname;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetHostname */
        int soap_type() const { return SOAP_TYPE___ns1__SetHostname; }
        /** Constructor with member initializations */
        __ns1__SetHostname()
        {
          ns1__SetHostname = (_ns1__SetHostname *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetHostname(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetHostname * SOAP_FMAC2 soap_instantiate___ns1__SetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:44907 */
#ifndef SOAP_TYPE___ns1__SetHostnameFromDHCP
#define SOAP_TYPE___ns1__SetHostnameFromDHCP (2352)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetHostnameFromDHCP {
      public:
        /** Optional element 'ns1:SetHostnameFromDHCP' of XSD type 'ns1:SetHostnameFromDHCP' */
        _ns1__SetHostnameFromDHCP *ns1__SetHostnameFromDHCP;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetHostnameFromDHCP */
        int soap_type() const { return SOAP_TYPE___ns1__SetHostnameFromDHCP; }
        /** Constructor with member initializations */
        __ns1__SetHostnameFromDHCP()
        {
          ns1__SetHostnameFromDHCP = (_ns1__SetHostnameFromDHCP *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetHostnameFromDHCP(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetHostnameFromDHCP * SOAP_FMAC2 soap_instantiate___ns1__SetHostnameFromDHCP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:44977 */
#ifndef SOAP_TYPE___ns1__GetDNS
#define SOAP_TYPE___ns1__GetDNS (2356)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetDNS {
      public:
        /** Optional element 'ns1:GetDNS' of XSD type 'ns1:GetDNS' */
        _ns1__GetDNS *ns1__GetDNS;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetDNS */
        int soap_type() const { return SOAP_TYPE___ns1__GetDNS; }
        /** Constructor with member initializations */
        __ns1__GetDNS()
        {
          ns1__GetDNS = (_ns1__GetDNS *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetDNS(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetDNS * SOAP_FMAC2 soap_instantiate___ns1__GetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:45047 */
#ifndef SOAP_TYPE___ns1__SetDNS
#define SOAP_TYPE___ns1__SetDNS (2360)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetDNS {
      public:
        /** Optional element 'ns1:SetDNS' of XSD type 'ns1:SetDNS' */
        _ns1__SetDNS *ns1__SetDNS;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetDNS */
        int soap_type() const { return SOAP_TYPE___ns1__SetDNS; }
        /** Constructor with member initializations */
        __ns1__SetDNS()
        {
          ns1__SetDNS = (_ns1__SetDNS *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetDNS(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetDNS * SOAP_FMAC2 soap_instantiate___ns1__SetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:45118 */
#ifndef SOAP_TYPE___ns1__GetNTP
#define SOAP_TYPE___ns1__GetNTP (2364)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetNTP {
      public:
        /** Optional element 'ns1:GetNTP' of XSD type 'ns1:GetNTP' */
        _ns1__GetNTP *ns1__GetNTP;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetNTP */
        int soap_type() const { return SOAP_TYPE___ns1__GetNTP; }
        /** Constructor with member initializations */
        __ns1__GetNTP()
        {
          ns1__GetNTP = (_ns1__GetNTP *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetNTP(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetNTP * SOAP_FMAC2 soap_instantiate___ns1__GetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:45196 */
#ifndef SOAP_TYPE___ns1__SetNTP
#define SOAP_TYPE___ns1__SetNTP (2368)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetNTP {
      public:
        /** Optional element 'ns1:SetNTP' of XSD type 'ns1:SetNTP' */
        _ns1__SetNTP *ns1__SetNTP;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetNTP */
        int soap_type() const { return SOAP_TYPE___ns1__SetNTP; }
        /** Constructor with member initializations */
        __ns1__SetNTP()
        {
          ns1__SetNTP = (_ns1__SetNTP *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetNTP(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetNTP * SOAP_FMAC2 soap_instantiate___ns1__SetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:45268 */
#ifndef SOAP_TYPE___ns1__GetDynamicDNS
#define SOAP_TYPE___ns1__GetDynamicDNS (2372)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetDynamicDNS {
      public:
        /** Optional element 'ns1:GetDynamicDNS' of XSD type 'ns1:GetDynamicDNS' */
        _ns1__GetDynamicDNS *ns1__GetDynamicDNS;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetDynamicDNS */
        int soap_type() const { return SOAP_TYPE___ns1__GetDynamicDNS; }
        /** Constructor with member initializations */
        __ns1__GetDynamicDNS()
        {
          ns1__GetDynamicDNS = (_ns1__GetDynamicDNS *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetDynamicDNS(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetDynamicDNS * SOAP_FMAC2 soap_instantiate___ns1__GetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:45340 */
#ifndef SOAP_TYPE___ns1__SetDynamicDNS
#define SOAP_TYPE___ns1__SetDynamicDNS (2376)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetDynamicDNS {
      public:
        /** Optional element 'ns1:SetDynamicDNS' of XSD type 'ns1:SetDynamicDNS' */
        _ns1__SetDynamicDNS *ns1__SetDynamicDNS;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetDynamicDNS */
        int soap_type() const { return SOAP_TYPE___ns1__SetDynamicDNS; }
        /** Constructor with member initializations */
        __ns1__SetDynamicDNS()
        {
          ns1__SetDynamicDNS = (_ns1__SetDynamicDNS *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetDynamicDNS(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetDynamicDNS * SOAP_FMAC2 soap_instantiate___ns1__SetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:45412 */
#ifndef SOAP_TYPE___ns1__GetNetworkInterfaces
#define SOAP_TYPE___ns1__GetNetworkInterfaces (2380)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetNetworkInterfaces {
      public:
        /** Optional element 'ns1:GetNetworkInterfaces' of XSD type 'ns1:GetNetworkInterfaces' */
        _ns1__GetNetworkInterfaces *ns1__GetNetworkInterfaces;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetNetworkInterfaces */
        int soap_type() const { return SOAP_TYPE___ns1__GetNetworkInterfaces; }
        /** Constructor with member initializations */
        __ns1__GetNetworkInterfaces()
        {
          ns1__GetNetworkInterfaces = (_ns1__GetNetworkInterfaces *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetNetworkInterfaces(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetNetworkInterfaces * SOAP_FMAC2 soap_instantiate___ns1__GetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:45489 */
#ifndef SOAP_TYPE___ns1__SetNetworkInterfaces
#define SOAP_TYPE___ns1__SetNetworkInterfaces (2384)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetNetworkInterfaces {
      public:
        /** Optional element 'ns1:SetNetworkInterfaces' of XSD type 'ns1:SetNetworkInterfaces' */
        _ns1__SetNetworkInterfaces *ns1__SetNetworkInterfaces;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetNetworkInterfaces */
        int soap_type() const { return SOAP_TYPE___ns1__SetNetworkInterfaces; }
        /** Constructor with member initializations */
        __ns1__SetNetworkInterfaces()
        {
          ns1__SetNetworkInterfaces = (_ns1__SetNetworkInterfaces *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetNetworkInterfaces(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetNetworkInterfaces * SOAP_FMAC2 soap_instantiate___ns1__SetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:45560 */
#ifndef SOAP_TYPE___ns1__GetNetworkProtocols
#define SOAP_TYPE___ns1__GetNetworkProtocols (2388)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetNetworkProtocols {
      public:
        /** Optional element 'ns1:GetNetworkProtocols' of XSD type 'ns1:GetNetworkProtocols' */
        _ns1__GetNetworkProtocols *ns1__GetNetworkProtocols;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetNetworkProtocols */
        int soap_type() const { return SOAP_TYPE___ns1__GetNetworkProtocols; }
        /** Constructor with member initializations */
        __ns1__GetNetworkProtocols()
        {
          ns1__GetNetworkProtocols = (_ns1__GetNetworkProtocols *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetNetworkProtocols(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetNetworkProtocols * SOAP_FMAC2 soap_instantiate___ns1__GetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:45631 */
#ifndef SOAP_TYPE___ns1__SetNetworkProtocols
#define SOAP_TYPE___ns1__SetNetworkProtocols (2392)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetNetworkProtocols {
      public:
        /** Optional element 'ns1:SetNetworkProtocols' of XSD type 'ns1:SetNetworkProtocols' */
        _ns1__SetNetworkProtocols *ns1__SetNetworkProtocols;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetNetworkProtocols */
        int soap_type() const { return SOAP_TYPE___ns1__SetNetworkProtocols; }
        /** Constructor with member initializations */
        __ns1__SetNetworkProtocols()
        {
          ns1__SetNetworkProtocols = (_ns1__SetNetworkProtocols *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetNetworkProtocols(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetNetworkProtocols * SOAP_FMAC2 soap_instantiate___ns1__SetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:45702 */
#ifndef SOAP_TYPE___ns1__GetNetworkDefaultGateway
#define SOAP_TYPE___ns1__GetNetworkDefaultGateway (2396)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetNetworkDefaultGateway {
      public:
        /** Optional element 'ns1:GetNetworkDefaultGateway' of XSD type 'ns1:GetNetworkDefaultGateway' */
        _ns1__GetNetworkDefaultGateway *ns1__GetNetworkDefaultGateway;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetNetworkDefaultGateway */
        int soap_type() const { return SOAP_TYPE___ns1__GetNetworkDefaultGateway; }
        /** Constructor with member initializations */
        __ns1__GetNetworkDefaultGateway()
        {
          ns1__GetNetworkDefaultGateway = (_ns1__GetNetworkDefaultGateway *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetNetworkDefaultGateway(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate___ns1__GetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:45772 */
#ifndef SOAP_TYPE___ns1__SetNetworkDefaultGateway
#define SOAP_TYPE___ns1__SetNetworkDefaultGateway (2400)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetNetworkDefaultGateway {
      public:
        /** Optional element 'ns1:SetNetworkDefaultGateway' of XSD type 'ns1:SetNetworkDefaultGateway' */
        _ns1__SetNetworkDefaultGateway *ns1__SetNetworkDefaultGateway;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetNetworkDefaultGateway */
        int soap_type() const { return SOAP_TYPE___ns1__SetNetworkDefaultGateway; }
        /** Constructor with member initializations */
        __ns1__SetNetworkDefaultGateway()
        {
          ns1__SetNetworkDefaultGateway = (_ns1__SetNetworkDefaultGateway *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetNetworkDefaultGateway(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate___ns1__SetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:45847 */
#ifndef SOAP_TYPE___ns1__GetZeroConfiguration
#define SOAP_TYPE___ns1__GetZeroConfiguration (2404)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetZeroConfiguration {
      public:
        /** Optional element 'ns1:GetZeroConfiguration' of XSD type 'ns1:GetZeroConfiguration' */
        _ns1__GetZeroConfiguration *ns1__GetZeroConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetZeroConfiguration */
        int soap_type() const { return SOAP_TYPE___ns1__GetZeroConfiguration; }
        /** Constructor with member initializations */
        __ns1__GetZeroConfiguration()
        {
          ns1__GetZeroConfiguration = (_ns1__GetZeroConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetZeroConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetZeroConfiguration * SOAP_FMAC2 soap_instantiate___ns1__GetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:45916 */
#ifndef SOAP_TYPE___ns1__SetZeroConfiguration
#define SOAP_TYPE___ns1__SetZeroConfiguration (2408)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetZeroConfiguration {
      public:
        /** Optional element 'ns1:SetZeroConfiguration' of XSD type 'ns1:SetZeroConfiguration' */
        _ns1__SetZeroConfiguration *ns1__SetZeroConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetZeroConfiguration */
        int soap_type() const { return SOAP_TYPE___ns1__SetZeroConfiguration; }
        /** Constructor with member initializations */
        __ns1__SetZeroConfiguration()
        {
          ns1__SetZeroConfiguration = (_ns1__SetZeroConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetZeroConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetZeroConfiguration * SOAP_FMAC2 soap_instantiate___ns1__SetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:45988 */
#ifndef SOAP_TYPE___ns1__GetIPAddressFilter
#define SOAP_TYPE___ns1__GetIPAddressFilter (2412)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetIPAddressFilter {
      public:
        /** Optional element 'ns1:GetIPAddressFilter' of XSD type 'ns1:GetIPAddressFilter' */
        _ns1__GetIPAddressFilter *ns1__GetIPAddressFilter;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetIPAddressFilter */
        int soap_type() const { return SOAP_TYPE___ns1__GetIPAddressFilter; }
        /** Constructor with member initializations */
        __ns1__GetIPAddressFilter()
        {
          ns1__GetIPAddressFilter = (_ns1__GetIPAddressFilter *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetIPAddressFilter(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetIPAddressFilter * SOAP_FMAC2 soap_instantiate___ns1__GetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:46062 */
#ifndef SOAP_TYPE___ns1__SetIPAddressFilter
#define SOAP_TYPE___ns1__SetIPAddressFilter (2416)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetIPAddressFilter {
      public:
        /** Optional element 'ns1:SetIPAddressFilter' of XSD type 'ns1:SetIPAddressFilter' */
        _ns1__SetIPAddressFilter *ns1__SetIPAddressFilter;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetIPAddressFilter */
        int soap_type() const { return SOAP_TYPE___ns1__SetIPAddressFilter; }
        /** Constructor with member initializations */
        __ns1__SetIPAddressFilter()
        {
          ns1__SetIPAddressFilter = (_ns1__SetIPAddressFilter *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetIPAddressFilter(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetIPAddressFilter * SOAP_FMAC2 soap_instantiate___ns1__SetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:46135 */
#ifndef SOAP_TYPE___ns1__AddIPAddressFilter
#define SOAP_TYPE___ns1__AddIPAddressFilter (2420)
/* Wrapper: */
struct SOAP_CMAC __ns1__AddIPAddressFilter {
      public:
        /** Optional element 'ns1:AddIPAddressFilter' of XSD type 'ns1:AddIPAddressFilter' */
        _ns1__AddIPAddressFilter *ns1__AddIPAddressFilter;
      public:
        /** Return unique type id SOAP_TYPE___ns1__AddIPAddressFilter */
        int soap_type() const { return SOAP_TYPE___ns1__AddIPAddressFilter; }
        /** Constructor with member initializations */
        __ns1__AddIPAddressFilter()
        {
          ns1__AddIPAddressFilter = (_ns1__AddIPAddressFilter *)0;
        }
        /** Friend allocator used by soap_new___ns1__AddIPAddressFilter(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__AddIPAddressFilter * SOAP_FMAC2 soap_instantiate___ns1__AddIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:46208 */
#ifndef SOAP_TYPE___ns1__RemoveIPAddressFilter
#define SOAP_TYPE___ns1__RemoveIPAddressFilter (2424)
/* Wrapper: */
struct SOAP_CMAC __ns1__RemoveIPAddressFilter {
      public:
        /** Optional element 'ns1:RemoveIPAddressFilter' of XSD type 'ns1:RemoveIPAddressFilter' */
        _ns1__RemoveIPAddressFilter *ns1__RemoveIPAddressFilter;
      public:
        /** Return unique type id SOAP_TYPE___ns1__RemoveIPAddressFilter */
        int soap_type() const { return SOAP_TYPE___ns1__RemoveIPAddressFilter; }
        /** Constructor with member initializations */
        __ns1__RemoveIPAddressFilter()
        {
          ns1__RemoveIPAddressFilter = (_ns1__RemoveIPAddressFilter *)0;
        }
        /** Friend allocator used by soap_new___ns1__RemoveIPAddressFilter(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__RemoveIPAddressFilter * SOAP_FMAC2 soap_instantiate___ns1__RemoveIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:46290 */
#ifndef SOAP_TYPE___ns1__GetAccessPolicy
#define SOAP_TYPE___ns1__GetAccessPolicy (2428)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetAccessPolicy {
      public:
        /** Optional element 'ns1:GetAccessPolicy' of XSD type 'ns1:GetAccessPolicy' */
        _ns1__GetAccessPolicy *ns1__GetAccessPolicy;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetAccessPolicy */
        int soap_type() const { return SOAP_TYPE___ns1__GetAccessPolicy; }
        /** Constructor with member initializations */
        __ns1__GetAccessPolicy()
        {
          ns1__GetAccessPolicy = (_ns1__GetAccessPolicy *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetAccessPolicy(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetAccessPolicy * SOAP_FMAC2 soap_instantiate___ns1__GetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:46363 */
#ifndef SOAP_TYPE___ns1__SetAccessPolicy
#define SOAP_TYPE___ns1__SetAccessPolicy (2432)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetAccessPolicy {
      public:
        /** Optional element 'ns1:SetAccessPolicy' of XSD type 'ns1:SetAccessPolicy' */
        _ns1__SetAccessPolicy *ns1__SetAccessPolicy;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetAccessPolicy */
        int soap_type() const { return SOAP_TYPE___ns1__SetAccessPolicy; }
        /** Constructor with member initializations */
        __ns1__SetAccessPolicy()
        {
          ns1__SetAccessPolicy = (_ns1__SetAccessPolicy *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetAccessPolicy(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetAccessPolicy * SOAP_FMAC2 soap_instantiate___ns1__SetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:46446 */
#ifndef SOAP_TYPE___ns1__CreateCertificate
#define SOAP_TYPE___ns1__CreateCertificate (2436)
/* Wrapper: */
struct SOAP_CMAC __ns1__CreateCertificate {
      public:
        /** Optional element 'ns1:CreateCertificate' of XSD type 'ns1:CreateCertificate' */
        _ns1__CreateCertificate *ns1__CreateCertificate;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CreateCertificate */
        int soap_type() const { return SOAP_TYPE___ns1__CreateCertificate; }
        /** Constructor with member initializations */
        __ns1__CreateCertificate()
        {
          ns1__CreateCertificate = (_ns1__CreateCertificate *)0;
        }
        /** Friend allocator used by soap_new___ns1__CreateCertificate(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__CreateCertificate * SOAP_FMAC2 soap_instantiate___ns1__CreateCertificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:46526 */
#ifndef SOAP_TYPE___ns1__GetCertificates
#define SOAP_TYPE___ns1__GetCertificates (2440)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetCertificates {
      public:
        /** Optional element 'ns1:GetCertificates' of XSD type 'ns1:GetCertificates' */
        _ns1__GetCertificates *ns1__GetCertificates;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetCertificates */
        int soap_type() const { return SOAP_TYPE___ns1__GetCertificates; }
        /** Constructor with member initializations */
        __ns1__GetCertificates()
        {
          ns1__GetCertificates = (_ns1__GetCertificates *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetCertificates(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetCertificates * SOAP_FMAC2 soap_instantiate___ns1__GetCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:46597 */
#ifndef SOAP_TYPE___ns1__GetCertificatesStatus
#define SOAP_TYPE___ns1__GetCertificatesStatus (2444)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetCertificatesStatus {
      public:
        /** Optional element 'ns1:GetCertificatesStatus' of XSD type 'ns1:GetCertificatesStatus' */
        _ns1__GetCertificatesStatus *ns1__GetCertificatesStatus;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetCertificatesStatus */
        int soap_type() const { return SOAP_TYPE___ns1__GetCertificatesStatus; }
        /** Constructor with member initializations */
        __ns1__GetCertificatesStatus()
        {
          ns1__GetCertificatesStatus = (_ns1__GetCertificatesStatus *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetCertificatesStatus(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetCertificatesStatus * SOAP_FMAC2 soap_instantiate___ns1__GetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:46670 */
#ifndef SOAP_TYPE___ns1__SetCertificatesStatus
#define SOAP_TYPE___ns1__SetCertificatesStatus (2448)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetCertificatesStatus {
      public:
        /** Optional element 'ns1:SetCertificatesStatus' of XSD type 'ns1:SetCertificatesStatus' */
        _ns1__SetCertificatesStatus *ns1__SetCertificatesStatus;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetCertificatesStatus */
        int soap_type() const { return SOAP_TYPE___ns1__SetCertificatesStatus; }
        /** Constructor with member initializations */
        __ns1__SetCertificatesStatus()
        {
          ns1__SetCertificatesStatus = (_ns1__SetCertificatesStatus *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetCertificatesStatus(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetCertificatesStatus * SOAP_FMAC2 soap_instantiate___ns1__SetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:46746 */
#ifndef SOAP_TYPE___ns1__DeleteCertificates
#define SOAP_TYPE___ns1__DeleteCertificates (2452)
/* Wrapper: */
struct SOAP_CMAC __ns1__DeleteCertificates {
      public:
        /** Optional element 'ns1:DeleteCertificates' of XSD type 'ns1:DeleteCertificates' */
        _ns1__DeleteCertificates *ns1__DeleteCertificates;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DeleteCertificates */
        int soap_type() const { return SOAP_TYPE___ns1__DeleteCertificates; }
        /** Constructor with member initializations */
        __ns1__DeleteCertificates()
        {
          ns1__DeleteCertificates = (_ns1__DeleteCertificates *)0;
        }
        /** Friend allocator used by soap_new___ns1__DeleteCertificates(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__DeleteCertificates * SOAP_FMAC2 soap_instantiate___ns1__DeleteCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:46827 */
#ifndef SOAP_TYPE___ns1__GetPkcs10Request
#define SOAP_TYPE___ns1__GetPkcs10Request (2456)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetPkcs10Request {
      public:
        /** Optional element 'ns1:GetPkcs10Request' of XSD type 'ns1:GetPkcs10Request' */
        _ns1__GetPkcs10Request *ns1__GetPkcs10Request;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetPkcs10Request */
        int soap_type() const { return SOAP_TYPE___ns1__GetPkcs10Request; }
        /** Constructor with member initializations */
        __ns1__GetPkcs10Request()
        {
          ns1__GetPkcs10Request = (_ns1__GetPkcs10Request *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetPkcs10Request(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetPkcs10Request * SOAP_FMAC2 soap_instantiate___ns1__GetPkcs10Request(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:46918 */
#ifndef SOAP_TYPE___ns1__LoadCertificates
#define SOAP_TYPE___ns1__LoadCertificates (2460)
/* Wrapper: */
struct SOAP_CMAC __ns1__LoadCertificates {
      public:
        /** Optional element 'ns1:LoadCertificates' of XSD type 'ns1:LoadCertificates' */
        _ns1__LoadCertificates *ns1__LoadCertificates;
      public:
        /** Return unique type id SOAP_TYPE___ns1__LoadCertificates */
        int soap_type() const { return SOAP_TYPE___ns1__LoadCertificates; }
        /** Constructor with member initializations */
        __ns1__LoadCertificates()
        {
          ns1__LoadCertificates = (_ns1__LoadCertificates *)0;
        }
        /** Friend allocator used by soap_new___ns1__LoadCertificates(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__LoadCertificates * SOAP_FMAC2 soap_instantiate___ns1__LoadCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:46989 */
#ifndef SOAP_TYPE___ns1__GetClientCertificateMode
#define SOAP_TYPE___ns1__GetClientCertificateMode (2464)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetClientCertificateMode {
      public:
        /** Optional element 'ns1:GetClientCertificateMode' of XSD type 'ns1:GetClientCertificateMode' */
        _ns1__GetClientCertificateMode *ns1__GetClientCertificateMode;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetClientCertificateMode */
        int soap_type() const { return SOAP_TYPE___ns1__GetClientCertificateMode; }
        /** Constructor with member initializations */
        __ns1__GetClientCertificateMode()
        {
          ns1__GetClientCertificateMode = (_ns1__GetClientCertificateMode *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetClientCertificateMode(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetClientCertificateMode * SOAP_FMAC2 soap_instantiate___ns1__GetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:47060 */
#ifndef SOAP_TYPE___ns1__SetClientCertificateMode
#define SOAP_TYPE___ns1__SetClientCertificateMode (2468)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetClientCertificateMode {
      public:
        /** Optional element 'ns1:SetClientCertificateMode' of XSD type 'ns1:SetClientCertificateMode' */
        _ns1__SetClientCertificateMode *ns1__SetClientCertificateMode;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetClientCertificateMode */
        int soap_type() const { return SOAP_TYPE___ns1__SetClientCertificateMode; }
        /** Constructor with member initializations */
        __ns1__SetClientCertificateMode()
        {
          ns1__SetClientCertificateMode = (_ns1__SetClientCertificateMode *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetClientCertificateMode(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetClientCertificateMode * SOAP_FMAC2 soap_instantiate___ns1__SetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:47130 */
#ifndef SOAP_TYPE___ns1__GetRelayOutputs
#define SOAP_TYPE___ns1__GetRelayOutputs (2472)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetRelayOutputs {
      public:
        /** Optional element 'ns1:GetRelayOutputs' of XSD type 'ns1:GetRelayOutputs' */
        _ns1__GetRelayOutputs *ns1__GetRelayOutputs;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetRelayOutputs */
        int soap_type() const { return SOAP_TYPE___ns1__GetRelayOutputs; }
        /** Constructor with member initializations */
        __ns1__GetRelayOutputs()
        {
          ns1__GetRelayOutputs = (_ns1__GetRelayOutputs *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetRelayOutputs(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetRelayOutputs * SOAP_FMAC2 soap_instantiate___ns1__GetRelayOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:47200 */
#ifndef SOAP_TYPE___ns1__SetRelayOutputSettings
#define SOAP_TYPE___ns1__SetRelayOutputSettings (2476)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetRelayOutputSettings {
      public:
        /** Optional element 'ns1:SetRelayOutputSettings' of XSD type 'ns1:SetRelayOutputSettings' */
        _ns1__SetRelayOutputSettings *ns1__SetRelayOutputSettings;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetRelayOutputSettings */
        int soap_type() const { return SOAP_TYPE___ns1__SetRelayOutputSettings; }
        /** Constructor with member initializations */
        __ns1__SetRelayOutputSettings()
        {
          ns1__SetRelayOutputSettings = (_ns1__SetRelayOutputSettings *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetRelayOutputSettings(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate___ns1__SetRelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:47270 */
#ifndef SOAP_TYPE___ns1__SetRelayOutputState
#define SOAP_TYPE___ns1__SetRelayOutputState (2480)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetRelayOutputState {
      public:
        /** Optional element 'ns1:SetRelayOutputState' of XSD type 'ns1:SetRelayOutputState' */
        _ns1__SetRelayOutputState *ns1__SetRelayOutputState;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetRelayOutputState */
        int soap_type() const { return SOAP_TYPE___ns1__SetRelayOutputState; }
        /** Constructor with member initializations */
        __ns1__SetRelayOutputState()
        {
          ns1__SetRelayOutputState = (_ns1__SetRelayOutputState *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetRelayOutputState(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetRelayOutputState * SOAP_FMAC2 soap_instantiate___ns1__SetRelayOutputState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:47369 */
#ifndef SOAP_TYPE___ns1__SendAuxiliaryCommand
#define SOAP_TYPE___ns1__SendAuxiliaryCommand (2484)
/* Wrapper: */
struct SOAP_CMAC __ns1__SendAuxiliaryCommand {
      public:
        /** Optional element 'ns1:SendAuxiliaryCommand' of XSD type 'ns1:SendAuxiliaryCommand' */
        _ns1__SendAuxiliaryCommand *ns1__SendAuxiliaryCommand;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SendAuxiliaryCommand */
        int soap_type() const { return SOAP_TYPE___ns1__SendAuxiliaryCommand; }
        /** Constructor with member initializations */
        __ns1__SendAuxiliaryCommand()
        {
          ns1__SendAuxiliaryCommand = (_ns1__SendAuxiliaryCommand *)0;
        }
        /** Friend allocator used by soap_new___ns1__SendAuxiliaryCommand(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate___ns1__SendAuxiliaryCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:47448 */
#ifndef SOAP_TYPE___ns1__GetCACertificates
#define SOAP_TYPE___ns1__GetCACertificates (2488)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetCACertificates {
      public:
        /** Optional element 'ns1:GetCACertificates' of XSD type 'ns1:GetCACertificates' */
        _ns1__GetCACertificates *ns1__GetCACertificates;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetCACertificates */
        int soap_type() const { return SOAP_TYPE___ns1__GetCACertificates; }
        /** Constructor with member initializations */
        __ns1__GetCACertificates()
        {
          ns1__GetCACertificates = (_ns1__GetCACertificates *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetCACertificates(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetCACertificates * SOAP_FMAC2 soap_instantiate___ns1__GetCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:47539 */
#ifndef SOAP_TYPE___ns1__LoadCertificateWithPrivateKey
#define SOAP_TYPE___ns1__LoadCertificateWithPrivateKey (2492)
/* Wrapper: */
struct SOAP_CMAC __ns1__LoadCertificateWithPrivateKey {
      public:
        /** Optional element 'ns1:LoadCertificateWithPrivateKey' of XSD type 'ns1:LoadCertificateWithPrivateKey' */
        _ns1__LoadCertificateWithPrivateKey *ns1__LoadCertificateWithPrivateKey;
      public:
        /** Return unique type id SOAP_TYPE___ns1__LoadCertificateWithPrivateKey */
        int soap_type() const { return SOAP_TYPE___ns1__LoadCertificateWithPrivateKey; }
        /** Constructor with member initializations */
        __ns1__LoadCertificateWithPrivateKey()
        {
          ns1__LoadCertificateWithPrivateKey = (_ns1__LoadCertificateWithPrivateKey *)0;
        }
        /** Friend allocator used by soap_new___ns1__LoadCertificateWithPrivateKey(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__LoadCertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate___ns1__LoadCertificateWithPrivateKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:47617 */
#ifndef SOAP_TYPE___ns1__GetCertificateInformation
#define SOAP_TYPE___ns1__GetCertificateInformation (2496)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetCertificateInformation {
      public:
        /** Optional element 'ns1:GetCertificateInformation' of XSD type 'ns1:GetCertificateInformation' */
        _ns1__GetCertificateInformation *ns1__GetCertificateInformation;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetCertificateInformation */
        int soap_type() const { return SOAP_TYPE___ns1__GetCertificateInformation; }
        /** Constructor with member initializations */
        __ns1__GetCertificateInformation()
        {
          ns1__GetCertificateInformation = (_ns1__GetCertificateInformation *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetCertificateInformation(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetCertificateInformation * SOAP_FMAC2 soap_instantiate___ns1__GetCertificateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:47702 */
#ifndef SOAP_TYPE___ns1__LoadCACertificates
#define SOAP_TYPE___ns1__LoadCACertificates (2500)
/* Wrapper: */
struct SOAP_CMAC __ns1__LoadCACertificates {
      public:
        /** Optional element 'ns1:LoadCACertificates' of XSD type 'ns1:LoadCACertificates' */
        _ns1__LoadCACertificates *ns1__LoadCACertificates;
      public:
        /** Return unique type id SOAP_TYPE___ns1__LoadCACertificates */
        int soap_type() const { return SOAP_TYPE___ns1__LoadCACertificates; }
        /** Constructor with member initializations */
        __ns1__LoadCACertificates()
        {
          ns1__LoadCACertificates = (_ns1__LoadCACertificates *)0;
        }
        /** Friend allocator used by soap_new___ns1__LoadCACertificates(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__LoadCACertificates * SOAP_FMAC2 soap_instantiate___ns1__LoadCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:47778 */
#ifndef SOAP_TYPE___ns1__CreateDot1XConfiguration
#define SOAP_TYPE___ns1__CreateDot1XConfiguration (2504)
/* Wrapper: */
struct SOAP_CMAC __ns1__CreateDot1XConfiguration {
      public:
        /** Optional element 'ns1:CreateDot1XConfiguration' of XSD type 'ns1:CreateDot1XConfiguration' */
        _ns1__CreateDot1XConfiguration *ns1__CreateDot1XConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CreateDot1XConfiguration */
        int soap_type() const { return SOAP_TYPE___ns1__CreateDot1XConfiguration; }
        /** Constructor with member initializations */
        __ns1__CreateDot1XConfiguration()
        {
          ns1__CreateDot1XConfiguration = (_ns1__CreateDot1XConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns1__CreateDot1XConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__CreateDot1XConfiguration * SOAP_FMAC2 soap_instantiate___ns1__CreateDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:47850 */
#ifndef SOAP_TYPE___ns1__SetDot1XConfiguration
#define SOAP_TYPE___ns1__SetDot1XConfiguration (2508)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetDot1XConfiguration {
      public:
        /** Optional element 'ns1:SetDot1XConfiguration' of XSD type 'ns1:SetDot1XConfiguration' */
        _ns1__SetDot1XConfiguration *ns1__SetDot1XConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetDot1XConfiguration */
        int soap_type() const { return SOAP_TYPE___ns1__SetDot1XConfiguration; }
        /** Constructor with member initializations */
        __ns1__SetDot1XConfiguration()
        {
          ns1__SetDot1XConfiguration = (_ns1__SetDot1XConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetDot1XConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetDot1XConfiguration * SOAP_FMAC2 soap_instantiate___ns1__SetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:47926 */
#ifndef SOAP_TYPE___ns1__GetDot1XConfiguration
#define SOAP_TYPE___ns1__GetDot1XConfiguration (2512)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetDot1XConfiguration {
      public:
        /** Optional element 'ns1:GetDot1XConfiguration' of XSD type 'ns1:GetDot1XConfiguration' */
        _ns1__GetDot1XConfiguration *ns1__GetDot1XConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetDot1XConfiguration */
        int soap_type() const { return SOAP_TYPE___ns1__GetDot1XConfiguration; }
        /** Constructor with member initializations */
        __ns1__GetDot1XConfiguration()
        {
          ns1__GetDot1XConfiguration = (_ns1__GetDot1XConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetDot1XConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetDot1XConfiguration * SOAP_FMAC2 soap_instantiate___ns1__GetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:48005 */
#ifndef SOAP_TYPE___ns1__GetDot1XConfigurations
#define SOAP_TYPE___ns1__GetDot1XConfigurations (2516)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetDot1XConfigurations {
      public:
        /** Optional element 'ns1:GetDot1XConfigurations' of XSD type 'ns1:GetDot1XConfigurations' */
        _ns1__GetDot1XConfigurations *ns1__GetDot1XConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetDot1XConfigurations */
        int soap_type() const { return SOAP_TYPE___ns1__GetDot1XConfigurations; }
        /** Constructor with member initializations */
        __ns1__GetDot1XConfigurations()
        {
          ns1__GetDot1XConfigurations = (_ns1__GetDot1XConfigurations *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetDot1XConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetDot1XConfigurations * SOAP_FMAC2 soap_instantiate___ns1__GetDot1XConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:48078 */
#ifndef SOAP_TYPE___ns1__DeleteDot1XConfiguration
#define SOAP_TYPE___ns1__DeleteDot1XConfiguration (2520)
/* Wrapper: */
struct SOAP_CMAC __ns1__DeleteDot1XConfiguration {
      public:
        /** Optional element 'ns1:DeleteDot1XConfiguration' of XSD type 'ns1:DeleteDot1XConfiguration' */
        _ns1__DeleteDot1XConfiguration *ns1__DeleteDot1XConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DeleteDot1XConfiguration */
        int soap_type() const { return SOAP_TYPE___ns1__DeleteDot1XConfiguration; }
        /** Constructor with member initializations */
        __ns1__DeleteDot1XConfiguration()
        {
          ns1__DeleteDot1XConfiguration = (_ns1__DeleteDot1XConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns1__DeleteDot1XConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__DeleteDot1XConfiguration * SOAP_FMAC2 soap_instantiate___ns1__DeleteDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:48147 */
#ifndef SOAP_TYPE___ns1__GetDot11Capabilities
#define SOAP_TYPE___ns1__GetDot11Capabilities (2524)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetDot11Capabilities {
      public:
        /** Optional element 'ns1:GetDot11Capabilities' of XSD type 'ns1:GetDot11Capabilities' */
        _ns1__GetDot11Capabilities *ns1__GetDot11Capabilities;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetDot11Capabilities */
        int soap_type() const { return SOAP_TYPE___ns1__GetDot11Capabilities; }
        /** Constructor with member initializations */
        __ns1__GetDot11Capabilities()
        {
          ns1__GetDot11Capabilities = (_ns1__GetDot11Capabilities *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetDot11Capabilities(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetDot11Capabilities * SOAP_FMAC2 soap_instantiate___ns1__GetDot11Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:48217 */
#ifndef SOAP_TYPE___ns1__GetDot11Status
#define SOAP_TYPE___ns1__GetDot11Status (2528)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetDot11Status {
      public:
        /** Optional element 'ns1:GetDot11Status' of XSD type 'ns1:GetDot11Status' */
        _ns1__GetDot11Status *ns1__GetDot11Status;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetDot11Status */
        int soap_type() const { return SOAP_TYPE___ns1__GetDot11Status; }
        /** Constructor with member initializations */
        __ns1__GetDot11Status()
        {
          ns1__GetDot11Status = (_ns1__GetDot11Status *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetDot11Status(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetDot11Status * SOAP_FMAC2 soap_instantiate___ns1__GetDot11Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:48287 */
#ifndef SOAP_TYPE___ns1__ScanAvailableDot11Networks
#define SOAP_TYPE___ns1__ScanAvailableDot11Networks (2532)
/* Wrapper: */
struct SOAP_CMAC __ns1__ScanAvailableDot11Networks {
      public:
        /** Optional element 'ns1:ScanAvailableDot11Networks' of XSD type 'ns1:ScanAvailableDot11Networks' */
        _ns1__ScanAvailableDot11Networks *ns1__ScanAvailableDot11Networks;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ScanAvailableDot11Networks */
        int soap_type() const { return SOAP_TYPE___ns1__ScanAvailableDot11Networks; }
        /** Constructor with member initializations */
        __ns1__ScanAvailableDot11Networks()
        {
          ns1__ScanAvailableDot11Networks = (_ns1__ScanAvailableDot11Networks *)0;
        }
        /** Friend allocator used by soap_new___ns1__ScanAvailableDot11Networks(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__ScanAvailableDot11Networks * SOAP_FMAC2 soap_instantiate___ns1__ScanAvailableDot11Networks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:48374 */
#ifndef SOAP_TYPE___ns1__GetSystemUris
#define SOAP_TYPE___ns1__GetSystemUris (2536)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetSystemUris {
      public:
        /** Optional element 'ns1:GetSystemUris' of XSD type 'ns1:GetSystemUris' */
        _ns1__GetSystemUris *ns1__GetSystemUris;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetSystemUris */
        int soap_type() const { return SOAP_TYPE___ns1__GetSystemUris; }
        /** Constructor with member initializations */
        __ns1__GetSystemUris()
        {
          ns1__GetSystemUris = (_ns1__GetSystemUris *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetSystemUris(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetSystemUris * SOAP_FMAC2 soap_instantiate___ns1__GetSystemUris(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:48470 */
#ifndef SOAP_TYPE___ns1__StartFirmwareUpgrade
#define SOAP_TYPE___ns1__StartFirmwareUpgrade (2540)
/* Wrapper: */
struct SOAP_CMAC __ns1__StartFirmwareUpgrade {
      public:
        /** Optional element 'ns1:StartFirmwareUpgrade' of XSD type 'ns1:StartFirmwareUpgrade' */
        _ns1__StartFirmwareUpgrade *ns1__StartFirmwareUpgrade;
      public:
        /** Return unique type id SOAP_TYPE___ns1__StartFirmwareUpgrade */
        int soap_type() const { return SOAP_TYPE___ns1__StartFirmwareUpgrade; }
        /** Constructor with member initializations */
        __ns1__StartFirmwareUpgrade()
        {
          ns1__StartFirmwareUpgrade = (_ns1__StartFirmwareUpgrade *)0;
        }
        /** Friend allocator used by soap_new___ns1__StartFirmwareUpgrade(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__StartFirmwareUpgrade * SOAP_FMAC2 soap_instantiate___ns1__StartFirmwareUpgrade(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:48565 */
#ifndef SOAP_TYPE___ns1__StartSystemRestore
#define SOAP_TYPE___ns1__StartSystemRestore (2544)
/* Wrapper: */
struct SOAP_CMAC __ns1__StartSystemRestore {
      public:
        /** Optional element 'ns1:StartSystemRestore' of XSD type 'ns1:StartSystemRestore' */
        _ns1__StartSystemRestore *ns1__StartSystemRestore;
      public:
        /** Return unique type id SOAP_TYPE___ns1__StartSystemRestore */
        int soap_type() const { return SOAP_TYPE___ns1__StartSystemRestore; }
        /** Constructor with member initializations */
        __ns1__StartSystemRestore()
        {
          ns1__StartSystemRestore = (_ns1__StartSystemRestore *)0;
        }
        /** Friend allocator used by soap_new___ns1__StartSystemRestore(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__StartSystemRestore * SOAP_FMAC2 soap_instantiate___ns1__StartSystemRestore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:48636 */
#ifndef SOAP_TYPE___ns1__GetStorageConfigurations
#define SOAP_TYPE___ns1__GetStorageConfigurations (2548)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetStorageConfigurations {
      public:
        /** Optional element 'ns1:GetStorageConfigurations' of XSD type 'ns1:GetStorageConfigurations' */
        _ns1__GetStorageConfigurations *ns1__GetStorageConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetStorageConfigurations */
        int soap_type() const { return SOAP_TYPE___ns1__GetStorageConfigurations; }
        /** Constructor with member initializations */
        __ns1__GetStorageConfigurations()
        {
          ns1__GetStorageConfigurations = (_ns1__GetStorageConfigurations *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetStorageConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetStorageConfigurations * SOAP_FMAC2 soap_instantiate___ns1__GetStorageConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:48708 */
#ifndef SOAP_TYPE___ns1__CreateStorageConfiguration
#define SOAP_TYPE___ns1__CreateStorageConfiguration (2552)
/* Wrapper: */
struct SOAP_CMAC __ns1__CreateStorageConfiguration {
      public:
        /** Optional element 'ns1:CreateStorageConfiguration' of XSD type 'ns1:CreateStorageConfiguration' */
        _ns1__CreateStorageConfiguration *ns1__CreateStorageConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CreateStorageConfiguration */
        int soap_type() const { return SOAP_TYPE___ns1__CreateStorageConfiguration; }
        /** Constructor with member initializations */
        __ns1__CreateStorageConfiguration()
        {
          ns1__CreateStorageConfiguration = (_ns1__CreateStorageConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns1__CreateStorageConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__CreateStorageConfiguration * SOAP_FMAC2 soap_instantiate___ns1__CreateStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:48779 */
#ifndef SOAP_TYPE___ns1__GetStorageConfiguration
#define SOAP_TYPE___ns1__GetStorageConfiguration (2556)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetStorageConfiguration {
      public:
        /** Optional element 'ns1:GetStorageConfiguration' of XSD type 'ns1:GetStorageConfiguration' */
        _ns1__GetStorageConfiguration *ns1__GetStorageConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetStorageConfiguration */
        int soap_type() const { return SOAP_TYPE___ns1__GetStorageConfiguration; }
        /** Constructor with member initializations */
        __ns1__GetStorageConfiguration()
        {
          ns1__GetStorageConfiguration = (_ns1__GetStorageConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetStorageConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetStorageConfiguration * SOAP_FMAC2 soap_instantiate___ns1__GetStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:48849 */
#ifndef SOAP_TYPE___ns1__SetStorageConfiguration
#define SOAP_TYPE___ns1__SetStorageConfiguration (2560)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetStorageConfiguration {
      public:
        /** Optional element 'ns1:SetStorageConfiguration' of XSD type 'ns1:SetStorageConfiguration' */
        _ns1__SetStorageConfiguration *ns1__SetStorageConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetStorageConfiguration */
        int soap_type() const { return SOAP_TYPE___ns1__SetStorageConfiguration; }
        /** Constructor with member initializations */
        __ns1__SetStorageConfiguration()
        {
          ns1__SetStorageConfiguration = (_ns1__SetStorageConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetStorageConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetStorageConfiguration * SOAP_FMAC2 soap_instantiate___ns1__SetStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:48920 */
#ifndef SOAP_TYPE___ns1__DeleteStorageConfiguration
#define SOAP_TYPE___ns1__DeleteStorageConfiguration (2564)
/* Wrapper: */
struct SOAP_CMAC __ns1__DeleteStorageConfiguration {
      public:
        /** Optional element 'ns1:DeleteStorageConfiguration' of XSD type 'ns1:DeleteStorageConfiguration' */
        _ns1__DeleteStorageConfiguration *ns1__DeleteStorageConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DeleteStorageConfiguration */
        int soap_type() const { return SOAP_TYPE___ns1__DeleteStorageConfiguration; }
        /** Constructor with member initializations */
        __ns1__DeleteStorageConfiguration()
        {
          ns1__DeleteStorageConfiguration = (_ns1__DeleteStorageConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns1__DeleteStorageConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__DeleteStorageConfiguration * SOAP_FMAC2 soap_instantiate___ns1__DeleteStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:49007 */
#ifndef SOAP_TYPE___ns10__GetServiceCapabilities
#define SOAP_TYPE___ns10__GetServiceCapabilities (2568)
/* Wrapper: */
struct SOAP_CMAC __ns10__GetServiceCapabilities {
      public:
        /** Optional element 'ns10:GetServiceCapabilities' of XSD type 'ns10:GetServiceCapabilities' */
        _ns10__GetServiceCapabilities *ns10__GetServiceCapabilities;
      public:
        /** Return unique type id SOAP_TYPE___ns10__GetServiceCapabilities */
        int soap_type() const { return SOAP_TYPE___ns10__GetServiceCapabilities; }
        /** Constructor with member initializations */
        __ns10__GetServiceCapabilities()
        {
          ns10__GetServiceCapabilities = (_ns10__GetServiceCapabilities *)0;
        }
        /** Friend allocator used by soap_new___ns10__GetServiceCapabilities(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___ns10__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:49081 */
#ifndef SOAP_TYPE___ns10__CreateProfile
#define SOAP_TYPE___ns10__CreateProfile (2572)
/* Wrapper: */
struct SOAP_CMAC __ns10__CreateProfile {
      public:
        /** Optional element 'ns10:CreateProfile' of XSD type 'ns10:CreateProfile' */
        _ns10__CreateProfile *ns10__CreateProfile;
      public:
        /** Return unique type id SOAP_TYPE___ns10__CreateProfile */
        int soap_type() const { return SOAP_TYPE___ns10__CreateProfile; }
        /** Constructor with member initializations */
        __ns10__CreateProfile()
        {
          ns10__CreateProfile = (_ns10__CreateProfile *)0;
        }
        /** Friend allocator used by soap_new___ns10__CreateProfile(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__CreateProfile * SOAP_FMAC2 soap_instantiate___ns10__CreateProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:49159 */
#ifndef SOAP_TYPE___ns10__GetProfiles
#define SOAP_TYPE___ns10__GetProfiles (2576)
/* Wrapper: */
struct SOAP_CMAC __ns10__GetProfiles {
      public:
        /** Optional element 'ns10:GetProfiles' of XSD type 'ns10:GetProfiles' */
        _ns10__GetProfiles *ns10__GetProfiles;
      public:
        /** Return unique type id SOAP_TYPE___ns10__GetProfiles */
        int soap_type() const { return SOAP_TYPE___ns10__GetProfiles; }
        /** Constructor with member initializations */
        __ns10__GetProfiles()
        {
          ns10__GetProfiles = (_ns10__GetProfiles *)0;
        }
        /** Friend allocator used by soap_new___ns10__GetProfiles(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__GetProfiles * SOAP_FMAC2 soap_instantiate___ns10__GetProfiles(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:49235 */
#ifndef SOAP_TYPE___ns10__AddConfiguration
#define SOAP_TYPE___ns10__AddConfiguration (2580)
/* Wrapper: */
struct SOAP_CMAC __ns10__AddConfiguration {
      public:
        /** Optional element 'ns10:AddConfiguration' of XSD type 'ns10:AddConfiguration' */
        _ns10__AddConfiguration *ns10__AddConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns10__AddConfiguration */
        int soap_type() const { return SOAP_TYPE___ns10__AddConfiguration; }
        /** Constructor with member initializations */
        __ns10__AddConfiguration()
        {
          ns10__AddConfiguration = (_ns10__AddConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns10__AddConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__AddConfiguration * SOAP_FMAC2 soap_instantiate___ns10__AddConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:49308 */
#ifndef SOAP_TYPE___ns10__RemoveConfiguration
#define SOAP_TYPE___ns10__RemoveConfiguration (2584)
/* Wrapper: */
struct SOAP_CMAC __ns10__RemoveConfiguration {
      public:
        /** Optional element 'ns10:RemoveConfiguration' of XSD type 'ns10:RemoveConfiguration' */
        _ns10__RemoveConfiguration *ns10__RemoveConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns10__RemoveConfiguration */
        int soap_type() const { return SOAP_TYPE___ns10__RemoveConfiguration; }
        /** Constructor with member initializations */
        __ns10__RemoveConfiguration()
        {
          ns10__RemoveConfiguration = (_ns10__RemoveConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns10__RemoveConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__RemoveConfiguration * SOAP_FMAC2 soap_instantiate___ns10__RemoveConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:49377 */
#ifndef SOAP_TYPE___ns10__DeleteProfile
#define SOAP_TYPE___ns10__DeleteProfile (2588)
/* Wrapper: */
struct SOAP_CMAC __ns10__DeleteProfile {
      public:
        /** Optional element 'ns10:DeleteProfile' of XSD type 'ns10:DeleteProfile' */
        _ns10__DeleteProfile *ns10__DeleteProfile;
      public:
        /** Return unique type id SOAP_TYPE___ns10__DeleteProfile */
        int soap_type() const { return SOAP_TYPE___ns10__DeleteProfile; }
        /** Constructor with member initializations */
        __ns10__DeleteProfile()
        {
          ns10__DeleteProfile = (_ns10__DeleteProfile *)0;
        }
        /** Friend allocator used by soap_new___ns10__DeleteProfile(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__DeleteProfile * SOAP_FMAC2 soap_instantiate___ns10__DeleteProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:49448 */
#ifndef SOAP_TYPE___ns10__GetVideoSourceConfigurations
#define SOAP_TYPE___ns10__GetVideoSourceConfigurations (2592)
/* Wrapper: */
struct SOAP_CMAC __ns10__GetVideoSourceConfigurations {
      public:
        /** Optional element 'ns10:GetVideoSourceConfigurations' of XSD type 'ns10:GetConfiguration' */
        ns10__GetConfiguration *ns10__GetVideoSourceConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns10__GetVideoSourceConfigurations */
        int soap_type() const { return SOAP_TYPE___ns10__GetVideoSourceConfigurations; }
        /** Constructor with member initializations */
        __ns10__GetVideoSourceConfigurations()
        {
          ns10__GetVideoSourceConfigurations = (ns10__GetConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns10__GetVideoSourceConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__GetVideoSourceConfigurations * SOAP_FMAC2 soap_instantiate___ns10__GetVideoSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:49519 */
#ifndef SOAP_TYPE___ns10__GetVideoEncoderConfigurations
#define SOAP_TYPE___ns10__GetVideoEncoderConfigurations (2595)
/* Wrapper: */
struct SOAP_CMAC __ns10__GetVideoEncoderConfigurations {
      public:
        /** Optional element 'ns10:GetVideoEncoderConfigurations' of XSD type 'ns10:GetConfiguration' */
        ns10__GetConfiguration *ns10__GetVideoEncoderConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns10__GetVideoEncoderConfigurations */
        int soap_type() const { return SOAP_TYPE___ns10__GetVideoEncoderConfigurations; }
        /** Constructor with member initializations */
        __ns10__GetVideoEncoderConfigurations()
        {
          ns10__GetVideoEncoderConfigurations = (ns10__GetConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns10__GetVideoEncoderConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__GetVideoEncoderConfigurations * SOAP_FMAC2 soap_instantiate___ns10__GetVideoEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:49590 */
#ifndef SOAP_TYPE___ns10__GetAudioSourceConfigurations
#define SOAP_TYPE___ns10__GetAudioSourceConfigurations (2598)
/* Wrapper: */
struct SOAP_CMAC __ns10__GetAudioSourceConfigurations {
      public:
        /** Optional element 'ns10:GetAudioSourceConfigurations' of XSD type 'ns10:GetConfiguration' */
        ns10__GetConfiguration *ns10__GetAudioSourceConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns10__GetAudioSourceConfigurations */
        int soap_type() const { return SOAP_TYPE___ns10__GetAudioSourceConfigurations; }
        /** Constructor with member initializations */
        __ns10__GetAudioSourceConfigurations()
        {
          ns10__GetAudioSourceConfigurations = (ns10__GetConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns10__GetAudioSourceConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__GetAudioSourceConfigurations * SOAP_FMAC2 soap_instantiate___ns10__GetAudioSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:49661 */
#ifndef SOAP_TYPE___ns10__GetAudioEncoderConfigurations
#define SOAP_TYPE___ns10__GetAudioEncoderConfigurations (2601)
/* Wrapper: */
struct SOAP_CMAC __ns10__GetAudioEncoderConfigurations {
      public:
        /** Optional element 'ns10:GetAudioEncoderConfigurations' of XSD type 'ns10:GetConfiguration' */
        ns10__GetConfiguration *ns10__GetAudioEncoderConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns10__GetAudioEncoderConfigurations */
        int soap_type() const { return SOAP_TYPE___ns10__GetAudioEncoderConfigurations; }
        /** Constructor with member initializations */
        __ns10__GetAudioEncoderConfigurations()
        {
          ns10__GetAudioEncoderConfigurations = (ns10__GetConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns10__GetAudioEncoderConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__GetAudioEncoderConfigurations * SOAP_FMAC2 soap_instantiate___ns10__GetAudioEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:49732 */
#ifndef SOAP_TYPE___ns10__GetAnalyticsConfigurations
#define SOAP_TYPE___ns10__GetAnalyticsConfigurations (2604)
/* Wrapper: */
struct SOAP_CMAC __ns10__GetAnalyticsConfigurations {
      public:
        /** Optional element 'ns10:GetAnalyticsConfigurations' of XSD type 'ns10:GetConfiguration' */
        ns10__GetConfiguration *ns10__GetAnalyticsConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns10__GetAnalyticsConfigurations */
        int soap_type() const { return SOAP_TYPE___ns10__GetAnalyticsConfigurations; }
        /** Constructor with member initializations */
        __ns10__GetAnalyticsConfigurations()
        {
          ns10__GetAnalyticsConfigurations = (ns10__GetConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns10__GetAnalyticsConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__GetAnalyticsConfigurations * SOAP_FMAC2 soap_instantiate___ns10__GetAnalyticsConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:49803 */
#ifndef SOAP_TYPE___ns10__GetMetadataConfigurations
#define SOAP_TYPE___ns10__GetMetadataConfigurations (2607)
/* Wrapper: */
struct SOAP_CMAC __ns10__GetMetadataConfigurations {
      public:
        /** Optional element 'ns10:GetMetadataConfigurations' of XSD type 'ns10:GetConfiguration' */
        ns10__GetConfiguration *ns10__GetMetadataConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns10__GetMetadataConfigurations */
        int soap_type() const { return SOAP_TYPE___ns10__GetMetadataConfigurations; }
        /** Constructor with member initializations */
        __ns10__GetMetadataConfigurations()
        {
          ns10__GetMetadataConfigurations = (ns10__GetConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns10__GetMetadataConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__GetMetadataConfigurations * SOAP_FMAC2 soap_instantiate___ns10__GetMetadataConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:49874 */
#ifndef SOAP_TYPE___ns10__GetAudioOutputConfigurations
#define SOAP_TYPE___ns10__GetAudioOutputConfigurations (2610)
/* Wrapper: */
struct SOAP_CMAC __ns10__GetAudioOutputConfigurations {
      public:
        /** Optional element 'ns10:GetAudioOutputConfigurations' of XSD type 'ns10:GetConfiguration' */
        ns10__GetConfiguration *ns10__GetAudioOutputConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns10__GetAudioOutputConfigurations */
        int soap_type() const { return SOAP_TYPE___ns10__GetAudioOutputConfigurations; }
        /** Constructor with member initializations */
        __ns10__GetAudioOutputConfigurations()
        {
          ns10__GetAudioOutputConfigurations = (ns10__GetConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns10__GetAudioOutputConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__GetAudioOutputConfigurations * SOAP_FMAC2 soap_instantiate___ns10__GetAudioOutputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:49945 */
#ifndef SOAP_TYPE___ns10__GetAudioDecoderConfigurations
#define SOAP_TYPE___ns10__GetAudioDecoderConfigurations (2613)
/* Wrapper: */
struct SOAP_CMAC __ns10__GetAudioDecoderConfigurations {
      public:
        /** Optional element 'ns10:GetAudioDecoderConfigurations' of XSD type 'ns10:GetConfiguration' */
        ns10__GetConfiguration *ns10__GetAudioDecoderConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns10__GetAudioDecoderConfigurations */
        int soap_type() const { return SOAP_TYPE___ns10__GetAudioDecoderConfigurations; }
        /** Constructor with member initializations */
        __ns10__GetAudioDecoderConfigurations()
        {
          ns10__GetAudioDecoderConfigurations = (ns10__GetConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns10__GetAudioDecoderConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__GetAudioDecoderConfigurations * SOAP_FMAC2 soap_instantiate___ns10__GetAudioDecoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:50017 */
#ifndef SOAP_TYPE___ns10__SetVideoSourceConfiguration
#define SOAP_TYPE___ns10__SetVideoSourceConfiguration (2617)
/* Wrapper: */
struct SOAP_CMAC __ns10__SetVideoSourceConfiguration {
      public:
        /** Optional element 'ns10:SetVideoSourceConfiguration' of XSD type 'ns10:SetVideoSourceConfiguration' */
        _ns10__SetVideoSourceConfiguration *ns10__SetVideoSourceConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns10__SetVideoSourceConfiguration */
        int soap_type() const { return SOAP_TYPE___ns10__SetVideoSourceConfiguration; }
        /** Constructor with member initializations */
        __ns10__SetVideoSourceConfiguration()
        {
          ns10__SetVideoSourceConfiguration = (_ns10__SetVideoSourceConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns10__SetVideoSourceConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__SetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___ns10__SetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:50092 */
#ifndef SOAP_TYPE___ns10__SetVideoEncoderConfiguration
#define SOAP_TYPE___ns10__SetVideoEncoderConfiguration (2620)
/* Wrapper: */
struct SOAP_CMAC __ns10__SetVideoEncoderConfiguration {
      public:
        /** Optional element 'ns10:SetVideoEncoderConfiguration' of XSD type 'ns10:SetVideoEncoderConfiguration' */
        _ns10__SetVideoEncoderConfiguration *ns10__SetVideoEncoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns10__SetVideoEncoderConfiguration */
        int soap_type() const { return SOAP_TYPE___ns10__SetVideoEncoderConfiguration; }
        /** Constructor with member initializations */
        __ns10__SetVideoEncoderConfiguration()
        {
          ns10__SetVideoEncoderConfiguration = (_ns10__SetVideoEncoderConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns10__SetVideoEncoderConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__SetVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___ns10__SetVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:50167 */
#ifndef SOAP_TYPE___ns10__SetAudioSourceConfiguration
#define SOAP_TYPE___ns10__SetAudioSourceConfiguration (2623)
/* Wrapper: */
struct SOAP_CMAC __ns10__SetAudioSourceConfiguration {
      public:
        /** Optional element 'ns10:SetAudioSourceConfiguration' of XSD type 'ns10:SetAudioSourceConfiguration' */
        _ns10__SetAudioSourceConfiguration *ns10__SetAudioSourceConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns10__SetAudioSourceConfiguration */
        int soap_type() const { return SOAP_TYPE___ns10__SetAudioSourceConfiguration; }
        /** Constructor with member initializations */
        __ns10__SetAudioSourceConfiguration()
        {
          ns10__SetAudioSourceConfiguration = (_ns10__SetAudioSourceConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns10__SetAudioSourceConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__SetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___ns10__SetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:50241 */
#ifndef SOAP_TYPE___ns10__SetAudioEncoderConfiguration
#define SOAP_TYPE___ns10__SetAudioEncoderConfiguration (2626)
/* Wrapper: */
struct SOAP_CMAC __ns10__SetAudioEncoderConfiguration {
      public:
        /** Optional element 'ns10:SetAudioEncoderConfiguration' of XSD type 'ns10:SetAudioEncoderConfiguration' */
        _ns10__SetAudioEncoderConfiguration *ns10__SetAudioEncoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns10__SetAudioEncoderConfiguration */
        int soap_type() const { return SOAP_TYPE___ns10__SetAudioEncoderConfiguration; }
        /** Constructor with member initializations */
        __ns10__SetAudioEncoderConfiguration()
        {
          ns10__SetAudioEncoderConfiguration = (_ns10__SetAudioEncoderConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns10__SetAudioEncoderConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__SetAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___ns10__SetAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:50315 */
#ifndef SOAP_TYPE___ns10__SetMetadataConfiguration
#define SOAP_TYPE___ns10__SetMetadataConfiguration (2629)
/* Wrapper: */
struct SOAP_CMAC __ns10__SetMetadataConfiguration {
      public:
        /** Optional element 'ns10:SetMetadataConfiguration' of XSD type 'ns10:SetMetadataConfiguration' */
        _ns10__SetMetadataConfiguration *ns10__SetMetadataConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns10__SetMetadataConfiguration */
        int soap_type() const { return SOAP_TYPE___ns10__SetMetadataConfiguration; }
        /** Constructor with member initializations */
        __ns10__SetMetadataConfiguration()
        {
          ns10__SetMetadataConfiguration = (_ns10__SetMetadataConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns10__SetMetadataConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__SetMetadataConfiguration * SOAP_FMAC2 soap_instantiate___ns10__SetMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:50383 */
#ifndef SOAP_TYPE___ns10__SetAudioOutputConfiguration
#define SOAP_TYPE___ns10__SetAudioOutputConfiguration (2632)
/* Wrapper: */
struct SOAP_CMAC __ns10__SetAudioOutputConfiguration {
      public:
        /** Optional element 'ns10:SetAudioOutputConfiguration' of XSD type 'ns10:SetAudioOutputConfiguration' */
        _ns10__SetAudioOutputConfiguration *ns10__SetAudioOutputConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns10__SetAudioOutputConfiguration */
        int soap_type() const { return SOAP_TYPE___ns10__SetAudioOutputConfiguration; }
        /** Constructor with member initializations */
        __ns10__SetAudioOutputConfiguration()
        {
          ns10__SetAudioOutputConfiguration = (_ns10__SetAudioOutputConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns10__SetAudioOutputConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__SetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___ns10__SetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:50451 */
#ifndef SOAP_TYPE___ns10__SetAudioDecoderConfiguration
#define SOAP_TYPE___ns10__SetAudioDecoderConfiguration (2635)
/* Wrapper: */
struct SOAP_CMAC __ns10__SetAudioDecoderConfiguration {
      public:
        /** Optional element 'ns10:SetAudioDecoderConfiguration' of XSD type 'ns10:SetAudioDecoderConfiguration' */
        _ns10__SetAudioDecoderConfiguration *ns10__SetAudioDecoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns10__SetAudioDecoderConfiguration */
        int soap_type() const { return SOAP_TYPE___ns10__SetAudioDecoderConfiguration; }
        /** Constructor with member initializations */
        __ns10__SetAudioDecoderConfiguration()
        {
          ns10__SetAudioDecoderConfiguration = (_ns10__SetAudioDecoderConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns10__SetAudioDecoderConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__SetAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___ns10__SetAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:50525 */
#ifndef SOAP_TYPE___ns10__GetVideoSourceConfigurationOptions
#define SOAP_TYPE___ns10__GetVideoSourceConfigurationOptions (2638)
/* Wrapper: */
struct SOAP_CMAC __ns10__GetVideoSourceConfigurationOptions {
      public:
        /** Optional element 'ns10:GetVideoSourceConfigurationOptions' of XSD type 'ns10:GetConfiguration' */
        ns10__GetConfiguration *ns10__GetVideoSourceConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___ns10__GetVideoSourceConfigurationOptions */
        int soap_type() const { return SOAP_TYPE___ns10__GetVideoSourceConfigurationOptions; }
        /** Constructor with member initializations */
        __ns10__GetVideoSourceConfigurationOptions()
        {
          ns10__GetVideoSourceConfigurationOptions = (ns10__GetConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns10__GetVideoSourceConfigurationOptions(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__GetVideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate___ns10__GetVideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:50607 */
#ifndef SOAP_TYPE___ns10__GetVideoEncoderConfigurationOptions
#define SOAP_TYPE___ns10__GetVideoEncoderConfigurationOptions (2641)
/* Wrapper: */
struct SOAP_CMAC __ns10__GetVideoEncoderConfigurationOptions {
      public:
        /** Optional element 'ns10:GetVideoEncoderConfigurationOptions' of XSD type 'ns10:GetConfiguration' */
        ns10__GetConfiguration *ns10__GetVideoEncoderConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___ns10__GetVideoEncoderConfigurationOptions */
        int soap_type() const { return SOAP_TYPE___ns10__GetVideoEncoderConfigurationOptions; }
        /** Constructor with member initializations */
        __ns10__GetVideoEncoderConfigurationOptions()
        {
          ns10__GetVideoEncoderConfigurationOptions = (ns10__GetConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns10__GetVideoEncoderConfigurationOptions(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__GetVideoEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate___ns10__GetVideoEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:50681 */
#ifndef SOAP_TYPE___ns10__GetAudioSourceConfigurationOptions
#define SOAP_TYPE___ns10__GetAudioSourceConfigurationOptions (2644)
/* Wrapper: */
struct SOAP_CMAC __ns10__GetAudioSourceConfigurationOptions {
      public:
        /** Optional element 'ns10:GetAudioSourceConfigurationOptions' of XSD type 'ns10:GetConfiguration' */
        ns10__GetConfiguration *ns10__GetAudioSourceConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___ns10__GetAudioSourceConfigurationOptions */
        int soap_type() const { return SOAP_TYPE___ns10__GetAudioSourceConfigurationOptions; }
        /** Constructor with member initializations */
        __ns10__GetAudioSourceConfigurationOptions()
        {
          ns10__GetAudioSourceConfigurationOptions = (ns10__GetConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns10__GetAudioSourceConfigurationOptions(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__GetAudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate___ns10__GetAudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:50751 */
#ifndef SOAP_TYPE___ns10__GetAudioEncoderConfigurationOptions
#define SOAP_TYPE___ns10__GetAudioEncoderConfigurationOptions (2647)
/* Wrapper: */
struct SOAP_CMAC __ns10__GetAudioEncoderConfigurationOptions {
      public:
        /** Optional element 'ns10:GetAudioEncoderConfigurationOptions' of XSD type 'ns10:GetConfiguration' */
        ns10__GetConfiguration *ns10__GetAudioEncoderConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___ns10__GetAudioEncoderConfigurationOptions */
        int soap_type() const { return SOAP_TYPE___ns10__GetAudioEncoderConfigurationOptions; }
        /** Constructor with member initializations */
        __ns10__GetAudioEncoderConfigurationOptions()
        {
          ns10__GetAudioEncoderConfigurationOptions = (ns10__GetConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns10__GetAudioEncoderConfigurationOptions(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__GetAudioEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate___ns10__GetAudioEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:50820 */
#ifndef SOAP_TYPE___ns10__GetMetadataConfigurationOptions
#define SOAP_TYPE___ns10__GetMetadataConfigurationOptions (2650)
/* Wrapper: */
struct SOAP_CMAC __ns10__GetMetadataConfigurationOptions {
      public:
        /** Optional element 'ns10:GetMetadataConfigurationOptions' of XSD type 'ns10:GetConfiguration' */
        ns10__GetConfiguration *ns10__GetMetadataConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___ns10__GetMetadataConfigurationOptions */
        int soap_type() const { return SOAP_TYPE___ns10__GetMetadataConfigurationOptions; }
        /** Constructor with member initializations */
        __ns10__GetMetadataConfigurationOptions()
        {
          ns10__GetMetadataConfigurationOptions = (ns10__GetConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns10__GetMetadataConfigurationOptions(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__GetMetadataConfigurationOptions * SOAP_FMAC2 soap_instantiate___ns10__GetMetadataConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:50889 */
#ifndef SOAP_TYPE___ns10__GetAudioOutputConfigurationOptions
#define SOAP_TYPE___ns10__GetAudioOutputConfigurationOptions (2653)
/* Wrapper: */
struct SOAP_CMAC __ns10__GetAudioOutputConfigurationOptions {
      public:
        /** Optional element 'ns10:GetAudioOutputConfigurationOptions' of XSD type 'ns10:GetConfiguration' */
        ns10__GetConfiguration *ns10__GetAudioOutputConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___ns10__GetAudioOutputConfigurationOptions */
        int soap_type() const { return SOAP_TYPE___ns10__GetAudioOutputConfigurationOptions; }
        /** Constructor with member initializations */
        __ns10__GetAudioOutputConfigurationOptions()
        {
          ns10__GetAudioOutputConfigurationOptions = (ns10__GetConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns10__GetAudioOutputConfigurationOptions(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__GetAudioOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate___ns10__GetAudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:50959 */
#ifndef SOAP_TYPE___ns10__GetAudioDecoderConfigurationOptions
#define SOAP_TYPE___ns10__GetAudioDecoderConfigurationOptions (2656)
/* Wrapper: */
struct SOAP_CMAC __ns10__GetAudioDecoderConfigurationOptions {
      public:
        /** Optional element 'ns10:GetAudioDecoderConfigurationOptions' of XSD type 'ns10:GetConfiguration' */
        ns10__GetConfiguration *ns10__GetAudioDecoderConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___ns10__GetAudioDecoderConfigurationOptions */
        int soap_type() const { return SOAP_TYPE___ns10__GetAudioDecoderConfigurationOptions; }
        /** Constructor with member initializations */
        __ns10__GetAudioDecoderConfigurationOptions()
        {
          ns10__GetAudioDecoderConfigurationOptions = (ns10__GetConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns10__GetAudioDecoderConfigurationOptions(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__GetAudioDecoderConfigurationOptions * SOAP_FMAC2 soap_instantiate___ns10__GetAudioDecoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:51030 */
#ifndef SOAP_TYPE___ns10__GetVideoEncoderInstances
#define SOAP_TYPE___ns10__GetVideoEncoderInstances (2660)
/* Wrapper: */
struct SOAP_CMAC __ns10__GetVideoEncoderInstances {
      public:
        /** Optional element 'ns10:GetVideoEncoderInstances' of XSD type 'ns10:GetVideoEncoderInstances' */
        _ns10__GetVideoEncoderInstances *ns10__GetVideoEncoderInstances;
      public:
        /** Return unique type id SOAP_TYPE___ns10__GetVideoEncoderInstances */
        int soap_type() const { return SOAP_TYPE___ns10__GetVideoEncoderInstances; }
        /** Constructor with member initializations */
        __ns10__GetVideoEncoderInstances()
        {
          ns10__GetVideoEncoderInstances = (_ns10__GetVideoEncoderInstances *)0;
        }
        /** Friend allocator used by soap_new___ns10__GetVideoEncoderInstances(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__GetVideoEncoderInstances * SOAP_FMAC2 soap_instantiate___ns10__GetVideoEncoderInstances(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:51120 */
#ifndef SOAP_TYPE___ns10__GetStreamUri
#define SOAP_TYPE___ns10__GetStreamUri (2664)
/* Wrapper: */
struct SOAP_CMAC __ns10__GetStreamUri {
      public:
        /** Optional element 'ns10:GetStreamUri' of XSD type 'ns10:GetStreamUri' */
        _ns10__GetStreamUri *ns10__GetStreamUri;
      public:
        /** Return unique type id SOAP_TYPE___ns10__GetStreamUri */
        int soap_type() const { return SOAP_TYPE___ns10__GetStreamUri; }
        /** Constructor with member initializations */
        __ns10__GetStreamUri()
        {
          ns10__GetStreamUri = (_ns10__GetStreamUri *)0;
        }
        /** Friend allocator used by soap_new___ns10__GetStreamUri(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__GetStreamUri * SOAP_FMAC2 soap_instantiate___ns10__GetStreamUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:51197 */
#ifndef SOAP_TYPE___ns10__StartMulticastStreaming
#define SOAP_TYPE___ns10__StartMulticastStreaming (2668)
/* Wrapper: */
struct SOAP_CMAC __ns10__StartMulticastStreaming {
      public:
        /** Optional element 'ns10:StartMulticastStreaming' of XSD type 'ns10:StartStopMulticastStreaming' */
        ns10__StartStopMulticastStreaming *ns10__StartMulticastStreaming;
      public:
        /** Return unique type id SOAP_TYPE___ns10__StartMulticastStreaming */
        int soap_type() const { return SOAP_TYPE___ns10__StartMulticastStreaming; }
        /** Constructor with member initializations */
        __ns10__StartMulticastStreaming()
        {
          ns10__StartMulticastStreaming = (ns10__StartStopMulticastStreaming *)0;
        }
        /** Friend allocator used by soap_new___ns10__StartMulticastStreaming(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__StartMulticastStreaming * SOAP_FMAC2 soap_instantiate___ns10__StartMulticastStreaming(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:51265 */
#ifndef SOAP_TYPE___ns10__StopMulticastStreaming
#define SOAP_TYPE___ns10__StopMulticastStreaming (2670)
/* Wrapper: */
struct SOAP_CMAC __ns10__StopMulticastStreaming {
      public:
        /** Optional element 'ns10:StopMulticastStreaming' of XSD type 'ns10:StartStopMulticastStreaming' */
        ns10__StartStopMulticastStreaming *ns10__StopMulticastStreaming;
      public:
        /** Return unique type id SOAP_TYPE___ns10__StopMulticastStreaming */
        int soap_type() const { return SOAP_TYPE___ns10__StopMulticastStreaming; }
        /** Constructor with member initializations */
        __ns10__StopMulticastStreaming()
        {
          ns10__StopMulticastStreaming = (ns10__StartStopMulticastStreaming *)0;
        }
        /** Friend allocator used by soap_new___ns10__StopMulticastStreaming(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__StopMulticastStreaming * SOAP_FMAC2 soap_instantiate___ns10__StopMulticastStreaming(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:51350 */
#ifndef SOAP_TYPE___ns10__SetSynchronizationPoint
#define SOAP_TYPE___ns10__SetSynchronizationPoint (2674)
/* Wrapper: */
struct SOAP_CMAC __ns10__SetSynchronizationPoint {
      public:
        /** Optional element 'ns10:SetSynchronizationPoint' of XSD type 'ns10:SetSynchronizationPoint' */
        _ns10__SetSynchronizationPoint *ns10__SetSynchronizationPoint;
      public:
        /** Return unique type id SOAP_TYPE___ns10__SetSynchronizationPoint */
        int soap_type() const { return SOAP_TYPE___ns10__SetSynchronizationPoint; }
        /** Constructor with member initializations */
        __ns10__SetSynchronizationPoint()
        {
          ns10__SetSynchronizationPoint = (_ns10__SetSynchronizationPoint *)0;
        }
        /** Friend allocator used by soap_new___ns10__SetSynchronizationPoint(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__SetSynchronizationPoint * SOAP_FMAC2 soap_instantiate___ns10__SetSynchronizationPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:51428 */
#ifndef SOAP_TYPE___ns10__GetSnapshotUri
#define SOAP_TYPE___ns10__GetSnapshotUri (2678)
/* Wrapper: */
struct SOAP_CMAC __ns10__GetSnapshotUri {
      public:
        /** Optional element 'ns10:GetSnapshotUri' of XSD type 'ns10:GetSnapshotUri' */
        _ns10__GetSnapshotUri *ns10__GetSnapshotUri;
      public:
        /** Return unique type id SOAP_TYPE___ns10__GetSnapshotUri */
        int soap_type() const { return SOAP_TYPE___ns10__GetSnapshotUri; }
        /** Constructor with member initializations */
        __ns10__GetSnapshotUri()
        {
          ns10__GetSnapshotUri = (_ns10__GetSnapshotUri *)0;
        }
        /** Friend allocator used by soap_new___ns10__GetSnapshotUri(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__GetSnapshotUri * SOAP_FMAC2 soap_instantiate___ns10__GetSnapshotUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:51498 */
#ifndef SOAP_TYPE___ns10__GetVideoSourceModes
#define SOAP_TYPE___ns10__GetVideoSourceModes (2682)
/* Wrapper: */
struct SOAP_CMAC __ns10__GetVideoSourceModes {
      public:
        /** Optional element 'ns10:GetVideoSourceModes' of XSD type 'ns10:GetVideoSourceModes' */
        _ns10__GetVideoSourceModes *ns10__GetVideoSourceModes;
      public:
        /** Return unique type id SOAP_TYPE___ns10__GetVideoSourceModes */
        int soap_type() const { return SOAP_TYPE___ns10__GetVideoSourceModes; }
        /** Constructor with member initializations */
        __ns10__GetVideoSourceModes()
        {
          ns10__GetVideoSourceModes = (_ns10__GetVideoSourceModes *)0;
        }
        /** Friend allocator used by soap_new___ns10__GetVideoSourceModes(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__GetVideoSourceModes * SOAP_FMAC2 soap_instantiate___ns10__GetVideoSourceModes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:51569 */
#ifndef SOAP_TYPE___ns10__SetVideoSourceMode
#define SOAP_TYPE___ns10__SetVideoSourceMode (2686)
/* Wrapper: */
struct SOAP_CMAC __ns10__SetVideoSourceMode {
      public:
        /** Optional element 'ns10:SetVideoSourceMode' of XSD type 'ns10:SetVideoSourceMode' */
        _ns10__SetVideoSourceMode *ns10__SetVideoSourceMode;
      public:
        /** Return unique type id SOAP_TYPE___ns10__SetVideoSourceMode */
        int soap_type() const { return SOAP_TYPE___ns10__SetVideoSourceMode; }
        /** Constructor with member initializations */
        __ns10__SetVideoSourceMode()
        {
          ns10__SetVideoSourceMode = (_ns10__SetVideoSourceMode *)0;
        }
        /** Friend allocator used by soap_new___ns10__SetVideoSourceMode(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__SetVideoSourceMode * SOAP_FMAC2 soap_instantiate___ns10__SetVideoSourceMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:51648 */
#ifndef SOAP_TYPE___ns10__GetOSDs
#define SOAP_TYPE___ns10__GetOSDs (2690)
/* Wrapper: */
struct SOAP_CMAC __ns10__GetOSDs {
      public:
        /** Optional element 'ns10:GetOSDs' of XSD type 'ns10:GetOSDs' */
        _ns10__GetOSDs *ns10__GetOSDs;
      public:
        /** Return unique type id SOAP_TYPE___ns10__GetOSDs */
        int soap_type() const { return SOAP_TYPE___ns10__GetOSDs; }
        /** Constructor with member initializations */
        __ns10__GetOSDs()
        {
          ns10__GetOSDs = (_ns10__GetOSDs *)0;
        }
        /** Friend allocator used by soap_new___ns10__GetOSDs(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__GetOSDs * SOAP_FMAC2 soap_instantiate___ns10__GetOSDs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:51716 */
#ifndef SOAP_TYPE___ns10__GetOSDOptions
#define SOAP_TYPE___ns10__GetOSDOptions (2694)
/* Wrapper: */
struct SOAP_CMAC __ns10__GetOSDOptions {
      public:
        /** Optional element 'ns10:GetOSDOptions' of XSD type 'ns10:GetOSDOptions' */
        _ns10__GetOSDOptions *ns10__GetOSDOptions;
      public:
        /** Return unique type id SOAP_TYPE___ns10__GetOSDOptions */
        int soap_type() const { return SOAP_TYPE___ns10__GetOSDOptions; }
        /** Constructor with member initializations */
        __ns10__GetOSDOptions()
        {
          ns10__GetOSDOptions = (_ns10__GetOSDOptions *)0;
        }
        /** Friend allocator used by soap_new___ns10__GetOSDOptions(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__GetOSDOptions * SOAP_FMAC2 soap_instantiate___ns10__GetOSDOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:51784 */
#ifndef SOAP_TYPE___ns10__SetOSD
#define SOAP_TYPE___ns10__SetOSD (2697)
/* Wrapper: */
struct SOAP_CMAC __ns10__SetOSD {
      public:
        /** Optional element 'ns10:SetOSD' of XSD type 'ns10:SetOSD' */
        _ns10__SetOSD *ns10__SetOSD;
      public:
        /** Return unique type id SOAP_TYPE___ns10__SetOSD */
        int soap_type() const { return SOAP_TYPE___ns10__SetOSD; }
        /** Constructor with member initializations */
        __ns10__SetOSD()
        {
          ns10__SetOSD = (_ns10__SetOSD *)0;
        }
        /** Friend allocator used by soap_new___ns10__SetOSD(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__SetOSD * SOAP_FMAC2 soap_instantiate___ns10__SetOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:51852 */
#ifndef SOAP_TYPE___ns10__CreateOSD
#define SOAP_TYPE___ns10__CreateOSD (2701)
/* Wrapper: */
struct SOAP_CMAC __ns10__CreateOSD {
      public:
        /** Optional element 'ns10:CreateOSD' of XSD type 'ns10:CreateOSD' */
        _ns10__CreateOSD *ns10__CreateOSD;
      public:
        /** Return unique type id SOAP_TYPE___ns10__CreateOSD */
        int soap_type() const { return SOAP_TYPE___ns10__CreateOSD; }
        /** Constructor with member initializations */
        __ns10__CreateOSD()
        {
          ns10__CreateOSD = (_ns10__CreateOSD *)0;
        }
        /** Friend allocator used by soap_new___ns10__CreateOSD(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__CreateOSD * SOAP_FMAC2 soap_instantiate___ns10__CreateOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:51920 */
#ifndef SOAP_TYPE___ns10__DeleteOSD
#define SOAP_TYPE___ns10__DeleteOSD (2704)
/* Wrapper: */
struct SOAP_CMAC __ns10__DeleteOSD {
      public:
        /** Optional element 'ns10:DeleteOSD' of XSD type 'ns10:DeleteOSD' */
        _ns10__DeleteOSD *ns10__DeleteOSD;
      public:
        /** Return unique type id SOAP_TYPE___ns10__DeleteOSD */
        int soap_type() const { return SOAP_TYPE___ns10__DeleteOSD; }
        /** Constructor with member initializations */
        __ns10__DeleteOSD()
        {
          ns10__DeleteOSD = (_ns10__DeleteOSD *)0;
        }
        /** Friend allocator used by soap_new___ns10__DeleteOSD(struct soap*, int) */
        friend SOAP_FMAC1 __ns10__DeleteOSD * SOAP_FMAC2 soap_instantiate___ns10__DeleteOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:52006 */
#ifndef SOAP_TYPE___ns11__GetServiceCapabilities
#define SOAP_TYPE___ns11__GetServiceCapabilities (2708)
/* Wrapper: */
struct SOAP_CMAC __ns11__GetServiceCapabilities {
      public:
        /** Optional element 'ns11:GetServiceCapabilities' of XSD type 'ns11:GetServiceCapabilities' */
        _ns11__GetServiceCapabilities *ns11__GetServiceCapabilities;
      public:
        /** Return unique type id SOAP_TYPE___ns11__GetServiceCapabilities */
        int soap_type() const { return SOAP_TYPE___ns11__GetServiceCapabilities; }
        /** Constructor with member initializations */
        __ns11__GetServiceCapabilities()
        {
          ns11__GetServiceCapabilities = (_ns11__GetServiceCapabilities *)0;
        }
        /** Friend allocator used by soap_new___ns11__GetServiceCapabilities(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___ns11__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:52103 */
#ifndef SOAP_TYPE___ns11__GetConfigurations
#define SOAP_TYPE___ns11__GetConfigurations (2712)
/* Wrapper: */
struct SOAP_CMAC __ns11__GetConfigurations {
      public:
        /** Optional element 'ns11:GetConfigurations' of XSD type 'ns11:GetConfigurations' */
        _ns11__GetConfigurations *ns11__GetConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns11__GetConfigurations */
        int soap_type() const { return SOAP_TYPE___ns11__GetConfigurations; }
        /** Constructor with member initializations */
        __ns11__GetConfigurations()
        {
          ns11__GetConfigurations = (_ns11__GetConfigurations *)0;
        }
        /** Friend allocator used by soap_new___ns11__GetConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__GetConfigurations * SOAP_FMAC2 soap_instantiate___ns11__GetConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:52174 */
#ifndef SOAP_TYPE___ns11__GetPresets
#define SOAP_TYPE___ns11__GetPresets (2716)
/* Wrapper: */
struct SOAP_CMAC __ns11__GetPresets {
      public:
        /** Optional element 'ns11:GetPresets' of XSD type 'ns11:GetPresets' */
        _ns11__GetPresets *ns11__GetPresets;
      public:
        /** Return unique type id SOAP_TYPE___ns11__GetPresets */
        int soap_type() const { return SOAP_TYPE___ns11__GetPresets; }
        /** Constructor with member initializations */
        __ns11__GetPresets()
        {
          ns11__GetPresets = (_ns11__GetPresets *)0;
        }
        /** Friend allocator used by soap_new___ns11__GetPresets(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__GetPresets * SOAP_FMAC2 soap_instantiate___ns11__GetPresets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:52260 */
#ifndef SOAP_TYPE___ns11__SetPreset
#define SOAP_TYPE___ns11__SetPreset (2720)
/* Wrapper: */
struct SOAP_CMAC __ns11__SetPreset {
      public:
        /** Optional element 'ns11:SetPreset' of XSD type 'ns11:SetPreset' */
        _ns11__SetPreset *ns11__SetPreset;
      public:
        /** Return unique type id SOAP_TYPE___ns11__SetPreset */
        int soap_type() const { return SOAP_TYPE___ns11__SetPreset; }
        /** Constructor with member initializations */
        __ns11__SetPreset()
        {
          ns11__SetPreset = (_ns11__SetPreset *)0;
        }
        /** Friend allocator used by soap_new___ns11__SetPreset(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__SetPreset * SOAP_FMAC2 soap_instantiate___ns11__SetPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:52335 */
#ifndef SOAP_TYPE___ns11__RemovePreset
#define SOAP_TYPE___ns11__RemovePreset (2724)
/* Wrapper: */
struct SOAP_CMAC __ns11__RemovePreset {
      public:
        /** Optional element 'ns11:RemovePreset' of XSD type 'ns11:RemovePreset' */
        _ns11__RemovePreset *ns11__RemovePreset;
      public:
        /** Return unique type id SOAP_TYPE___ns11__RemovePreset */
        int soap_type() const { return SOAP_TYPE___ns11__RemovePreset; }
        /** Constructor with member initializations */
        __ns11__RemovePreset()
        {
          ns11__RemovePreset = (_ns11__RemovePreset *)0;
        }
        /** Friend allocator used by soap_new___ns11__RemovePreset(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__RemovePreset * SOAP_FMAC2 soap_instantiate___ns11__RemovePreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:52406 */
#ifndef SOAP_TYPE___ns11__GotoPreset
#define SOAP_TYPE___ns11__GotoPreset (2728)
/* Wrapper: */
struct SOAP_CMAC __ns11__GotoPreset {
      public:
        /** Optional element 'ns11:GotoPreset' of XSD type 'ns11:GotoPreset' */
        _ns11__GotoPreset *ns11__GotoPreset;
      public:
        /** Return unique type id SOAP_TYPE___ns11__GotoPreset */
        int soap_type() const { return SOAP_TYPE___ns11__GotoPreset; }
        /** Constructor with member initializations */
        __ns11__GotoPreset()
        {
          ns11__GotoPreset = (_ns11__GotoPreset *)0;
        }
        /** Friend allocator used by soap_new___ns11__GotoPreset(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__GotoPreset * SOAP_FMAC2 soap_instantiate___ns11__GotoPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:52477 */
#ifndef SOAP_TYPE___ns11__GetStatus
#define SOAP_TYPE___ns11__GetStatus (2732)
/* Wrapper: */
struct SOAP_CMAC __ns11__GetStatus {
      public:
        /** Optional element 'ns11:GetStatus' of XSD type 'ns11:GetStatus' */
        _ns11__GetStatus *ns11__GetStatus;
      public:
        /** Return unique type id SOAP_TYPE___ns11__GetStatus */
        int soap_type() const { return SOAP_TYPE___ns11__GetStatus; }
        /** Constructor with member initializations */
        __ns11__GetStatus()
        {
          ns11__GetStatus = (_ns11__GetStatus *)0;
        }
        /** Friend allocator used by soap_new___ns11__GetStatus(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__GetStatus * SOAP_FMAC2 soap_instantiate___ns11__GetStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:52574 */
#ifndef SOAP_TYPE___ns11__GetConfiguration
#define SOAP_TYPE___ns11__GetConfiguration (2736)
/* Wrapper: */
struct SOAP_CMAC __ns11__GetConfiguration {
      public:
        /** Optional element 'ns11:GetConfiguration' of XSD type 'ns11:GetConfiguration' */
        _ns11__GetConfiguration *ns11__GetConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns11__GetConfiguration */
        int soap_type() const { return SOAP_TYPE___ns11__GetConfiguration; }
        /** Constructor with member initializations */
        __ns11__GetConfiguration()
        {
          ns11__GetConfiguration = (_ns11__GetConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns11__GetConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__GetConfiguration * SOAP_FMAC2 soap_instantiate___ns11__GetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:52653 */
#ifndef SOAP_TYPE___ns11__GetNodes
#define SOAP_TYPE___ns11__GetNodes (2740)
/* Wrapper: */
struct SOAP_CMAC __ns11__GetNodes {
      public:
        /** Optional element 'ns11:GetNodes' of XSD type 'ns11:GetNodes' */
        _ns11__GetNodes *ns11__GetNodes;
      public:
        /** Return unique type id SOAP_TYPE___ns11__GetNodes */
        int soap_type() const { return SOAP_TYPE___ns11__GetNodes; }
        /** Constructor with member initializations */
        __ns11__GetNodes()
        {
          ns11__GetNodes = (_ns11__GetNodes *)0;
        }
        /** Friend allocator used by soap_new___ns11__GetNodes(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__GetNodes * SOAP_FMAC2 soap_instantiate___ns11__GetNodes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:52723 */
#ifndef SOAP_TYPE___ns11__GetNode
#define SOAP_TYPE___ns11__GetNode (2744)
/* Wrapper: */
struct SOAP_CMAC __ns11__GetNode {
      public:
        /** Optional element 'ns11:GetNode' of XSD type 'ns11:GetNode' */
        _ns11__GetNode *ns11__GetNode;
      public:
        /** Return unique type id SOAP_TYPE___ns11__GetNode */
        int soap_type() const { return SOAP_TYPE___ns11__GetNode; }
        /** Constructor with member initializations */
        __ns11__GetNode()
        {
          ns11__GetNode = (_ns11__GetNode *)0;
        }
        /** Friend allocator used by soap_new___ns11__GetNode(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__GetNode * SOAP_FMAC2 soap_instantiate___ns11__GetNode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:52793 */
#ifndef SOAP_TYPE___ns11__SetConfiguration
#define SOAP_TYPE___ns11__SetConfiguration (2748)
/* Wrapper: */
struct SOAP_CMAC __ns11__SetConfiguration {
      public:
        /** Optional element 'ns11:SetConfiguration' of XSD type 'ns11:SetConfiguration' */
        _ns11__SetConfiguration *ns11__SetConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns11__SetConfiguration */
        int soap_type() const { return SOAP_TYPE___ns11__SetConfiguration; }
        /** Constructor with member initializations */
        __ns11__SetConfiguration()
        {
          ns11__SetConfiguration = (_ns11__SetConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns11__SetConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__SetConfiguration * SOAP_FMAC2 soap_instantiate___ns11__SetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:52873 */
#ifndef SOAP_TYPE___ns11__GetConfigurationOptions
#define SOAP_TYPE___ns11__GetConfigurationOptions (2752)
/* Wrapper: */
struct SOAP_CMAC __ns11__GetConfigurationOptions {
      public:
        /** Optional element 'ns11:GetConfigurationOptions' of XSD type 'ns11:GetConfigurationOptions' */
        _ns11__GetConfigurationOptions *ns11__GetConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___ns11__GetConfigurationOptions */
        int soap_type() const { return SOAP_TYPE___ns11__GetConfigurationOptions; }
        /** Constructor with member initializations */
        __ns11__GetConfigurationOptions()
        {
          ns11__GetConfigurationOptions = (_ns11__GetConfigurationOptions *)0;
        }
        /** Friend allocator used by soap_new___ns11__GetConfigurationOptions(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__GetConfigurationOptions * SOAP_FMAC2 soap_instantiate___ns11__GetConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:52943 */
#ifndef SOAP_TYPE___ns11__GotoHomePosition
#define SOAP_TYPE___ns11__GotoHomePosition (2756)
/* Wrapper: */
struct SOAP_CMAC __ns11__GotoHomePosition {
      public:
        /** Optional element 'ns11:GotoHomePosition' of XSD type 'ns11:GotoHomePosition' */
        _ns11__GotoHomePosition *ns11__GotoHomePosition;
      public:
        /** Return unique type id SOAP_TYPE___ns11__GotoHomePosition */
        int soap_type() const { return SOAP_TYPE___ns11__GotoHomePosition; }
        /** Constructor with member initializations */
        __ns11__GotoHomePosition()
        {
          ns11__GotoHomePosition = (_ns11__GotoHomePosition *)0;
        }
        /** Friend allocator used by soap_new___ns11__GotoHomePosition(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__GotoHomePosition * SOAP_FMAC2 soap_instantiate___ns11__GotoHomePosition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:53016 */
#ifndef SOAP_TYPE___ns11__SetHomePosition
#define SOAP_TYPE___ns11__SetHomePosition (2760)
/* Wrapper: */
struct SOAP_CMAC __ns11__SetHomePosition {
      public:
        /** Optional element 'ns11:SetHomePosition' of XSD type 'ns11:SetHomePosition' */
        _ns11__SetHomePosition *ns11__SetHomePosition;
      public:
        /** Return unique type id SOAP_TYPE___ns11__SetHomePosition */
        int soap_type() const { return SOAP_TYPE___ns11__SetHomePosition; }
        /** Constructor with member initializations */
        __ns11__SetHomePosition()
        {
          ns11__SetHomePosition = (_ns11__SetHomePosition *)0;
        }
        /** Friend allocator used by soap_new___ns11__SetHomePosition(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__SetHomePosition * SOAP_FMAC2 soap_instantiate___ns11__SetHomePosition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:53087 */
#ifndef SOAP_TYPE___ns11__ContinuousMove
#define SOAP_TYPE___ns11__ContinuousMove (2764)
/* Wrapper: */
struct SOAP_CMAC __ns11__ContinuousMove {
      public:
        /** Optional element 'ns11:ContinuousMove' of XSD type 'ns11:ContinuousMove' */
        _ns11__ContinuousMove *ns11__ContinuousMove;
      public:
        /** Return unique type id SOAP_TYPE___ns11__ContinuousMove */
        int soap_type() const { return SOAP_TYPE___ns11__ContinuousMove; }
        /** Constructor with member initializations */
        __ns11__ContinuousMove()
        {
          ns11__ContinuousMove = (_ns11__ContinuousMove *)0;
        }
        /** Friend allocator used by soap_new___ns11__ContinuousMove(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__ContinuousMove * SOAP_FMAC2 soap_instantiate___ns11__ContinuousMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:53163 */
#ifndef SOAP_TYPE___ns11__RelativeMove
#define SOAP_TYPE___ns11__RelativeMove (2768)
/* Wrapper: */
struct SOAP_CMAC __ns11__RelativeMove {
      public:
        /** Optional element 'ns11:RelativeMove' of XSD type 'ns11:RelativeMove' */
        _ns11__RelativeMove *ns11__RelativeMove;
      public:
        /** Return unique type id SOAP_TYPE___ns11__RelativeMove */
        int soap_type() const { return SOAP_TYPE___ns11__RelativeMove; }
        /** Constructor with member initializations */
        __ns11__RelativeMove()
        {
          ns11__RelativeMove = (_ns11__RelativeMove *)0;
        }
        /** Friend allocator used by soap_new___ns11__RelativeMove(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__RelativeMove * SOAP_FMAC2 soap_instantiate___ns11__RelativeMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:53236 */
#ifndef SOAP_TYPE___ns11__SendAuxiliaryCommand
#define SOAP_TYPE___ns11__SendAuxiliaryCommand (2772)
/* Wrapper: */
struct SOAP_CMAC __ns11__SendAuxiliaryCommand {
      public:
        /** Optional element 'ns11:SendAuxiliaryCommand' of XSD type 'ns11:SendAuxiliaryCommand' */
        _ns11__SendAuxiliaryCommand *ns11__SendAuxiliaryCommand;
      public:
        /** Return unique type id SOAP_TYPE___ns11__SendAuxiliaryCommand */
        int soap_type() const { return SOAP_TYPE___ns11__SendAuxiliaryCommand; }
        /** Constructor with member initializations */
        __ns11__SendAuxiliaryCommand()
        {
          ns11__SendAuxiliaryCommand = (_ns11__SendAuxiliaryCommand *)0;
        }
        /** Friend allocator used by soap_new___ns11__SendAuxiliaryCommand(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate___ns11__SendAuxiliaryCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:53311 */
#ifndef SOAP_TYPE___ns11__AbsoluteMove
#define SOAP_TYPE___ns11__AbsoluteMove (2776)
/* Wrapper: */
struct SOAP_CMAC __ns11__AbsoluteMove {
      public:
        /** Optional element 'ns11:AbsoluteMove' of XSD type 'ns11:AbsoluteMove' */
        _ns11__AbsoluteMove *ns11__AbsoluteMove;
      public:
        /** Return unique type id SOAP_TYPE___ns11__AbsoluteMove */
        int soap_type() const { return SOAP_TYPE___ns11__AbsoluteMove; }
        /** Constructor with member initializations */
        __ns11__AbsoluteMove()
        {
          ns11__AbsoluteMove = (_ns11__AbsoluteMove *)0;
        }
        /** Friend allocator used by soap_new___ns11__AbsoluteMove(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__AbsoluteMove * SOAP_FMAC2 soap_instantiate___ns11__AbsoluteMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:53382 */
#ifndef SOAP_TYPE___ns11__Stop
#define SOAP_TYPE___ns11__Stop (2780)
/* Wrapper: */
struct SOAP_CMAC __ns11__Stop {
      public:
        /** Optional element 'ns11:Stop' of XSD type 'ns11:Stop' */
        _ns11__Stop *ns11__Stop;
      public:
        /** Return unique type id SOAP_TYPE___ns11__Stop */
        int soap_type() const { return SOAP_TYPE___ns11__Stop; }
        /** Constructor with member initializations */
        __ns11__Stop()
        {
          ns11__Stop = (_ns11__Stop *)0;
        }
        /** Friend allocator used by soap_new___ns11__Stop(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__Stop * SOAP_FMAC2 soap_instantiate___ns11__Stop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:53450 */
#ifndef SOAP_TYPE___ns11__GetPresetTours
#define SOAP_TYPE___ns11__GetPresetTours (2784)
/* Wrapper: */
struct SOAP_CMAC __ns11__GetPresetTours {
      public:
        /** Optional element 'ns11:GetPresetTours' of XSD type 'ns11:GetPresetTours' */
        _ns11__GetPresetTours *ns11__GetPresetTours;
      public:
        /** Return unique type id SOAP_TYPE___ns11__GetPresetTours */
        int soap_type() const { return SOAP_TYPE___ns11__GetPresetTours; }
        /** Constructor with member initializations */
        __ns11__GetPresetTours()
        {
          ns11__GetPresetTours = (_ns11__GetPresetTours *)0;
        }
        /** Friend allocator used by soap_new___ns11__GetPresetTours(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__GetPresetTours * SOAP_FMAC2 soap_instantiate___ns11__GetPresetTours(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:53518 */
#ifndef SOAP_TYPE___ns11__GetPresetTour
#define SOAP_TYPE___ns11__GetPresetTour (2788)
/* Wrapper: */
struct SOAP_CMAC __ns11__GetPresetTour {
      public:
        /** Optional element 'ns11:GetPresetTour' of XSD type 'ns11:GetPresetTour' */
        _ns11__GetPresetTour *ns11__GetPresetTour;
      public:
        /** Return unique type id SOAP_TYPE___ns11__GetPresetTour */
        int soap_type() const { return SOAP_TYPE___ns11__GetPresetTour; }
        /** Constructor with member initializations */
        __ns11__GetPresetTour()
        {
          ns11__GetPresetTour = (_ns11__GetPresetTour *)0;
        }
        /** Friend allocator used by soap_new___ns11__GetPresetTour(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__GetPresetTour * SOAP_FMAC2 soap_instantiate___ns11__GetPresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:53586 */
#ifndef SOAP_TYPE___ns11__GetPresetTourOptions
#define SOAP_TYPE___ns11__GetPresetTourOptions (2792)
/* Wrapper: */
struct SOAP_CMAC __ns11__GetPresetTourOptions {
      public:
        /** Optional element 'ns11:GetPresetTourOptions' of XSD type 'ns11:GetPresetTourOptions' */
        _ns11__GetPresetTourOptions *ns11__GetPresetTourOptions;
      public:
        /** Return unique type id SOAP_TYPE___ns11__GetPresetTourOptions */
        int soap_type() const { return SOAP_TYPE___ns11__GetPresetTourOptions; }
        /** Constructor with member initializations */
        __ns11__GetPresetTourOptions()
        {
          ns11__GetPresetTourOptions = (_ns11__GetPresetTourOptions *)0;
        }
        /** Friend allocator used by soap_new___ns11__GetPresetTourOptions(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__GetPresetTourOptions * SOAP_FMAC2 soap_instantiate___ns11__GetPresetTourOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:53654 */
#ifndef SOAP_TYPE___ns11__CreatePresetTour
#define SOAP_TYPE___ns11__CreatePresetTour (2796)
/* Wrapper: */
struct SOAP_CMAC __ns11__CreatePresetTour {
      public:
        /** Optional element 'ns11:CreatePresetTour' of XSD type 'ns11:CreatePresetTour' */
        _ns11__CreatePresetTour *ns11__CreatePresetTour;
      public:
        /** Return unique type id SOAP_TYPE___ns11__CreatePresetTour */
        int soap_type() const { return SOAP_TYPE___ns11__CreatePresetTour; }
        /** Constructor with member initializations */
        __ns11__CreatePresetTour()
        {
          ns11__CreatePresetTour = (_ns11__CreatePresetTour *)0;
        }
        /** Friend allocator used by soap_new___ns11__CreatePresetTour(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__CreatePresetTour * SOAP_FMAC2 soap_instantiate___ns11__CreatePresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:53722 */
#ifndef SOAP_TYPE___ns11__ModifyPresetTour
#define SOAP_TYPE___ns11__ModifyPresetTour (2800)
/* Wrapper: */
struct SOAP_CMAC __ns11__ModifyPresetTour {
      public:
        /** Optional element 'ns11:ModifyPresetTour' of XSD type 'ns11:ModifyPresetTour' */
        _ns11__ModifyPresetTour *ns11__ModifyPresetTour;
      public:
        /** Return unique type id SOAP_TYPE___ns11__ModifyPresetTour */
        int soap_type() const { return SOAP_TYPE___ns11__ModifyPresetTour; }
        /** Constructor with member initializations */
        __ns11__ModifyPresetTour()
        {
          ns11__ModifyPresetTour = (_ns11__ModifyPresetTour *)0;
        }
        /** Friend allocator used by soap_new___ns11__ModifyPresetTour(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__ModifyPresetTour * SOAP_FMAC2 soap_instantiate___ns11__ModifyPresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:53790 */
#ifndef SOAP_TYPE___ns11__OperatePresetTour
#define SOAP_TYPE___ns11__OperatePresetTour (2804)
/* Wrapper: */
struct SOAP_CMAC __ns11__OperatePresetTour {
      public:
        /** Optional element 'ns11:OperatePresetTour' of XSD type 'ns11:OperatePresetTour' */
        _ns11__OperatePresetTour *ns11__OperatePresetTour;
      public:
        /** Return unique type id SOAP_TYPE___ns11__OperatePresetTour */
        int soap_type() const { return SOAP_TYPE___ns11__OperatePresetTour; }
        /** Constructor with member initializations */
        __ns11__OperatePresetTour()
        {
          ns11__OperatePresetTour = (_ns11__OperatePresetTour *)0;
        }
        /** Friend allocator used by soap_new___ns11__OperatePresetTour(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__OperatePresetTour * SOAP_FMAC2 soap_instantiate___ns11__OperatePresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:53858 */
#ifndef SOAP_TYPE___ns11__RemovePresetTour
#define SOAP_TYPE___ns11__RemovePresetTour (2808)
/* Wrapper: */
struct SOAP_CMAC __ns11__RemovePresetTour {
      public:
        /** Optional element 'ns11:RemovePresetTour' of XSD type 'ns11:RemovePresetTour' */
        _ns11__RemovePresetTour *ns11__RemovePresetTour;
      public:
        /** Return unique type id SOAP_TYPE___ns11__RemovePresetTour */
        int soap_type() const { return SOAP_TYPE___ns11__RemovePresetTour; }
        /** Constructor with member initializations */
        __ns11__RemovePresetTour()
        {
          ns11__RemovePresetTour = (_ns11__RemovePresetTour *)0;
        }
        /** Friend allocator used by soap_new___ns11__RemovePresetTour(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__RemovePresetTour * SOAP_FMAC2 soap_instantiate___ns11__RemovePresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:53934 */
#ifndef SOAP_TYPE___ns11__GetCompatibleConfigurations
#define SOAP_TYPE___ns11__GetCompatibleConfigurations (2812)
/* Wrapper: */
struct SOAP_CMAC __ns11__GetCompatibleConfigurations {
      public:
        /** Optional element 'ns11:GetCompatibleConfigurations' of XSD type 'ns11:GetCompatibleConfigurations' */
        _ns11__GetCompatibleConfigurations *ns11__GetCompatibleConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns11__GetCompatibleConfigurations */
        int soap_type() const { return SOAP_TYPE___ns11__GetCompatibleConfigurations; }
        /** Constructor with member initializations */
        __ns11__GetCompatibleConfigurations()
        {
          ns11__GetCompatibleConfigurations = (_ns11__GetCompatibleConfigurations *)0;
        }
        /** Friend allocator used by soap_new___ns11__GetCompatibleConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns11__GetCompatibleConfigurations * SOAP_FMAC2 soap_instantiate___ns11__GetCompatibleConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:54020 */
#ifndef SOAP_TYPE___ns12__GetServiceCapabilities
#define SOAP_TYPE___ns12__GetServiceCapabilities (2816)
/* Wrapper: */
struct SOAP_CMAC __ns12__GetServiceCapabilities {
      public:
        /** Optional element 'ns12:GetServiceCapabilities' of XSD type 'ns12:GetServiceCapabilities' */
        _ns12__GetServiceCapabilities *ns12__GetServiceCapabilities;
      public:
        /** Return unique type id SOAP_TYPE___ns12__GetServiceCapabilities */
        int soap_type() const { return SOAP_TYPE___ns12__GetServiceCapabilities; }
        /** Constructor with member initializations */
        __ns12__GetServiceCapabilities()
        {
          ns12__GetServiceCapabilities = (_ns12__GetServiceCapabilities *)0;
        }
        /** Friend allocator used by soap_new___ns12__GetServiceCapabilities(struct soap*, int) */
        friend SOAP_FMAC1 __ns12__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___ns12__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:54092 */
#ifndef SOAP_TYPE___ns12__GetSupportedFormatTypes
#define SOAP_TYPE___ns12__GetSupportedFormatTypes (2820)
/* Wrapper: */
struct SOAP_CMAC __ns12__GetSupportedFormatTypes {
      public:
        /** Optional element 'ns12:GetSupportedFormatTypes' of XSD type 'ns12:GetSupportedFormatTypes' */
        _ns12__GetSupportedFormatTypes *ns12__GetSupportedFormatTypes;
      public:
        /** Return unique type id SOAP_TYPE___ns12__GetSupportedFormatTypes */
        int soap_type() const { return SOAP_TYPE___ns12__GetSupportedFormatTypes; }
        /** Constructor with member initializations */
        __ns12__GetSupportedFormatTypes()
        {
          ns12__GetSupportedFormatTypes = (_ns12__GetSupportedFormatTypes *)0;
        }
        /** Friend allocator used by soap_new___ns12__GetSupportedFormatTypes(struct soap*, int) */
        friend SOAP_FMAC1 __ns12__GetSupportedFormatTypes * SOAP_FMAC2 soap_instantiate___ns12__GetSupportedFormatTypes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:54171 */
#ifndef SOAP_TYPE___ns12__GetCredentialInfo
#define SOAP_TYPE___ns12__GetCredentialInfo (2824)
/* Wrapper: */
struct SOAP_CMAC __ns12__GetCredentialInfo {
      public:
        /** Optional element 'ns12:GetCredentialInfo' of XSD type 'ns12:GetCredentialInfo' */
        _ns12__GetCredentialInfo *ns12__GetCredentialInfo;
      public:
        /** Return unique type id SOAP_TYPE___ns12__GetCredentialInfo */
        int soap_type() const { return SOAP_TYPE___ns12__GetCredentialInfo; }
        /** Constructor with member initializations */
        __ns12__GetCredentialInfo()
        {
          ns12__GetCredentialInfo = (_ns12__GetCredentialInfo *)0;
        }
        /** Friend allocator used by soap_new___ns12__GetCredentialInfo(struct soap*, int) */
        friend SOAP_FMAC1 __ns12__GetCredentialInfo * SOAP_FMAC2 soap_instantiate___ns12__GetCredentialInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:54250 */
#ifndef SOAP_TYPE___ns12__GetCredentialInfoList
#define SOAP_TYPE___ns12__GetCredentialInfoList (2828)
/* Wrapper: */
struct SOAP_CMAC __ns12__GetCredentialInfoList {
      public:
        /** Optional element 'ns12:GetCredentialInfoList' of XSD type 'ns12:GetCredentialInfoList' */
        _ns12__GetCredentialInfoList *ns12__GetCredentialInfoList;
      public:
        /** Return unique type id SOAP_TYPE___ns12__GetCredentialInfoList */
        int soap_type() const { return SOAP_TYPE___ns12__GetCredentialInfoList; }
        /** Constructor with member initializations */
        __ns12__GetCredentialInfoList()
        {
          ns12__GetCredentialInfoList = (_ns12__GetCredentialInfoList *)0;
        }
        /** Friend allocator used by soap_new___ns12__GetCredentialInfoList(struct soap*, int) */
        friend SOAP_FMAC1 __ns12__GetCredentialInfoList * SOAP_FMAC2 soap_instantiate___ns12__GetCredentialInfoList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:54327 */
#ifndef SOAP_TYPE___ns12__GetCredentials
#define SOAP_TYPE___ns12__GetCredentials (2832)
/* Wrapper: */
struct SOAP_CMAC __ns12__GetCredentials {
      public:
        /** Optional element 'ns12:GetCredentials' of XSD type 'ns12:GetCredentials' */
        _ns12__GetCredentials *ns12__GetCredentials;
      public:
        /** Return unique type id SOAP_TYPE___ns12__GetCredentials */
        int soap_type() const { return SOAP_TYPE___ns12__GetCredentials; }
        /** Constructor with member initializations */
        __ns12__GetCredentials()
        {
          ns12__GetCredentials = (_ns12__GetCredentials *)0;
        }
        /** Friend allocator used by soap_new___ns12__GetCredentials(struct soap*, int) */
        friend SOAP_FMAC1 __ns12__GetCredentials * SOAP_FMAC2 soap_instantiate___ns12__GetCredentials(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:54405 */
#ifndef SOAP_TYPE___ns12__GetCredentialList
#define SOAP_TYPE___ns12__GetCredentialList (2836)
/* Wrapper: */
struct SOAP_CMAC __ns12__GetCredentialList {
      public:
        /** Optional element 'ns12:GetCredentialList' of XSD type 'ns12:GetCredentialList' */
        _ns12__GetCredentialList *ns12__GetCredentialList;
      public:
        /** Return unique type id SOAP_TYPE___ns12__GetCredentialList */
        int soap_type() const { return SOAP_TYPE___ns12__GetCredentialList; }
        /** Constructor with member initializations */
        __ns12__GetCredentialList()
        {
          ns12__GetCredentialList = (_ns12__GetCredentialList *)0;
        }
        /** Friend allocator used by soap_new___ns12__GetCredentialList(struct soap*, int) */
        friend SOAP_FMAC1 __ns12__GetCredentialList * SOAP_FMAC2 soap_instantiate___ns12__GetCredentialList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:54484 */
#ifndef SOAP_TYPE___ns12__CreateCredential
#define SOAP_TYPE___ns12__CreateCredential (2840)
/* Wrapper: */
struct SOAP_CMAC __ns12__CreateCredential {
      public:
        /** Optional element 'ns12:CreateCredential' of XSD type 'ns12:CreateCredential' */
        _ns12__CreateCredential *ns12__CreateCredential;
      public:
        /** Return unique type id SOAP_TYPE___ns12__CreateCredential */
        int soap_type() const { return SOAP_TYPE___ns12__CreateCredential; }
        /** Constructor with member initializations */
        __ns12__CreateCredential()
        {
          ns12__CreateCredential = (_ns12__CreateCredential *)0;
        }
        /** Friend allocator used by soap_new___ns12__CreateCredential(struct soap*, int) */
        friend SOAP_FMAC1 __ns12__CreateCredential * SOAP_FMAC2 soap_instantiate___ns12__CreateCredential(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:54562 */
#ifndef SOAP_TYPE___ns12__ModifyCredential
#define SOAP_TYPE___ns12__ModifyCredential (2844)
/* Wrapper: */
struct SOAP_CMAC __ns12__ModifyCredential {
      public:
        /** Optional element 'ns12:ModifyCredential' of XSD type 'ns12:ModifyCredential' */
        _ns12__ModifyCredential *ns12__ModifyCredential;
      public:
        /** Return unique type id SOAP_TYPE___ns12__ModifyCredential */
        int soap_type() const { return SOAP_TYPE___ns12__ModifyCredential; }
        /** Constructor with member initializations */
        __ns12__ModifyCredential()
        {
          ns12__ModifyCredential = (_ns12__ModifyCredential *)0;
        }
        /** Friend allocator used by soap_new___ns12__ModifyCredential(struct soap*, int) */
        friend SOAP_FMAC1 __ns12__ModifyCredential * SOAP_FMAC2 soap_instantiate___ns12__ModifyCredential(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:54635 */
#ifndef SOAP_TYPE___ns12__DeleteCredential
#define SOAP_TYPE___ns12__DeleteCredential (2848)
/* Wrapper: */
struct SOAP_CMAC __ns12__DeleteCredential {
      public:
        /** Optional element 'ns12:DeleteCredential' of XSD type 'ns12:DeleteCredential' */
        _ns12__DeleteCredential *ns12__DeleteCredential;
      public:
        /** Return unique type id SOAP_TYPE___ns12__DeleteCredential */
        int soap_type() const { return SOAP_TYPE___ns12__DeleteCredential; }
        /** Constructor with member initializations */
        __ns12__DeleteCredential()
        {
          ns12__DeleteCredential = (_ns12__DeleteCredential *)0;
        }
        /** Friend allocator used by soap_new___ns12__DeleteCredential(struct soap*, int) */
        friend SOAP_FMAC1 __ns12__DeleteCredential * SOAP_FMAC2 soap_instantiate___ns12__DeleteCredential(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:54710 */
#ifndef SOAP_TYPE___ns12__GetCredentialState
#define SOAP_TYPE___ns12__GetCredentialState (2852)
/* Wrapper: */
struct SOAP_CMAC __ns12__GetCredentialState {
      public:
        /** Optional element 'ns12:GetCredentialState' of XSD type 'ns12:GetCredentialState' */
        _ns12__GetCredentialState *ns12__GetCredentialState;
      public:
        /** Return unique type id SOAP_TYPE___ns12__GetCredentialState */
        int soap_type() const { return SOAP_TYPE___ns12__GetCredentialState; }
        /** Constructor with member initializations */
        __ns12__GetCredentialState()
        {
          ns12__GetCredentialState = (_ns12__GetCredentialState *)0;
        }
        /** Friend allocator used by soap_new___ns12__GetCredentialState(struct soap*, int) */
        friend SOAP_FMAC1 __ns12__GetCredentialState * SOAP_FMAC2 soap_instantiate___ns12__GetCredentialState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:54780 */
#ifndef SOAP_TYPE___ns12__EnableCredential
#define SOAP_TYPE___ns12__EnableCredential (2856)
/* Wrapper: */
struct SOAP_CMAC __ns12__EnableCredential {
      public:
        /** Optional element 'ns12:EnableCredential' of XSD type 'ns12:EnableCredential' */
        _ns12__EnableCredential *ns12__EnableCredential;
      public:
        /** Return unique type id SOAP_TYPE___ns12__EnableCredential */
        int soap_type() const { return SOAP_TYPE___ns12__EnableCredential; }
        /** Constructor with member initializations */
        __ns12__EnableCredential()
        {
          ns12__EnableCredential = (_ns12__EnableCredential *)0;
        }
        /** Friend allocator used by soap_new___ns12__EnableCredential(struct soap*, int) */
        friend SOAP_FMAC1 __ns12__EnableCredential * SOAP_FMAC2 soap_instantiate___ns12__EnableCredential(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:54850 */
#ifndef SOAP_TYPE___ns12__DisableCredential
#define SOAP_TYPE___ns12__DisableCredential (2860)
/* Wrapper: */
struct SOAP_CMAC __ns12__DisableCredential {
      public:
        /** Optional element 'ns12:DisableCredential' of XSD type 'ns12:DisableCredential' */
        _ns12__DisableCredential *ns12__DisableCredential;
      public:
        /** Return unique type id SOAP_TYPE___ns12__DisableCredential */
        int soap_type() const { return SOAP_TYPE___ns12__DisableCredential; }
        /** Constructor with member initializations */
        __ns12__DisableCredential()
        {
          ns12__DisableCredential = (_ns12__DisableCredential *)0;
        }
        /** Friend allocator used by soap_new___ns12__DisableCredential(struct soap*, int) */
        friend SOAP_FMAC1 __ns12__DisableCredential * SOAP_FMAC2 soap_instantiate___ns12__DisableCredential(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:54921 */
#ifndef SOAP_TYPE___ns12__ResetAntipassbackViolation
#define SOAP_TYPE___ns12__ResetAntipassbackViolation (2864)
/* Wrapper: */
struct SOAP_CMAC __ns12__ResetAntipassbackViolation {
      public:
        /** Optional element 'ns12:ResetAntipassbackViolation' of XSD type 'ns12:ResetAntipassbackViolation' */
        _ns12__ResetAntipassbackViolation *ns12__ResetAntipassbackViolation;
      public:
        /** Return unique type id SOAP_TYPE___ns12__ResetAntipassbackViolation */
        int soap_type() const { return SOAP_TYPE___ns12__ResetAntipassbackViolation; }
        /** Constructor with member initializations */
        __ns12__ResetAntipassbackViolation()
        {
          ns12__ResetAntipassbackViolation = (_ns12__ResetAntipassbackViolation *)0;
        }
        /** Friend allocator used by soap_new___ns12__ResetAntipassbackViolation(struct soap*, int) */
        friend SOAP_FMAC1 __ns12__ResetAntipassbackViolation * SOAP_FMAC2 soap_instantiate___ns12__ResetAntipassbackViolation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:54992 */
#ifndef SOAP_TYPE___ns12__GetCredentialIdentifiers
#define SOAP_TYPE___ns12__GetCredentialIdentifiers (2868)
/* Wrapper: */
struct SOAP_CMAC __ns12__GetCredentialIdentifiers {
      public:
        /** Optional element 'ns12:GetCredentialIdentifiers' of XSD type 'ns12:GetCredentialIdentifiers' */
        _ns12__GetCredentialIdentifiers *ns12__GetCredentialIdentifiers;
      public:
        /** Return unique type id SOAP_TYPE___ns12__GetCredentialIdentifiers */
        int soap_type() const { return SOAP_TYPE___ns12__GetCredentialIdentifiers; }
        /** Constructor with member initializations */
        __ns12__GetCredentialIdentifiers()
        {
          ns12__GetCredentialIdentifiers = (_ns12__GetCredentialIdentifiers *)0;
        }
        /** Friend allocator used by soap_new___ns12__GetCredentialIdentifiers(struct soap*, int) */
        friend SOAP_FMAC1 __ns12__GetCredentialIdentifiers * SOAP_FMAC2 soap_instantiate___ns12__GetCredentialIdentifiers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:55067 */
#ifndef SOAP_TYPE___ns12__SetCredentialIdentifier
#define SOAP_TYPE___ns12__SetCredentialIdentifier (2872)
/* Wrapper: */
struct SOAP_CMAC __ns12__SetCredentialIdentifier {
      public:
        /** Optional element 'ns12:SetCredentialIdentifier' of XSD type 'ns12:SetCredentialIdentifier' */
        _ns12__SetCredentialIdentifier *ns12__SetCredentialIdentifier;
      public:
        /** Return unique type id SOAP_TYPE___ns12__SetCredentialIdentifier */
        int soap_type() const { return SOAP_TYPE___ns12__SetCredentialIdentifier; }
        /** Constructor with member initializations */
        __ns12__SetCredentialIdentifier()
        {
          ns12__SetCredentialIdentifier = (_ns12__SetCredentialIdentifier *)0;
        }
        /** Friend allocator used by soap_new___ns12__SetCredentialIdentifier(struct soap*, int) */
        friend SOAP_FMAC1 __ns12__SetCredentialIdentifier * SOAP_FMAC2 soap_instantiate___ns12__SetCredentialIdentifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:55140 */
#ifndef SOAP_TYPE___ns12__DeleteCredentialIdentifier
#define SOAP_TYPE___ns12__DeleteCredentialIdentifier (2876)
/* Wrapper: */
struct SOAP_CMAC __ns12__DeleteCredentialIdentifier {
      public:
        /** Optional element 'ns12:DeleteCredentialIdentifier' of XSD type 'ns12:DeleteCredentialIdentifier' */
        _ns12__DeleteCredentialIdentifier *ns12__DeleteCredentialIdentifier;
      public:
        /** Return unique type id SOAP_TYPE___ns12__DeleteCredentialIdentifier */
        int soap_type() const { return SOAP_TYPE___ns12__DeleteCredentialIdentifier; }
        /** Constructor with member initializations */
        __ns12__DeleteCredentialIdentifier()
        {
          ns12__DeleteCredentialIdentifier = (_ns12__DeleteCredentialIdentifier *)0;
        }
        /** Friend allocator used by soap_new___ns12__DeleteCredentialIdentifier(struct soap*, int) */
        friend SOAP_FMAC1 __ns12__DeleteCredentialIdentifier * SOAP_FMAC2 soap_instantiate___ns12__DeleteCredentialIdentifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:55211 */
#ifndef SOAP_TYPE___ns12__GetCredentialAccessProfiles
#define SOAP_TYPE___ns12__GetCredentialAccessProfiles (2880)
/* Wrapper: */
struct SOAP_CMAC __ns12__GetCredentialAccessProfiles {
      public:
        /** Optional element 'ns12:GetCredentialAccessProfiles' of XSD type 'ns12:GetCredentialAccessProfiles' */
        _ns12__GetCredentialAccessProfiles *ns12__GetCredentialAccessProfiles;
      public:
        /** Return unique type id SOAP_TYPE___ns12__GetCredentialAccessProfiles */
        int soap_type() const { return SOAP_TYPE___ns12__GetCredentialAccessProfiles; }
        /** Constructor with member initializations */
        __ns12__GetCredentialAccessProfiles()
        {
          ns12__GetCredentialAccessProfiles = (_ns12__GetCredentialAccessProfiles *)0;
        }
        /** Friend allocator used by soap_new___ns12__GetCredentialAccessProfiles(struct soap*, int) */
        friend SOAP_FMAC1 __ns12__GetCredentialAccessProfiles * SOAP_FMAC2 soap_instantiate___ns12__GetCredentialAccessProfiles(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:55286 */
#ifndef SOAP_TYPE___ns12__SetCredentialAccessProfiles
#define SOAP_TYPE___ns12__SetCredentialAccessProfiles (2884)
/* Wrapper: */
struct SOAP_CMAC __ns12__SetCredentialAccessProfiles {
      public:
        /** Optional element 'ns12:SetCredentialAccessProfiles' of XSD type 'ns12:SetCredentialAccessProfiles' */
        _ns12__SetCredentialAccessProfiles *ns12__SetCredentialAccessProfiles;
      public:
        /** Return unique type id SOAP_TYPE___ns12__SetCredentialAccessProfiles */
        int soap_type() const { return SOAP_TYPE___ns12__SetCredentialAccessProfiles; }
        /** Constructor with member initializations */
        __ns12__SetCredentialAccessProfiles()
        {
          ns12__SetCredentialAccessProfiles = (_ns12__SetCredentialAccessProfiles *)0;
        }
        /** Friend allocator used by soap_new___ns12__SetCredentialAccessProfiles(struct soap*, int) */
        friend SOAP_FMAC1 __ns12__SetCredentialAccessProfiles * SOAP_FMAC2 soap_instantiate___ns12__SetCredentialAccessProfiles(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:55360 */
#ifndef SOAP_TYPE___ns12__DeleteCredentialAccessProfiles
#define SOAP_TYPE___ns12__DeleteCredentialAccessProfiles (2888)
/* Wrapper: */
struct SOAP_CMAC __ns12__DeleteCredentialAccessProfiles {
      public:
        /** Optional element 'ns12:DeleteCredentialAccessProfiles' of XSD type 'ns12:DeleteCredentialAccessProfiles' */
        _ns12__DeleteCredentialAccessProfiles *ns12__DeleteCredentialAccessProfiles;
      public:
        /** Return unique type id SOAP_TYPE___ns12__DeleteCredentialAccessProfiles */
        int soap_type() const { return SOAP_TYPE___ns12__DeleteCredentialAccessProfiles; }
        /** Constructor with member initializations */
        __ns12__DeleteCredentialAccessProfiles()
        {
          ns12__DeleteCredentialAccessProfiles = (_ns12__DeleteCredentialAccessProfiles *)0;
        }
        /** Friend allocator used by soap_new___ns12__DeleteCredentialAccessProfiles(struct soap*, int) */
        friend SOAP_FMAC1 __ns12__DeleteCredentialAccessProfiles * SOAP_FMAC2 soap_instantiate___ns12__DeleteCredentialAccessProfiles(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:55447 */
#ifndef SOAP_TYPE___ns7__GetServiceCapabilities
#define SOAP_TYPE___ns7__GetServiceCapabilities (2892)
/* Wrapper: */
struct SOAP_CMAC __ns7__GetServiceCapabilities {
      public:
        /** Optional element 'ns7:GetServiceCapabilities' of XSD type 'ns7:GetServiceCapabilities' */
        _ns7__GetServiceCapabilities *ns7__GetServiceCapabilities;
      public:
        /** Return unique type id SOAP_TYPE___ns7__GetServiceCapabilities */
        int soap_type() const { return SOAP_TYPE___ns7__GetServiceCapabilities; }
        /** Constructor with member initializations */
        __ns7__GetServiceCapabilities()
        {
          ns7__GetServiceCapabilities = (_ns7__GetServiceCapabilities *)0;
        }
        /** Friend allocator used by soap_new___ns7__GetServiceCapabilities(struct soap*, int) */
        friend SOAP_FMAC1 __ns7__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___ns7__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:55519 */
#ifndef SOAP_TYPE___ns7__GetLayout
#define SOAP_TYPE___ns7__GetLayout (2896)
/* Wrapper: */
struct SOAP_CMAC __ns7__GetLayout {
      public:
        /** Optional element 'ns7:GetLayout' of XSD type 'ns7:GetLayout' */
        _ns7__GetLayout *ns7__GetLayout;
      public:
        /** Return unique type id SOAP_TYPE___ns7__GetLayout */
        int soap_type() const { return SOAP_TYPE___ns7__GetLayout; }
        /** Constructor with member initializations */
        __ns7__GetLayout()
        {
          ns7__GetLayout = (_ns7__GetLayout *)0;
        }
        /** Friend allocator used by soap_new___ns7__GetLayout(struct soap*, int) */
        friend SOAP_FMAC1 __ns7__GetLayout * SOAP_FMAC2 soap_instantiate___ns7__GetLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:55596 */
#ifndef SOAP_TYPE___ns7__SetLayout
#define SOAP_TYPE___ns7__SetLayout (2900)
/* Wrapper: */
struct SOAP_CMAC __ns7__SetLayout {
      public:
        /** Optional element 'ns7:SetLayout' of XSD type 'ns7:SetLayout' */
        _ns7__SetLayout *ns7__SetLayout;
      public:
        /** Return unique type id SOAP_TYPE___ns7__SetLayout */
        int soap_type() const { return SOAP_TYPE___ns7__SetLayout; }
        /** Constructor with member initializations */
        __ns7__SetLayout()
        {
          ns7__SetLayout = (_ns7__SetLayout *)0;
        }
        /** Friend allocator used by soap_new___ns7__SetLayout(struct soap*, int) */
        friend SOAP_FMAC1 __ns7__SetLayout * SOAP_FMAC2 soap_instantiate___ns7__SetLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:55668 */
#ifndef SOAP_TYPE___ns7__GetDisplayOptions
#define SOAP_TYPE___ns7__GetDisplayOptions (2904)
/* Wrapper: */
struct SOAP_CMAC __ns7__GetDisplayOptions {
      public:
        /** Optional element 'ns7:GetDisplayOptions' of XSD type 'ns7:GetDisplayOptions' */
        _ns7__GetDisplayOptions *ns7__GetDisplayOptions;
      public:
        /** Return unique type id SOAP_TYPE___ns7__GetDisplayOptions */
        int soap_type() const { return SOAP_TYPE___ns7__GetDisplayOptions; }
        /** Constructor with member initializations */
        __ns7__GetDisplayOptions()
        {
          ns7__GetDisplayOptions = (_ns7__GetDisplayOptions *)0;
        }
        /** Friend allocator used by soap_new___ns7__GetDisplayOptions(struct soap*, int) */
        friend SOAP_FMAC1 __ns7__GetDisplayOptions * SOAP_FMAC2 soap_instantiate___ns7__GetDisplayOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:55744 */
#ifndef SOAP_TYPE___ns7__GetPaneConfigurations
#define SOAP_TYPE___ns7__GetPaneConfigurations (2908)
/* Wrapper: */
struct SOAP_CMAC __ns7__GetPaneConfigurations {
      public:
        /** Optional element 'ns7:GetPaneConfigurations' of XSD type 'ns7:GetPaneConfigurations' */
        _ns7__GetPaneConfigurations *ns7__GetPaneConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns7__GetPaneConfigurations */
        int soap_type() const { return SOAP_TYPE___ns7__GetPaneConfigurations; }
        /** Constructor with member initializations */
        __ns7__GetPaneConfigurations()
        {
          ns7__GetPaneConfigurations = (_ns7__GetPaneConfigurations *)0;
        }
        /** Friend allocator used by soap_new___ns7__GetPaneConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns7__GetPaneConfigurations * SOAP_FMAC2 soap_instantiate___ns7__GetPaneConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:55812 */
#ifndef SOAP_TYPE___ns7__GetPaneConfiguration
#define SOAP_TYPE___ns7__GetPaneConfiguration (2912)
/* Wrapper: */
struct SOAP_CMAC __ns7__GetPaneConfiguration {
      public:
        /** Optional element 'ns7:GetPaneConfiguration' of XSD type 'ns7:GetPaneConfiguration' */
        _ns7__GetPaneConfiguration *ns7__GetPaneConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns7__GetPaneConfiguration */
        int soap_type() const { return SOAP_TYPE___ns7__GetPaneConfiguration; }
        /** Constructor with member initializations */
        __ns7__GetPaneConfiguration()
        {
          ns7__GetPaneConfiguration = (_ns7__GetPaneConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns7__GetPaneConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns7__GetPaneConfiguration * SOAP_FMAC2 soap_instantiate___ns7__GetPaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:55884 */
#ifndef SOAP_TYPE___ns7__SetPaneConfigurations
#define SOAP_TYPE___ns7__SetPaneConfigurations (2916)
/* Wrapper: */
struct SOAP_CMAC __ns7__SetPaneConfigurations {
      public:
        /** Optional element 'ns7:SetPaneConfigurations' of XSD type 'ns7:SetPaneConfigurations' */
        _ns7__SetPaneConfigurations *ns7__SetPaneConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns7__SetPaneConfigurations */
        int soap_type() const { return SOAP_TYPE___ns7__SetPaneConfigurations; }
        /** Constructor with member initializations */
        __ns7__SetPaneConfigurations()
        {
          ns7__SetPaneConfigurations = (_ns7__SetPaneConfigurations *)0;
        }
        /** Friend allocator used by soap_new___ns7__SetPaneConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns7__SetPaneConfigurations * SOAP_FMAC2 soap_instantiate___ns7__SetPaneConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:55952 */
#ifndef SOAP_TYPE___ns7__SetPaneConfiguration
#define SOAP_TYPE___ns7__SetPaneConfiguration (2920)
/* Wrapper: */
struct SOAP_CMAC __ns7__SetPaneConfiguration {
      public:
        /** Optional element 'ns7:SetPaneConfiguration' of XSD type 'ns7:SetPaneConfiguration' */
        _ns7__SetPaneConfiguration *ns7__SetPaneConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns7__SetPaneConfiguration */
        int soap_type() const { return SOAP_TYPE___ns7__SetPaneConfiguration; }
        /** Constructor with member initializations */
        __ns7__SetPaneConfiguration()
        {
          ns7__SetPaneConfiguration = (_ns7__SetPaneConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns7__SetPaneConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns7__SetPaneConfiguration * SOAP_FMAC2 soap_instantiate___ns7__SetPaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:56026 */
#ifndef SOAP_TYPE___ns7__CreatePaneConfiguration
#define SOAP_TYPE___ns7__CreatePaneConfiguration (2924)
/* Wrapper: */
struct SOAP_CMAC __ns7__CreatePaneConfiguration {
      public:
        /** Optional element 'ns7:CreatePaneConfiguration' of XSD type 'ns7:CreatePaneConfiguration' */
        _ns7__CreatePaneConfiguration *ns7__CreatePaneConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns7__CreatePaneConfiguration */
        int soap_type() const { return SOAP_TYPE___ns7__CreatePaneConfiguration; }
        /** Constructor with member initializations */
        __ns7__CreatePaneConfiguration()
        {
          ns7__CreatePaneConfiguration = (_ns7__CreatePaneConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns7__CreatePaneConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns7__CreatePaneConfiguration * SOAP_FMAC2 soap_instantiate___ns7__CreatePaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:56098 */
#ifndef SOAP_TYPE___ns7__DeletePaneConfiguration
#define SOAP_TYPE___ns7__DeletePaneConfiguration (2928)
/* Wrapper: */
struct SOAP_CMAC __ns7__DeletePaneConfiguration {
      public:
        /** Optional element 'ns7:DeletePaneConfiguration' of XSD type 'ns7:DeletePaneConfiguration' */
        _ns7__DeletePaneConfiguration *ns7__DeletePaneConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns7__DeletePaneConfiguration */
        int soap_type() const { return SOAP_TYPE___ns7__DeletePaneConfiguration; }
        /** Constructor with member initializations */
        __ns7__DeletePaneConfiguration()
        {
          ns7__DeletePaneConfiguration = (_ns7__DeletePaneConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns7__DeletePaneConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns7__DeletePaneConfiguration * SOAP_FMAC2 soap_instantiate___ns7__DeletePaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:56185 */
#ifndef SOAP_TYPE___ns8__GetServiceCapabilities
#define SOAP_TYPE___ns8__GetServiceCapabilities (2932)
/* Wrapper: */
struct SOAP_CMAC __ns8__GetServiceCapabilities {
      public:
        /** Optional element 'ns8:GetServiceCapabilities' of XSD type 'ns8:GetServiceCapabilities' */
        _ns8__GetServiceCapabilities *ns8__GetServiceCapabilities;
      public:
        /** Return unique type id SOAP_TYPE___ns8__GetServiceCapabilities */
        int soap_type() const { return SOAP_TYPE___ns8__GetServiceCapabilities; }
        /** Constructor with member initializations */
        __ns8__GetServiceCapabilities()
        {
          ns8__GetServiceCapabilities = (_ns8__GetServiceCapabilities *)0;
        }
        /** Friend allocator used by soap_new___ns8__GetServiceCapabilities(struct soap*, int) */
        friend SOAP_FMAC1 __ns8__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___ns8__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:56253 */
#ifndef SOAP_TYPE___ns8__GetImagingSettings
#define SOAP_TYPE___ns8__GetImagingSettings (2936)
/* Wrapper: */
struct SOAP_CMAC __ns8__GetImagingSettings {
      public:
        /** Optional element 'ns8:GetImagingSettings' of XSD type 'ns8:GetImagingSettings' */
        _ns8__GetImagingSettings *ns8__GetImagingSettings;
      public:
        /** Return unique type id SOAP_TYPE___ns8__GetImagingSettings */
        int soap_type() const { return SOAP_TYPE___ns8__GetImagingSettings; }
        /** Constructor with member initializations */
        __ns8__GetImagingSettings()
        {
          ns8__GetImagingSettings = (_ns8__GetImagingSettings *)0;
        }
        /** Friend allocator used by soap_new___ns8__GetImagingSettings(struct soap*, int) */
        friend SOAP_FMAC1 __ns8__GetImagingSettings * SOAP_FMAC2 soap_instantiate___ns8__GetImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:56321 */
#ifndef SOAP_TYPE___ns8__SetImagingSettings
#define SOAP_TYPE___ns8__SetImagingSettings (2940)
/* Wrapper: */
struct SOAP_CMAC __ns8__SetImagingSettings {
      public:
        /** Optional element 'ns8:SetImagingSettings' of XSD type 'ns8:SetImagingSettings' */
        _ns8__SetImagingSettings *ns8__SetImagingSettings;
      public:
        /** Return unique type id SOAP_TYPE___ns8__SetImagingSettings */
        int soap_type() const { return SOAP_TYPE___ns8__SetImagingSettings; }
        /** Constructor with member initializations */
        __ns8__SetImagingSettings()
        {
          ns8__SetImagingSettings = (_ns8__SetImagingSettings *)0;
        }
        /** Friend allocator used by soap_new___ns8__SetImagingSettings(struct soap*, int) */
        friend SOAP_FMAC1 __ns8__SetImagingSettings * SOAP_FMAC2 soap_instantiate___ns8__SetImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:56399 */
#ifndef SOAP_TYPE___ns8__GetOptions
#define SOAP_TYPE___ns8__GetOptions (2944)
/* Wrapper: */
struct SOAP_CMAC __ns8__GetOptions {
      public:
        /** Optional element 'ns8:GetOptions' of XSD type 'ns8:GetOptions' */
        _ns8__GetOptions *ns8__GetOptions;
      public:
        /** Return unique type id SOAP_TYPE___ns8__GetOptions */
        int soap_type() const { return SOAP_TYPE___ns8__GetOptions; }
        /** Constructor with member initializations */
        __ns8__GetOptions()
        {
          ns8__GetOptions = (_ns8__GetOptions *)0;
        }
        /** Friend allocator used by soap_new___ns8__GetOptions(struct soap*, int) */
        friend SOAP_FMAC1 __ns8__GetOptions * SOAP_FMAC2 soap_instantiate___ns8__GetOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:56489 */
#ifndef SOAP_TYPE___ns8__Move
#define SOAP_TYPE___ns8__Move (2948)
/* Wrapper: */
struct SOAP_CMAC __ns8__Move {
      public:
        /** Optional element 'ns8:Move' of XSD type 'ns8:Move' */
        _ns8__Move *ns8__Move;
      public:
        /** Return unique type id SOAP_TYPE___ns8__Move */
        int soap_type() const { return SOAP_TYPE___ns8__Move; }
        /** Constructor with member initializations */
        __ns8__Move()
        {
          ns8__Move = (_ns8__Move *)0;
        }
        /** Friend allocator used by soap_new___ns8__Move(struct soap*, int) */
        friend SOAP_FMAC1 __ns8__Move * SOAP_FMAC2 soap_instantiate___ns8__Move(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:56560 */
#ifndef SOAP_TYPE___ns8__Stop
#define SOAP_TYPE___ns8__Stop (2952)
/* Wrapper: */
struct SOAP_CMAC __ns8__Stop {
      public:
        /** Optional element 'ns8:Stop' of XSD type 'ns8:Stop' */
        _ns8__Stop *ns8__Stop;
      public:
        /** Return unique type id SOAP_TYPE___ns8__Stop */
        int soap_type() const { return SOAP_TYPE___ns8__Stop; }
        /** Constructor with member initializations */
        __ns8__Stop()
        {
          ns8__Stop = (_ns8__Stop *)0;
        }
        /** Friend allocator used by soap_new___ns8__Stop(struct soap*, int) */
        friend SOAP_FMAC1 __ns8__Stop * SOAP_FMAC2 soap_instantiate___ns8__Stop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:56630 */
#ifndef SOAP_TYPE___ns8__GetStatus
#define SOAP_TYPE___ns8__GetStatus (2956)
/* Wrapper: */
struct SOAP_CMAC __ns8__GetStatus {
      public:
        /** Optional element 'ns8:GetStatus' of XSD type 'ns8:GetStatus' */
        _ns8__GetStatus *ns8__GetStatus;
      public:
        /** Return unique type id SOAP_TYPE___ns8__GetStatus */
        int soap_type() const { return SOAP_TYPE___ns8__GetStatus; }
        /** Constructor with member initializations */
        __ns8__GetStatus()
        {
          ns8__GetStatus = (_ns8__GetStatus *)0;
        }
        /** Friend allocator used by soap_new___ns8__GetStatus(struct soap*, int) */
        friend SOAP_FMAC1 __ns8__GetStatus * SOAP_FMAC2 soap_instantiate___ns8__GetStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:56698 */
#ifndef SOAP_TYPE___ns8__GetMoveOptions
#define SOAP_TYPE___ns8__GetMoveOptions (2960)
/* Wrapper: */
struct SOAP_CMAC __ns8__GetMoveOptions {
      public:
        /** Optional element 'ns8:GetMoveOptions' of XSD type 'ns8:GetMoveOptions' */
        _ns8__GetMoveOptions *ns8__GetMoveOptions;
      public:
        /** Return unique type id SOAP_TYPE___ns8__GetMoveOptions */
        int soap_type() const { return SOAP_TYPE___ns8__GetMoveOptions; }
        /** Constructor with member initializations */
        __ns8__GetMoveOptions()
        {
          ns8__GetMoveOptions = (_ns8__GetMoveOptions *)0;
        }
        /** Friend allocator used by soap_new___ns8__GetMoveOptions(struct soap*, int) */
        friend SOAP_FMAC1 __ns8__GetMoveOptions * SOAP_FMAC2 soap_instantiate___ns8__GetMoveOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:56766 */
#ifndef SOAP_TYPE___ns8__GetPresets
#define SOAP_TYPE___ns8__GetPresets (2964)
/* Wrapper: */
struct SOAP_CMAC __ns8__GetPresets {
      public:
        /** Optional element 'ns8:GetPresets' of XSD type 'ns8:GetPresets' */
        _ns8__GetPresets *ns8__GetPresets;
      public:
        /** Return unique type id SOAP_TYPE___ns8__GetPresets */
        int soap_type() const { return SOAP_TYPE___ns8__GetPresets; }
        /** Constructor with member initializations */
        __ns8__GetPresets()
        {
          ns8__GetPresets = (_ns8__GetPresets *)0;
        }
        /** Friend allocator used by soap_new___ns8__GetPresets(struct soap*, int) */
        friend SOAP_FMAC1 __ns8__GetPresets * SOAP_FMAC2 soap_instantiate___ns8__GetPresets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:56838 */
#ifndef SOAP_TYPE___ns8__GetCurrentPreset
#define SOAP_TYPE___ns8__GetCurrentPreset (2968)
/* Wrapper: */
struct SOAP_CMAC __ns8__GetCurrentPreset {
      public:
        /** Optional element 'ns8:GetCurrentPreset' of XSD type 'ns8:GetCurrentPreset' */
        _ns8__GetCurrentPreset *ns8__GetCurrentPreset;
      public:
        /** Return unique type id SOAP_TYPE___ns8__GetCurrentPreset */
        int soap_type() const { return SOAP_TYPE___ns8__GetCurrentPreset; }
        /** Constructor with member initializations */
        __ns8__GetCurrentPreset()
        {
          ns8__GetCurrentPreset = (_ns8__GetCurrentPreset *)0;
        }
        /** Friend allocator used by soap_new___ns8__GetCurrentPreset(struct soap*, int) */
        friend SOAP_FMAC1 __ns8__GetCurrentPreset * SOAP_FMAC2 soap_instantiate___ns8__GetCurrentPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:56914 */
#ifndef SOAP_TYPE___ns8__SetCurrentPreset
#define SOAP_TYPE___ns8__SetCurrentPreset (2972)
/* Wrapper: */
struct SOAP_CMAC __ns8__SetCurrentPreset {
      public:
        /** Optional element 'ns8:SetCurrentPreset' of XSD type 'ns8:SetCurrentPreset' */
        _ns8__SetCurrentPreset *ns8__SetCurrentPreset;
      public:
        /** Return unique type id SOAP_TYPE___ns8__SetCurrentPreset */
        int soap_type() const { return SOAP_TYPE___ns8__SetCurrentPreset; }
        /** Constructor with member initializations */
        __ns8__SetCurrentPreset()
        {
          ns8__SetCurrentPreset = (_ns8__SetCurrentPreset *)0;
        }
        /** Friend allocator used by soap_new___ns8__SetCurrentPreset(struct soap*, int) */
        friend SOAP_FMAC1 __ns8__SetCurrentPreset * SOAP_FMAC2 soap_instantiate___ns8__SetCurrentPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:57001 */
#ifndef SOAP_TYPE___ns9__GetServiceCapabilities
#define SOAP_TYPE___ns9__GetServiceCapabilities (2976)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetServiceCapabilities {
      public:
        /** Optional element 'ns9:GetServiceCapabilities' of XSD type 'ns9:GetServiceCapabilities' */
        _ns9__GetServiceCapabilities *ns9__GetServiceCapabilities;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetServiceCapabilities */
        int soap_type() const { return SOAP_TYPE___ns9__GetServiceCapabilities; }
        /** Constructor with member initializations */
        __ns9__GetServiceCapabilities()
        {
          ns9__GetServiceCapabilities = (_ns9__GetServiceCapabilities *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetServiceCapabilities(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___ns9__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:57069 */
#ifndef SOAP_TYPE___ns9__GetVideoSources
#define SOAP_TYPE___ns9__GetVideoSources (2980)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetVideoSources {
      public:
        /** Optional element 'ns9:GetVideoSources' of XSD type 'ns9:GetVideoSources' */
        _ns9__GetVideoSources *ns9__GetVideoSources;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetVideoSources */
        int soap_type() const { return SOAP_TYPE___ns9__GetVideoSources; }
        /** Constructor with member initializations */
        __ns9__GetVideoSources()
        {
          ns9__GetVideoSources = (_ns9__GetVideoSources *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetVideoSources(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetVideoSources * SOAP_FMAC2 soap_instantiate___ns9__GetVideoSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:57137 */
#ifndef SOAP_TYPE___ns9__GetAudioSources
#define SOAP_TYPE___ns9__GetAudioSources (2984)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetAudioSources {
      public:
        /** Optional element 'ns9:GetAudioSources' of XSD type 'ns9:GetAudioSources' */
        _ns9__GetAudioSources *ns9__GetAudioSources;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetAudioSources */
        int soap_type() const { return SOAP_TYPE___ns9__GetAudioSources; }
        /** Constructor with member initializations */
        __ns9__GetAudioSources()
        {
          ns9__GetAudioSources = (_ns9__GetAudioSources *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetAudioSources(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetAudioSources * SOAP_FMAC2 soap_instantiate___ns9__GetAudioSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:57205 */
#ifndef SOAP_TYPE___ns9__GetAudioOutputs
#define SOAP_TYPE___ns9__GetAudioOutputs (2988)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetAudioOutputs {
      public:
        /** Optional element 'ns9:GetAudioOutputs' of XSD type 'ns9:GetAudioOutputs' */
        _ns9__GetAudioOutputs *ns9__GetAudioOutputs;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetAudioOutputs */
        int soap_type() const { return SOAP_TYPE___ns9__GetAudioOutputs; }
        /** Constructor with member initializations */
        __ns9__GetAudioOutputs()
        {
          ns9__GetAudioOutputs = (_ns9__GetAudioOutputs *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetAudioOutputs(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetAudioOutputs * SOAP_FMAC2 soap_instantiate___ns9__GetAudioOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:57277 */
#ifndef SOAP_TYPE___ns9__CreateProfile
#define SOAP_TYPE___ns9__CreateProfile (2992)
/* Wrapper: */
struct SOAP_CMAC __ns9__CreateProfile {
      public:
        /** Optional element 'ns9:CreateProfile' of XSD type 'ns9:CreateProfile' */
        _ns9__CreateProfile *ns9__CreateProfile;
      public:
        /** Return unique type id SOAP_TYPE___ns9__CreateProfile */
        int soap_type() const { return SOAP_TYPE___ns9__CreateProfile; }
        /** Constructor with member initializations */
        __ns9__CreateProfile()
        {
          ns9__CreateProfile = (_ns9__CreateProfile *)0;
        }
        /** Friend allocator used by soap_new___ns9__CreateProfile(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__CreateProfile * SOAP_FMAC2 soap_instantiate___ns9__CreateProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:57346 */
#ifndef SOAP_TYPE___ns9__GetProfile
#define SOAP_TYPE___ns9__GetProfile (2996)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetProfile {
      public:
        /** Optional element 'ns9:GetProfile' of XSD type 'ns9:GetProfile' */
        _ns9__GetProfile *ns9__GetProfile;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetProfile */
        int soap_type() const { return SOAP_TYPE___ns9__GetProfile; }
        /** Constructor with member initializations */
        __ns9__GetProfile()
        {
          ns9__GetProfile = (_ns9__GetProfile *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetProfile(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetProfile * SOAP_FMAC2 soap_instantiate___ns9__GetProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:57419 */
#ifndef SOAP_TYPE___ns9__GetProfiles
#define SOAP_TYPE___ns9__GetProfiles (3000)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetProfiles {
      public:
        /** Optional element 'ns9:GetProfiles' of XSD type 'ns9:GetProfiles' */
        _ns9__GetProfiles *ns9__GetProfiles;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetProfiles */
        int soap_type() const { return SOAP_TYPE___ns9__GetProfiles; }
        /** Constructor with member initializations */
        __ns9__GetProfiles()
        {
          ns9__GetProfiles = (_ns9__GetProfiles *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetProfiles(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetProfiles * SOAP_FMAC2 soap_instantiate___ns9__GetProfiles(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:57494 */
#ifndef SOAP_TYPE___ns9__AddVideoEncoderConfiguration
#define SOAP_TYPE___ns9__AddVideoEncoderConfiguration (3004)
/* Wrapper: */
struct SOAP_CMAC __ns9__AddVideoEncoderConfiguration {
      public:
        /** Optional element 'ns9:AddVideoEncoderConfiguration' of XSD type 'ns9:AddVideoEncoderConfiguration' */
        _ns9__AddVideoEncoderConfiguration *ns9__AddVideoEncoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__AddVideoEncoderConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__AddVideoEncoderConfiguration; }
        /** Constructor with member initializations */
        __ns9__AddVideoEncoderConfiguration()
        {
          ns9__AddVideoEncoderConfiguration = (_ns9__AddVideoEncoderConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__AddVideoEncoderConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__AddVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___ns9__AddVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:57565 */
#ifndef SOAP_TYPE___ns9__AddVideoSourceConfiguration
#define SOAP_TYPE___ns9__AddVideoSourceConfiguration (3008)
/* Wrapper: */
struct SOAP_CMAC __ns9__AddVideoSourceConfiguration {
      public:
        /** Optional element 'ns9:AddVideoSourceConfiguration' of XSD type 'ns9:AddVideoSourceConfiguration' */
        _ns9__AddVideoSourceConfiguration *ns9__AddVideoSourceConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__AddVideoSourceConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__AddVideoSourceConfiguration; }
        /** Constructor with member initializations */
        __ns9__AddVideoSourceConfiguration()
        {
          ns9__AddVideoSourceConfiguration = (_ns9__AddVideoSourceConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__AddVideoSourceConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__AddVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___ns9__AddVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:57640 */
#ifndef SOAP_TYPE___ns9__AddAudioEncoderConfiguration
#define SOAP_TYPE___ns9__AddAudioEncoderConfiguration (3012)
/* Wrapper: */
struct SOAP_CMAC __ns9__AddAudioEncoderConfiguration {
      public:
        /** Optional element 'ns9:AddAudioEncoderConfiguration' of XSD type 'ns9:AddAudioEncoderConfiguration' */
        _ns9__AddAudioEncoderConfiguration *ns9__AddAudioEncoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__AddAudioEncoderConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__AddAudioEncoderConfiguration; }
        /** Constructor with member initializations */
        __ns9__AddAudioEncoderConfiguration()
        {
          ns9__AddAudioEncoderConfiguration = (_ns9__AddAudioEncoderConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__AddAudioEncoderConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__AddAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___ns9__AddAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:57711 */
#ifndef SOAP_TYPE___ns9__AddAudioSourceConfiguration
#define SOAP_TYPE___ns9__AddAudioSourceConfiguration (3016)
/* Wrapper: */
struct SOAP_CMAC __ns9__AddAudioSourceConfiguration {
      public:
        /** Optional element 'ns9:AddAudioSourceConfiguration' of XSD type 'ns9:AddAudioSourceConfiguration' */
        _ns9__AddAudioSourceConfiguration *ns9__AddAudioSourceConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__AddAudioSourceConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__AddAudioSourceConfiguration; }
        /** Constructor with member initializations */
        __ns9__AddAudioSourceConfiguration()
        {
          ns9__AddAudioSourceConfiguration = (_ns9__AddAudioSourceConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__AddAudioSourceConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__AddAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___ns9__AddAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:57786 */
#ifndef SOAP_TYPE___ns9__AddPTZConfiguration
#define SOAP_TYPE___ns9__AddPTZConfiguration (3020)
/* Wrapper: */
struct SOAP_CMAC __ns9__AddPTZConfiguration {
      public:
        /** Optional element 'ns9:AddPTZConfiguration' of XSD type 'ns9:AddPTZConfiguration' */
        _ns9__AddPTZConfiguration *ns9__AddPTZConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__AddPTZConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__AddPTZConfiguration; }
        /** Constructor with member initializations */
        __ns9__AddPTZConfiguration()
        {
          ns9__AddPTZConfiguration = (_ns9__AddPTZConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__AddPTZConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__AddPTZConfiguration * SOAP_FMAC2 soap_instantiate___ns9__AddPTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:57864 */
#ifndef SOAP_TYPE___ns9__AddVideoAnalyticsConfiguration
#define SOAP_TYPE___ns9__AddVideoAnalyticsConfiguration (3024)
/* Wrapper: */
struct SOAP_CMAC __ns9__AddVideoAnalyticsConfiguration {
      public:
        /** Optional element 'ns9:AddVideoAnalyticsConfiguration' of XSD type 'ns9:AddVideoAnalyticsConfiguration' */
        _ns9__AddVideoAnalyticsConfiguration *ns9__AddVideoAnalyticsConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__AddVideoAnalyticsConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__AddVideoAnalyticsConfiguration; }
        /** Constructor with member initializations */
        __ns9__AddVideoAnalyticsConfiguration()
        {
          ns9__AddVideoAnalyticsConfiguration = (_ns9__AddVideoAnalyticsConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__AddVideoAnalyticsConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__AddVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___ns9__AddVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:57936 */
#ifndef SOAP_TYPE___ns9__AddMetadataConfiguration
#define SOAP_TYPE___ns9__AddMetadataConfiguration (3028)
/* Wrapper: */
struct SOAP_CMAC __ns9__AddMetadataConfiguration {
      public:
        /** Optional element 'ns9:AddMetadataConfiguration' of XSD type 'ns9:AddMetadataConfiguration' */
        _ns9__AddMetadataConfiguration *ns9__AddMetadataConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__AddMetadataConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__AddMetadataConfiguration; }
        /** Constructor with member initializations */
        __ns9__AddMetadataConfiguration()
        {
          ns9__AddMetadataConfiguration = (_ns9__AddMetadataConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__AddMetadataConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__AddMetadataConfiguration * SOAP_FMAC2 soap_instantiate___ns9__AddMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:58006 */
#ifndef SOAP_TYPE___ns9__AddAudioOutputConfiguration
#define SOAP_TYPE___ns9__AddAudioOutputConfiguration (3032)
/* Wrapper: */
struct SOAP_CMAC __ns9__AddAudioOutputConfiguration {
      public:
        /** Optional element 'ns9:AddAudioOutputConfiguration' of XSD type 'ns9:AddAudioOutputConfiguration' */
        _ns9__AddAudioOutputConfiguration *ns9__AddAudioOutputConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__AddAudioOutputConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__AddAudioOutputConfiguration; }
        /** Constructor with member initializations */
        __ns9__AddAudioOutputConfiguration()
        {
          ns9__AddAudioOutputConfiguration = (_ns9__AddAudioOutputConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__AddAudioOutputConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__AddAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___ns9__AddAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:58076 */
#ifndef SOAP_TYPE___ns9__AddAudioDecoderConfiguration
#define SOAP_TYPE___ns9__AddAudioDecoderConfiguration (3036)
/* Wrapper: */
struct SOAP_CMAC __ns9__AddAudioDecoderConfiguration {
      public:
        /** Optional element 'ns9:AddAudioDecoderConfiguration' of XSD type 'ns9:AddAudioDecoderConfiguration' */
        _ns9__AddAudioDecoderConfiguration *ns9__AddAudioDecoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__AddAudioDecoderConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__AddAudioDecoderConfiguration; }
        /** Constructor with member initializations */
        __ns9__AddAudioDecoderConfiguration()
        {
          ns9__AddAudioDecoderConfiguration = (_ns9__AddAudioDecoderConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__AddAudioDecoderConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__AddAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___ns9__AddAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:58147 */
#ifndef SOAP_TYPE___ns9__RemoveVideoEncoderConfiguration
#define SOAP_TYPE___ns9__RemoveVideoEncoderConfiguration (3040)
/* Wrapper: */
struct SOAP_CMAC __ns9__RemoveVideoEncoderConfiguration {
      public:
        /** Optional element 'ns9:RemoveVideoEncoderConfiguration' of XSD type 'ns9:RemoveVideoEncoderConfiguration' */
        _ns9__RemoveVideoEncoderConfiguration *ns9__RemoveVideoEncoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__RemoveVideoEncoderConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__RemoveVideoEncoderConfiguration; }
        /** Constructor with member initializations */
        __ns9__RemoveVideoEncoderConfiguration()
        {
          ns9__RemoveVideoEncoderConfiguration = (_ns9__RemoveVideoEncoderConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__RemoveVideoEncoderConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__RemoveVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___ns9__RemoveVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:58220 */
#ifndef SOAP_TYPE___ns9__RemoveVideoSourceConfiguration
#define SOAP_TYPE___ns9__RemoveVideoSourceConfiguration (3044)
/* Wrapper: */
struct SOAP_CMAC __ns9__RemoveVideoSourceConfiguration {
      public:
        /** Optional element 'ns9:RemoveVideoSourceConfiguration' of XSD type 'ns9:RemoveVideoSourceConfiguration' */
        _ns9__RemoveVideoSourceConfiguration *ns9__RemoveVideoSourceConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__RemoveVideoSourceConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__RemoveVideoSourceConfiguration; }
        /** Constructor with member initializations */
        __ns9__RemoveVideoSourceConfiguration()
        {
          ns9__RemoveVideoSourceConfiguration = (_ns9__RemoveVideoSourceConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__RemoveVideoSourceConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__RemoveVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___ns9__RemoveVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:58292 */
#ifndef SOAP_TYPE___ns9__RemoveAudioEncoderConfiguration
#define SOAP_TYPE___ns9__RemoveAudioEncoderConfiguration (3048)
/* Wrapper: */
struct SOAP_CMAC __ns9__RemoveAudioEncoderConfiguration {
      public:
        /** Optional element 'ns9:RemoveAudioEncoderConfiguration' of XSD type 'ns9:RemoveAudioEncoderConfiguration' */
        _ns9__RemoveAudioEncoderConfiguration *ns9__RemoveAudioEncoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__RemoveAudioEncoderConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__RemoveAudioEncoderConfiguration; }
        /** Constructor with member initializations */
        __ns9__RemoveAudioEncoderConfiguration()
        {
          ns9__RemoveAudioEncoderConfiguration = (_ns9__RemoveAudioEncoderConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__RemoveAudioEncoderConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__RemoveAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___ns9__RemoveAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:58366 */
#ifndef SOAP_TYPE___ns9__RemoveAudioSourceConfiguration
#define SOAP_TYPE___ns9__RemoveAudioSourceConfiguration (3052)
/* Wrapper: */
struct SOAP_CMAC __ns9__RemoveAudioSourceConfiguration {
      public:
        /** Optional element 'ns9:RemoveAudioSourceConfiguration' of XSD type 'ns9:RemoveAudioSourceConfiguration' */
        _ns9__RemoveAudioSourceConfiguration *ns9__RemoveAudioSourceConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__RemoveAudioSourceConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__RemoveAudioSourceConfiguration; }
        /** Constructor with member initializations */
        __ns9__RemoveAudioSourceConfiguration()
        {
          ns9__RemoveAudioSourceConfiguration = (_ns9__RemoveAudioSourceConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__RemoveAudioSourceConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__RemoveAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___ns9__RemoveAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:58437 */
#ifndef SOAP_TYPE___ns9__RemovePTZConfiguration
#define SOAP_TYPE___ns9__RemovePTZConfiguration (3056)
/* Wrapper: */
struct SOAP_CMAC __ns9__RemovePTZConfiguration {
      public:
        /** Optional element 'ns9:RemovePTZConfiguration' of XSD type 'ns9:RemovePTZConfiguration' */
        _ns9__RemovePTZConfiguration *ns9__RemovePTZConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__RemovePTZConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__RemovePTZConfiguration; }
        /** Constructor with member initializations */
        __ns9__RemovePTZConfiguration()
        {
          ns9__RemovePTZConfiguration = (_ns9__RemovePTZConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__RemovePTZConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__RemovePTZConfiguration * SOAP_FMAC2 soap_instantiate___ns9__RemovePTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:58508 */
#ifndef SOAP_TYPE___ns9__RemoveVideoAnalyticsConfiguration
#define SOAP_TYPE___ns9__RemoveVideoAnalyticsConfiguration (3060)
/* Wrapper: */
struct SOAP_CMAC __ns9__RemoveVideoAnalyticsConfiguration {
      public:
        /** Optional element 'ns9:RemoveVideoAnalyticsConfiguration' of XSD type 'ns9:RemoveVideoAnalyticsConfiguration' */
        _ns9__RemoveVideoAnalyticsConfiguration *ns9__RemoveVideoAnalyticsConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__RemoveVideoAnalyticsConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__RemoveVideoAnalyticsConfiguration; }
        /** Constructor with member initializations */
        __ns9__RemoveVideoAnalyticsConfiguration()
        {
          ns9__RemoveVideoAnalyticsConfiguration = (_ns9__RemoveVideoAnalyticsConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__RemoveVideoAnalyticsConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__RemoveVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___ns9__RemoveVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:58578 */
#ifndef SOAP_TYPE___ns9__RemoveMetadataConfiguration
#define SOAP_TYPE___ns9__RemoveMetadataConfiguration (3064)
/* Wrapper: */
struct SOAP_CMAC __ns9__RemoveMetadataConfiguration {
      public:
        /** Optional element 'ns9:RemoveMetadataConfiguration' of XSD type 'ns9:RemoveMetadataConfiguration' */
        _ns9__RemoveMetadataConfiguration *ns9__RemoveMetadataConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__RemoveMetadataConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__RemoveMetadataConfiguration; }
        /** Constructor with member initializations */
        __ns9__RemoveMetadataConfiguration()
        {
          ns9__RemoveMetadataConfiguration = (_ns9__RemoveMetadataConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__RemoveMetadataConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__RemoveMetadataConfiguration * SOAP_FMAC2 soap_instantiate___ns9__RemoveMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:58648 */
#ifndef SOAP_TYPE___ns9__RemoveAudioOutputConfiguration
#define SOAP_TYPE___ns9__RemoveAudioOutputConfiguration (3068)
/* Wrapper: */
struct SOAP_CMAC __ns9__RemoveAudioOutputConfiguration {
      public:
        /** Optional element 'ns9:RemoveAudioOutputConfiguration' of XSD type 'ns9:RemoveAudioOutputConfiguration' */
        _ns9__RemoveAudioOutputConfiguration *ns9__RemoveAudioOutputConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__RemoveAudioOutputConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__RemoveAudioOutputConfiguration; }
        /** Constructor with member initializations */
        __ns9__RemoveAudioOutputConfiguration()
        {
          ns9__RemoveAudioOutputConfiguration = (_ns9__RemoveAudioOutputConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__RemoveAudioOutputConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__RemoveAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___ns9__RemoveAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:58718 */
#ifndef SOAP_TYPE___ns9__RemoveAudioDecoderConfiguration
#define SOAP_TYPE___ns9__RemoveAudioDecoderConfiguration (3072)
/* Wrapper: */
struct SOAP_CMAC __ns9__RemoveAudioDecoderConfiguration {
      public:
        /** Optional element 'ns9:RemoveAudioDecoderConfiguration' of XSD type 'ns9:RemoveAudioDecoderConfiguration' */
        _ns9__RemoveAudioDecoderConfiguration *ns9__RemoveAudioDecoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__RemoveAudioDecoderConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__RemoveAudioDecoderConfiguration; }
        /** Constructor with member initializations */
        __ns9__RemoveAudioDecoderConfiguration()
        {
          ns9__RemoveAudioDecoderConfiguration = (_ns9__RemoveAudioDecoderConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__RemoveAudioDecoderConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__RemoveAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___ns9__RemoveAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:58787 */
#ifndef SOAP_TYPE___ns9__DeleteProfile
#define SOAP_TYPE___ns9__DeleteProfile (3076)
/* Wrapper: */
struct SOAP_CMAC __ns9__DeleteProfile {
      public:
        /** Optional element 'ns9:DeleteProfile' of XSD type 'ns9:DeleteProfile' */
        _ns9__DeleteProfile *ns9__DeleteProfile;
      public:
        /** Return unique type id SOAP_TYPE___ns9__DeleteProfile */
        int soap_type() const { return SOAP_TYPE___ns9__DeleteProfile; }
        /** Constructor with member initializations */
        __ns9__DeleteProfile()
        {
          ns9__DeleteProfile = (_ns9__DeleteProfile *)0;
        }
        /** Friend allocator used by soap_new___ns9__DeleteProfile(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__DeleteProfile * SOAP_FMAC2 soap_instantiate___ns9__DeleteProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:58857 */
#ifndef SOAP_TYPE___ns9__GetVideoSourceConfigurations
#define SOAP_TYPE___ns9__GetVideoSourceConfigurations (3080)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetVideoSourceConfigurations {
      public:
        /** Optional element 'ns9:GetVideoSourceConfigurations' of XSD type 'ns9:GetVideoSourceConfigurations' */
        _ns9__GetVideoSourceConfigurations *ns9__GetVideoSourceConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetVideoSourceConfigurations */
        int soap_type() const { return SOAP_TYPE___ns9__GetVideoSourceConfigurations; }
        /** Constructor with member initializations */
        __ns9__GetVideoSourceConfigurations()
        {
          ns9__GetVideoSourceConfigurations = (_ns9__GetVideoSourceConfigurations *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetVideoSourceConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetVideoSourceConfigurations * SOAP_FMAC2 soap_instantiate___ns9__GetVideoSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:58928 */
#ifndef SOAP_TYPE___ns9__GetVideoEncoderConfigurations
#define SOAP_TYPE___ns9__GetVideoEncoderConfigurations (3084)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetVideoEncoderConfigurations {
      public:
        /** Optional element 'ns9:GetVideoEncoderConfigurations' of XSD type 'ns9:GetVideoEncoderConfigurations' */
        _ns9__GetVideoEncoderConfigurations *ns9__GetVideoEncoderConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetVideoEncoderConfigurations */
        int soap_type() const { return SOAP_TYPE___ns9__GetVideoEncoderConfigurations; }
        /** Constructor with member initializations */
        __ns9__GetVideoEncoderConfigurations()
        {
          ns9__GetVideoEncoderConfigurations = (_ns9__GetVideoEncoderConfigurations *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetVideoEncoderConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetVideoEncoderConfigurations * SOAP_FMAC2 soap_instantiate___ns9__GetVideoEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:58999 */
#ifndef SOAP_TYPE___ns9__GetAudioSourceConfigurations
#define SOAP_TYPE___ns9__GetAudioSourceConfigurations (3088)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetAudioSourceConfigurations {
      public:
        /** Optional element 'ns9:GetAudioSourceConfigurations' of XSD type 'ns9:GetAudioSourceConfigurations' */
        _ns9__GetAudioSourceConfigurations *ns9__GetAudioSourceConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetAudioSourceConfigurations */
        int soap_type() const { return SOAP_TYPE___ns9__GetAudioSourceConfigurations; }
        /** Constructor with member initializations */
        __ns9__GetAudioSourceConfigurations()
        {
          ns9__GetAudioSourceConfigurations = (_ns9__GetAudioSourceConfigurations *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetAudioSourceConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetAudioSourceConfigurations * SOAP_FMAC2 soap_instantiate___ns9__GetAudioSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:59069 */
#ifndef SOAP_TYPE___ns9__GetAudioEncoderConfigurations
#define SOAP_TYPE___ns9__GetAudioEncoderConfigurations (3092)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetAudioEncoderConfigurations {
      public:
        /** Optional element 'ns9:GetAudioEncoderConfigurations' of XSD type 'ns9:GetAudioEncoderConfigurations' */
        _ns9__GetAudioEncoderConfigurations *ns9__GetAudioEncoderConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetAudioEncoderConfigurations */
        int soap_type() const { return SOAP_TYPE___ns9__GetAudioEncoderConfigurations; }
        /** Constructor with member initializations */
        __ns9__GetAudioEncoderConfigurations()
        {
          ns9__GetAudioEncoderConfigurations = (_ns9__GetAudioEncoderConfigurations *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetAudioEncoderConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetAudioEncoderConfigurations * SOAP_FMAC2 soap_instantiate___ns9__GetAudioEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:59139 */
#ifndef SOAP_TYPE___ns9__GetVideoAnalyticsConfigurations
#define SOAP_TYPE___ns9__GetVideoAnalyticsConfigurations (3096)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetVideoAnalyticsConfigurations {
      public:
        /** Optional element 'ns9:GetVideoAnalyticsConfigurations' of XSD type 'ns9:GetVideoAnalyticsConfigurations' */
        _ns9__GetVideoAnalyticsConfigurations *ns9__GetVideoAnalyticsConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetVideoAnalyticsConfigurations */
        int soap_type() const { return SOAP_TYPE___ns9__GetVideoAnalyticsConfigurations; }
        /** Constructor with member initializations */
        __ns9__GetVideoAnalyticsConfigurations()
        {
          ns9__GetVideoAnalyticsConfigurations = (_ns9__GetVideoAnalyticsConfigurations *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetVideoAnalyticsConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetVideoAnalyticsConfigurations * SOAP_FMAC2 soap_instantiate___ns9__GetVideoAnalyticsConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:59208 */
#ifndef SOAP_TYPE___ns9__GetMetadataConfigurations
#define SOAP_TYPE___ns9__GetMetadataConfigurations (3100)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetMetadataConfigurations {
      public:
        /** Optional element 'ns9:GetMetadataConfigurations' of XSD type 'ns9:GetMetadataConfigurations' */
        _ns9__GetMetadataConfigurations *ns9__GetMetadataConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetMetadataConfigurations */
        int soap_type() const { return SOAP_TYPE___ns9__GetMetadataConfigurations; }
        /** Constructor with member initializations */
        __ns9__GetMetadataConfigurations()
        {
          ns9__GetMetadataConfigurations = (_ns9__GetMetadataConfigurations *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetMetadataConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetMetadataConfigurations * SOAP_FMAC2 soap_instantiate___ns9__GetMetadataConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:59277 */
#ifndef SOAP_TYPE___ns9__GetAudioOutputConfigurations
#define SOAP_TYPE___ns9__GetAudioOutputConfigurations (3104)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetAudioOutputConfigurations {
      public:
        /** Optional element 'ns9:GetAudioOutputConfigurations' of XSD type 'ns9:GetAudioOutputConfigurations' */
        _ns9__GetAudioOutputConfigurations *ns9__GetAudioOutputConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetAudioOutputConfigurations */
        int soap_type() const { return SOAP_TYPE___ns9__GetAudioOutputConfigurations; }
        /** Constructor with member initializations */
        __ns9__GetAudioOutputConfigurations()
        {
          ns9__GetAudioOutputConfigurations = (_ns9__GetAudioOutputConfigurations *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetAudioOutputConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetAudioOutputConfigurations * SOAP_FMAC2 soap_instantiate___ns9__GetAudioOutputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:59348 */
#ifndef SOAP_TYPE___ns9__GetAudioDecoderConfigurations
#define SOAP_TYPE___ns9__GetAudioDecoderConfigurations (3108)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetAudioDecoderConfigurations {
      public:
        /** Optional element 'ns9:GetAudioDecoderConfigurations' of XSD type 'ns9:GetAudioDecoderConfigurations' */
        _ns9__GetAudioDecoderConfigurations *ns9__GetAudioDecoderConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetAudioDecoderConfigurations */
        int soap_type() const { return SOAP_TYPE___ns9__GetAudioDecoderConfigurations; }
        /** Constructor with member initializations */
        __ns9__GetAudioDecoderConfigurations()
        {
          ns9__GetAudioDecoderConfigurations = (_ns9__GetAudioDecoderConfigurations *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetAudioDecoderConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetAudioDecoderConfigurations * SOAP_FMAC2 soap_instantiate___ns9__GetAudioDecoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:59417 */
#ifndef SOAP_TYPE___ns9__GetVideoSourceConfiguration
#define SOAP_TYPE___ns9__GetVideoSourceConfiguration (3112)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetVideoSourceConfiguration {
      public:
        /** Optional element 'ns9:GetVideoSourceConfiguration' of XSD type 'ns9:GetVideoSourceConfiguration' */
        _ns9__GetVideoSourceConfiguration *ns9__GetVideoSourceConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetVideoSourceConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__GetVideoSourceConfiguration; }
        /** Constructor with member initializations */
        __ns9__GetVideoSourceConfiguration()
        {
          ns9__GetVideoSourceConfiguration = (_ns9__GetVideoSourceConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetVideoSourceConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___ns9__GetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:59486 */
#ifndef SOAP_TYPE___ns9__GetVideoEncoderConfiguration
#define SOAP_TYPE___ns9__GetVideoEncoderConfiguration (3116)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetVideoEncoderConfiguration {
      public:
        /** Optional element 'ns9:GetVideoEncoderConfiguration' of XSD type 'ns9:GetVideoEncoderConfiguration' */
        _ns9__GetVideoEncoderConfiguration *ns9__GetVideoEncoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetVideoEncoderConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__GetVideoEncoderConfiguration; }
        /** Constructor with member initializations */
        __ns9__GetVideoEncoderConfiguration()
        {
          ns9__GetVideoEncoderConfiguration = (_ns9__GetVideoEncoderConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetVideoEncoderConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___ns9__GetVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:59555 */
#ifndef SOAP_TYPE___ns9__GetAudioSourceConfiguration
#define SOAP_TYPE___ns9__GetAudioSourceConfiguration (3120)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetAudioSourceConfiguration {
      public:
        /** Optional element 'ns9:GetAudioSourceConfiguration' of XSD type 'ns9:GetAudioSourceConfiguration' */
        _ns9__GetAudioSourceConfiguration *ns9__GetAudioSourceConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetAudioSourceConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__GetAudioSourceConfiguration; }
        /** Constructor with member initializations */
        __ns9__GetAudioSourceConfiguration()
        {
          ns9__GetAudioSourceConfiguration = (_ns9__GetAudioSourceConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetAudioSourceConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___ns9__GetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:59624 */
#ifndef SOAP_TYPE___ns9__GetAudioEncoderConfiguration
#define SOAP_TYPE___ns9__GetAudioEncoderConfiguration (3124)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetAudioEncoderConfiguration {
      public:
        /** Optional element 'ns9:GetAudioEncoderConfiguration' of XSD type 'ns9:GetAudioEncoderConfiguration' */
        _ns9__GetAudioEncoderConfiguration *ns9__GetAudioEncoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetAudioEncoderConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__GetAudioEncoderConfiguration; }
        /** Constructor with member initializations */
        __ns9__GetAudioEncoderConfiguration()
        {
          ns9__GetAudioEncoderConfiguration = (_ns9__GetAudioEncoderConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetAudioEncoderConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___ns9__GetAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:59693 */
#ifndef SOAP_TYPE___ns9__GetVideoAnalyticsConfiguration
#define SOAP_TYPE___ns9__GetVideoAnalyticsConfiguration (3128)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetVideoAnalyticsConfiguration {
      public:
        /** Optional element 'ns9:GetVideoAnalyticsConfiguration' of XSD type 'ns9:GetVideoAnalyticsConfiguration' */
        _ns9__GetVideoAnalyticsConfiguration *ns9__GetVideoAnalyticsConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetVideoAnalyticsConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__GetVideoAnalyticsConfiguration; }
        /** Constructor with member initializations */
        __ns9__GetVideoAnalyticsConfiguration()
        {
          ns9__GetVideoAnalyticsConfiguration = (_ns9__GetVideoAnalyticsConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetVideoAnalyticsConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___ns9__GetVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:59762 */
#ifndef SOAP_TYPE___ns9__GetMetadataConfiguration
#define SOAP_TYPE___ns9__GetMetadataConfiguration (3132)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetMetadataConfiguration {
      public:
        /** Optional element 'ns9:GetMetadataConfiguration' of XSD type 'ns9:GetMetadataConfiguration' */
        _ns9__GetMetadataConfiguration *ns9__GetMetadataConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetMetadataConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__GetMetadataConfiguration; }
        /** Constructor with member initializations */
        __ns9__GetMetadataConfiguration()
        {
          ns9__GetMetadataConfiguration = (_ns9__GetMetadataConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetMetadataConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetMetadataConfiguration * SOAP_FMAC2 soap_instantiate___ns9__GetMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:59831 */
#ifndef SOAP_TYPE___ns9__GetAudioOutputConfiguration
#define SOAP_TYPE___ns9__GetAudioOutputConfiguration (3136)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetAudioOutputConfiguration {
      public:
        /** Optional element 'ns9:GetAudioOutputConfiguration' of XSD type 'ns9:GetAudioOutputConfiguration' */
        _ns9__GetAudioOutputConfiguration *ns9__GetAudioOutputConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetAudioOutputConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__GetAudioOutputConfiguration; }
        /** Constructor with member initializations */
        __ns9__GetAudioOutputConfiguration()
        {
          ns9__GetAudioOutputConfiguration = (_ns9__GetAudioOutputConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetAudioOutputConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___ns9__GetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:59900 */
#ifndef SOAP_TYPE___ns9__GetAudioDecoderConfiguration
#define SOAP_TYPE___ns9__GetAudioDecoderConfiguration (3140)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetAudioDecoderConfiguration {
      public:
        /** Optional element 'ns9:GetAudioDecoderConfiguration' of XSD type 'ns9:GetAudioDecoderConfiguration' */
        _ns9__GetAudioDecoderConfiguration *ns9__GetAudioDecoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetAudioDecoderConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__GetAudioDecoderConfiguration; }
        /** Constructor with member initializations */
        __ns9__GetAudioDecoderConfiguration()
        {
          ns9__GetAudioDecoderConfiguration = (_ns9__GetAudioDecoderConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetAudioDecoderConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___ns9__GetAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:59972 */
#ifndef SOAP_TYPE___ns9__GetCompatibleVideoEncoderConfigurations
#define SOAP_TYPE___ns9__GetCompatibleVideoEncoderConfigurations (3144)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetCompatibleVideoEncoderConfigurations {
      public:
        /** Optional element 'ns9:GetCompatibleVideoEncoderConfigurations' of XSD type 'ns9:GetCompatibleVideoEncoderConfigurations' */
        _ns9__GetCompatibleVideoEncoderConfigurations *ns9__GetCompatibleVideoEncoderConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetCompatibleVideoEncoderConfigurations */
        int soap_type() const { return SOAP_TYPE___ns9__GetCompatibleVideoEncoderConfigurations; }
        /** Constructor with member initializations */
        __ns9__GetCompatibleVideoEncoderConfigurations()
        {
          ns9__GetCompatibleVideoEncoderConfigurations = (_ns9__GetCompatibleVideoEncoderConfigurations *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetCompatibleVideoEncoderConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetCompatibleVideoEncoderConfigurations * SOAP_FMAC2 soap_instantiate___ns9__GetCompatibleVideoEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:60046 */
#ifndef SOAP_TYPE___ns9__GetCompatibleVideoSourceConfigurations
#define SOAP_TYPE___ns9__GetCompatibleVideoSourceConfigurations (3148)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetCompatibleVideoSourceConfigurations {
      public:
        /** Optional element 'ns9:GetCompatibleVideoSourceConfigurations' of XSD type 'ns9:GetCompatibleVideoSourceConfigurations' */
        _ns9__GetCompatibleVideoSourceConfigurations *ns9__GetCompatibleVideoSourceConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetCompatibleVideoSourceConfigurations */
        int soap_type() const { return SOAP_TYPE___ns9__GetCompatibleVideoSourceConfigurations; }
        /** Constructor with member initializations */
        __ns9__GetCompatibleVideoSourceConfigurations()
        {
          ns9__GetCompatibleVideoSourceConfigurations = (_ns9__GetCompatibleVideoSourceConfigurations *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetCompatibleVideoSourceConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetCompatibleVideoSourceConfigurations * SOAP_FMAC2 soap_instantiate___ns9__GetCompatibleVideoSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:60118 */
#ifndef SOAP_TYPE___ns9__GetCompatibleAudioEncoderConfigurations
#define SOAP_TYPE___ns9__GetCompatibleAudioEncoderConfigurations (3152)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetCompatibleAudioEncoderConfigurations {
      public:
        /** Optional element 'ns9:GetCompatibleAudioEncoderConfigurations' of XSD type 'ns9:GetCompatibleAudioEncoderConfigurations' */
        _ns9__GetCompatibleAudioEncoderConfigurations *ns9__GetCompatibleAudioEncoderConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetCompatibleAudioEncoderConfigurations */
        int soap_type() const { return SOAP_TYPE___ns9__GetCompatibleAudioEncoderConfigurations; }
        /** Constructor with member initializations */
        __ns9__GetCompatibleAudioEncoderConfigurations()
        {
          ns9__GetCompatibleAudioEncoderConfigurations = (_ns9__GetCompatibleAudioEncoderConfigurations *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetCompatibleAudioEncoderConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetCompatibleAudioEncoderConfigurations * SOAP_FMAC2 soap_instantiate___ns9__GetCompatibleAudioEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:60190 */
#ifndef SOAP_TYPE___ns9__GetCompatibleAudioSourceConfigurations
#define SOAP_TYPE___ns9__GetCompatibleAudioSourceConfigurations (3156)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetCompatibleAudioSourceConfigurations {
      public:
        /** Optional element 'ns9:GetCompatibleAudioSourceConfigurations' of XSD type 'ns9:GetCompatibleAudioSourceConfigurations' */
        _ns9__GetCompatibleAudioSourceConfigurations *ns9__GetCompatibleAudioSourceConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetCompatibleAudioSourceConfigurations */
        int soap_type() const { return SOAP_TYPE___ns9__GetCompatibleAudioSourceConfigurations; }
        /** Constructor with member initializations */
        __ns9__GetCompatibleAudioSourceConfigurations()
        {
          ns9__GetCompatibleAudioSourceConfigurations = (_ns9__GetCompatibleAudioSourceConfigurations *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetCompatibleAudioSourceConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetCompatibleAudioSourceConfigurations * SOAP_FMAC2 soap_instantiate___ns9__GetCompatibleAudioSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:60262 */
#ifndef SOAP_TYPE___ns9__GetCompatibleVideoAnalyticsConfigurations
#define SOAP_TYPE___ns9__GetCompatibleVideoAnalyticsConfigurations (3160)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetCompatibleVideoAnalyticsConfigurations {
      public:
        /** Optional element 'ns9:GetCompatibleVideoAnalyticsConfigurations' of XSD type 'ns9:GetCompatibleVideoAnalyticsConfigurations' */
        _ns9__GetCompatibleVideoAnalyticsConfigurations *ns9__GetCompatibleVideoAnalyticsConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetCompatibleVideoAnalyticsConfigurations */
        int soap_type() const { return SOAP_TYPE___ns9__GetCompatibleVideoAnalyticsConfigurations; }
        /** Constructor with member initializations */
        __ns9__GetCompatibleVideoAnalyticsConfigurations()
        {
          ns9__GetCompatibleVideoAnalyticsConfigurations = (_ns9__GetCompatibleVideoAnalyticsConfigurations *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetCompatibleVideoAnalyticsConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetCompatibleVideoAnalyticsConfigurations * SOAP_FMAC2 soap_instantiate___ns9__GetCompatibleVideoAnalyticsConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:60334 */
#ifndef SOAP_TYPE___ns9__GetCompatibleMetadataConfigurations
#define SOAP_TYPE___ns9__GetCompatibleMetadataConfigurations (3164)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetCompatibleMetadataConfigurations {
      public:
        /** Optional element 'ns9:GetCompatibleMetadataConfigurations' of XSD type 'ns9:GetCompatibleMetadataConfigurations' */
        _ns9__GetCompatibleMetadataConfigurations *ns9__GetCompatibleMetadataConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetCompatibleMetadataConfigurations */
        int soap_type() const { return SOAP_TYPE___ns9__GetCompatibleMetadataConfigurations; }
        /** Constructor with member initializations */
        __ns9__GetCompatibleMetadataConfigurations()
        {
          ns9__GetCompatibleMetadataConfigurations = (_ns9__GetCompatibleMetadataConfigurations *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetCompatibleMetadataConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetCompatibleMetadataConfigurations * SOAP_FMAC2 soap_instantiate___ns9__GetCompatibleMetadataConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:60405 */
#ifndef SOAP_TYPE___ns9__GetCompatibleAudioOutputConfigurations
#define SOAP_TYPE___ns9__GetCompatibleAudioOutputConfigurations (3168)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetCompatibleAudioOutputConfigurations {
      public:
        /** Optional element 'ns9:GetCompatibleAudioOutputConfigurations' of XSD type 'ns9:GetCompatibleAudioOutputConfigurations' */
        _ns9__GetCompatibleAudioOutputConfigurations *ns9__GetCompatibleAudioOutputConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetCompatibleAudioOutputConfigurations */
        int soap_type() const { return SOAP_TYPE___ns9__GetCompatibleAudioOutputConfigurations; }
        /** Constructor with member initializations */
        __ns9__GetCompatibleAudioOutputConfigurations()
        {
          ns9__GetCompatibleAudioOutputConfigurations = (_ns9__GetCompatibleAudioOutputConfigurations *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetCompatibleAudioOutputConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetCompatibleAudioOutputConfigurations * SOAP_FMAC2 soap_instantiate___ns9__GetCompatibleAudioOutputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:60476 */
#ifndef SOAP_TYPE___ns9__GetCompatibleAudioDecoderConfigurations
#define SOAP_TYPE___ns9__GetCompatibleAudioDecoderConfigurations (3172)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetCompatibleAudioDecoderConfigurations {
      public:
        /** Optional element 'ns9:GetCompatibleAudioDecoderConfigurations' of XSD type 'ns9:GetCompatibleAudioDecoderConfigurations' */
        _ns9__GetCompatibleAudioDecoderConfigurations *ns9__GetCompatibleAudioDecoderConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetCompatibleAudioDecoderConfigurations */
        int soap_type() const { return SOAP_TYPE___ns9__GetCompatibleAudioDecoderConfigurations; }
        /** Constructor with member initializations */
        __ns9__GetCompatibleAudioDecoderConfigurations()
        {
          ns9__GetCompatibleAudioDecoderConfigurations = (_ns9__GetCompatibleAudioDecoderConfigurations *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetCompatibleAudioDecoderConfigurations(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetCompatibleAudioDecoderConfigurations * SOAP_FMAC2 soap_instantiate___ns9__GetCompatibleAudioDecoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:60549 */
#ifndef SOAP_TYPE___ns9__SetVideoSourceConfiguration
#define SOAP_TYPE___ns9__SetVideoSourceConfiguration (3176)
/* Wrapper: */
struct SOAP_CMAC __ns9__SetVideoSourceConfiguration {
      public:
        /** Optional element 'ns9:SetVideoSourceConfiguration' of XSD type 'ns9:SetVideoSourceConfiguration' */
        _ns9__SetVideoSourceConfiguration *ns9__SetVideoSourceConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__SetVideoSourceConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__SetVideoSourceConfiguration; }
        /** Constructor with member initializations */
        __ns9__SetVideoSourceConfiguration()
        {
          ns9__SetVideoSourceConfiguration = (_ns9__SetVideoSourceConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__SetVideoSourceConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__SetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___ns9__SetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:60626 */
#ifndef SOAP_TYPE___ns9__SetVideoEncoderConfiguration
#define SOAP_TYPE___ns9__SetVideoEncoderConfiguration (3180)
/* Wrapper: */
struct SOAP_CMAC __ns9__SetVideoEncoderConfiguration {
      public:
        /** Optional element 'ns9:SetVideoEncoderConfiguration' of XSD type 'ns9:SetVideoEncoderConfiguration' */
        _ns9__SetVideoEncoderConfiguration *ns9__SetVideoEncoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__SetVideoEncoderConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__SetVideoEncoderConfiguration; }
        /** Constructor with member initializations */
        __ns9__SetVideoEncoderConfiguration()
        {
          ns9__SetVideoEncoderConfiguration = (_ns9__SetVideoEncoderConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__SetVideoEncoderConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__SetVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___ns9__SetVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:60701 */
#ifndef SOAP_TYPE___ns9__SetAudioSourceConfiguration
#define SOAP_TYPE___ns9__SetAudioSourceConfiguration (3184)
/* Wrapper: */
struct SOAP_CMAC __ns9__SetAudioSourceConfiguration {
      public:
        /** Optional element 'ns9:SetAudioSourceConfiguration' of XSD type 'ns9:SetAudioSourceConfiguration' */
        _ns9__SetAudioSourceConfiguration *ns9__SetAudioSourceConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__SetAudioSourceConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__SetAudioSourceConfiguration; }
        /** Constructor with member initializations */
        __ns9__SetAudioSourceConfiguration()
        {
          ns9__SetAudioSourceConfiguration = (_ns9__SetAudioSourceConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__SetAudioSourceConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__SetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___ns9__SetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:60777 */
#ifndef SOAP_TYPE___ns9__SetAudioEncoderConfiguration
#define SOAP_TYPE___ns9__SetAudioEncoderConfiguration (3188)
/* Wrapper: */
struct SOAP_CMAC __ns9__SetAudioEncoderConfiguration {
      public:
        /** Optional element 'ns9:SetAudioEncoderConfiguration' of XSD type 'ns9:SetAudioEncoderConfiguration' */
        _ns9__SetAudioEncoderConfiguration *ns9__SetAudioEncoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__SetAudioEncoderConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__SetAudioEncoderConfiguration; }
        /** Constructor with member initializations */
        __ns9__SetAudioEncoderConfiguration()
        {
          ns9__SetAudioEncoderConfiguration = (_ns9__SetAudioEncoderConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__SetAudioEncoderConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__SetAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___ns9__SetAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:60855 */
#ifndef SOAP_TYPE___ns9__SetVideoAnalyticsConfiguration
#define SOAP_TYPE___ns9__SetVideoAnalyticsConfiguration (3192)
/* Wrapper: */
struct SOAP_CMAC __ns9__SetVideoAnalyticsConfiguration {
      public:
        /** Optional element 'ns9:SetVideoAnalyticsConfiguration' of XSD type 'ns9:SetVideoAnalyticsConfiguration' */
        _ns9__SetVideoAnalyticsConfiguration *ns9__SetVideoAnalyticsConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__SetVideoAnalyticsConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__SetVideoAnalyticsConfiguration; }
        /** Constructor with member initializations */
        __ns9__SetVideoAnalyticsConfiguration()
        {
          ns9__SetVideoAnalyticsConfiguration = (_ns9__SetVideoAnalyticsConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__SetVideoAnalyticsConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__SetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___ns9__SetVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:60932 */
#ifndef SOAP_TYPE___ns9__SetMetadataConfiguration
#define SOAP_TYPE___ns9__SetMetadataConfiguration (3196)
/* Wrapper: */
struct SOAP_CMAC __ns9__SetMetadataConfiguration {
      public:
        /** Optional element 'ns9:SetMetadataConfiguration' of XSD type 'ns9:SetMetadataConfiguration' */
        _ns9__SetMetadataConfiguration *ns9__SetMetadataConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__SetMetadataConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__SetMetadataConfiguration; }
        /** Constructor with member initializations */
        __ns9__SetMetadataConfiguration()
        {
          ns9__SetMetadataConfiguration = (_ns9__SetMetadataConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__SetMetadataConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__SetMetadataConfiguration * SOAP_FMAC2 soap_instantiate___ns9__SetMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:61002 */
#ifndef SOAP_TYPE___ns9__SetAudioOutputConfiguration
#define SOAP_TYPE___ns9__SetAudioOutputConfiguration (3200)
/* Wrapper: */
struct SOAP_CMAC __ns9__SetAudioOutputConfiguration {
      public:
        /** Optional element 'ns9:SetAudioOutputConfiguration' of XSD type 'ns9:SetAudioOutputConfiguration' */
        _ns9__SetAudioOutputConfiguration *ns9__SetAudioOutputConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__SetAudioOutputConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__SetAudioOutputConfiguration; }
        /** Constructor with member initializations */
        __ns9__SetAudioOutputConfiguration()
        {
          ns9__SetAudioOutputConfiguration = (_ns9__SetAudioOutputConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__SetAudioOutputConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__SetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___ns9__SetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:61072 */
#ifndef SOAP_TYPE___ns9__SetAudioDecoderConfiguration
#define SOAP_TYPE___ns9__SetAudioDecoderConfiguration (3204)
/* Wrapper: */
struct SOAP_CMAC __ns9__SetAudioDecoderConfiguration {
      public:
        /** Optional element 'ns9:SetAudioDecoderConfiguration' of XSD type 'ns9:SetAudioDecoderConfiguration' */
        _ns9__SetAudioDecoderConfiguration *ns9__SetAudioDecoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns9__SetAudioDecoderConfiguration */
        int soap_type() const { return SOAP_TYPE___ns9__SetAudioDecoderConfiguration; }
        /** Constructor with member initializations */
        __ns9__SetAudioDecoderConfiguration()
        {
          ns9__SetAudioDecoderConfiguration = (_ns9__SetAudioDecoderConfiguration *)0;
        }
        /** Friend allocator used by soap_new___ns9__SetAudioDecoderConfiguration(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__SetAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___ns9__SetAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:61146 */
#ifndef SOAP_TYPE___ns9__GetVideoSourceConfigurationOptions
#define SOAP_TYPE___ns9__GetVideoSourceConfigurationOptions (3208)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetVideoSourceConfigurationOptions {
      public:
        /** Optional element 'ns9:GetVideoSourceConfigurationOptions' of XSD type 'ns9:GetVideoSourceConfigurationOptions' */
        _ns9__GetVideoSourceConfigurationOptions *ns9__GetVideoSourceConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetVideoSourceConfigurationOptions */
        int soap_type() const { return SOAP_TYPE___ns9__GetVideoSourceConfigurationOptions; }
        /** Constructor with member initializations */
        __ns9__GetVideoSourceConfigurationOptions()
        {
          ns9__GetVideoSourceConfigurationOptions = (_ns9__GetVideoSourceConfigurationOptions *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetVideoSourceConfigurationOptions(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetVideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate___ns9__GetVideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:61228 */
#ifndef SOAP_TYPE___ns9__GetVideoEncoderConfigurationOptions
#define SOAP_TYPE___ns9__GetVideoEncoderConfigurationOptions (3212)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetVideoEncoderConfigurationOptions {
      public:
        /** Optional element 'ns9:GetVideoEncoderConfigurationOptions' of XSD type 'ns9:GetVideoEncoderConfigurationOptions' */
        _ns9__GetVideoEncoderConfigurationOptions *ns9__GetVideoEncoderConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetVideoEncoderConfigurationOptions */
        int soap_type() const { return SOAP_TYPE___ns9__GetVideoEncoderConfigurationOptions; }
        /** Constructor with member initializations */
        __ns9__GetVideoEncoderConfigurationOptions()
        {
          ns9__GetVideoEncoderConfigurationOptions = (_ns9__GetVideoEncoderConfigurationOptions *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetVideoEncoderConfigurationOptions(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetVideoEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate___ns9__GetVideoEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:61302 */
#ifndef SOAP_TYPE___ns9__GetAudioSourceConfigurationOptions
#define SOAP_TYPE___ns9__GetAudioSourceConfigurationOptions (3216)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetAudioSourceConfigurationOptions {
      public:
        /** Optional element 'ns9:GetAudioSourceConfigurationOptions' of XSD type 'ns9:GetAudioSourceConfigurationOptions' */
        _ns9__GetAudioSourceConfigurationOptions *ns9__GetAudioSourceConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetAudioSourceConfigurationOptions */
        int soap_type() const { return SOAP_TYPE___ns9__GetAudioSourceConfigurationOptions; }
        /** Constructor with member initializations */
        __ns9__GetAudioSourceConfigurationOptions()
        {
          ns9__GetAudioSourceConfigurationOptions = (_ns9__GetAudioSourceConfigurationOptions *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetAudioSourceConfigurationOptions(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetAudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate___ns9__GetAudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:61372 */
#ifndef SOAP_TYPE___ns9__GetAudioEncoderConfigurationOptions
#define SOAP_TYPE___ns9__GetAudioEncoderConfigurationOptions (3220)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetAudioEncoderConfigurationOptions {
      public:
        /** Optional element 'ns9:GetAudioEncoderConfigurationOptions' of XSD type 'ns9:GetAudioEncoderConfigurationOptions' */
        _ns9__GetAudioEncoderConfigurationOptions *ns9__GetAudioEncoderConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetAudioEncoderConfigurationOptions */
        int soap_type() const { return SOAP_TYPE___ns9__GetAudioEncoderConfigurationOptions; }
        /** Constructor with member initializations */
        __ns9__GetAudioEncoderConfigurationOptions()
        {
          ns9__GetAudioEncoderConfigurationOptions = (_ns9__GetAudioEncoderConfigurationOptions *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetAudioEncoderConfigurationOptions(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetAudioEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate___ns9__GetAudioEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:61441 */
#ifndef SOAP_TYPE___ns9__GetMetadataConfigurationOptions
#define SOAP_TYPE___ns9__GetMetadataConfigurationOptions (3224)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetMetadataConfigurationOptions {
      public:
        /** Optional element 'ns9:GetMetadataConfigurationOptions' of XSD type 'ns9:GetMetadataConfigurationOptions' */
        _ns9__GetMetadataConfigurationOptions *ns9__GetMetadataConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetMetadataConfigurationOptions */
        int soap_type() const { return SOAP_TYPE___ns9__GetMetadataConfigurationOptions; }
        /** Constructor with member initializations */
        __ns9__GetMetadataConfigurationOptions()
        {
          ns9__GetMetadataConfigurationOptions = (_ns9__GetMetadataConfigurationOptions *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetMetadataConfigurationOptions(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetMetadataConfigurationOptions * SOAP_FMAC2 soap_instantiate___ns9__GetMetadataConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:61510 */
#ifndef SOAP_TYPE___ns9__GetAudioOutputConfigurationOptions
#define SOAP_TYPE___ns9__GetAudioOutputConfigurationOptions (3228)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetAudioOutputConfigurationOptions {
      public:
        /** Optional element 'ns9:GetAudioOutputConfigurationOptions' of XSD type 'ns9:GetAudioOutputConfigurationOptions' */
        _ns9__GetAudioOutputConfigurationOptions *ns9__GetAudioOutputConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetAudioOutputConfigurationOptions */
        int soap_type() const { return SOAP_TYPE___ns9__GetAudioOutputConfigurationOptions; }
        /** Constructor with member initializations */
        __ns9__GetAudioOutputConfigurationOptions()
        {
          ns9__GetAudioOutputConfigurationOptions = (_ns9__GetAudioOutputConfigurationOptions *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetAudioOutputConfigurationOptions(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetAudioOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate___ns9__GetAudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:61580 */
#ifndef SOAP_TYPE___ns9__GetAudioDecoderConfigurationOptions
#define SOAP_TYPE___ns9__GetAudioDecoderConfigurationOptions (3232)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetAudioDecoderConfigurationOptions {
      public:
        /** Optional element 'ns9:GetAudioDecoderConfigurationOptions' of XSD type 'ns9:GetAudioDecoderConfigurationOptions' */
        _ns9__GetAudioDecoderConfigurationOptions *ns9__GetAudioDecoderConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetAudioDecoderConfigurationOptions */
        int soap_type() const { return SOAP_TYPE___ns9__GetAudioDecoderConfigurationOptions; }
        /** Constructor with member initializations */
        __ns9__GetAudioDecoderConfigurationOptions()
        {
          ns9__GetAudioDecoderConfigurationOptions = (_ns9__GetAudioDecoderConfigurationOptions *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetAudioDecoderConfigurationOptions(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetAudioDecoderConfigurationOptions * SOAP_FMAC2 soap_instantiate___ns9__GetAudioDecoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:61650 */
#ifndef SOAP_TYPE___ns9__GetGuaranteedNumberOfVideoEncoderInstances
#define SOAP_TYPE___ns9__GetGuaranteedNumberOfVideoEncoderInstances (3236)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetGuaranteedNumberOfVideoEncoderInstances {
      public:
        /** Optional element 'ns9:GetGuaranteedNumberOfVideoEncoderInstances' of XSD type 'ns9:GetGuaranteedNumberOfVideoEncoderInstances' */
        _ns9__GetGuaranteedNumberOfVideoEncoderInstances *ns9__GetGuaranteedNumberOfVideoEncoderInstances;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetGuaranteedNumberOfVideoEncoderInstances */
        int soap_type() const { return SOAP_TYPE___ns9__GetGuaranteedNumberOfVideoEncoderInstances; }
        /** Constructor with member initializations */
        __ns9__GetGuaranteedNumberOfVideoEncoderInstances()
        {
          ns9__GetGuaranteedNumberOfVideoEncoderInstances = (_ns9__GetGuaranteedNumberOfVideoEncoderInstances *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetGuaranteedNumberOfVideoEncoderInstances(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetGuaranteedNumberOfVideoEncoderInstances * SOAP_FMAC2 soap_instantiate___ns9__GetGuaranteedNumberOfVideoEncoderInstances(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:61742 */
#ifndef SOAP_TYPE___ns9__GetStreamUri
#define SOAP_TYPE___ns9__GetStreamUri (3240)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetStreamUri {
      public:
        /** Optional element 'ns9:GetStreamUri' of XSD type 'ns9:GetStreamUri' */
        _ns9__GetStreamUri *ns9__GetStreamUri;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetStreamUri */
        int soap_type() const { return SOAP_TYPE___ns9__GetStreamUri; }
        /** Constructor with member initializations */
        __ns9__GetStreamUri()
        {
          ns9__GetStreamUri = (_ns9__GetStreamUri *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetStreamUri(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetStreamUri * SOAP_FMAC2 soap_instantiate___ns9__GetStreamUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:61817 */
#ifndef SOAP_TYPE___ns9__StartMulticastStreaming
#define SOAP_TYPE___ns9__StartMulticastStreaming (3244)
/* Wrapper: */
struct SOAP_CMAC __ns9__StartMulticastStreaming {
      public:
        /** Optional element 'ns9:StartMulticastStreaming' of XSD type 'ns9:StartMulticastStreaming' */
        _ns9__StartMulticastStreaming *ns9__StartMulticastStreaming;
      public:
        /** Return unique type id SOAP_TYPE___ns9__StartMulticastStreaming */
        int soap_type() const { return SOAP_TYPE___ns9__StartMulticastStreaming; }
        /** Constructor with member initializations */
        __ns9__StartMulticastStreaming()
        {
          ns9__StartMulticastStreaming = (_ns9__StartMulticastStreaming *)0;
        }
        /** Friend allocator used by soap_new___ns9__StartMulticastStreaming(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__StartMulticastStreaming * SOAP_FMAC2 soap_instantiate___ns9__StartMulticastStreaming(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:61885 */
#ifndef SOAP_TYPE___ns9__StopMulticastStreaming
#define SOAP_TYPE___ns9__StopMulticastStreaming (3248)
/* Wrapper: */
struct SOAP_CMAC __ns9__StopMulticastStreaming {
      public:
        /** Optional element 'ns9:StopMulticastStreaming' of XSD type 'ns9:StopMulticastStreaming' */
        _ns9__StopMulticastStreaming *ns9__StopMulticastStreaming;
      public:
        /** Return unique type id SOAP_TYPE___ns9__StopMulticastStreaming */
        int soap_type() const { return SOAP_TYPE___ns9__StopMulticastStreaming; }
        /** Constructor with member initializations */
        __ns9__StopMulticastStreaming()
        {
          ns9__StopMulticastStreaming = (_ns9__StopMulticastStreaming *)0;
        }
        /** Friend allocator used by soap_new___ns9__StopMulticastStreaming(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__StopMulticastStreaming * SOAP_FMAC2 soap_instantiate___ns9__StopMulticastStreaming(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:61970 */
#ifndef SOAP_TYPE___ns9__SetSynchronizationPoint
#define SOAP_TYPE___ns9__SetSynchronizationPoint (3252)
/* Wrapper: */
struct SOAP_CMAC __ns9__SetSynchronizationPoint {
      public:
        /** Optional element 'ns9:SetSynchronizationPoint' of XSD type 'ns9:SetSynchronizationPoint' */
        _ns9__SetSynchronizationPoint *ns9__SetSynchronizationPoint;
      public:
        /** Return unique type id SOAP_TYPE___ns9__SetSynchronizationPoint */
        int soap_type() const { return SOAP_TYPE___ns9__SetSynchronizationPoint; }
        /** Constructor with member initializations */
        __ns9__SetSynchronizationPoint()
        {
          ns9__SetSynchronizationPoint = (_ns9__SetSynchronizationPoint *)0;
        }
        /** Friend allocator used by soap_new___ns9__SetSynchronizationPoint(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__SetSynchronizationPoint * SOAP_FMAC2 soap_instantiate___ns9__SetSynchronizationPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:62048 */
#ifndef SOAP_TYPE___ns9__GetSnapshotUri
#define SOAP_TYPE___ns9__GetSnapshotUri (3256)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetSnapshotUri {
      public:
        /** Optional element 'ns9:GetSnapshotUri' of XSD type 'ns9:GetSnapshotUri' */
        _ns9__GetSnapshotUri *ns9__GetSnapshotUri;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetSnapshotUri */
        int soap_type() const { return SOAP_TYPE___ns9__GetSnapshotUri; }
        /** Constructor with member initializations */
        __ns9__GetSnapshotUri()
        {
          ns9__GetSnapshotUri = (_ns9__GetSnapshotUri *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetSnapshotUri(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetSnapshotUri * SOAP_FMAC2 soap_instantiate___ns9__GetSnapshotUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:62118 */
#ifndef SOAP_TYPE___ns9__GetVideoSourceModes
#define SOAP_TYPE___ns9__GetVideoSourceModes (3260)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetVideoSourceModes {
      public:
        /** Optional element 'ns9:GetVideoSourceModes' of XSD type 'ns9:GetVideoSourceModes' */
        _ns9__GetVideoSourceModes *ns9__GetVideoSourceModes;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetVideoSourceModes */
        int soap_type() const { return SOAP_TYPE___ns9__GetVideoSourceModes; }
        /** Constructor with member initializations */
        __ns9__GetVideoSourceModes()
        {
          ns9__GetVideoSourceModes = (_ns9__GetVideoSourceModes *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetVideoSourceModes(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetVideoSourceModes * SOAP_FMAC2 soap_instantiate___ns9__GetVideoSourceModes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:62189 */
#ifndef SOAP_TYPE___ns9__SetVideoSourceMode
#define SOAP_TYPE___ns9__SetVideoSourceMode (3264)
/* Wrapper: */
struct SOAP_CMAC __ns9__SetVideoSourceMode {
      public:
        /** Optional element 'ns9:SetVideoSourceMode' of XSD type 'ns9:SetVideoSourceMode' */
        _ns9__SetVideoSourceMode *ns9__SetVideoSourceMode;
      public:
        /** Return unique type id SOAP_TYPE___ns9__SetVideoSourceMode */
        int soap_type() const { return SOAP_TYPE___ns9__SetVideoSourceMode; }
        /** Constructor with member initializations */
        __ns9__SetVideoSourceMode()
        {
          ns9__SetVideoSourceMode = (_ns9__SetVideoSourceMode *)0;
        }
        /** Friend allocator used by soap_new___ns9__SetVideoSourceMode(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__SetVideoSourceMode * SOAP_FMAC2 soap_instantiate___ns9__SetVideoSourceMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:62257 */
#ifndef SOAP_TYPE___ns9__GetOSDs
#define SOAP_TYPE___ns9__GetOSDs (3268)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetOSDs {
      public:
        /** Optional element 'ns9:GetOSDs' of XSD type 'ns9:GetOSDs' */
        _ns9__GetOSDs *ns9__GetOSDs;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetOSDs */
        int soap_type() const { return SOAP_TYPE___ns9__GetOSDs; }
        /** Constructor with member initializations */
        __ns9__GetOSDs()
        {
          ns9__GetOSDs = (_ns9__GetOSDs *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetOSDs(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetOSDs * SOAP_FMAC2 soap_instantiate___ns9__GetOSDs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:62325 */
#ifndef SOAP_TYPE___ns9__GetOSD
#define SOAP_TYPE___ns9__GetOSD (3272)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetOSD {
      public:
        /** Optional element 'ns9:GetOSD' of XSD type 'ns9:GetOSD' */
        _ns9__GetOSD *ns9__GetOSD;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetOSD */
        int soap_type() const { return SOAP_TYPE___ns9__GetOSD; }
        /** Constructor with member initializations */
        __ns9__GetOSD()
        {
          ns9__GetOSD = (_ns9__GetOSD *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetOSD(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetOSD * SOAP_FMAC2 soap_instantiate___ns9__GetOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:62393 */
#ifndef SOAP_TYPE___ns9__GetOSDOptions
#define SOAP_TYPE___ns9__GetOSDOptions (3276)
/* Wrapper: */
struct SOAP_CMAC __ns9__GetOSDOptions {
      public:
        /** Optional element 'ns9:GetOSDOptions' of XSD type 'ns9:GetOSDOptions' */
        _ns9__GetOSDOptions *ns9__GetOSDOptions;
      public:
        /** Return unique type id SOAP_TYPE___ns9__GetOSDOptions */
        int soap_type() const { return SOAP_TYPE___ns9__GetOSDOptions; }
        /** Constructor with member initializations */
        __ns9__GetOSDOptions()
        {
          ns9__GetOSDOptions = (_ns9__GetOSDOptions *)0;
        }
        /** Friend allocator used by soap_new___ns9__GetOSDOptions(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__GetOSDOptions * SOAP_FMAC2 soap_instantiate___ns9__GetOSDOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:62461 */
#ifndef SOAP_TYPE___ns9__SetOSD
#define SOAP_TYPE___ns9__SetOSD (3280)
/* Wrapper: */
struct SOAP_CMAC __ns9__SetOSD {
      public:
        /** Optional element 'ns9:SetOSD' of XSD type 'ns9:SetOSD' */
        _ns9__SetOSD *ns9__SetOSD;
      public:
        /** Return unique type id SOAP_TYPE___ns9__SetOSD */
        int soap_type() const { return SOAP_TYPE___ns9__SetOSD; }
        /** Constructor with member initializations */
        __ns9__SetOSD()
        {
          ns9__SetOSD = (_ns9__SetOSD *)0;
        }
        /** Friend allocator used by soap_new___ns9__SetOSD(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__SetOSD * SOAP_FMAC2 soap_instantiate___ns9__SetOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:62529 */
#ifndef SOAP_TYPE___ns9__CreateOSD
#define SOAP_TYPE___ns9__CreateOSD (3284)
/* Wrapper: */
struct SOAP_CMAC __ns9__CreateOSD {
      public:
        /** Optional element 'ns9:CreateOSD' of XSD type 'ns9:CreateOSD' */
        _ns9__CreateOSD *ns9__CreateOSD;
      public:
        /** Return unique type id SOAP_TYPE___ns9__CreateOSD */
        int soap_type() const { return SOAP_TYPE___ns9__CreateOSD; }
        /** Constructor with member initializations */
        __ns9__CreateOSD()
        {
          ns9__CreateOSD = (_ns9__CreateOSD *)0;
        }
        /** Friend allocator used by soap_new___ns9__CreateOSD(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__CreateOSD * SOAP_FMAC2 soap_instantiate___ns9__CreateOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:62597 */
#ifndef SOAP_TYPE___ns9__DeleteOSD
#define SOAP_TYPE___ns9__DeleteOSD (3288)
/* Wrapper: */
struct SOAP_CMAC __ns9__DeleteOSD {
      public:
        /** Optional element 'ns9:DeleteOSD' of XSD type 'ns9:DeleteOSD' */
        _ns9__DeleteOSD *ns9__DeleteOSD;
      public:
        /** Return unique type id SOAP_TYPE___ns9__DeleteOSD */
        int soap_type() const { return SOAP_TYPE___ns9__DeleteOSD; }
        /** Constructor with member initializations */
        __ns9__DeleteOSD()
        {
          ns9__DeleteOSD = (_ns9__DeleteOSD *)0;
        }
        /** Friend allocator used by soap_new___ns9__DeleteOSD(struct soap*, int) */
        friend SOAP_FMAC1 __ns9__DeleteOSD * SOAP_FMAC2 soap_instantiate___ns9__DeleteOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvifgen/onvif.h:71037 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (3289)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code()
        {
          SOAP_ENV__Value = (char *)0;
          SOAP_ENV__Subcode = (struct SOAP_ENV__Code *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Code(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* onvifgen/onvif.h:71037 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (3291)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail()
        {
          __any = (char *)0;
          __type = 0;
          fault = NULL;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Detail(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* onvifgen/onvif.h:71037 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (3294)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason()
        {
          SOAP_ENV__Text = (char *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Reason(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* onvifgen/onvif.h:101 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* onvifgen/onvif.h:101 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/* ds.h:44 */
#ifndef SOAP_TYPE__ds__SignatureValue
#define SOAP_TYPE__ds__SignatureValue (26)
typedef char *_ds__SignatureValue;
#endif

/* ds.h:50 */
#ifndef SOAP_TYPE__ds__Signature
#define SOAP_TYPE__ds__Signature (32)
typedef struct ds__SignatureType _ds__Signature;
#endif

/* ds.h:76 */
#ifndef SOAP_TYPE__ds__Transform
#define SOAP_TYPE__ds__Transform (40)
typedef struct ds__TransformType _ds__Transform;
#endif

/* ds.h:89 */
#ifndef SOAP_TYPE__ds__KeyInfo
#define SOAP_TYPE__ds__KeyInfo (47)
typedef struct ds__KeyInfoType _ds__KeyInfo;
#endif

/* wsc.h:57 */
#ifndef SOAP_TYPE_wsc__FaultCodeOpenEnumType
#define SOAP_TYPE_wsc__FaultCodeOpenEnumType (85)
typedef char *wsc__FaultCodeOpenEnumType;
#endif

/* onvifgen/onvif.h:234 */
#ifndef SOAP_TYPE_SOAP_ENV__Envelope
#define SOAP_TYPE_SOAP_ENV__Envelope (232)
typedef std::string SOAP_ENV__Envelope;
#endif

/* onvifgen/onvif.h:237 */
#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (233)
typedef std::string xsd__NCName;
#endif

/* onvifgen/onvif.h:240 */
#ifndef SOAP_TYPE_xsd__anySimpleType
#define SOAP_TYPE_xsd__anySimpleType (234)
typedef std::string xsd__anySimpleType;
#endif

/* onvifgen/onvif.h:243 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (235)
typedef std::string xsd__anyURI;
#endif

/* onvifgen/onvif.h:246 */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (236)
typedef std::string xsd__duration;
#endif

/* onvifgen/onvif.h:249 */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (237)
typedef std::string xsd__integer;
#endif

/* onvifgen/onvif.h:252 */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (238)
typedef std::string xsd__nonNegativeInteger;
#endif

/* onvifgen/onvif.h:255 */
#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (239)
typedef std::string xsd__token;
#endif

/* onvifgen/onvif.h:258 */
#ifndef SOAP_TYPE__xmime__contentType
#define SOAP_TYPE__xmime__contentType (240)
typedef std::string _xmime__contentType;
#endif

/* onvifgen/onvif.h:263 */
#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (241)
typedef std::string _xml__lang;
#endif

/* onvifgen/onvif.h:3649 */
#ifndef SOAP_TYPE_ns1__EAPMethodTypes
#define SOAP_TYPE_ns1__EAPMethodTypes (1364)
typedef std::string ns1__EAPMethodTypes;
#endif

/* onvifgen/onvif.h:3661 */
#ifndef SOAP_TYPE_ns2__IntAttrList
#define SOAP_TYPE_ns2__IntAttrList (1365)
typedef std::string ns2__IntAttrList;
#endif

/* onvifgen/onvif.h:3665 */
#ifndef SOAP_TYPE_ns2__FloatAttrList
#define SOAP_TYPE_ns2__FloatAttrList (1366)
typedef std::string ns2__FloatAttrList;
#endif

/* onvifgen/onvif.h:3669 */
#ifndef SOAP_TYPE_ns2__StringAttrList
#define SOAP_TYPE_ns2__StringAttrList (1367)
typedef std::string ns2__StringAttrList;
#endif

/* onvifgen/onvif.h:3673 */
#ifndef SOAP_TYPE_ns2__ReferenceTokenList
#define SOAP_TYPE_ns2__ReferenceTokenList (1368)
typedef std::string ns2__ReferenceTokenList;
#endif

/* onvifgen/onvif.h:3684 */
#ifndef SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType (1369)
typedef std::string ns3__AbsoluteOrRelativeTimeType;
#endif

/* onvifgen/onvif.h:3739 */
#ifndef SOAP_TYPE_ns9__EncodingTypes
#define SOAP_TYPE_ns9__EncodingTypes (1370)
typedef std::string ns9__EncodingTypes;
#endif

/* onvifgen/onvif.h:3754 */
#ifndef SOAP_TYPE_ns10__EncodingTypes
#define SOAP_TYPE_ns10__EncodingTypes (1371)
typedef std::string ns10__EncodingTypes;
#endif

/* onvifgen/onvif.h:3789 */
#ifndef SOAP_TYPE_ns14__RelationshipTypeOpenEnum
#define SOAP_TYPE_ns14__RelationshipTypeOpenEnum (1372)
typedef std::string ns14__RelationshipTypeOpenEnum;
#endif

/* onvifgen/onvif.h:3792 */
#ifndef SOAP_TYPE_ns14__FaultCodesOpenEnumType
#define SOAP_TYPE_ns14__FaultCodesOpenEnumType (1373)
typedef std::string ns14__FaultCodesOpenEnumType;
#endif

/* onvifgen/onvif.h:3828 */
#ifndef SOAP_TYPE_ns2__ReferenceToken
#define SOAP_TYPE_ns2__ReferenceToken (1375)
typedef std::string ns2__ReferenceToken;
#endif

/* onvifgen/onvif.h:3836 */
#ifndef SOAP_TYPE_ns2__Name
#define SOAP_TYPE_ns2__Name (1376)
typedef std::string ns2__Name;
#endif

/* onvifgen/onvif.h:3970 */
#ifndef SOAP_TYPE_ns2__NetworkInterfaceConfigPriority
#define SOAP_TYPE_ns2__NetworkInterfaceConfigPriority (1390)
typedef xsd__integer ns2__NetworkInterfaceConfigPriority;
#endif

/* onvifgen/onvif.h:3985 */
#ifndef SOAP_TYPE_ns2__IANA_IfTypes
#define SOAP_TYPE_ns2__IANA_IfTypes (1392)
typedef int ns2__IANA_IfTypes;
#endif

/* onvifgen/onvif.h:4017 */
#ifndef SOAP_TYPE_ns2__IPv4Address
#define SOAP_TYPE_ns2__IPv4Address (1396)
typedef xsd__token ns2__IPv4Address;
#endif

/* onvifgen/onvif.h:4021 */
#ifndef SOAP_TYPE_ns2__IPv6Address
#define SOAP_TYPE_ns2__IPv6Address (1397)
typedef xsd__token ns2__IPv6Address;
#endif

/* onvifgen/onvif.h:4025 */
#ifndef SOAP_TYPE_ns2__HwAddress
#define SOAP_TYPE_ns2__HwAddress (1398)
typedef xsd__token ns2__HwAddress;
#endif

/* onvifgen/onvif.h:4037 */
#ifndef SOAP_TYPE_ns2__DNSName
#define SOAP_TYPE_ns2__DNSName (1400)
typedef xsd__token ns2__DNSName;
#endif

/* onvifgen/onvif.h:4041 */
#ifndef SOAP_TYPE_ns2__Domain
#define SOAP_TYPE_ns2__Domain (1401)
typedef xsd__token ns2__Domain;
#endif

/* onvifgen/onvif.h:4063 */
#ifndef SOAP_TYPE_ns2__Dot11SSIDType
#define SOAP_TYPE_ns2__Dot11SSIDType (1404)
typedef xsd__hexBinary ns2__Dot11SSIDType;
#endif

/* onvifgen/onvif.h:4098 */
#ifndef SOAP_TYPE_ns2__Dot11PSK
#define SOAP_TYPE_ns2__Dot11PSK (1408)
typedef xsd__hexBinary ns2__Dot11PSK;
#endif

/* onvifgen/onvif.h:4103 */
#ifndef SOAP_TYPE_ns2__Dot11PSKPassphrase
#define SOAP_TYPE_ns2__Dot11PSKPassphrase (1409)
typedef std::string ns2__Dot11PSKPassphrase;
#endif

/* onvifgen/onvif.h:4253 */
#ifndef SOAP_TYPE_ns2__AuxiliaryData
#define SOAP_TYPE_ns2__AuxiliaryData (1423)
typedef std::string ns2__AuxiliaryData;
#endif

/* onvifgen/onvif.h:4407 */
#ifndef SOAP_TYPE_ns2__TopicNamespaceLocation
#define SOAP_TYPE_ns2__TopicNamespaceLocation (1440)
typedef xsd__anyURI ns2__TopicNamespaceLocation;
#endif

/* onvifgen/onvif.h:4490 */
#ifndef SOAP_TYPE_ns2__Description
#define SOAP_TYPE_ns2__Description (1446)
typedef std::string ns2__Description;
#endif

/* onvifgen/onvif.h:4494 */
#ifndef SOAP_TYPE_ns2__XPathExpression
#define SOAP_TYPE_ns2__XPathExpression (1447)
typedef std::string ns2__XPathExpression;
#endif

/* onvifgen/onvif.h:4548 */
#ifndef SOAP_TYPE_ns2__RecordingJobMode
#define SOAP_TYPE_ns2__RecordingJobMode (1451)
typedef std::string ns2__RecordingJobMode;
#endif

/* onvifgen/onvif.h:4552 */
#ifndef SOAP_TYPE_ns2__RecordingJobState
#define SOAP_TYPE_ns2__RecordingJobState (1452)
typedef std::string ns2__RecordingJobState;
#endif

/* onvifgen/onvif.h:4572 */
#ifndef SOAP_TYPE_ns2__AudioClassType
#define SOAP_TYPE_ns2__AudioClassType (1454)
typedef std::string ns2__AudioClassType;
#endif

/* onvifgen/onvif.h:4621 */
#ifndef SOAP_TYPE_ns6__FullTopicExpression
#define SOAP_TYPE_ns6__FullTopicExpression (1456)
typedef std::string ns6__FullTopicExpression;
#endif

/* onvifgen/onvif.h:4630 */
#ifndef SOAP_TYPE_ns6__ConcreteTopicExpression
#define SOAP_TYPE_ns6__ConcreteTopicExpression (1457)
typedef std::string ns6__ConcreteTopicExpression;
#endif

/* onvifgen/onvif.h:4638 */
#ifndef SOAP_TYPE_ns6__SimpleTopicExpression
#define SOAP_TYPE_ns6__SimpleTopicExpression (1458)
typedef xsd__QName ns6__SimpleTopicExpression;
#endif

/* onvifgen/onvif.h:4761 */
#ifndef SOAP_TYPE_ns13__ReferenceToken
#define SOAP_TYPE_ns13__ReferenceToken (1462)
typedef std::string ns13__ReferenceToken;
#endif

/* onvifgen/onvif.h:4769 */
#ifndef SOAP_TYPE_ns13__Name
#define SOAP_TYPE_ns13__Name (1463)
typedef std::string ns13__Name;
#endif

/* onvifgen/onvif.h:4779 */
#ifndef SOAP_TYPE_ns13__Description
#define SOAP_TYPE_ns13__Description (1464)
typedef std::string ns13__Description;
#endif

/* onvifgen/onvif.h:4787 */
#ifndef SOAP_TYPE_ns13__PositiveInteger
#define SOAP_TYPE_ns13__PositiveInteger (1465)
typedef unsigned int ns13__PositiveInteger;
#endif

/* onvifgen/onvif.h:4823 */
#ifndef SOAP_TYPE_ns2__ReceiverReference
#define SOAP_TYPE_ns2__ReceiverReference (1468)
typedef ns2__ReferenceToken ns2__ReceiverReference;
#endif

/* onvifgen/onvif.h:4827 */
#ifndef SOAP_TYPE_ns2__RecordingReference
#define SOAP_TYPE_ns2__RecordingReference (1469)
typedef ns2__ReferenceToken ns2__RecordingReference;
#endif

/* onvifgen/onvif.h:4831 */
#ifndef SOAP_TYPE_ns2__TrackReference
#define SOAP_TYPE_ns2__TrackReference (1470)
typedef ns2__ReferenceToken ns2__TrackReference;
#endif

/* onvifgen/onvif.h:4835 */
#ifndef SOAP_TYPE_ns2__JobToken
#define SOAP_TYPE_ns2__JobToken (1471)
typedef ns2__ReferenceToken ns2__JobToken;
#endif

/* onvifgen/onvif.h:4839 */
#ifndef SOAP_TYPE_ns2__RecordingJobReference
#define SOAP_TYPE_ns2__RecordingJobReference (1472)
typedef ns2__ReferenceToken ns2__RecordingJobReference;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* ns2__IANA_IfTypes has binding name 'ns2__IANA_IfTypes' for type 'ns2:IANA-IfTypes' */
#ifndef SOAP_TYPE_ns2__IANA_IfTypes
#define SOAP_TYPE_ns2__IANA_IfTypes (1392)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* float has binding name 'float' for type 'xsd:float' */
#ifndef SOAP_TYPE_float
#define SOAP_TYPE_float (1560)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_unsignedByte
#define SOAP_TYPE_unsignedByte (228)
#endif

/* ns13__PositiveInteger has binding name 'ns13__PositiveInteger' for type 'ns13:PositiveInteger' */
#ifndef SOAP_TYPE_ns13__PositiveInteger
#define SOAP_TYPE_ns13__PositiveInteger (1465)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (227)
#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_ULONG64
#define SOAP_TYPE_ULONG64 (92)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (127)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (1481)
#endif

/* enum saml2__DecisionType has binding name 'saml2__DecisionType' for type 'saml2:DecisionType' */
#ifndef SOAP_TYPE_saml2__DecisionType
#define SOAP_TYPE_saml2__DecisionType (172)
#endif

/* enum saml1__DecisionType has binding name 'saml1__DecisionType' for type 'saml1:DecisionType' */
#ifndef SOAP_TYPE_saml1__DecisionType
#define SOAP_TYPE_saml1__DecisionType (116)
#endif

/* enum wsc__FaultCodeType has binding name 'wsc__FaultCodeType' for type 'wsc:FaultCodeType' */
#ifndef SOAP_TYPE_wsc__FaultCodeType
#define SOAP_TYPE_wsc__FaultCodeType (86)
#endif

/* enum wsse__FaultcodeEnum has binding name 'wsse__FaultcodeEnum' for type 'wsse:FaultcodeEnum' */
#ifndef SOAP_TYPE_wsse__FaultcodeEnum
#define SOAP_TYPE_wsse__FaultcodeEnum (11)
#endif

/* enum wsu__tTimestampFault has binding name 'wsu__tTimestampFault' for type 'wsu:tTimestampFault' */
#ifndef SOAP_TYPE_wsu__tTimestampFault
#define SOAP_TYPE_wsu__tTimestampFault (8)
#endif

/* ns14__FaultCodesType has binding name 'ns14__FaultCodesType' for type 'ns14:FaultCodesType' */
#ifndef SOAP_TYPE_ns14__FaultCodesType
#define SOAP_TYPE_ns14__FaultCodesType (1467)
#endif

/* ns14__RelationshipType has binding name 'ns14__RelationshipType' for type 'ns14:RelationshipType' */
#ifndef SOAP_TYPE_ns14__RelationshipType
#define SOAP_TYPE_ns14__RelationshipType (1466)
#endif

/* ns10__TransportProtocol has binding name 'ns10__TransportProtocol' for type 'ns10:TransportProtocol' */
#ifndef SOAP_TYPE_ns10__TransportProtocol
#define SOAP_TYPE_ns10__TransportProtocol (1461)
#endif

/* ns10__ConfigurationEnumeration has binding name 'ns10__ConfigurationEnumeration' for type 'ns10:ConfigurationEnumeration' */
#ifndef SOAP_TYPE_ns10__ConfigurationEnumeration
#define SOAP_TYPE_ns10__ConfigurationEnumeration (1460)
#endif

/* ns8__ImagingPresetType has binding name 'ns8__ImagingPresetType' for type 'ns8:ImagingPresetType' */
#ifndef SOAP_TYPE_ns8__ImagingPresetType
#define SOAP_TYPE_ns8__ImagingPresetType (1459)
#endif

/* ns2__OSDType has binding name 'ns2__OSDType' for type 'ns2:OSDType' */
#ifndef SOAP_TYPE_ns2__OSDType
#define SOAP_TYPE_ns2__OSDType (1455)
#endif

/* ns2__ModeOfOperation has binding name 'ns2__ModeOfOperation' for type 'ns2:ModeOfOperation' */
#ifndef SOAP_TYPE_ns2__ModeOfOperation
#define SOAP_TYPE_ns2__ModeOfOperation (1453)
#endif

/* ns2__TrackType has binding name 'ns2__TrackType' for type 'ns2:TrackType' */
#ifndef SOAP_TYPE_ns2__TrackType
#define SOAP_TYPE_ns2__TrackType (1450)
#endif

/* ns2__RecordingStatus has binding name 'ns2__RecordingStatus' for type 'ns2:RecordingStatus' */
#ifndef SOAP_TYPE_ns2__RecordingStatus
#define SOAP_TYPE_ns2__RecordingStatus (1449)
#endif

/* ns2__SearchState has binding name 'ns2__SearchState' for type 'ns2:SearchState' */
#ifndef SOAP_TYPE_ns2__SearchState
#define SOAP_TYPE_ns2__SearchState (1448)
#endif

/* ns2__ReceiverState has binding name 'ns2__ReceiverState' for type 'ns2:ReceiverState' */
#ifndef SOAP_TYPE_ns2__ReceiverState
#define SOAP_TYPE_ns2__ReceiverState (1445)
#endif

/* ns2__ReceiverMode has binding name 'ns2__ReceiverMode' for type 'ns2:ReceiverMode' */
#ifndef SOAP_TYPE_ns2__ReceiverMode
#define SOAP_TYPE_ns2__ReceiverMode (1444)
#endif

/* ns2__ClassType has binding name 'ns2__ClassType' for type 'ns2:ClassType' */
#ifndef SOAP_TYPE_ns2__ClassType
#define SOAP_TYPE_ns2__ClassType (1443)
#endif

/* ns2__Direction has binding name 'ns2__Direction' for type 'ns2:Direction' */
#ifndef SOAP_TYPE_ns2__Direction
#define SOAP_TYPE_ns2__Direction (1442)
#endif

/* ns2__PropertyOperation has binding name 'ns2__PropertyOperation' for type 'ns2:PropertyOperation' */
#ifndef SOAP_TYPE_ns2__PropertyOperation
#define SOAP_TYPE_ns2__PropertyOperation (1441)
#endif

/* ns2__DefoggingMode has binding name 'ns2__DefoggingMode' for type 'ns2:DefoggingMode' */
#ifndef SOAP_TYPE_ns2__DefoggingMode
#define SOAP_TYPE_ns2__DefoggingMode (1439)
#endif

/* ns2__ToneCompensationMode has binding name 'ns2__ToneCompensationMode' for type 'ns2:ToneCompensationMode' */
#ifndef SOAP_TYPE_ns2__ToneCompensationMode
#define SOAP_TYPE_ns2__ToneCompensationMode (1438)
#endif

/* ns2__IrCutFilterAutoBoundaryType has binding name 'ns2__IrCutFilterAutoBoundaryType' for type 'ns2:IrCutFilterAutoBoundaryType' */
#ifndef SOAP_TYPE_ns2__IrCutFilterAutoBoundaryType
#define SOAP_TYPE_ns2__IrCutFilterAutoBoundaryType (1437)
#endif

/* ns2__ImageStabilizationMode has binding name 'ns2__ImageStabilizationMode' for type 'ns2:ImageStabilizationMode' */
#ifndef SOAP_TYPE_ns2__ImageStabilizationMode
#define SOAP_TYPE_ns2__ImageStabilizationMode (1436)
#endif

/* ns2__IrCutFilterMode has binding name 'ns2__IrCutFilterMode' for type 'ns2:IrCutFilterMode' */
#ifndef SOAP_TYPE_ns2__IrCutFilterMode
#define SOAP_TYPE_ns2__IrCutFilterMode (1435)
#endif

/* ns2__WhiteBalanceMode has binding name 'ns2__WhiteBalanceMode' for type 'ns2:WhiteBalanceMode' */
#ifndef SOAP_TYPE_ns2__WhiteBalanceMode
#define SOAP_TYPE_ns2__WhiteBalanceMode (1434)
#endif

/* ns2__Enabled has binding name 'ns2__Enabled' for type 'ns2:Enabled' */
#ifndef SOAP_TYPE_ns2__Enabled
#define SOAP_TYPE_ns2__Enabled (1433)
#endif

/* ns2__ExposureMode has binding name 'ns2__ExposureMode' for type 'ns2:ExposureMode' */
#ifndef SOAP_TYPE_ns2__ExposureMode
#define SOAP_TYPE_ns2__ExposureMode (1432)
#endif

/* ns2__ExposurePriority has binding name 'ns2__ExposurePriority' for type 'ns2:ExposurePriority' */
#ifndef SOAP_TYPE_ns2__ExposurePriority
#define SOAP_TYPE_ns2__ExposurePriority (1431)
#endif

/* ns2__BacklightCompensationMode has binding name 'ns2__BacklightCompensationMode' for type 'ns2:BacklightCompensationMode' */
#ifndef SOAP_TYPE_ns2__BacklightCompensationMode
#define SOAP_TYPE_ns2__BacklightCompensationMode (1430)
#endif

/* ns2__WideDynamicMode has binding name 'ns2__WideDynamicMode' for type 'ns2:WideDynamicMode' */
#ifndef SOAP_TYPE_ns2__WideDynamicMode
#define SOAP_TYPE_ns2__WideDynamicMode (1429)
#endif

/* ns2__AutoFocusMode has binding name 'ns2__AutoFocusMode' for type 'ns2:AutoFocusMode' */
#ifndef SOAP_TYPE_ns2__AutoFocusMode
#define SOAP_TYPE_ns2__AutoFocusMode (1428)
#endif

/* ns2__PTZPresetTourOperation has binding name 'ns2__PTZPresetTourOperation' for type 'ns2:PTZPresetTourOperation' */
#ifndef SOAP_TYPE_ns2__PTZPresetTourOperation
#define SOAP_TYPE_ns2__PTZPresetTourOperation (1427)
#endif

/* ns2__PTZPresetTourDirection has binding name 'ns2__PTZPresetTourDirection' for type 'ns2:PTZPresetTourDirection' */
#ifndef SOAP_TYPE_ns2__PTZPresetTourDirection
#define SOAP_TYPE_ns2__PTZPresetTourDirection (1426)
#endif

/* ns2__PTZPresetTourState has binding name 'ns2__PTZPresetTourState' for type 'ns2:PTZPresetTourState' */
#ifndef SOAP_TYPE_ns2__PTZPresetTourState
#define SOAP_TYPE_ns2__PTZPresetTourState (1425)
#endif

/* ns2__MoveStatus has binding name 'ns2__MoveStatus' for type 'ns2:MoveStatus' */
#ifndef SOAP_TYPE_ns2__MoveStatus
#define SOAP_TYPE_ns2__MoveStatus (1424)
#endif

/* ns2__ReverseMode has binding name 'ns2__ReverseMode' for type 'ns2:ReverseMode' */
#ifndef SOAP_TYPE_ns2__ReverseMode
#define SOAP_TYPE_ns2__ReverseMode (1422)
#endif

/* ns2__EFlipMode has binding name 'ns2__EFlipMode' for type 'ns2:EFlipMode' */
#ifndef SOAP_TYPE_ns2__EFlipMode
#define SOAP_TYPE_ns2__EFlipMode (1421)
#endif

/* ns2__DigitalIdleState has binding name 'ns2__DigitalIdleState' for type 'ns2:DigitalIdleState' */
#ifndef SOAP_TYPE_ns2__DigitalIdleState
#define SOAP_TYPE_ns2__DigitalIdleState (1420)
#endif

/* ns2__RelayMode has binding name 'ns2__RelayMode' for type 'ns2:RelayMode' */
#ifndef SOAP_TYPE_ns2__RelayMode
#define SOAP_TYPE_ns2__RelayMode (1419)
#endif

/* ns2__RelayIdleState has binding name 'ns2__RelayIdleState' for type 'ns2:RelayIdleState' */
#ifndef SOAP_TYPE_ns2__RelayIdleState
#define SOAP_TYPE_ns2__RelayIdleState (1418)
#endif

/* ns2__RelayLogicalState has binding name 'ns2__RelayLogicalState' for type 'ns2:RelayLogicalState' */
#ifndef SOAP_TYPE_ns2__RelayLogicalState
#define SOAP_TYPE_ns2__RelayLogicalState (1417)
#endif

/* ns2__UserLevel has binding name 'ns2__UserLevel' for type 'ns2:UserLevel' */
#ifndef SOAP_TYPE_ns2__UserLevel
#define SOAP_TYPE_ns2__UserLevel (1416)
#endif

/* ns2__SetDateTimeType has binding name 'ns2__SetDateTimeType' for type 'ns2:SetDateTimeType' */
#ifndef SOAP_TYPE_ns2__SetDateTimeType
#define SOAP_TYPE_ns2__SetDateTimeType (1415)
#endif

/* ns2__FactoryDefaultType has binding name 'ns2__FactoryDefaultType' for type 'ns2:FactoryDefaultType' */
#ifndef SOAP_TYPE_ns2__FactoryDefaultType
#define SOAP_TYPE_ns2__FactoryDefaultType (1414)
#endif

/* ns2__SystemLogType has binding name 'ns2__SystemLogType' for type 'ns2:SystemLogType' */
#ifndef SOAP_TYPE_ns2__SystemLogType
#define SOAP_TYPE_ns2__SystemLogType (1413)
#endif

/* ns2__CapabilityCategory has binding name 'ns2__CapabilityCategory' for type 'ns2:CapabilityCategory' */
#ifndef SOAP_TYPE_ns2__CapabilityCategory
#define SOAP_TYPE_ns2__CapabilityCategory (1412)
#endif

/* ns2__Dot11AuthAndMangementSuite has binding name 'ns2__Dot11AuthAndMangementSuite' for type 'ns2:Dot11AuthAndMangementSuite' */
#ifndef SOAP_TYPE_ns2__Dot11AuthAndMangementSuite
#define SOAP_TYPE_ns2__Dot11AuthAndMangementSuite (1411)
#endif

/* ns2__Dot11SignalStrength has binding name 'ns2__Dot11SignalStrength' for type 'ns2:Dot11SignalStrength' */
#ifndef SOAP_TYPE_ns2__Dot11SignalStrength
#define SOAP_TYPE_ns2__Dot11SignalStrength (1410)
#endif

/* ns2__Dot11Cipher has binding name 'ns2__Dot11Cipher' for type 'ns2:Dot11Cipher' */
#ifndef SOAP_TYPE_ns2__Dot11Cipher
#define SOAP_TYPE_ns2__Dot11Cipher (1407)
#endif

/* ns2__Dot11SecurityMode has binding name 'ns2__Dot11SecurityMode' for type 'ns2:Dot11SecurityMode' */
#ifndef SOAP_TYPE_ns2__Dot11SecurityMode
#define SOAP_TYPE_ns2__Dot11SecurityMode (1406)
#endif

/* ns2__Dot11StationMode has binding name 'ns2__Dot11StationMode' for type 'ns2:Dot11StationMode' */
#ifndef SOAP_TYPE_ns2__Dot11StationMode
#define SOAP_TYPE_ns2__Dot11StationMode (1405)
#endif

/* ns2__DynamicDNSType has binding name 'ns2__DynamicDNSType' for type 'ns2:DynamicDNSType' */
#ifndef SOAP_TYPE_ns2__DynamicDNSType
#define SOAP_TYPE_ns2__DynamicDNSType (1403)
#endif

/* ns2__IPAddressFilterType has binding name 'ns2__IPAddressFilterType' for type 'ns2:IPAddressFilterType' */
#ifndef SOAP_TYPE_ns2__IPAddressFilterType
#define SOAP_TYPE_ns2__IPAddressFilterType (1402)
#endif

/* ns2__IPType has binding name 'ns2__IPType' for type 'ns2:IPType' */
#ifndef SOAP_TYPE_ns2__IPType
#define SOAP_TYPE_ns2__IPType (1399)
#endif

/* ns2__NetworkHostType has binding name 'ns2__NetworkHostType' for type 'ns2:NetworkHostType' */
#ifndef SOAP_TYPE_ns2__NetworkHostType
#define SOAP_TYPE_ns2__NetworkHostType (1395)
#endif

/* ns2__NetworkProtocolType has binding name 'ns2__NetworkProtocolType' for type 'ns2:NetworkProtocolType' */
#ifndef SOAP_TYPE_ns2__NetworkProtocolType
#define SOAP_TYPE_ns2__NetworkProtocolType (1394)
#endif

/* ns2__IPv6DHCPConfiguration has binding name 'ns2__IPv6DHCPConfiguration' for type 'ns2:IPv6DHCPConfiguration' */
#ifndef SOAP_TYPE_ns2__IPv6DHCPConfiguration
#define SOAP_TYPE_ns2__IPv6DHCPConfiguration (1393)
#endif

/* ns2__Duplex has binding name 'ns2__Duplex' for type 'ns2:Duplex' */
#ifndef SOAP_TYPE_ns2__Duplex
#define SOAP_TYPE_ns2__Duplex (1391)
#endif

/* ns2__DiscoveryMode has binding name 'ns2__DiscoveryMode' for type 'ns2:DiscoveryMode' */
#ifndef SOAP_TYPE_ns2__DiscoveryMode
#define SOAP_TYPE_ns2__DiscoveryMode (1389)
#endif

/* ns2__ScopeDefinition has binding name 'ns2__ScopeDefinition' for type 'ns2:ScopeDefinition' */
#ifndef SOAP_TYPE_ns2__ScopeDefinition
#define SOAP_TYPE_ns2__ScopeDefinition (1388)
#endif

/* ns2__TransportProtocol has binding name 'ns2__TransportProtocol' for type 'ns2:TransportProtocol' */
#ifndef SOAP_TYPE_ns2__TransportProtocol
#define SOAP_TYPE_ns2__TransportProtocol (1387)
#endif

/* ns2__StreamType has binding name 'ns2__StreamType' for type 'ns2:StreamType' */
#ifndef SOAP_TYPE_ns2__StreamType
#define SOAP_TYPE_ns2__StreamType (1386)
#endif

/* ns2__MetadataCompressionType has binding name 'ns2__MetadataCompressionType' for type 'ns2:MetadataCompressionType' */
#ifndef SOAP_TYPE_ns2__MetadataCompressionType
#define SOAP_TYPE_ns2__MetadataCompressionType (1385)
#endif

/* ns2__AudioEncodingMimeNames has binding name 'ns2__AudioEncodingMimeNames' for type 'ns2:AudioEncodingMimeNames' */
#ifndef SOAP_TYPE_ns2__AudioEncodingMimeNames
#define SOAP_TYPE_ns2__AudioEncodingMimeNames (1384)
#endif

/* ns2__AudioEncoding has binding name 'ns2__AudioEncoding' for type 'ns2:AudioEncoding' */
#ifndef SOAP_TYPE_ns2__AudioEncoding
#define SOAP_TYPE_ns2__AudioEncoding (1383)
#endif

/* ns2__VideoEncodingProfiles has binding name 'ns2__VideoEncodingProfiles' for type 'ns2:VideoEncodingProfiles' */
#ifndef SOAP_TYPE_ns2__VideoEncodingProfiles
#define SOAP_TYPE_ns2__VideoEncodingProfiles (1382)
#endif

/* ns2__VideoEncodingMimeNames has binding name 'ns2__VideoEncodingMimeNames' for type 'ns2:VideoEncodingMimeNames' */
#ifndef SOAP_TYPE_ns2__VideoEncodingMimeNames
#define SOAP_TYPE_ns2__VideoEncodingMimeNames (1381)
#endif

/* ns2__H264Profile has binding name 'ns2__H264Profile' for type 'ns2:H264Profile' */
#ifndef SOAP_TYPE_ns2__H264Profile
#define SOAP_TYPE_ns2__H264Profile (1380)
#endif

/* ns2__Mpeg4Profile has binding name 'ns2__Mpeg4Profile' for type 'ns2:Mpeg4Profile' */
#ifndef SOAP_TYPE_ns2__Mpeg4Profile
#define SOAP_TYPE_ns2__Mpeg4Profile (1379)
#endif

/* ns2__VideoEncoding has binding name 'ns2__VideoEncoding' for type 'ns2:VideoEncoding' */
#ifndef SOAP_TYPE_ns2__VideoEncoding
#define SOAP_TYPE_ns2__VideoEncoding (1378)
#endif

/* ns2__RotateMode has binding name 'ns2__RotateMode' for type 'ns2:RotateMode' */
#ifndef SOAP_TYPE_ns2__RotateMode
#define SOAP_TYPE_ns2__RotateMode (1377)
#endif

/* ns1__StorageType has binding name 'ns1__StorageType' for type 'ns1:StorageType' */
#ifndef SOAP_TYPE_ns1__StorageType
#define SOAP_TYPE_ns1__StorageType (1374)
#endif

/* _ns6__TopicNamespaceType_Topic has binding name '_ns6__TopicNamespaceType_Topic' for type '' */
#ifndef SOAP_TYPE__ns6__TopicNamespaceType_Topic
#define SOAP_TYPE__ns6__TopicNamespaceType_Topic (2205)
#endif

/* _ns5__BaseFaultType_FaultCause has binding name '_ns5__BaseFaultType_FaultCause' for type '' */
#ifndef SOAP_TYPE__ns5__BaseFaultType_FaultCause
#define SOAP_TYPE__ns5__BaseFaultType_FaultCause (2063)
#endif

/* _ns5__BaseFaultType_Description has binding name '_ns5__BaseFaultType_Description' for type '' */
#ifndef SOAP_TYPE__ns5__BaseFaultType_Description
#define SOAP_TYPE__ns5__BaseFaultType_Description (2059)
#endif

/* _ns5__BaseFaultType_ErrorCode has binding name '_ns5__BaseFaultType_ErrorCode' for type '' */
#ifndef SOAP_TYPE__ns5__BaseFaultType_ErrorCode
#define SOAP_TYPE__ns5__BaseFaultType_ErrorCode (2057)
#endif

/* _ns3__Subscribe_SubscriptionPolicy has binding name '_ns3__Subscribe_SubscriptionPolicy' for type '' */
#ifndef SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy
#define SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy (2054)
#endif

/* _ns3__NotificationMessageHolderType_Message has binding name '_ns3__NotificationMessageHolderType_Message' for type '' */
#ifndef SOAP_TYPE__ns3__NotificationMessageHolderType_Message
#define SOAP_TYPE__ns3__NotificationMessageHolderType_Message (2048)
#endif

/* _ns2__ConfigDescription_Messages has binding name '_ns2__ConfigDescription_Messages' for type '' */
#ifndef SOAP_TYPE__ns2__ConfigDescription_Messages
#define SOAP_TYPE__ns2__ConfigDescription_Messages (1910)
#endif

/* _ns2__Behaviour_Idle has binding name '_ns2__Behaviour_Idle' for type '' */
#ifndef SOAP_TYPE__ns2__Behaviour_Idle
#define SOAP_TYPE__ns2__Behaviour_Idle (1895)
#endif

/* _ns2__Behaviour_Removed has binding name '_ns2__Behaviour_Removed' for type '' */
#ifndef SOAP_TYPE__ns2__Behaviour_Removed
#define SOAP_TYPE__ns2__Behaviour_Removed (1893)
#endif

/* _ns2__ClassDescriptor_ClassCandidate has binding name '_ns2__ClassDescriptor_ClassCandidate' for type '' */
#ifndef SOAP_TYPE__ns2__ClassDescriptor_ClassCandidate
#define SOAP_TYPE__ns2__ClassDescriptor_ClassCandidate (1875)
#endif

/* _ns2__ColorDescriptor_ColorCluster has binding name '_ns2__ColorDescriptor_ColorCluster' for type '' */
#ifndef SOAP_TYPE__ns2__ColorDescriptor_ColorCluster
#define SOAP_TYPE__ns2__ColorDescriptor_ColorCluster (1869)
#endif

/* _ns2__ItemListDescription_ElementItemDescription has binding name '_ns2__ItemListDescription_ElementItemDescription' for type '' */
#ifndef SOAP_TYPE__ns2__ItemListDescription_ElementItemDescription
#define SOAP_TYPE__ns2__ItemListDescription_ElementItemDescription (1855)
#endif

/* _ns2__ItemListDescription_SimpleItemDescription has binding name '_ns2__ItemListDescription_SimpleItemDescription' for type '' */
#ifndef SOAP_TYPE__ns2__ItemListDescription_SimpleItemDescription
#define SOAP_TYPE__ns2__ItemListDescription_SimpleItemDescription (1852)
#endif

/* _ns2__ItemList_ElementItem has binding name '_ns2__ItemList_ElementItem' for type '' */
#ifndef SOAP_TYPE__ns2__ItemList_ElementItem
#define SOAP_TYPE__ns2__ItemList_ElementItem (1846)
#endif

/* _ns2__ItemList_SimpleItem has binding name '_ns2__ItemList_SimpleItem' for type '' */
#ifndef SOAP_TYPE__ns2__ItemList_SimpleItem
#define SOAP_TYPE__ns2__ItemList_SimpleItem (1843)
#endif

/* _ns2__EventSubscription_SubscriptionPolicy has binding name '_ns2__EventSubscription_SubscriptionPolicy' for type '' */
#ifndef SOAP_TYPE__ns2__EventSubscription_SubscriptionPolicy
#define SOAP_TYPE__ns2__EventSubscription_SubscriptionPolicy (1613)
#endif

/* _ns1__GetSystemUrisResponse_Extension has binding name '_ns1__GetSystemUrisResponse_Extension' for type '' */
#ifndef SOAP_TYPE__ns1__GetSystemUrisResponse_Extension
#define SOAP_TYPE__ns1__GetSystemUrisResponse_Extension (1554)
#endif

/* _ns1__StorageConfigurationData_Extension has binding name '_ns1__StorageConfigurationData_Extension' for type '' */
#ifndef SOAP_TYPE__ns1__StorageConfigurationData_Extension
#define SOAP_TYPE__ns1__StorageConfigurationData_Extension (1490)
#endif

/* _ns1__UserCredential_Extension has binding name '_ns1__UserCredential_Extension' for type '' */
#ifndef SOAP_TYPE__ns1__UserCredential_Extension
#define SOAP_TYPE__ns1__UserCredential_Extension (1486)
#endif

/* _ns1__Service_Capabilities has binding name '_ns1__Service_Capabilities' for type '' */
#ifndef SOAP_TYPE__ns1__Service_Capabilities
#define SOAP_TYPE__ns1__Service_Capabilities (1473)
#endif

/* ns2__RecordingJobReference has binding name 'ns2__RecordingJobReference' for type 'ns2:RecordingJobReference' */
#ifndef SOAP_TYPE_ns2__RecordingJobReference
#define SOAP_TYPE_ns2__RecordingJobReference (1472)
#endif

/* ns2__JobToken has binding name 'ns2__JobToken' for type 'ns2:JobToken' */
#ifndef SOAP_TYPE_ns2__JobToken
#define SOAP_TYPE_ns2__JobToken (1471)
#endif

/* ns2__TrackReference has binding name 'ns2__TrackReference' for type 'ns2:TrackReference' */
#ifndef SOAP_TYPE_ns2__TrackReference
#define SOAP_TYPE_ns2__TrackReference (1470)
#endif

/* ns2__RecordingReference has binding name 'ns2__RecordingReference' for type 'ns2:RecordingReference' */
#ifndef SOAP_TYPE_ns2__RecordingReference
#define SOAP_TYPE_ns2__RecordingReference (1469)
#endif

/* ns2__ReceiverReference has binding name 'ns2__ReceiverReference' for type 'ns2:ReceiverReference' */
#ifndef SOAP_TYPE_ns2__ReceiverReference
#define SOAP_TYPE_ns2__ReceiverReference (1468)
#endif

/* ns13__Description has binding name 'ns13__Description' for type 'ns13:Description' */
#ifndef SOAP_TYPE_ns13__Description
#define SOAP_TYPE_ns13__Description (1464)
#endif

/* ns13__Name has binding name 'ns13__Name' for type 'ns13:Name' */
#ifndef SOAP_TYPE_ns13__Name
#define SOAP_TYPE_ns13__Name (1463)
#endif

/* ns13__ReferenceToken has binding name 'ns13__ReferenceToken' for type 'ns13:ReferenceToken' */
#ifndef SOAP_TYPE_ns13__ReferenceToken
#define SOAP_TYPE_ns13__ReferenceToken (1462)
#endif

/* ns6__SimpleTopicExpression has binding name 'ns6__SimpleTopicExpression' for type 'ns6:SimpleTopicExpression' */
#ifndef SOAP_TYPE_ns6__SimpleTopicExpression
#define SOAP_TYPE_ns6__SimpleTopicExpression (1458)
#endif

/* ns6__ConcreteTopicExpression has binding name 'ns6__ConcreteTopicExpression' for type 'ns6:ConcreteTopicExpression' */
#ifndef SOAP_TYPE_ns6__ConcreteTopicExpression
#define SOAP_TYPE_ns6__ConcreteTopicExpression (1457)
#endif

/* ns6__FullTopicExpression has binding name 'ns6__FullTopicExpression' for type 'ns6:FullTopicExpression' */
#ifndef SOAP_TYPE_ns6__FullTopicExpression
#define SOAP_TYPE_ns6__FullTopicExpression (1456)
#endif

/* ns2__AudioClassType has binding name 'ns2__AudioClassType' for type 'ns2:AudioClassType' */
#ifndef SOAP_TYPE_ns2__AudioClassType
#define SOAP_TYPE_ns2__AudioClassType (1454)
#endif

/* ns2__RecordingJobState has binding name 'ns2__RecordingJobState' for type 'ns2:RecordingJobState' */
#ifndef SOAP_TYPE_ns2__RecordingJobState
#define SOAP_TYPE_ns2__RecordingJobState (1452)
#endif

/* ns2__RecordingJobMode has binding name 'ns2__RecordingJobMode' for type 'ns2:RecordingJobMode' */
#ifndef SOAP_TYPE_ns2__RecordingJobMode
#define SOAP_TYPE_ns2__RecordingJobMode (1451)
#endif

/* ns2__XPathExpression has binding name 'ns2__XPathExpression' for type 'ns2:XPathExpression' */
#ifndef SOAP_TYPE_ns2__XPathExpression
#define SOAP_TYPE_ns2__XPathExpression (1447)
#endif

/* ns2__Description has binding name 'ns2__Description' for type 'ns2:Description' */
#ifndef SOAP_TYPE_ns2__Description
#define SOAP_TYPE_ns2__Description (1446)
#endif

/* ns2__TopicNamespaceLocation has binding name 'ns2__TopicNamespaceLocation' for type 'ns2:TopicNamespaceLocation' */
#ifndef SOAP_TYPE_ns2__TopicNamespaceLocation
#define SOAP_TYPE_ns2__TopicNamespaceLocation (1440)
#endif

/* ns2__AuxiliaryData has binding name 'ns2__AuxiliaryData' for type 'ns2:AuxiliaryData' */
#ifndef SOAP_TYPE_ns2__AuxiliaryData
#define SOAP_TYPE_ns2__AuxiliaryData (1423)
#endif

/* ns2__Dot11PSKPassphrase has binding name 'ns2__Dot11PSKPassphrase' for type 'ns2:Dot11PSKPassphrase' */
#ifndef SOAP_TYPE_ns2__Dot11PSKPassphrase
#define SOAP_TYPE_ns2__Dot11PSKPassphrase (1409)
#endif

/* ns2__Dot11PSK has binding name 'ns2__Dot11PSK' for type 'ns2:Dot11PSK' */
#ifndef SOAP_TYPE_ns2__Dot11PSK
#define SOAP_TYPE_ns2__Dot11PSK (1408)
#endif

/* ns2__Dot11SSIDType has binding name 'ns2__Dot11SSIDType' for type 'ns2:Dot11SSIDType' */
#ifndef SOAP_TYPE_ns2__Dot11SSIDType
#define SOAP_TYPE_ns2__Dot11SSIDType (1404)
#endif

/* ns2__Domain has binding name 'ns2__Domain' for type 'ns2:Domain' */
#ifndef SOAP_TYPE_ns2__Domain
#define SOAP_TYPE_ns2__Domain (1401)
#endif

/* ns2__DNSName has binding name 'ns2__DNSName' for type 'ns2:DNSName' */
#ifndef SOAP_TYPE_ns2__DNSName
#define SOAP_TYPE_ns2__DNSName (1400)
#endif

/* ns2__HwAddress has binding name 'ns2__HwAddress' for type 'ns2:HwAddress' */
#ifndef SOAP_TYPE_ns2__HwAddress
#define SOAP_TYPE_ns2__HwAddress (1398)
#endif

/* ns2__IPv6Address has binding name 'ns2__IPv6Address' for type 'ns2:IPv6Address' */
#ifndef SOAP_TYPE_ns2__IPv6Address
#define SOAP_TYPE_ns2__IPv6Address (1397)
#endif

/* ns2__IPv4Address has binding name 'ns2__IPv4Address' for type 'ns2:IPv4Address' */
#ifndef SOAP_TYPE_ns2__IPv4Address
#define SOAP_TYPE_ns2__IPv4Address (1396)
#endif

/* ns2__NetworkInterfaceConfigPriority has binding name 'ns2__NetworkInterfaceConfigPriority' for type 'ns2:NetworkInterfaceConfigPriority' */
#ifndef SOAP_TYPE_ns2__NetworkInterfaceConfigPriority
#define SOAP_TYPE_ns2__NetworkInterfaceConfigPriority (1390)
#endif

/* ns2__Name has binding name 'ns2__Name' for type 'ns2:Name' */
#ifndef SOAP_TYPE_ns2__Name
#define SOAP_TYPE_ns2__Name (1376)
#endif

/* ns2__ReferenceToken has binding name 'ns2__ReferenceToken' for type 'ns2:ReferenceToken' */
#ifndef SOAP_TYPE_ns2__ReferenceToken
#define SOAP_TYPE_ns2__ReferenceToken (1375)
#endif

/* ns14__FaultCodesOpenEnumType has binding name 'ns14__FaultCodesOpenEnumType' for type 'ns14:FaultCodesOpenEnumType' */
#ifndef SOAP_TYPE_ns14__FaultCodesOpenEnumType
#define SOAP_TYPE_ns14__FaultCodesOpenEnumType (1373)
#endif

/* ns14__RelationshipTypeOpenEnum has binding name 'ns14__RelationshipTypeOpenEnum' for type 'ns14:RelationshipTypeOpenEnum' */
#ifndef SOAP_TYPE_ns14__RelationshipTypeOpenEnum
#define SOAP_TYPE_ns14__RelationshipTypeOpenEnum (1372)
#endif

/* ns10__EncodingTypes has binding name 'ns10__EncodingTypes' for type 'ns10:EncodingTypes' */
#ifndef SOAP_TYPE_ns10__EncodingTypes
#define SOAP_TYPE_ns10__EncodingTypes (1371)
#endif

/* ns9__EncodingTypes has binding name 'ns9__EncodingTypes' for type 'ns9:EncodingTypes' */
#ifndef SOAP_TYPE_ns9__EncodingTypes
#define SOAP_TYPE_ns9__EncodingTypes (1370)
#endif

/* ns3__AbsoluteOrRelativeTimeType has binding name 'ns3__AbsoluteOrRelativeTimeType' for type 'ns3:AbsoluteOrRelativeTimeType' */
#ifndef SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType (1369)
#endif

/* ns2__ReferenceTokenList has binding name 'ns2__ReferenceTokenList' for type 'ns2:ReferenceTokenList' */
#ifndef SOAP_TYPE_ns2__ReferenceTokenList
#define SOAP_TYPE_ns2__ReferenceTokenList (1368)
#endif

/* ns2__StringAttrList has binding name 'ns2__StringAttrList' for type 'ns2:StringAttrList' */
#ifndef SOAP_TYPE_ns2__StringAttrList
#define SOAP_TYPE_ns2__StringAttrList (1367)
#endif

/* ns2__FloatAttrList has binding name 'ns2__FloatAttrList' for type 'ns2:FloatAttrList' */
#ifndef SOAP_TYPE_ns2__FloatAttrList
#define SOAP_TYPE_ns2__FloatAttrList (1366)
#endif

/* ns2__IntAttrList has binding name 'ns2__IntAttrList' for type 'ns2:IntAttrList' */
#ifndef SOAP_TYPE_ns2__IntAttrList
#define SOAP_TYPE_ns2__IntAttrList (1365)
#endif

/* ns1__EAPMethodTypes has binding name 'ns1__EAPMethodTypes' for type 'ns1:EAPMethodTypes' */
#ifndef SOAP_TYPE_ns1__EAPMethodTypes
#define SOAP_TYPE_ns1__EAPMethodTypes (1364)
#endif

/* ns14__ProblemActionType has binding name 'ns14__ProblemActionType' for type 'ns14:ProblemActionType' */
#ifndef SOAP_TYPE_ns14__ProblemActionType
#define SOAP_TYPE_ns14__ProblemActionType (1363)
#endif

/* ns14__AttributedQNameType has binding name 'ns14__AttributedQNameType' for type 'ns14:AttributedQNameType' */
#ifndef SOAP_TYPE_ns14__AttributedQNameType
#define SOAP_TYPE_ns14__AttributedQNameType (1362)
#endif

/* ns14__AttributedUnsignedLongType has binding name 'ns14__AttributedUnsignedLongType' for type 'ns14:AttributedUnsignedLongType' */
#ifndef SOAP_TYPE_ns14__AttributedUnsignedLongType
#define SOAP_TYPE_ns14__AttributedUnsignedLongType (1361)
#endif

/* ns14__AttributedURIType has binding name 'ns14__AttributedURIType' for type 'ns14:AttributedURIType' */
#ifndef SOAP_TYPE_ns14__AttributedURIType
#define SOAP_TYPE_ns14__AttributedURIType (1360)
#endif

/* ns14__RelatesToType has binding name 'ns14__RelatesToType' for type 'ns14:RelatesToType' */
#ifndef SOAP_TYPE_ns14__RelatesToType
#define SOAP_TYPE_ns14__RelatesToType (1359)
#endif

/* ns14__MetadataType has binding name 'ns14__MetadataType' for type 'ns14:MetadataType' */
#ifndef SOAP_TYPE_ns14__MetadataType
#define SOAP_TYPE_ns14__MetadataType (1358)
#endif

/* ns14__ReferenceParametersType has binding name 'ns14__ReferenceParametersType' for type 'ns14:ReferenceParametersType' */
#ifndef SOAP_TYPE_ns14__ReferenceParametersType
#define SOAP_TYPE_ns14__ReferenceParametersType (1357)
#endif

/* ns14__EndpointReferenceType has binding name 'ns14__EndpointReferenceType' for type 'ns14:EndpointReferenceType' */
#ifndef SOAP_TYPE_ns14__EndpointReferenceType
#define SOAP_TYPE_ns14__EndpointReferenceType (1356)
#endif

/* ns13__Attribute has binding name 'ns13__Attribute' for type 'ns13:Attribute' */
#ifndef SOAP_TYPE_ns13__Attribute
#define SOAP_TYPE_ns13__Attribute (1355)
#endif

/* ns13__DataEntity has binding name 'ns13__DataEntity' for type 'ns13:DataEntity' */
#ifndef SOAP_TYPE_ns13__DataEntity
#define SOAP_TYPE_ns13__DataEntity (1354)
#endif

/* _ns12__DeleteCredentialAccessProfilesResponse has binding name '_ns12__DeleteCredentialAccessProfilesResponse' for type '' */
#ifndef SOAP_TYPE__ns12__DeleteCredentialAccessProfilesResponse
#define SOAP_TYPE__ns12__DeleteCredentialAccessProfilesResponse (1353)
#endif

/* _ns12__DeleteCredentialAccessProfiles has binding name '_ns12__DeleteCredentialAccessProfiles' for type '' */
#ifndef SOAP_TYPE__ns12__DeleteCredentialAccessProfiles
#define SOAP_TYPE__ns12__DeleteCredentialAccessProfiles (1352)
#endif

/* _ns12__SetCredentialAccessProfilesResponse has binding name '_ns12__SetCredentialAccessProfilesResponse' for type '' */
#ifndef SOAP_TYPE__ns12__SetCredentialAccessProfilesResponse
#define SOAP_TYPE__ns12__SetCredentialAccessProfilesResponse (1351)
#endif

/* _ns12__SetCredentialAccessProfiles has binding name '_ns12__SetCredentialAccessProfiles' for type '' */
#ifndef SOAP_TYPE__ns12__SetCredentialAccessProfiles
#define SOAP_TYPE__ns12__SetCredentialAccessProfiles (1350)
#endif

/* _ns12__GetCredentialAccessProfilesResponse has binding name '_ns12__GetCredentialAccessProfilesResponse' for type '' */
#ifndef SOAP_TYPE__ns12__GetCredentialAccessProfilesResponse
#define SOAP_TYPE__ns12__GetCredentialAccessProfilesResponse (1349)
#endif

/* _ns12__GetCredentialAccessProfiles has binding name '_ns12__GetCredentialAccessProfiles' for type '' */
#ifndef SOAP_TYPE__ns12__GetCredentialAccessProfiles
#define SOAP_TYPE__ns12__GetCredentialAccessProfiles (1348)
#endif

/* _ns12__DeleteCredentialIdentifierResponse has binding name '_ns12__DeleteCredentialIdentifierResponse' for type '' */
#ifndef SOAP_TYPE__ns12__DeleteCredentialIdentifierResponse
#define SOAP_TYPE__ns12__DeleteCredentialIdentifierResponse (1347)
#endif

/* _ns12__DeleteCredentialIdentifier has binding name '_ns12__DeleteCredentialIdentifier' for type '' */
#ifndef SOAP_TYPE__ns12__DeleteCredentialIdentifier
#define SOAP_TYPE__ns12__DeleteCredentialIdentifier (1346)
#endif

/* _ns12__SetCredentialIdentifierResponse has binding name '_ns12__SetCredentialIdentifierResponse' for type '' */
#ifndef SOAP_TYPE__ns12__SetCredentialIdentifierResponse
#define SOAP_TYPE__ns12__SetCredentialIdentifierResponse (1345)
#endif

/* _ns12__SetCredentialIdentifier has binding name '_ns12__SetCredentialIdentifier' for type '' */
#ifndef SOAP_TYPE__ns12__SetCredentialIdentifier
#define SOAP_TYPE__ns12__SetCredentialIdentifier (1344)
#endif

/* _ns12__GetCredentialIdentifiersResponse has binding name '_ns12__GetCredentialIdentifiersResponse' for type '' */
#ifndef SOAP_TYPE__ns12__GetCredentialIdentifiersResponse
#define SOAP_TYPE__ns12__GetCredentialIdentifiersResponse (1343)
#endif

/* _ns12__GetCredentialIdentifiers has binding name '_ns12__GetCredentialIdentifiers' for type '' */
#ifndef SOAP_TYPE__ns12__GetCredentialIdentifiers
#define SOAP_TYPE__ns12__GetCredentialIdentifiers (1342)
#endif

/* _ns12__ResetAntipassbackViolationResponse has binding name '_ns12__ResetAntipassbackViolationResponse' for type '' */
#ifndef SOAP_TYPE__ns12__ResetAntipassbackViolationResponse
#define SOAP_TYPE__ns12__ResetAntipassbackViolationResponse (1341)
#endif

/* _ns12__ResetAntipassbackViolation has binding name '_ns12__ResetAntipassbackViolation' for type '' */
#ifndef SOAP_TYPE__ns12__ResetAntipassbackViolation
#define SOAP_TYPE__ns12__ResetAntipassbackViolation (1340)
#endif

/* _ns12__DisableCredentialResponse has binding name '_ns12__DisableCredentialResponse' for type '' */
#ifndef SOAP_TYPE__ns12__DisableCredentialResponse
#define SOAP_TYPE__ns12__DisableCredentialResponse (1339)
#endif

/* _ns12__DisableCredential has binding name '_ns12__DisableCredential' for type '' */
#ifndef SOAP_TYPE__ns12__DisableCredential
#define SOAP_TYPE__ns12__DisableCredential (1338)
#endif

/* _ns12__EnableCredentialResponse has binding name '_ns12__EnableCredentialResponse' for type '' */
#ifndef SOAP_TYPE__ns12__EnableCredentialResponse
#define SOAP_TYPE__ns12__EnableCredentialResponse (1337)
#endif

/* _ns12__EnableCredential has binding name '_ns12__EnableCredential' for type '' */
#ifndef SOAP_TYPE__ns12__EnableCredential
#define SOAP_TYPE__ns12__EnableCredential (1336)
#endif

/* _ns12__GetCredentialStateResponse has binding name '_ns12__GetCredentialStateResponse' for type '' */
#ifndef SOAP_TYPE__ns12__GetCredentialStateResponse
#define SOAP_TYPE__ns12__GetCredentialStateResponse (1335)
#endif

/* _ns12__GetCredentialState has binding name '_ns12__GetCredentialState' for type '' */
#ifndef SOAP_TYPE__ns12__GetCredentialState
#define SOAP_TYPE__ns12__GetCredentialState (1334)
#endif

/* _ns12__DeleteCredentialResponse has binding name '_ns12__DeleteCredentialResponse' for type '' */
#ifndef SOAP_TYPE__ns12__DeleteCredentialResponse
#define SOAP_TYPE__ns12__DeleteCredentialResponse (1333)
#endif

/* _ns12__DeleteCredential has binding name '_ns12__DeleteCredential' for type '' */
#ifndef SOAP_TYPE__ns12__DeleteCredential
#define SOAP_TYPE__ns12__DeleteCredential (1332)
#endif

/* _ns12__ModifyCredentialResponse has binding name '_ns12__ModifyCredentialResponse' for type '' */
#ifndef SOAP_TYPE__ns12__ModifyCredentialResponse
#define SOAP_TYPE__ns12__ModifyCredentialResponse (1331)
#endif

/* _ns12__ModifyCredential has binding name '_ns12__ModifyCredential' for type '' */
#ifndef SOAP_TYPE__ns12__ModifyCredential
#define SOAP_TYPE__ns12__ModifyCredential (1330)
#endif

/* _ns12__CreateCredentialResponse has binding name '_ns12__CreateCredentialResponse' for type '' */
#ifndef SOAP_TYPE__ns12__CreateCredentialResponse
#define SOAP_TYPE__ns12__CreateCredentialResponse (1329)
#endif

/* _ns12__CreateCredential has binding name '_ns12__CreateCredential' for type '' */
#ifndef SOAP_TYPE__ns12__CreateCredential
#define SOAP_TYPE__ns12__CreateCredential (1328)
#endif

/* _ns12__GetCredentialListResponse has binding name '_ns12__GetCredentialListResponse' for type '' */
#ifndef SOAP_TYPE__ns12__GetCredentialListResponse
#define SOAP_TYPE__ns12__GetCredentialListResponse (1327)
#endif

/* _ns12__GetCredentialList has binding name '_ns12__GetCredentialList' for type '' */
#ifndef SOAP_TYPE__ns12__GetCredentialList
#define SOAP_TYPE__ns12__GetCredentialList (1326)
#endif

/* _ns12__GetCredentialsResponse has binding name '_ns12__GetCredentialsResponse' for type '' */
#ifndef SOAP_TYPE__ns12__GetCredentialsResponse
#define SOAP_TYPE__ns12__GetCredentialsResponse (1325)
#endif

/* _ns12__GetCredentials has binding name '_ns12__GetCredentials' for type '' */
#ifndef SOAP_TYPE__ns12__GetCredentials
#define SOAP_TYPE__ns12__GetCredentials (1324)
#endif

/* _ns12__GetCredentialInfoListResponse has binding name '_ns12__GetCredentialInfoListResponse' for type '' */
#ifndef SOAP_TYPE__ns12__GetCredentialInfoListResponse
#define SOAP_TYPE__ns12__GetCredentialInfoListResponse (1323)
#endif

/* _ns12__GetCredentialInfoList has binding name '_ns12__GetCredentialInfoList' for type '' */
#ifndef SOAP_TYPE__ns12__GetCredentialInfoList
#define SOAP_TYPE__ns12__GetCredentialInfoList (1322)
#endif

/* _ns12__GetCredentialInfoResponse has binding name '_ns12__GetCredentialInfoResponse' for type '' */
#ifndef SOAP_TYPE__ns12__GetCredentialInfoResponse
#define SOAP_TYPE__ns12__GetCredentialInfoResponse (1321)
#endif

/* _ns12__GetCredentialInfo has binding name '_ns12__GetCredentialInfo' for type '' */
#ifndef SOAP_TYPE__ns12__GetCredentialInfo
#define SOAP_TYPE__ns12__GetCredentialInfo (1320)
#endif

/* _ns12__GetSupportedFormatTypesResponse has binding name '_ns12__GetSupportedFormatTypesResponse' for type '' */
#ifndef SOAP_TYPE__ns12__GetSupportedFormatTypesResponse
#define SOAP_TYPE__ns12__GetSupportedFormatTypesResponse (1319)
#endif

/* _ns12__GetSupportedFormatTypes has binding name '_ns12__GetSupportedFormatTypes' for type '' */
#ifndef SOAP_TYPE__ns12__GetSupportedFormatTypes
#define SOAP_TYPE__ns12__GetSupportedFormatTypes (1318)
#endif

/* _ns12__GetServiceCapabilitiesResponse has binding name '_ns12__GetServiceCapabilitiesResponse' for type '' */
#ifndef SOAP_TYPE__ns12__GetServiceCapabilitiesResponse
#define SOAP_TYPE__ns12__GetServiceCapabilitiesResponse (1317)
#endif

/* _ns12__GetServiceCapabilities has binding name '_ns12__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE__ns12__GetServiceCapabilities
#define SOAP_TYPE__ns12__GetServiceCapabilities (1316)
#endif

/* ns12__CredentialIdentifierFormatTypeInfoExtension has binding name 'ns12__CredentialIdentifierFormatTypeInfoExtension' for type 'ns12:CredentialIdentifierFormatTypeInfoExtension' */
#ifndef SOAP_TYPE_ns12__CredentialIdentifierFormatTypeInfoExtension
#define SOAP_TYPE_ns12__CredentialIdentifierFormatTypeInfoExtension (1315)
#endif

/* ns12__CredentialIdentifierFormatTypeInfo has binding name 'ns12__CredentialIdentifierFormatTypeInfo' for type 'ns12:CredentialIdentifierFormatTypeInfo' */
#ifndef SOAP_TYPE_ns12__CredentialIdentifierFormatTypeInfo
#define SOAP_TYPE_ns12__CredentialIdentifierFormatTypeInfo (1314)
#endif

/* ns12__AntipassbackState has binding name 'ns12__AntipassbackState' for type 'ns12:AntipassbackState' */
#ifndef SOAP_TYPE_ns12__AntipassbackState
#define SOAP_TYPE_ns12__AntipassbackState (1313)
#endif

/* ns12__CredentialStateExtension has binding name 'ns12__CredentialStateExtension' for type 'ns12:CredentialStateExtension' */
#ifndef SOAP_TYPE_ns12__CredentialStateExtension
#define SOAP_TYPE_ns12__CredentialStateExtension (1312)
#endif

/* ns12__CredentialState has binding name 'ns12__CredentialState' for type 'ns12:CredentialState' */
#ifndef SOAP_TYPE_ns12__CredentialState
#define SOAP_TYPE_ns12__CredentialState (1311)
#endif

/* ns12__CredentialAccessProfile has binding name 'ns12__CredentialAccessProfile' for type 'ns12:CredentialAccessProfile' */
#ifndef SOAP_TYPE_ns12__CredentialAccessProfile
#define SOAP_TYPE_ns12__CredentialAccessProfile (1310)
#endif

/* ns12__CredentialIdentifierType has binding name 'ns12__CredentialIdentifierType' for type 'ns12:CredentialIdentifierType' */
#ifndef SOAP_TYPE_ns12__CredentialIdentifierType
#define SOAP_TYPE_ns12__CredentialIdentifierType (1309)
#endif

/* ns12__CredentialIdentifier has binding name 'ns12__CredentialIdentifier' for type 'ns12:CredentialIdentifier' */
#ifndef SOAP_TYPE_ns12__CredentialIdentifier
#define SOAP_TYPE_ns12__CredentialIdentifier (1308)
#endif

/* ns12__CredentialExtension has binding name 'ns12__CredentialExtension' for type 'ns12:CredentialExtension' */
#ifndef SOAP_TYPE_ns12__CredentialExtension
#define SOAP_TYPE_ns12__CredentialExtension (1307)
#endif

/* ns12__Credential has binding name 'ns12__Credential' for type 'ns12:Credential' */
#ifndef SOAP_TYPE_ns12__Credential
#define SOAP_TYPE_ns12__Credential (1306)
#endif

/* ns12__CredentialInfo has binding name 'ns12__CredentialInfo' for type 'ns12:CredentialInfo' */
#ifndef SOAP_TYPE_ns12__CredentialInfo
#define SOAP_TYPE_ns12__CredentialInfo (1305)
#endif

/* ns12__ServiceCapabilitiesExtension has binding name 'ns12__ServiceCapabilitiesExtension' for type 'ns12:ServiceCapabilitiesExtension' */
#ifndef SOAP_TYPE_ns12__ServiceCapabilitiesExtension
#define SOAP_TYPE_ns12__ServiceCapabilitiesExtension (1304)
#endif

/* ns12__ServiceCapabilities has binding name 'ns12__ServiceCapabilities' for type 'ns12:ServiceCapabilities' */
#ifndef SOAP_TYPE_ns12__ServiceCapabilities
#define SOAP_TYPE_ns12__ServiceCapabilities (1303)
#endif

/* _ns11__GetCompatibleConfigurationsResponse has binding name '_ns11__GetCompatibleConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns11__GetCompatibleConfigurationsResponse
#define SOAP_TYPE__ns11__GetCompatibleConfigurationsResponse (1302)
#endif

/* _ns11__GetCompatibleConfigurations has binding name '_ns11__GetCompatibleConfigurations' for type '' */
#ifndef SOAP_TYPE__ns11__GetCompatibleConfigurations
#define SOAP_TYPE__ns11__GetCompatibleConfigurations (1301)
#endif

/* _ns11__RemovePresetTourResponse has binding name '_ns11__RemovePresetTourResponse' for type '' */
#ifndef SOAP_TYPE__ns11__RemovePresetTourResponse
#define SOAP_TYPE__ns11__RemovePresetTourResponse (1300)
#endif

/* _ns11__RemovePresetTour has binding name '_ns11__RemovePresetTour' for type '' */
#ifndef SOAP_TYPE__ns11__RemovePresetTour
#define SOAP_TYPE__ns11__RemovePresetTour (1299)
#endif

/* _ns11__OperatePresetTourResponse has binding name '_ns11__OperatePresetTourResponse' for type '' */
#ifndef SOAP_TYPE__ns11__OperatePresetTourResponse
#define SOAP_TYPE__ns11__OperatePresetTourResponse (1298)
#endif

/* _ns11__OperatePresetTour has binding name '_ns11__OperatePresetTour' for type '' */
#ifndef SOAP_TYPE__ns11__OperatePresetTour
#define SOAP_TYPE__ns11__OperatePresetTour (1297)
#endif

/* _ns11__ModifyPresetTourResponse has binding name '_ns11__ModifyPresetTourResponse' for type '' */
#ifndef SOAP_TYPE__ns11__ModifyPresetTourResponse
#define SOAP_TYPE__ns11__ModifyPresetTourResponse (1296)
#endif

/* _ns11__ModifyPresetTour has binding name '_ns11__ModifyPresetTour' for type '' */
#ifndef SOAP_TYPE__ns11__ModifyPresetTour
#define SOAP_TYPE__ns11__ModifyPresetTour (1295)
#endif

/* _ns11__CreatePresetTourResponse has binding name '_ns11__CreatePresetTourResponse' for type '' */
#ifndef SOAP_TYPE__ns11__CreatePresetTourResponse
#define SOAP_TYPE__ns11__CreatePresetTourResponse (1294)
#endif

/* _ns11__CreatePresetTour has binding name '_ns11__CreatePresetTour' for type '' */
#ifndef SOAP_TYPE__ns11__CreatePresetTour
#define SOAP_TYPE__ns11__CreatePresetTour (1293)
#endif

/* _ns11__GetPresetTourOptionsResponse has binding name '_ns11__GetPresetTourOptionsResponse' for type '' */
#ifndef SOAP_TYPE__ns11__GetPresetTourOptionsResponse
#define SOAP_TYPE__ns11__GetPresetTourOptionsResponse (1292)
#endif

/* _ns11__GetPresetTourOptions has binding name '_ns11__GetPresetTourOptions' for type '' */
#ifndef SOAP_TYPE__ns11__GetPresetTourOptions
#define SOAP_TYPE__ns11__GetPresetTourOptions (1291)
#endif

/* _ns11__GetPresetTourResponse has binding name '_ns11__GetPresetTourResponse' for type '' */
#ifndef SOAP_TYPE__ns11__GetPresetTourResponse
#define SOAP_TYPE__ns11__GetPresetTourResponse (1290)
#endif

/* _ns11__GetPresetTour has binding name '_ns11__GetPresetTour' for type '' */
#ifndef SOAP_TYPE__ns11__GetPresetTour
#define SOAP_TYPE__ns11__GetPresetTour (1289)
#endif

/* _ns11__GetPresetToursResponse has binding name '_ns11__GetPresetToursResponse' for type '' */
#ifndef SOAP_TYPE__ns11__GetPresetToursResponse
#define SOAP_TYPE__ns11__GetPresetToursResponse (1288)
#endif

/* _ns11__GetPresetTours has binding name '_ns11__GetPresetTours' for type '' */
#ifndef SOAP_TYPE__ns11__GetPresetTours
#define SOAP_TYPE__ns11__GetPresetTours (1287)
#endif

/* _ns11__StopResponse has binding name '_ns11__StopResponse' for type '' */
#ifndef SOAP_TYPE__ns11__StopResponse
#define SOAP_TYPE__ns11__StopResponse (1286)
#endif

/* _ns11__Stop has binding name '_ns11__Stop' for type '' */
#ifndef SOAP_TYPE__ns11__Stop
#define SOAP_TYPE__ns11__Stop (1285)
#endif

/* _ns11__AbsoluteMoveResponse has binding name '_ns11__AbsoluteMoveResponse' for type '' */
#ifndef SOAP_TYPE__ns11__AbsoluteMoveResponse
#define SOAP_TYPE__ns11__AbsoluteMoveResponse (1284)
#endif

/* _ns11__AbsoluteMove has binding name '_ns11__AbsoluteMove' for type '' */
#ifndef SOAP_TYPE__ns11__AbsoluteMove
#define SOAP_TYPE__ns11__AbsoluteMove (1283)
#endif

/* _ns11__RelativeMoveResponse has binding name '_ns11__RelativeMoveResponse' for type '' */
#ifndef SOAP_TYPE__ns11__RelativeMoveResponse
#define SOAP_TYPE__ns11__RelativeMoveResponse (1282)
#endif

/* _ns11__RelativeMove has binding name '_ns11__RelativeMove' for type '' */
#ifndef SOAP_TYPE__ns11__RelativeMove
#define SOAP_TYPE__ns11__RelativeMove (1281)
#endif

/* _ns11__ContinuousMoveResponse has binding name '_ns11__ContinuousMoveResponse' for type '' */
#ifndef SOAP_TYPE__ns11__ContinuousMoveResponse
#define SOAP_TYPE__ns11__ContinuousMoveResponse (1280)
#endif

/* _ns11__ContinuousMove has binding name '_ns11__ContinuousMove' for type '' */
#ifndef SOAP_TYPE__ns11__ContinuousMove
#define SOAP_TYPE__ns11__ContinuousMove (1279)
#endif

/* _ns11__SetHomePositionResponse has binding name '_ns11__SetHomePositionResponse' for type '' */
#ifndef SOAP_TYPE__ns11__SetHomePositionResponse
#define SOAP_TYPE__ns11__SetHomePositionResponse (1278)
#endif

/* _ns11__SetHomePosition has binding name '_ns11__SetHomePosition' for type '' */
#ifndef SOAP_TYPE__ns11__SetHomePosition
#define SOAP_TYPE__ns11__SetHomePosition (1277)
#endif

/* _ns11__GotoHomePositionResponse has binding name '_ns11__GotoHomePositionResponse' for type '' */
#ifndef SOAP_TYPE__ns11__GotoHomePositionResponse
#define SOAP_TYPE__ns11__GotoHomePositionResponse (1276)
#endif

/* _ns11__GotoHomePosition has binding name '_ns11__GotoHomePosition' for type '' */
#ifndef SOAP_TYPE__ns11__GotoHomePosition
#define SOAP_TYPE__ns11__GotoHomePosition (1275)
#endif

/* _ns11__GetStatusResponse has binding name '_ns11__GetStatusResponse' for type '' */
#ifndef SOAP_TYPE__ns11__GetStatusResponse
#define SOAP_TYPE__ns11__GetStatusResponse (1274)
#endif

/* _ns11__GetStatus has binding name '_ns11__GetStatus' for type '' */
#ifndef SOAP_TYPE__ns11__GetStatus
#define SOAP_TYPE__ns11__GetStatus (1273)
#endif

/* _ns11__GotoPresetResponse has binding name '_ns11__GotoPresetResponse' for type '' */
#ifndef SOAP_TYPE__ns11__GotoPresetResponse
#define SOAP_TYPE__ns11__GotoPresetResponse (1272)
#endif

/* _ns11__GotoPreset has binding name '_ns11__GotoPreset' for type '' */
#ifndef SOAP_TYPE__ns11__GotoPreset
#define SOAP_TYPE__ns11__GotoPreset (1271)
#endif

/* _ns11__RemovePresetResponse has binding name '_ns11__RemovePresetResponse' for type '' */
#ifndef SOAP_TYPE__ns11__RemovePresetResponse
#define SOAP_TYPE__ns11__RemovePresetResponse (1270)
#endif

/* _ns11__RemovePreset has binding name '_ns11__RemovePreset' for type '' */
#ifndef SOAP_TYPE__ns11__RemovePreset
#define SOAP_TYPE__ns11__RemovePreset (1269)
#endif

/* _ns11__SetPresetResponse has binding name '_ns11__SetPresetResponse' for type '' */
#ifndef SOAP_TYPE__ns11__SetPresetResponse
#define SOAP_TYPE__ns11__SetPresetResponse (1268)
#endif

/* _ns11__SetPreset has binding name '_ns11__SetPreset' for type '' */
#ifndef SOAP_TYPE__ns11__SetPreset
#define SOAP_TYPE__ns11__SetPreset (1267)
#endif

/* _ns11__GetPresetsResponse has binding name '_ns11__GetPresetsResponse' for type '' */
#ifndef SOAP_TYPE__ns11__GetPresetsResponse
#define SOAP_TYPE__ns11__GetPresetsResponse (1266)
#endif

/* _ns11__GetPresets has binding name '_ns11__GetPresets' for type '' */
#ifndef SOAP_TYPE__ns11__GetPresets
#define SOAP_TYPE__ns11__GetPresets (1265)
#endif

/* _ns11__SendAuxiliaryCommandResponse has binding name '_ns11__SendAuxiliaryCommandResponse' for type '' */
#ifndef SOAP_TYPE__ns11__SendAuxiliaryCommandResponse
#define SOAP_TYPE__ns11__SendAuxiliaryCommandResponse (1264)
#endif

/* _ns11__SendAuxiliaryCommand has binding name '_ns11__SendAuxiliaryCommand' for type '' */
#ifndef SOAP_TYPE__ns11__SendAuxiliaryCommand
#define SOAP_TYPE__ns11__SendAuxiliaryCommand (1263)
#endif

/* _ns11__GetConfigurationOptionsResponse has binding name '_ns11__GetConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__ns11__GetConfigurationOptionsResponse
#define SOAP_TYPE__ns11__GetConfigurationOptionsResponse (1262)
#endif

/* _ns11__GetConfigurationOptions has binding name '_ns11__GetConfigurationOptions' for type '' */
#ifndef SOAP_TYPE__ns11__GetConfigurationOptions
#define SOAP_TYPE__ns11__GetConfigurationOptions (1261)
#endif

/* _ns11__SetConfigurationResponse has binding name '_ns11__SetConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns11__SetConfigurationResponse
#define SOAP_TYPE__ns11__SetConfigurationResponse (1260)
#endif

/* _ns11__SetConfiguration has binding name '_ns11__SetConfiguration' for type '' */
#ifndef SOAP_TYPE__ns11__SetConfiguration
#define SOAP_TYPE__ns11__SetConfiguration (1259)
#endif

/* _ns11__GetConfigurationResponse has binding name '_ns11__GetConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns11__GetConfigurationResponse
#define SOAP_TYPE__ns11__GetConfigurationResponse (1258)
#endif

/* _ns11__GetConfiguration has binding name '_ns11__GetConfiguration' for type '' */
#ifndef SOAP_TYPE__ns11__GetConfiguration
#define SOAP_TYPE__ns11__GetConfiguration (1257)
#endif

/* _ns11__GetConfigurationsResponse has binding name '_ns11__GetConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns11__GetConfigurationsResponse
#define SOAP_TYPE__ns11__GetConfigurationsResponse (1256)
#endif

/* _ns11__GetConfigurations has binding name '_ns11__GetConfigurations' for type '' */
#ifndef SOAP_TYPE__ns11__GetConfigurations
#define SOAP_TYPE__ns11__GetConfigurations (1255)
#endif

/* _ns11__GetNodeResponse has binding name '_ns11__GetNodeResponse' for type '' */
#ifndef SOAP_TYPE__ns11__GetNodeResponse
#define SOAP_TYPE__ns11__GetNodeResponse (1254)
#endif

/* _ns11__GetNode has binding name '_ns11__GetNode' for type '' */
#ifndef SOAP_TYPE__ns11__GetNode
#define SOAP_TYPE__ns11__GetNode (1253)
#endif

/* _ns11__GetNodesResponse has binding name '_ns11__GetNodesResponse' for type '' */
#ifndef SOAP_TYPE__ns11__GetNodesResponse
#define SOAP_TYPE__ns11__GetNodesResponse (1252)
#endif

/* _ns11__GetNodes has binding name '_ns11__GetNodes' for type '' */
#ifndef SOAP_TYPE__ns11__GetNodes
#define SOAP_TYPE__ns11__GetNodes (1251)
#endif

/* _ns11__GetServiceCapabilitiesResponse has binding name '_ns11__GetServiceCapabilitiesResponse' for type '' */
#ifndef SOAP_TYPE__ns11__GetServiceCapabilitiesResponse
#define SOAP_TYPE__ns11__GetServiceCapabilitiesResponse (1250)
#endif

/* _ns11__GetServiceCapabilities has binding name '_ns11__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE__ns11__GetServiceCapabilities
#define SOAP_TYPE__ns11__GetServiceCapabilities (1249)
#endif

/* ns11__Capabilities has binding name 'ns11__Capabilities' for type 'ns11:Capabilities' */
#ifndef SOAP_TYPE_ns11__Capabilities
#define SOAP_TYPE_ns11__Capabilities (1248)
#endif

/* _ns10__DeleteOSD has binding name '_ns10__DeleteOSD' for type '' */
#ifndef SOAP_TYPE__ns10__DeleteOSD
#define SOAP_TYPE__ns10__DeleteOSD (1247)
#endif

/* _ns10__CreateOSDResponse has binding name '_ns10__CreateOSDResponse' for type '' */
#ifndef SOAP_TYPE__ns10__CreateOSDResponse
#define SOAP_TYPE__ns10__CreateOSDResponse (1246)
#endif

/* _ns10__CreateOSD has binding name '_ns10__CreateOSD' for type '' */
#ifndef SOAP_TYPE__ns10__CreateOSD
#define SOAP_TYPE__ns10__CreateOSD (1245)
#endif

/* _ns10__GetOSDOptionsResponse has binding name '_ns10__GetOSDOptionsResponse' for type '' */
#ifndef SOAP_TYPE__ns10__GetOSDOptionsResponse
#define SOAP_TYPE__ns10__GetOSDOptionsResponse (1244)
#endif

/* _ns10__GetOSDOptions has binding name '_ns10__GetOSDOptions' for type '' */
#ifndef SOAP_TYPE__ns10__GetOSDOptions
#define SOAP_TYPE__ns10__GetOSDOptions (1243)
#endif

/* _ns10__SetOSD has binding name '_ns10__SetOSD' for type '' */
#ifndef SOAP_TYPE__ns10__SetOSD
#define SOAP_TYPE__ns10__SetOSD (1242)
#endif

/* _ns10__GetOSDsResponse has binding name '_ns10__GetOSDsResponse' for type '' */
#ifndef SOAP_TYPE__ns10__GetOSDsResponse
#define SOAP_TYPE__ns10__GetOSDsResponse (1241)
#endif

/* _ns10__GetOSDs has binding name '_ns10__GetOSDs' for type '' */
#ifndef SOAP_TYPE__ns10__GetOSDs
#define SOAP_TYPE__ns10__GetOSDs (1240)
#endif

/* _ns10__SetVideoSourceModeResponse has binding name '_ns10__SetVideoSourceModeResponse' for type '' */
#ifndef SOAP_TYPE__ns10__SetVideoSourceModeResponse
#define SOAP_TYPE__ns10__SetVideoSourceModeResponse (1239)
#endif

/* _ns10__SetVideoSourceMode has binding name '_ns10__SetVideoSourceMode' for type '' */
#ifndef SOAP_TYPE__ns10__SetVideoSourceMode
#define SOAP_TYPE__ns10__SetVideoSourceMode (1238)
#endif

/* _ns10__GetVideoSourceModesResponse has binding name '_ns10__GetVideoSourceModesResponse' for type '' */
#ifndef SOAP_TYPE__ns10__GetVideoSourceModesResponse
#define SOAP_TYPE__ns10__GetVideoSourceModesResponse (1237)
#endif

/* _ns10__GetVideoSourceModes has binding name '_ns10__GetVideoSourceModes' for type '' */
#ifndef SOAP_TYPE__ns10__GetVideoSourceModes
#define SOAP_TYPE__ns10__GetVideoSourceModes (1236)
#endif

/* _ns10__StartStopMulticastStreamingResponse has binding name '_ns10__StartStopMulticastStreamingResponse' for type '' */
#ifndef SOAP_TYPE__ns10__StartStopMulticastStreamingResponse
#define SOAP_TYPE__ns10__StartStopMulticastStreamingResponse (1235)
#endif

/* _ns10__GetSnapshotUriResponse has binding name '_ns10__GetSnapshotUriResponse' for type '' */
#ifndef SOAP_TYPE__ns10__GetSnapshotUriResponse
#define SOAP_TYPE__ns10__GetSnapshotUriResponse (1234)
#endif

/* _ns10__GetSnapshotUri has binding name '_ns10__GetSnapshotUri' for type '' */
#ifndef SOAP_TYPE__ns10__GetSnapshotUri
#define SOAP_TYPE__ns10__GetSnapshotUri (1233)
#endif

/* _ns10__SetSynchronizationPointResponse has binding name '_ns10__SetSynchronizationPointResponse' for type '' */
#ifndef SOAP_TYPE__ns10__SetSynchronizationPointResponse
#define SOAP_TYPE__ns10__SetSynchronizationPointResponse (1232)
#endif

/* _ns10__SetSynchronizationPoint has binding name '_ns10__SetSynchronizationPoint' for type '' */
#ifndef SOAP_TYPE__ns10__SetSynchronizationPoint
#define SOAP_TYPE__ns10__SetSynchronizationPoint (1231)
#endif

/* _ns10__GetStreamUriResponse has binding name '_ns10__GetStreamUriResponse' for type '' */
#ifndef SOAP_TYPE__ns10__GetStreamUriResponse
#define SOAP_TYPE__ns10__GetStreamUriResponse (1230)
#endif

/* _ns10__GetStreamUri has binding name '_ns10__GetStreamUri' for type '' */
#ifndef SOAP_TYPE__ns10__GetStreamUri
#define SOAP_TYPE__ns10__GetStreamUri (1229)
#endif

/* _ns10__GetVideoEncoderInstancesResponse has binding name '_ns10__GetVideoEncoderInstancesResponse' for type '' */
#ifndef SOAP_TYPE__ns10__GetVideoEncoderInstancesResponse
#define SOAP_TYPE__ns10__GetVideoEncoderInstancesResponse (1228)
#endif

/* _ns10__GetVideoEncoderInstances has binding name '_ns10__GetVideoEncoderInstances' for type '' */
#ifndef SOAP_TYPE__ns10__GetVideoEncoderInstances
#define SOAP_TYPE__ns10__GetVideoEncoderInstances (1227)
#endif

/* _ns10__GetAudioDecoderConfigurationOptionsResponse has binding name '_ns10__GetAudioDecoderConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__ns10__GetAudioDecoderConfigurationOptionsResponse
#define SOAP_TYPE__ns10__GetAudioDecoderConfigurationOptionsResponse (1226)
#endif

/* _ns10__GetAudioOutputConfigurationOptionsResponse has binding name '_ns10__GetAudioOutputConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__ns10__GetAudioOutputConfigurationOptionsResponse
#define SOAP_TYPE__ns10__GetAudioOutputConfigurationOptionsResponse (1225)
#endif

/* _ns10__GetMetadataConfigurationOptionsResponse has binding name '_ns10__GetMetadataConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__ns10__GetMetadataConfigurationOptionsResponse
#define SOAP_TYPE__ns10__GetMetadataConfigurationOptionsResponse (1224)
#endif

/* _ns10__GetAudioEncoderConfigurationOptionsResponse has binding name '_ns10__GetAudioEncoderConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__ns10__GetAudioEncoderConfigurationOptionsResponse
#define SOAP_TYPE__ns10__GetAudioEncoderConfigurationOptionsResponse (1223)
#endif

/* _ns10__GetAudioSourceConfigurationOptionsResponse has binding name '_ns10__GetAudioSourceConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__ns10__GetAudioSourceConfigurationOptionsResponse
#define SOAP_TYPE__ns10__GetAudioSourceConfigurationOptionsResponse (1222)
#endif

/* _ns10__GetVideoEncoderConfigurationOptionsResponse has binding name '_ns10__GetVideoEncoderConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__ns10__GetVideoEncoderConfigurationOptionsResponse
#define SOAP_TYPE__ns10__GetVideoEncoderConfigurationOptionsResponse (1221)
#endif

/* _ns10__GetVideoSourceConfigurationOptionsResponse has binding name '_ns10__GetVideoSourceConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__ns10__GetVideoSourceConfigurationOptionsResponse
#define SOAP_TYPE__ns10__GetVideoSourceConfigurationOptionsResponse (1220)
#endif

/* _ns10__SetAudioDecoderConfiguration has binding name '_ns10__SetAudioDecoderConfiguration' for type '' */
#ifndef SOAP_TYPE__ns10__SetAudioDecoderConfiguration
#define SOAP_TYPE__ns10__SetAudioDecoderConfiguration (1219)
#endif

/* _ns10__SetAudioOutputConfiguration has binding name '_ns10__SetAudioOutputConfiguration' for type '' */
#ifndef SOAP_TYPE__ns10__SetAudioOutputConfiguration
#define SOAP_TYPE__ns10__SetAudioOutputConfiguration (1218)
#endif

/* _ns10__SetMetadataConfiguration has binding name '_ns10__SetMetadataConfiguration' for type '' */
#ifndef SOAP_TYPE__ns10__SetMetadataConfiguration
#define SOAP_TYPE__ns10__SetMetadataConfiguration (1217)
#endif

/* _ns10__SetAudioSourceConfiguration has binding name '_ns10__SetAudioSourceConfiguration' for type '' */
#ifndef SOAP_TYPE__ns10__SetAudioSourceConfiguration
#define SOAP_TYPE__ns10__SetAudioSourceConfiguration (1216)
#endif

/* _ns10__SetAudioEncoderConfiguration has binding name '_ns10__SetAudioEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE__ns10__SetAudioEncoderConfiguration
#define SOAP_TYPE__ns10__SetAudioEncoderConfiguration (1215)
#endif

/* _ns10__SetVideoSourceConfiguration has binding name '_ns10__SetVideoSourceConfiguration' for type '' */
#ifndef SOAP_TYPE__ns10__SetVideoSourceConfiguration
#define SOAP_TYPE__ns10__SetVideoSourceConfiguration (1214)
#endif

/* _ns10__SetConfigurationResponse has binding name '_ns10__SetConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns10__SetConfigurationResponse
#define SOAP_TYPE__ns10__SetConfigurationResponse (1213)
#endif

/* _ns10__SetVideoEncoderConfiguration has binding name '_ns10__SetVideoEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE__ns10__SetVideoEncoderConfiguration
#define SOAP_TYPE__ns10__SetVideoEncoderConfiguration (1212)
#endif

/* _ns10__GetAudioDecoderConfigurationsResponse has binding name '_ns10__GetAudioDecoderConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns10__GetAudioDecoderConfigurationsResponse
#define SOAP_TYPE__ns10__GetAudioDecoderConfigurationsResponse (1211)
#endif

/* _ns10__GetAudioOutputConfigurationsResponse has binding name '_ns10__GetAudioOutputConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns10__GetAudioOutputConfigurationsResponse
#define SOAP_TYPE__ns10__GetAudioOutputConfigurationsResponse (1210)
#endif

/* _ns10__GetMetadataConfigurationsResponse has binding name '_ns10__GetMetadataConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns10__GetMetadataConfigurationsResponse
#define SOAP_TYPE__ns10__GetMetadataConfigurationsResponse (1209)
#endif

/* _ns10__GetAnalyticsConfigurationsResponse has binding name '_ns10__GetAnalyticsConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns10__GetAnalyticsConfigurationsResponse
#define SOAP_TYPE__ns10__GetAnalyticsConfigurationsResponse (1208)
#endif

/* _ns10__GetAudioSourceConfigurationsResponse has binding name '_ns10__GetAudioSourceConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns10__GetAudioSourceConfigurationsResponse
#define SOAP_TYPE__ns10__GetAudioSourceConfigurationsResponse (1207)
#endif

/* _ns10__GetAudioEncoderConfigurationsResponse has binding name '_ns10__GetAudioEncoderConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns10__GetAudioEncoderConfigurationsResponse
#define SOAP_TYPE__ns10__GetAudioEncoderConfigurationsResponse (1206)
#endif

/* _ns10__GetVideoSourceConfigurationsResponse has binding name '_ns10__GetVideoSourceConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns10__GetVideoSourceConfigurationsResponse
#define SOAP_TYPE__ns10__GetVideoSourceConfigurationsResponse (1205)
#endif

/* _ns10__GetVideoEncoderConfigurationsResponse has binding name '_ns10__GetVideoEncoderConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns10__GetVideoEncoderConfigurationsResponse
#define SOAP_TYPE__ns10__GetVideoEncoderConfigurationsResponse (1204)
#endif

/* _ns10__DeleteProfileResponse has binding name '_ns10__DeleteProfileResponse' for type '' */
#ifndef SOAP_TYPE__ns10__DeleteProfileResponse
#define SOAP_TYPE__ns10__DeleteProfileResponse (1203)
#endif

/* _ns10__DeleteProfile has binding name '_ns10__DeleteProfile' for type '' */
#ifndef SOAP_TYPE__ns10__DeleteProfile
#define SOAP_TYPE__ns10__DeleteProfile (1202)
#endif

/* _ns10__RemoveConfigurationResponse has binding name '_ns10__RemoveConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns10__RemoveConfigurationResponse
#define SOAP_TYPE__ns10__RemoveConfigurationResponse (1201)
#endif

/* _ns10__RemoveConfiguration has binding name '_ns10__RemoveConfiguration' for type '' */
#ifndef SOAP_TYPE__ns10__RemoveConfiguration
#define SOAP_TYPE__ns10__RemoveConfiguration (1200)
#endif

/* _ns10__AddConfigurationResponse has binding name '_ns10__AddConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns10__AddConfigurationResponse
#define SOAP_TYPE__ns10__AddConfigurationResponse (1199)
#endif

/* _ns10__AddConfiguration has binding name '_ns10__AddConfiguration' for type '' */
#ifndef SOAP_TYPE__ns10__AddConfiguration
#define SOAP_TYPE__ns10__AddConfiguration (1198)
#endif

/* _ns10__GetProfilesResponse has binding name '_ns10__GetProfilesResponse' for type '' */
#ifndef SOAP_TYPE__ns10__GetProfilesResponse
#define SOAP_TYPE__ns10__GetProfilesResponse (1197)
#endif

/* _ns10__GetProfiles has binding name '_ns10__GetProfiles' for type '' */
#ifndef SOAP_TYPE__ns10__GetProfiles
#define SOAP_TYPE__ns10__GetProfiles (1196)
#endif

/* _ns10__CreateProfileResponse has binding name '_ns10__CreateProfileResponse' for type '' */
#ifndef SOAP_TYPE__ns10__CreateProfileResponse
#define SOAP_TYPE__ns10__CreateProfileResponse (1195)
#endif

/* _ns10__CreateProfile has binding name '_ns10__CreateProfile' for type '' */
#ifndef SOAP_TYPE__ns10__CreateProfile
#define SOAP_TYPE__ns10__CreateProfile (1194)
#endif

/* _ns10__GetServiceCapabilitiesResponse2 has binding name '_ns10__GetServiceCapabilitiesResponse2' for type '' */
#ifndef SOAP_TYPE__ns10__GetServiceCapabilitiesResponse2
#define SOAP_TYPE__ns10__GetServiceCapabilitiesResponse2 (1193)
#endif

/* _ns10__GetServiceCapabilities has binding name '_ns10__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE__ns10__GetServiceCapabilities
#define SOAP_TYPE__ns10__GetServiceCapabilities (1192)
#endif

/* ns10__VideoSourceMode has binding name 'ns10__VideoSourceMode' for type 'ns10:VideoSourceMode' */
#ifndef SOAP_TYPE_ns10__VideoSourceMode
#define SOAP_TYPE_ns10__VideoSourceMode (1191)
#endif

/* ns10__StartStopMulticastStreaming has binding name 'ns10__StartStopMulticastStreaming' for type 'ns10:StartStopMulticastStreaming' */
#ifndef SOAP_TYPE_ns10__StartStopMulticastStreaming
#define SOAP_TYPE_ns10__StartStopMulticastStreaming (1190)
#endif

/* ns10__EncoderInstanceInfo has binding name 'ns10__EncoderInstanceInfo' for type 'ns10:EncoderInstanceInfo' */
#ifndef SOAP_TYPE_ns10__EncoderInstanceInfo
#define SOAP_TYPE_ns10__EncoderInstanceInfo (1189)
#endif

/* ns10__EncoderInstance has binding name 'ns10__EncoderInstance' for type 'ns10:EncoderInstance' */
#ifndef SOAP_TYPE_ns10__EncoderInstance
#define SOAP_TYPE_ns10__EncoderInstance (1188)
#endif

/* ns10__GetConfiguration has binding name 'ns10__GetConfiguration' for type 'ns10:GetConfiguration' */
#ifndef SOAP_TYPE_ns10__GetConfiguration
#define SOAP_TYPE_ns10__GetConfiguration (1187)
#endif

/* ns10__MediaProfile has binding name 'ns10__MediaProfile' for type 'ns10:MediaProfile' */
#ifndef SOAP_TYPE_ns10__MediaProfile
#define SOAP_TYPE_ns10__MediaProfile (1186)
#endif

/* ns10__ConfigurationSet has binding name 'ns10__ConfigurationSet' for type 'ns10:ConfigurationSet' */
#ifndef SOAP_TYPE_ns10__ConfigurationSet
#define SOAP_TYPE_ns10__ConfigurationSet (1185)
#endif

/* ns10__ConfigurationRef has binding name 'ns10__ConfigurationRef' for type 'ns10:ConfigurationRef' */
#ifndef SOAP_TYPE_ns10__ConfigurationRef
#define SOAP_TYPE_ns10__ConfigurationRef (1184)
#endif

/* ns10__StreamingCapabilities has binding name 'ns10__StreamingCapabilities' for type 'ns10:StreamingCapabilities' */
#ifndef SOAP_TYPE_ns10__StreamingCapabilities
#define SOAP_TYPE_ns10__StreamingCapabilities (1183)
#endif

/* ns10__ProfileCapabilities has binding name 'ns10__ProfileCapabilities' for type 'ns10:ProfileCapabilities' */
#ifndef SOAP_TYPE_ns10__ProfileCapabilities
#define SOAP_TYPE_ns10__ProfileCapabilities (1182)
#endif

/* ns10__Capabilities2 has binding name 'ns10__Capabilities2' for type 'ns10:Capabilities2' */
#ifndef SOAP_TYPE_ns10__Capabilities2
#define SOAP_TYPE_ns10__Capabilities2 (1181)
#endif

/* _ns9__DeleteOSDResponse has binding name '_ns9__DeleteOSDResponse' for type '' */
#ifndef SOAP_TYPE__ns9__DeleteOSDResponse
#define SOAP_TYPE__ns9__DeleteOSDResponse (1180)
#endif

/* _ns9__DeleteOSD has binding name '_ns9__DeleteOSD' for type '' */
#ifndef SOAP_TYPE__ns9__DeleteOSD
#define SOAP_TYPE__ns9__DeleteOSD (1179)
#endif

/* _ns9__CreateOSDResponse has binding name '_ns9__CreateOSDResponse' for type '' */
#ifndef SOAP_TYPE__ns9__CreateOSDResponse
#define SOAP_TYPE__ns9__CreateOSDResponse (1178)
#endif

/* _ns9__CreateOSD has binding name '_ns9__CreateOSD' for type '' */
#ifndef SOAP_TYPE__ns9__CreateOSD
#define SOAP_TYPE__ns9__CreateOSD (1177)
#endif

/* _ns9__GetOSDOptionsResponse has binding name '_ns9__GetOSDOptionsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetOSDOptionsResponse
#define SOAP_TYPE__ns9__GetOSDOptionsResponse (1176)
#endif

/* _ns9__GetOSDOptions has binding name '_ns9__GetOSDOptions' for type '' */
#ifndef SOAP_TYPE__ns9__GetOSDOptions
#define SOAP_TYPE__ns9__GetOSDOptions (1175)
#endif

/* _ns9__SetOSDResponse has binding name '_ns9__SetOSDResponse' for type '' */
#ifndef SOAP_TYPE__ns9__SetOSDResponse
#define SOAP_TYPE__ns9__SetOSDResponse (1174)
#endif

/* _ns9__SetOSD has binding name '_ns9__SetOSD' for type '' */
#ifndef SOAP_TYPE__ns9__SetOSD
#define SOAP_TYPE__ns9__SetOSD (1173)
#endif

/* _ns9__GetOSDResponse has binding name '_ns9__GetOSDResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetOSDResponse
#define SOAP_TYPE__ns9__GetOSDResponse (1172)
#endif

/* _ns9__GetOSD has binding name '_ns9__GetOSD' for type '' */
#ifndef SOAP_TYPE__ns9__GetOSD
#define SOAP_TYPE__ns9__GetOSD (1171)
#endif

/* _ns9__GetOSDsResponse has binding name '_ns9__GetOSDsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetOSDsResponse
#define SOAP_TYPE__ns9__GetOSDsResponse (1170)
#endif

/* _ns9__GetOSDs has binding name '_ns9__GetOSDs' for type '' */
#ifndef SOAP_TYPE__ns9__GetOSDs
#define SOAP_TYPE__ns9__GetOSDs (1169)
#endif

/* _ns9__SetVideoSourceModeResponse has binding name '_ns9__SetVideoSourceModeResponse' for type '' */
#ifndef SOAP_TYPE__ns9__SetVideoSourceModeResponse
#define SOAP_TYPE__ns9__SetVideoSourceModeResponse (1168)
#endif

/* _ns9__SetVideoSourceMode has binding name '_ns9__SetVideoSourceMode' for type '' */
#ifndef SOAP_TYPE__ns9__SetVideoSourceMode
#define SOAP_TYPE__ns9__SetVideoSourceMode (1167)
#endif

/* _ns9__GetVideoSourceModesResponse has binding name '_ns9__GetVideoSourceModesResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetVideoSourceModesResponse
#define SOAP_TYPE__ns9__GetVideoSourceModesResponse (1166)
#endif

/* _ns9__GetVideoSourceModes has binding name '_ns9__GetVideoSourceModes' for type '' */
#ifndef SOAP_TYPE__ns9__GetVideoSourceModes
#define SOAP_TYPE__ns9__GetVideoSourceModes (1165)
#endif

/* _ns9__GetSnapshotUriResponse has binding name '_ns9__GetSnapshotUriResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetSnapshotUriResponse
#define SOAP_TYPE__ns9__GetSnapshotUriResponse (1164)
#endif

/* _ns9__GetSnapshotUri has binding name '_ns9__GetSnapshotUri' for type '' */
#ifndef SOAP_TYPE__ns9__GetSnapshotUri
#define SOAP_TYPE__ns9__GetSnapshotUri (1163)
#endif

/* _ns9__SetSynchronizationPointResponse has binding name '_ns9__SetSynchronizationPointResponse' for type '' */
#ifndef SOAP_TYPE__ns9__SetSynchronizationPointResponse
#define SOAP_TYPE__ns9__SetSynchronizationPointResponse (1162)
#endif

/* _ns9__SetSynchronizationPoint has binding name '_ns9__SetSynchronizationPoint' for type '' */
#ifndef SOAP_TYPE__ns9__SetSynchronizationPoint
#define SOAP_TYPE__ns9__SetSynchronizationPoint (1161)
#endif

/* _ns9__StopMulticastStreamingResponse has binding name '_ns9__StopMulticastStreamingResponse' for type '' */
#ifndef SOAP_TYPE__ns9__StopMulticastStreamingResponse
#define SOAP_TYPE__ns9__StopMulticastStreamingResponse (1160)
#endif

/* _ns9__StopMulticastStreaming has binding name '_ns9__StopMulticastStreaming' for type '' */
#ifndef SOAP_TYPE__ns9__StopMulticastStreaming
#define SOAP_TYPE__ns9__StopMulticastStreaming (1159)
#endif

/* _ns9__StartMulticastStreamingResponse has binding name '_ns9__StartMulticastStreamingResponse' for type '' */
#ifndef SOAP_TYPE__ns9__StartMulticastStreamingResponse
#define SOAP_TYPE__ns9__StartMulticastStreamingResponse (1158)
#endif

/* _ns9__StartMulticastStreaming has binding name '_ns9__StartMulticastStreaming' for type '' */
#ifndef SOAP_TYPE__ns9__StartMulticastStreaming
#define SOAP_TYPE__ns9__StartMulticastStreaming (1157)
#endif

/* _ns9__GetStreamUriResponse has binding name '_ns9__GetStreamUriResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetStreamUriResponse
#define SOAP_TYPE__ns9__GetStreamUriResponse (1156)
#endif

/* _ns9__GetStreamUri has binding name '_ns9__GetStreamUri' for type '' */
#ifndef SOAP_TYPE__ns9__GetStreamUri
#define SOAP_TYPE__ns9__GetStreamUri (1155)
#endif

/* _ns9__GetGuaranteedNumberOfVideoEncoderInstancesResponse has binding name '_ns9__GetGuaranteedNumberOfVideoEncoderInstancesResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetGuaranteedNumberOfVideoEncoderInstancesResponse
#define SOAP_TYPE__ns9__GetGuaranteedNumberOfVideoEncoderInstancesResponse (1154)
#endif

/* _ns9__GetGuaranteedNumberOfVideoEncoderInstances has binding name '_ns9__GetGuaranteedNumberOfVideoEncoderInstances' for type '' */
#ifndef SOAP_TYPE__ns9__GetGuaranteedNumberOfVideoEncoderInstances
#define SOAP_TYPE__ns9__GetGuaranteedNumberOfVideoEncoderInstances (1153)
#endif

/* _ns9__GetAudioDecoderConfigurationOptionsResponse has binding name '_ns9__GetAudioDecoderConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioDecoderConfigurationOptionsResponse
#define SOAP_TYPE__ns9__GetAudioDecoderConfigurationOptionsResponse (1152)
#endif

/* _ns9__GetAudioDecoderConfigurationOptions has binding name '_ns9__GetAudioDecoderConfigurationOptions' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioDecoderConfigurationOptions
#define SOAP_TYPE__ns9__GetAudioDecoderConfigurationOptions (1151)
#endif

/* _ns9__GetAudioOutputConfigurationOptionsResponse has binding name '_ns9__GetAudioOutputConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioOutputConfigurationOptionsResponse
#define SOAP_TYPE__ns9__GetAudioOutputConfigurationOptionsResponse (1150)
#endif

/* _ns9__GetAudioOutputConfigurationOptions has binding name '_ns9__GetAudioOutputConfigurationOptions' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioOutputConfigurationOptions
#define SOAP_TYPE__ns9__GetAudioOutputConfigurationOptions (1149)
#endif

/* _ns9__GetMetadataConfigurationOptionsResponse has binding name '_ns9__GetMetadataConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetMetadataConfigurationOptionsResponse
#define SOAP_TYPE__ns9__GetMetadataConfigurationOptionsResponse (1148)
#endif

/* _ns9__GetMetadataConfigurationOptions has binding name '_ns9__GetMetadataConfigurationOptions' for type '' */
#ifndef SOAP_TYPE__ns9__GetMetadataConfigurationOptions
#define SOAP_TYPE__ns9__GetMetadataConfigurationOptions (1147)
#endif

/* _ns9__GetAudioEncoderConfigurationOptionsResponse has binding name '_ns9__GetAudioEncoderConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioEncoderConfigurationOptionsResponse
#define SOAP_TYPE__ns9__GetAudioEncoderConfigurationOptionsResponse (1146)
#endif

/* _ns9__GetAudioEncoderConfigurationOptions has binding name '_ns9__GetAudioEncoderConfigurationOptions' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioEncoderConfigurationOptions
#define SOAP_TYPE__ns9__GetAudioEncoderConfigurationOptions (1145)
#endif

/* _ns9__GetAudioSourceConfigurationOptionsResponse has binding name '_ns9__GetAudioSourceConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioSourceConfigurationOptionsResponse
#define SOAP_TYPE__ns9__GetAudioSourceConfigurationOptionsResponse (1144)
#endif

/* _ns9__GetAudioSourceConfigurationOptions has binding name '_ns9__GetAudioSourceConfigurationOptions' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioSourceConfigurationOptions
#define SOAP_TYPE__ns9__GetAudioSourceConfigurationOptions (1143)
#endif

/* _ns9__GetVideoEncoderConfigurationOptionsResponse has binding name '_ns9__GetVideoEncoderConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetVideoEncoderConfigurationOptionsResponse
#define SOAP_TYPE__ns9__GetVideoEncoderConfigurationOptionsResponse (1142)
#endif

/* _ns9__GetVideoEncoderConfigurationOptions has binding name '_ns9__GetVideoEncoderConfigurationOptions' for type '' */
#ifndef SOAP_TYPE__ns9__GetVideoEncoderConfigurationOptions
#define SOAP_TYPE__ns9__GetVideoEncoderConfigurationOptions (1141)
#endif

/* _ns9__GetVideoSourceConfigurationOptionsResponse has binding name '_ns9__GetVideoSourceConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetVideoSourceConfigurationOptionsResponse
#define SOAP_TYPE__ns9__GetVideoSourceConfigurationOptionsResponse (1140)
#endif

/* _ns9__GetVideoSourceConfigurationOptions has binding name '_ns9__GetVideoSourceConfigurationOptions' for type '' */
#ifndef SOAP_TYPE__ns9__GetVideoSourceConfigurationOptions
#define SOAP_TYPE__ns9__GetVideoSourceConfigurationOptions (1139)
#endif

/* _ns9__SetAudioDecoderConfigurationResponse has binding name '_ns9__SetAudioDecoderConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__SetAudioDecoderConfigurationResponse
#define SOAP_TYPE__ns9__SetAudioDecoderConfigurationResponse (1138)
#endif

/* _ns9__SetAudioDecoderConfiguration has binding name '_ns9__SetAudioDecoderConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__SetAudioDecoderConfiguration
#define SOAP_TYPE__ns9__SetAudioDecoderConfiguration (1137)
#endif

/* _ns9__SetAudioOutputConfigurationResponse has binding name '_ns9__SetAudioOutputConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__SetAudioOutputConfigurationResponse
#define SOAP_TYPE__ns9__SetAudioOutputConfigurationResponse (1136)
#endif

/* _ns9__SetAudioOutputConfiguration has binding name '_ns9__SetAudioOutputConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__SetAudioOutputConfiguration
#define SOAP_TYPE__ns9__SetAudioOutputConfiguration (1135)
#endif

/* _ns9__SetMetadataConfigurationResponse has binding name '_ns9__SetMetadataConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__SetMetadataConfigurationResponse
#define SOAP_TYPE__ns9__SetMetadataConfigurationResponse (1134)
#endif

/* _ns9__SetMetadataConfiguration has binding name '_ns9__SetMetadataConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__SetMetadataConfiguration
#define SOAP_TYPE__ns9__SetMetadataConfiguration (1133)
#endif

/* _ns9__SetVideoAnalyticsConfigurationResponse has binding name '_ns9__SetVideoAnalyticsConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__SetVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__ns9__SetVideoAnalyticsConfigurationResponse (1132)
#endif

/* _ns9__SetVideoAnalyticsConfiguration has binding name '_ns9__SetVideoAnalyticsConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__SetVideoAnalyticsConfiguration
#define SOAP_TYPE__ns9__SetVideoAnalyticsConfiguration (1131)
#endif

/* _ns9__SetAudioSourceConfigurationResponse has binding name '_ns9__SetAudioSourceConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__SetAudioSourceConfigurationResponse
#define SOAP_TYPE__ns9__SetAudioSourceConfigurationResponse (1130)
#endif

/* _ns9__SetAudioSourceConfiguration has binding name '_ns9__SetAudioSourceConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__SetAudioSourceConfiguration
#define SOAP_TYPE__ns9__SetAudioSourceConfiguration (1129)
#endif

/* _ns9__SetAudioEncoderConfigurationResponse has binding name '_ns9__SetAudioEncoderConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__SetAudioEncoderConfigurationResponse
#define SOAP_TYPE__ns9__SetAudioEncoderConfigurationResponse (1128)
#endif

/* _ns9__SetAudioEncoderConfiguration has binding name '_ns9__SetAudioEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__SetAudioEncoderConfiguration
#define SOAP_TYPE__ns9__SetAudioEncoderConfiguration (1127)
#endif

/* _ns9__SetVideoSourceConfigurationResponse has binding name '_ns9__SetVideoSourceConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__SetVideoSourceConfigurationResponse
#define SOAP_TYPE__ns9__SetVideoSourceConfigurationResponse (1126)
#endif

/* _ns9__SetVideoSourceConfiguration has binding name '_ns9__SetVideoSourceConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__SetVideoSourceConfiguration
#define SOAP_TYPE__ns9__SetVideoSourceConfiguration (1125)
#endif

/* _ns9__SetVideoEncoderConfigurationResponse has binding name '_ns9__SetVideoEncoderConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__SetVideoEncoderConfigurationResponse
#define SOAP_TYPE__ns9__SetVideoEncoderConfigurationResponse (1124)
#endif

/* _ns9__SetVideoEncoderConfiguration has binding name '_ns9__SetVideoEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__SetVideoEncoderConfiguration
#define SOAP_TYPE__ns9__SetVideoEncoderConfiguration (1123)
#endif

/* _ns9__GetCompatibleAudioDecoderConfigurationsResponse has binding name '_ns9__GetCompatibleAudioDecoderConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetCompatibleAudioDecoderConfigurationsResponse
#define SOAP_TYPE__ns9__GetCompatibleAudioDecoderConfigurationsResponse (1122)
#endif

/* _ns9__GetCompatibleAudioDecoderConfigurations has binding name '_ns9__GetCompatibleAudioDecoderConfigurations' for type '' */
#ifndef SOAP_TYPE__ns9__GetCompatibleAudioDecoderConfigurations
#define SOAP_TYPE__ns9__GetCompatibleAudioDecoderConfigurations (1121)
#endif

/* _ns9__GetCompatibleAudioOutputConfigurationsResponse has binding name '_ns9__GetCompatibleAudioOutputConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetCompatibleAudioOutputConfigurationsResponse
#define SOAP_TYPE__ns9__GetCompatibleAudioOutputConfigurationsResponse (1120)
#endif

/* _ns9__GetCompatibleAudioOutputConfigurations has binding name '_ns9__GetCompatibleAudioOutputConfigurations' for type '' */
#ifndef SOAP_TYPE__ns9__GetCompatibleAudioOutputConfigurations
#define SOAP_TYPE__ns9__GetCompatibleAudioOutputConfigurations (1119)
#endif

/* _ns9__GetCompatibleMetadataConfigurationsResponse has binding name '_ns9__GetCompatibleMetadataConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetCompatibleMetadataConfigurationsResponse
#define SOAP_TYPE__ns9__GetCompatibleMetadataConfigurationsResponse (1118)
#endif

/* _ns9__GetCompatibleMetadataConfigurations has binding name '_ns9__GetCompatibleMetadataConfigurations' for type '' */
#ifndef SOAP_TYPE__ns9__GetCompatibleMetadataConfigurations
#define SOAP_TYPE__ns9__GetCompatibleMetadataConfigurations (1117)
#endif

/* _ns9__GetCompatibleVideoAnalyticsConfigurationsResponse has binding name '_ns9__GetCompatibleVideoAnalyticsConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetCompatibleVideoAnalyticsConfigurationsResponse
#define SOAP_TYPE__ns9__GetCompatibleVideoAnalyticsConfigurationsResponse (1116)
#endif

/* _ns9__GetCompatibleVideoAnalyticsConfigurations has binding name '_ns9__GetCompatibleVideoAnalyticsConfigurations' for type '' */
#ifndef SOAP_TYPE__ns9__GetCompatibleVideoAnalyticsConfigurations
#define SOAP_TYPE__ns9__GetCompatibleVideoAnalyticsConfigurations (1115)
#endif

/* _ns9__GetCompatibleAudioSourceConfigurationsResponse has binding name '_ns9__GetCompatibleAudioSourceConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetCompatibleAudioSourceConfigurationsResponse
#define SOAP_TYPE__ns9__GetCompatibleAudioSourceConfigurationsResponse (1114)
#endif

/* _ns9__GetCompatibleAudioSourceConfigurations has binding name '_ns9__GetCompatibleAudioSourceConfigurations' for type '' */
#ifndef SOAP_TYPE__ns9__GetCompatibleAudioSourceConfigurations
#define SOAP_TYPE__ns9__GetCompatibleAudioSourceConfigurations (1113)
#endif

/* _ns9__GetCompatibleAudioEncoderConfigurationsResponse has binding name '_ns9__GetCompatibleAudioEncoderConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetCompatibleAudioEncoderConfigurationsResponse
#define SOAP_TYPE__ns9__GetCompatibleAudioEncoderConfigurationsResponse (1112)
#endif

/* _ns9__GetCompatibleAudioEncoderConfigurations has binding name '_ns9__GetCompatibleAudioEncoderConfigurations' for type '' */
#ifndef SOAP_TYPE__ns9__GetCompatibleAudioEncoderConfigurations
#define SOAP_TYPE__ns9__GetCompatibleAudioEncoderConfigurations (1111)
#endif

/* _ns9__GetCompatibleVideoSourceConfigurationsResponse has binding name '_ns9__GetCompatibleVideoSourceConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetCompatibleVideoSourceConfigurationsResponse
#define SOAP_TYPE__ns9__GetCompatibleVideoSourceConfigurationsResponse (1110)
#endif

/* _ns9__GetCompatibleVideoSourceConfigurations has binding name '_ns9__GetCompatibleVideoSourceConfigurations' for type '' */
#ifndef SOAP_TYPE__ns9__GetCompatibleVideoSourceConfigurations
#define SOAP_TYPE__ns9__GetCompatibleVideoSourceConfigurations (1109)
#endif

/* _ns9__GetCompatibleVideoEncoderConfigurationsResponse has binding name '_ns9__GetCompatibleVideoEncoderConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetCompatibleVideoEncoderConfigurationsResponse
#define SOAP_TYPE__ns9__GetCompatibleVideoEncoderConfigurationsResponse (1108)
#endif

/* _ns9__GetCompatibleVideoEncoderConfigurations has binding name '_ns9__GetCompatibleVideoEncoderConfigurations' for type '' */
#ifndef SOAP_TYPE__ns9__GetCompatibleVideoEncoderConfigurations
#define SOAP_TYPE__ns9__GetCompatibleVideoEncoderConfigurations (1107)
#endif

/* _ns9__GetAudioDecoderConfigurationResponse has binding name '_ns9__GetAudioDecoderConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioDecoderConfigurationResponse
#define SOAP_TYPE__ns9__GetAudioDecoderConfigurationResponse (1106)
#endif

/* _ns9__GetAudioDecoderConfiguration has binding name '_ns9__GetAudioDecoderConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioDecoderConfiguration
#define SOAP_TYPE__ns9__GetAudioDecoderConfiguration (1105)
#endif

/* _ns9__GetAudioOutputConfigurationResponse has binding name '_ns9__GetAudioOutputConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioOutputConfigurationResponse
#define SOAP_TYPE__ns9__GetAudioOutputConfigurationResponse (1104)
#endif

/* _ns9__GetAudioOutputConfiguration has binding name '_ns9__GetAudioOutputConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioOutputConfiguration
#define SOAP_TYPE__ns9__GetAudioOutputConfiguration (1103)
#endif

/* _ns9__GetMetadataConfigurationResponse has binding name '_ns9__GetMetadataConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetMetadataConfigurationResponse
#define SOAP_TYPE__ns9__GetMetadataConfigurationResponse (1102)
#endif

/* _ns9__GetMetadataConfiguration has binding name '_ns9__GetMetadataConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__GetMetadataConfiguration
#define SOAP_TYPE__ns9__GetMetadataConfiguration (1101)
#endif

/* _ns9__GetVideoAnalyticsConfigurationResponse has binding name '_ns9__GetVideoAnalyticsConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__ns9__GetVideoAnalyticsConfigurationResponse (1100)
#endif

/* _ns9__GetVideoAnalyticsConfiguration has binding name '_ns9__GetVideoAnalyticsConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__GetVideoAnalyticsConfiguration
#define SOAP_TYPE__ns9__GetVideoAnalyticsConfiguration (1099)
#endif

/* _ns9__GetAudioEncoderConfigurationResponse has binding name '_ns9__GetAudioEncoderConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioEncoderConfigurationResponse
#define SOAP_TYPE__ns9__GetAudioEncoderConfigurationResponse (1098)
#endif

/* _ns9__GetAudioEncoderConfiguration has binding name '_ns9__GetAudioEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioEncoderConfiguration
#define SOAP_TYPE__ns9__GetAudioEncoderConfiguration (1097)
#endif

/* _ns9__GetAudioSourceConfigurationResponse has binding name '_ns9__GetAudioSourceConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioSourceConfigurationResponse
#define SOAP_TYPE__ns9__GetAudioSourceConfigurationResponse (1096)
#endif

/* _ns9__GetAudioSourceConfiguration has binding name '_ns9__GetAudioSourceConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioSourceConfiguration
#define SOAP_TYPE__ns9__GetAudioSourceConfiguration (1095)
#endif

/* _ns9__GetVideoEncoderConfigurationResponse has binding name '_ns9__GetVideoEncoderConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetVideoEncoderConfigurationResponse
#define SOAP_TYPE__ns9__GetVideoEncoderConfigurationResponse (1094)
#endif

/* _ns9__GetVideoEncoderConfiguration has binding name '_ns9__GetVideoEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__GetVideoEncoderConfiguration
#define SOAP_TYPE__ns9__GetVideoEncoderConfiguration (1093)
#endif

/* _ns9__GetVideoSourceConfigurationResponse has binding name '_ns9__GetVideoSourceConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetVideoSourceConfigurationResponse
#define SOAP_TYPE__ns9__GetVideoSourceConfigurationResponse (1092)
#endif

/* _ns9__GetVideoSourceConfiguration has binding name '_ns9__GetVideoSourceConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__GetVideoSourceConfiguration
#define SOAP_TYPE__ns9__GetVideoSourceConfiguration (1091)
#endif

/* _ns9__GetAudioDecoderConfigurationsResponse has binding name '_ns9__GetAudioDecoderConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioDecoderConfigurationsResponse
#define SOAP_TYPE__ns9__GetAudioDecoderConfigurationsResponse (1090)
#endif

/* _ns9__GetAudioDecoderConfigurations has binding name '_ns9__GetAudioDecoderConfigurations' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioDecoderConfigurations
#define SOAP_TYPE__ns9__GetAudioDecoderConfigurations (1089)
#endif

/* _ns9__GetAudioOutputConfigurationsResponse has binding name '_ns9__GetAudioOutputConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioOutputConfigurationsResponse
#define SOAP_TYPE__ns9__GetAudioOutputConfigurationsResponse (1088)
#endif

/* _ns9__GetAudioOutputConfigurations has binding name '_ns9__GetAudioOutputConfigurations' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioOutputConfigurations
#define SOAP_TYPE__ns9__GetAudioOutputConfigurations (1087)
#endif

/* _ns9__GetMetadataConfigurationsResponse has binding name '_ns9__GetMetadataConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetMetadataConfigurationsResponse
#define SOAP_TYPE__ns9__GetMetadataConfigurationsResponse (1086)
#endif

/* _ns9__GetMetadataConfigurations has binding name '_ns9__GetMetadataConfigurations' for type '' */
#ifndef SOAP_TYPE__ns9__GetMetadataConfigurations
#define SOAP_TYPE__ns9__GetMetadataConfigurations (1085)
#endif

/* _ns9__GetVideoAnalyticsConfigurationsResponse has binding name '_ns9__GetVideoAnalyticsConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetVideoAnalyticsConfigurationsResponse
#define SOAP_TYPE__ns9__GetVideoAnalyticsConfigurationsResponse (1084)
#endif

/* _ns9__GetVideoAnalyticsConfigurations has binding name '_ns9__GetVideoAnalyticsConfigurations' for type '' */
#ifndef SOAP_TYPE__ns9__GetVideoAnalyticsConfigurations
#define SOAP_TYPE__ns9__GetVideoAnalyticsConfigurations (1083)
#endif

/* _ns9__GetAudioSourceConfigurationsResponse has binding name '_ns9__GetAudioSourceConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioSourceConfigurationsResponse
#define SOAP_TYPE__ns9__GetAudioSourceConfigurationsResponse (1082)
#endif

/* _ns9__GetAudioSourceConfigurations has binding name '_ns9__GetAudioSourceConfigurations' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioSourceConfigurations
#define SOAP_TYPE__ns9__GetAudioSourceConfigurations (1081)
#endif

/* _ns9__GetAudioEncoderConfigurationsResponse has binding name '_ns9__GetAudioEncoderConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioEncoderConfigurationsResponse
#define SOAP_TYPE__ns9__GetAudioEncoderConfigurationsResponse (1080)
#endif

/* _ns9__GetAudioEncoderConfigurations has binding name '_ns9__GetAudioEncoderConfigurations' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioEncoderConfigurations
#define SOAP_TYPE__ns9__GetAudioEncoderConfigurations (1079)
#endif

/* _ns9__GetVideoSourceConfigurationsResponse has binding name '_ns9__GetVideoSourceConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetVideoSourceConfigurationsResponse
#define SOAP_TYPE__ns9__GetVideoSourceConfigurationsResponse (1078)
#endif

/* _ns9__GetVideoSourceConfigurations has binding name '_ns9__GetVideoSourceConfigurations' for type '' */
#ifndef SOAP_TYPE__ns9__GetVideoSourceConfigurations
#define SOAP_TYPE__ns9__GetVideoSourceConfigurations (1077)
#endif

/* _ns9__GetVideoEncoderConfigurationsResponse has binding name '_ns9__GetVideoEncoderConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetVideoEncoderConfigurationsResponse
#define SOAP_TYPE__ns9__GetVideoEncoderConfigurationsResponse (1076)
#endif

/* _ns9__GetVideoEncoderConfigurations has binding name '_ns9__GetVideoEncoderConfigurations' for type '' */
#ifndef SOAP_TYPE__ns9__GetVideoEncoderConfigurations
#define SOAP_TYPE__ns9__GetVideoEncoderConfigurations (1075)
#endif

/* _ns9__DeleteProfileResponse has binding name '_ns9__DeleteProfileResponse' for type '' */
#ifndef SOAP_TYPE__ns9__DeleteProfileResponse
#define SOAP_TYPE__ns9__DeleteProfileResponse (1074)
#endif

/* _ns9__DeleteProfile has binding name '_ns9__DeleteProfile' for type '' */
#ifndef SOAP_TYPE__ns9__DeleteProfile
#define SOAP_TYPE__ns9__DeleteProfile (1073)
#endif

/* _ns9__RemoveAudioDecoderConfigurationResponse has binding name '_ns9__RemoveAudioDecoderConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__RemoveAudioDecoderConfigurationResponse
#define SOAP_TYPE__ns9__RemoveAudioDecoderConfigurationResponse (1072)
#endif

/* _ns9__RemoveAudioDecoderConfiguration has binding name '_ns9__RemoveAudioDecoderConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__RemoveAudioDecoderConfiguration
#define SOAP_TYPE__ns9__RemoveAudioDecoderConfiguration (1071)
#endif

/* _ns9__AddAudioDecoderConfigurationResponse has binding name '_ns9__AddAudioDecoderConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__AddAudioDecoderConfigurationResponse
#define SOAP_TYPE__ns9__AddAudioDecoderConfigurationResponse (1070)
#endif

/* _ns9__AddAudioDecoderConfiguration has binding name '_ns9__AddAudioDecoderConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__AddAudioDecoderConfiguration
#define SOAP_TYPE__ns9__AddAudioDecoderConfiguration (1069)
#endif

/* _ns9__RemoveAudioOutputConfigurationResponse has binding name '_ns9__RemoveAudioOutputConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__RemoveAudioOutputConfigurationResponse
#define SOAP_TYPE__ns9__RemoveAudioOutputConfigurationResponse (1068)
#endif

/* _ns9__RemoveAudioOutputConfiguration has binding name '_ns9__RemoveAudioOutputConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__RemoveAudioOutputConfiguration
#define SOAP_TYPE__ns9__RemoveAudioOutputConfiguration (1067)
#endif

/* _ns9__AddAudioOutputConfigurationResponse has binding name '_ns9__AddAudioOutputConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__AddAudioOutputConfigurationResponse
#define SOAP_TYPE__ns9__AddAudioOutputConfigurationResponse (1066)
#endif

/* _ns9__AddAudioOutputConfiguration has binding name '_ns9__AddAudioOutputConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__AddAudioOutputConfiguration
#define SOAP_TYPE__ns9__AddAudioOutputConfiguration (1065)
#endif

/* _ns9__RemoveMetadataConfigurationResponse has binding name '_ns9__RemoveMetadataConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__RemoveMetadataConfigurationResponse
#define SOAP_TYPE__ns9__RemoveMetadataConfigurationResponse (1064)
#endif

/* _ns9__RemoveMetadataConfiguration has binding name '_ns9__RemoveMetadataConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__RemoveMetadataConfiguration
#define SOAP_TYPE__ns9__RemoveMetadataConfiguration (1063)
#endif

/* _ns9__AddMetadataConfigurationResponse has binding name '_ns9__AddMetadataConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__AddMetadataConfigurationResponse
#define SOAP_TYPE__ns9__AddMetadataConfigurationResponse (1062)
#endif

/* _ns9__AddMetadataConfiguration has binding name '_ns9__AddMetadataConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__AddMetadataConfiguration
#define SOAP_TYPE__ns9__AddMetadataConfiguration (1061)
#endif

/* _ns9__RemoveVideoAnalyticsConfigurationResponse has binding name '_ns9__RemoveVideoAnalyticsConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__RemoveVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__ns9__RemoveVideoAnalyticsConfigurationResponse (1060)
#endif

/* _ns9__RemoveVideoAnalyticsConfiguration has binding name '_ns9__RemoveVideoAnalyticsConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__RemoveVideoAnalyticsConfiguration
#define SOAP_TYPE__ns9__RemoveVideoAnalyticsConfiguration (1059)
#endif

/* _ns9__AddVideoAnalyticsConfigurationResponse has binding name '_ns9__AddVideoAnalyticsConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__AddVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__ns9__AddVideoAnalyticsConfigurationResponse (1058)
#endif

/* _ns9__AddVideoAnalyticsConfiguration has binding name '_ns9__AddVideoAnalyticsConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__AddVideoAnalyticsConfiguration
#define SOAP_TYPE__ns9__AddVideoAnalyticsConfiguration (1057)
#endif

/* _ns9__RemovePTZConfigurationResponse has binding name '_ns9__RemovePTZConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__RemovePTZConfigurationResponse
#define SOAP_TYPE__ns9__RemovePTZConfigurationResponse (1056)
#endif

/* _ns9__RemovePTZConfiguration has binding name '_ns9__RemovePTZConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__RemovePTZConfiguration
#define SOAP_TYPE__ns9__RemovePTZConfiguration (1055)
#endif

/* _ns9__AddPTZConfigurationResponse has binding name '_ns9__AddPTZConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__AddPTZConfigurationResponse
#define SOAP_TYPE__ns9__AddPTZConfigurationResponse (1054)
#endif

/* _ns9__AddPTZConfiguration has binding name '_ns9__AddPTZConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__AddPTZConfiguration
#define SOAP_TYPE__ns9__AddPTZConfiguration (1053)
#endif

/* _ns9__RemoveAudioSourceConfigurationResponse has binding name '_ns9__RemoveAudioSourceConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__RemoveAudioSourceConfigurationResponse
#define SOAP_TYPE__ns9__RemoveAudioSourceConfigurationResponse (1052)
#endif

/* _ns9__RemoveAudioSourceConfiguration has binding name '_ns9__RemoveAudioSourceConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__RemoveAudioSourceConfiguration
#define SOAP_TYPE__ns9__RemoveAudioSourceConfiguration (1051)
#endif

/* _ns9__AddAudioSourceConfigurationResponse has binding name '_ns9__AddAudioSourceConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__AddAudioSourceConfigurationResponse
#define SOAP_TYPE__ns9__AddAudioSourceConfigurationResponse (1050)
#endif

/* _ns9__AddAudioSourceConfiguration has binding name '_ns9__AddAudioSourceConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__AddAudioSourceConfiguration
#define SOAP_TYPE__ns9__AddAudioSourceConfiguration (1049)
#endif

/* _ns9__RemoveAudioEncoderConfigurationResponse has binding name '_ns9__RemoveAudioEncoderConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__RemoveAudioEncoderConfigurationResponse
#define SOAP_TYPE__ns9__RemoveAudioEncoderConfigurationResponse (1048)
#endif

/* _ns9__RemoveAudioEncoderConfiguration has binding name '_ns9__RemoveAudioEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__RemoveAudioEncoderConfiguration
#define SOAP_TYPE__ns9__RemoveAudioEncoderConfiguration (1047)
#endif

/* _ns9__AddAudioEncoderConfigurationResponse has binding name '_ns9__AddAudioEncoderConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__AddAudioEncoderConfigurationResponse
#define SOAP_TYPE__ns9__AddAudioEncoderConfigurationResponse (1046)
#endif

/* _ns9__AddAudioEncoderConfiguration has binding name '_ns9__AddAudioEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__AddAudioEncoderConfiguration
#define SOAP_TYPE__ns9__AddAudioEncoderConfiguration (1045)
#endif

/* _ns9__RemoveVideoSourceConfigurationResponse has binding name '_ns9__RemoveVideoSourceConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__RemoveVideoSourceConfigurationResponse
#define SOAP_TYPE__ns9__RemoveVideoSourceConfigurationResponse (1044)
#endif

/* _ns9__RemoveVideoSourceConfiguration has binding name '_ns9__RemoveVideoSourceConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__RemoveVideoSourceConfiguration
#define SOAP_TYPE__ns9__RemoveVideoSourceConfiguration (1043)
#endif

/* _ns9__AddVideoSourceConfigurationResponse has binding name '_ns9__AddVideoSourceConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__AddVideoSourceConfigurationResponse
#define SOAP_TYPE__ns9__AddVideoSourceConfigurationResponse (1042)
#endif

/* _ns9__AddVideoSourceConfiguration has binding name '_ns9__AddVideoSourceConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__AddVideoSourceConfiguration
#define SOAP_TYPE__ns9__AddVideoSourceConfiguration (1041)
#endif

/* _ns9__RemoveVideoEncoderConfigurationResponse has binding name '_ns9__RemoveVideoEncoderConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__RemoveVideoEncoderConfigurationResponse
#define SOAP_TYPE__ns9__RemoveVideoEncoderConfigurationResponse (1040)
#endif

/* _ns9__RemoveVideoEncoderConfiguration has binding name '_ns9__RemoveVideoEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__RemoveVideoEncoderConfiguration
#define SOAP_TYPE__ns9__RemoveVideoEncoderConfiguration (1039)
#endif

/* _ns9__AddVideoEncoderConfigurationResponse has binding name '_ns9__AddVideoEncoderConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns9__AddVideoEncoderConfigurationResponse
#define SOAP_TYPE__ns9__AddVideoEncoderConfigurationResponse (1038)
#endif

/* _ns9__AddVideoEncoderConfiguration has binding name '_ns9__AddVideoEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE__ns9__AddVideoEncoderConfiguration
#define SOAP_TYPE__ns9__AddVideoEncoderConfiguration (1037)
#endif

/* _ns9__GetProfilesResponse has binding name '_ns9__GetProfilesResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetProfilesResponse
#define SOAP_TYPE__ns9__GetProfilesResponse (1036)
#endif

/* _ns9__GetProfiles has binding name '_ns9__GetProfiles' for type '' */
#ifndef SOAP_TYPE__ns9__GetProfiles
#define SOAP_TYPE__ns9__GetProfiles (1035)
#endif

/* _ns9__GetProfileResponse has binding name '_ns9__GetProfileResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetProfileResponse
#define SOAP_TYPE__ns9__GetProfileResponse (1034)
#endif

/* _ns9__GetProfile has binding name '_ns9__GetProfile' for type '' */
#ifndef SOAP_TYPE__ns9__GetProfile
#define SOAP_TYPE__ns9__GetProfile (1033)
#endif

/* _ns9__CreateProfileResponse has binding name '_ns9__CreateProfileResponse' for type '' */
#ifndef SOAP_TYPE__ns9__CreateProfileResponse
#define SOAP_TYPE__ns9__CreateProfileResponse (1032)
#endif

/* _ns9__CreateProfile has binding name '_ns9__CreateProfile' for type '' */
#ifndef SOAP_TYPE__ns9__CreateProfile
#define SOAP_TYPE__ns9__CreateProfile (1031)
#endif

/* _ns9__GetAudioOutputsResponse has binding name '_ns9__GetAudioOutputsResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioOutputsResponse
#define SOAP_TYPE__ns9__GetAudioOutputsResponse (1030)
#endif

/* _ns9__GetAudioOutputs has binding name '_ns9__GetAudioOutputs' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioOutputs
#define SOAP_TYPE__ns9__GetAudioOutputs (1029)
#endif

/* _ns9__GetAudioSourcesResponse has binding name '_ns9__GetAudioSourcesResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioSourcesResponse
#define SOAP_TYPE__ns9__GetAudioSourcesResponse (1028)
#endif

/* _ns9__GetAudioSources has binding name '_ns9__GetAudioSources' for type '' */
#ifndef SOAP_TYPE__ns9__GetAudioSources
#define SOAP_TYPE__ns9__GetAudioSources (1027)
#endif

/* _ns9__GetVideoSourcesResponse has binding name '_ns9__GetVideoSourcesResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetVideoSourcesResponse
#define SOAP_TYPE__ns9__GetVideoSourcesResponse (1026)
#endif

/* _ns9__GetVideoSources has binding name '_ns9__GetVideoSources' for type '' */
#ifndef SOAP_TYPE__ns9__GetVideoSources
#define SOAP_TYPE__ns9__GetVideoSources (1025)
#endif

/* _ns9__GetServiceCapabilitiesResponse has binding name '_ns9__GetServiceCapabilitiesResponse' for type '' */
#ifndef SOAP_TYPE__ns9__GetServiceCapabilitiesResponse
#define SOAP_TYPE__ns9__GetServiceCapabilitiesResponse (1024)
#endif

/* _ns9__GetServiceCapabilities has binding name '_ns9__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE__ns9__GetServiceCapabilities
#define SOAP_TYPE__ns9__GetServiceCapabilities (1023)
#endif

/* ns9__VideoSourceModeExtension has binding name 'ns9__VideoSourceModeExtension' for type 'ns9:VideoSourceModeExtension' */
#ifndef SOAP_TYPE_ns9__VideoSourceModeExtension
#define SOAP_TYPE_ns9__VideoSourceModeExtension (1022)
#endif

/* ns9__VideoSourceMode has binding name 'ns9__VideoSourceMode' for type 'ns9:VideoSourceMode' */
#ifndef SOAP_TYPE_ns9__VideoSourceMode
#define SOAP_TYPE_ns9__VideoSourceMode (1021)
#endif

/* ns9__StreamingCapabilities has binding name 'ns9__StreamingCapabilities' for type 'ns9:StreamingCapabilities' */
#ifndef SOAP_TYPE_ns9__StreamingCapabilities
#define SOAP_TYPE_ns9__StreamingCapabilities (1020)
#endif

/* ns9__ProfileCapabilities has binding name 'ns9__ProfileCapabilities' for type 'ns9:ProfileCapabilities' */
#ifndef SOAP_TYPE_ns9__ProfileCapabilities
#define SOAP_TYPE_ns9__ProfileCapabilities (1019)
#endif

/* ns9__Capabilities has binding name 'ns9__Capabilities' for type 'ns9:Capabilities' */
#ifndef SOAP_TYPE_ns9__Capabilities
#define SOAP_TYPE_ns9__Capabilities (1018)
#endif

/* _ns8__SetCurrentPresetResponse has binding name '_ns8__SetCurrentPresetResponse' for type '' */
#ifndef SOAP_TYPE__ns8__SetCurrentPresetResponse
#define SOAP_TYPE__ns8__SetCurrentPresetResponse (1017)
#endif

/* _ns8__SetCurrentPreset has binding name '_ns8__SetCurrentPreset' for type '' */
#ifndef SOAP_TYPE__ns8__SetCurrentPreset
#define SOAP_TYPE__ns8__SetCurrentPreset (1016)
#endif

/* _ns8__GetCurrentPresetResponse has binding name '_ns8__GetCurrentPresetResponse' for type '' */
#ifndef SOAP_TYPE__ns8__GetCurrentPresetResponse
#define SOAP_TYPE__ns8__GetCurrentPresetResponse (1015)
#endif

/* _ns8__GetCurrentPreset has binding name '_ns8__GetCurrentPreset' for type '' */
#ifndef SOAP_TYPE__ns8__GetCurrentPreset
#define SOAP_TYPE__ns8__GetCurrentPreset (1014)
#endif

/* _ns8__GetPresetsResponse has binding name '_ns8__GetPresetsResponse' for type '' */
#ifndef SOAP_TYPE__ns8__GetPresetsResponse
#define SOAP_TYPE__ns8__GetPresetsResponse (1013)
#endif

/* _ns8__GetPresets has binding name '_ns8__GetPresets' for type '' */
#ifndef SOAP_TYPE__ns8__GetPresets
#define SOAP_TYPE__ns8__GetPresets (1012)
#endif

/* _ns8__GetStatusResponse has binding name '_ns8__GetStatusResponse' for type '' */
#ifndef SOAP_TYPE__ns8__GetStatusResponse
#define SOAP_TYPE__ns8__GetStatusResponse (1011)
#endif

/* _ns8__GetStatus has binding name '_ns8__GetStatus' for type '' */
#ifndef SOAP_TYPE__ns8__GetStatus
#define SOAP_TYPE__ns8__GetStatus (1010)
#endif

/* _ns8__StopResponse has binding name '_ns8__StopResponse' for type '' */
#ifndef SOAP_TYPE__ns8__StopResponse
#define SOAP_TYPE__ns8__StopResponse (1009)
#endif

/* _ns8__Stop has binding name '_ns8__Stop' for type '' */
#ifndef SOAP_TYPE__ns8__Stop
#define SOAP_TYPE__ns8__Stop (1008)
#endif

/* _ns8__GetMoveOptionsResponse has binding name '_ns8__GetMoveOptionsResponse' for type '' */
#ifndef SOAP_TYPE__ns8__GetMoveOptionsResponse
#define SOAP_TYPE__ns8__GetMoveOptionsResponse (1007)
#endif

/* _ns8__GetMoveOptions has binding name '_ns8__GetMoveOptions' for type '' */
#ifndef SOAP_TYPE__ns8__GetMoveOptions
#define SOAP_TYPE__ns8__GetMoveOptions (1006)
#endif

/* _ns8__MoveResponse has binding name '_ns8__MoveResponse' for type '' */
#ifndef SOAP_TYPE__ns8__MoveResponse
#define SOAP_TYPE__ns8__MoveResponse (1005)
#endif

/* _ns8__Move has binding name '_ns8__Move' for type '' */
#ifndef SOAP_TYPE__ns8__Move
#define SOAP_TYPE__ns8__Move (1004)
#endif

/* _ns8__GetOptionsResponse has binding name '_ns8__GetOptionsResponse' for type '' */
#ifndef SOAP_TYPE__ns8__GetOptionsResponse
#define SOAP_TYPE__ns8__GetOptionsResponse (1003)
#endif

/* _ns8__GetOptions has binding name '_ns8__GetOptions' for type '' */
#ifndef SOAP_TYPE__ns8__GetOptions
#define SOAP_TYPE__ns8__GetOptions (1002)
#endif

/* _ns8__SetImagingSettingsResponse has binding name '_ns8__SetImagingSettingsResponse' for type '' */
#ifndef SOAP_TYPE__ns8__SetImagingSettingsResponse
#define SOAP_TYPE__ns8__SetImagingSettingsResponse (1001)
#endif

/* _ns8__SetImagingSettings has binding name '_ns8__SetImagingSettings' for type '' */
#ifndef SOAP_TYPE__ns8__SetImagingSettings
#define SOAP_TYPE__ns8__SetImagingSettings (1000)
#endif

/* _ns8__GetImagingSettingsResponse has binding name '_ns8__GetImagingSettingsResponse' for type '' */
#ifndef SOAP_TYPE__ns8__GetImagingSettingsResponse
#define SOAP_TYPE__ns8__GetImagingSettingsResponse (999)
#endif

/* _ns8__GetImagingSettings has binding name '_ns8__GetImagingSettings' for type '' */
#ifndef SOAP_TYPE__ns8__GetImagingSettings
#define SOAP_TYPE__ns8__GetImagingSettings (998)
#endif

/* _ns8__GetServiceCapabilitiesResponse has binding name '_ns8__GetServiceCapabilitiesResponse' for type '' */
#ifndef SOAP_TYPE__ns8__GetServiceCapabilitiesResponse
#define SOAP_TYPE__ns8__GetServiceCapabilitiesResponse (997)
#endif

/* _ns8__GetServiceCapabilities has binding name '_ns8__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE__ns8__GetServiceCapabilities
#define SOAP_TYPE__ns8__GetServiceCapabilities (996)
#endif

/* ns8__ImagingPreset has binding name 'ns8__ImagingPreset' for type 'ns8:ImagingPreset' */
#ifndef SOAP_TYPE_ns8__ImagingPreset
#define SOAP_TYPE_ns8__ImagingPreset (995)
#endif

/* ns8__Capabilities has binding name 'ns8__Capabilities' for type 'ns8:Capabilities' */
#ifndef SOAP_TYPE_ns8__Capabilities
#define SOAP_TYPE_ns8__Capabilities (994)
#endif

/* _ns7__DeletePaneConfigurationResponse has binding name '_ns7__DeletePaneConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns7__DeletePaneConfigurationResponse
#define SOAP_TYPE__ns7__DeletePaneConfigurationResponse (993)
#endif

/* _ns7__DeletePaneConfiguration has binding name '_ns7__DeletePaneConfiguration' for type '' */
#ifndef SOAP_TYPE__ns7__DeletePaneConfiguration
#define SOAP_TYPE__ns7__DeletePaneConfiguration (992)
#endif

/* _ns7__CreatePaneConfigurationResponse has binding name '_ns7__CreatePaneConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns7__CreatePaneConfigurationResponse
#define SOAP_TYPE__ns7__CreatePaneConfigurationResponse (991)
#endif

/* _ns7__CreatePaneConfiguration has binding name '_ns7__CreatePaneConfiguration' for type '' */
#ifndef SOAP_TYPE__ns7__CreatePaneConfiguration
#define SOAP_TYPE__ns7__CreatePaneConfiguration (990)
#endif

/* _ns7__SetPaneConfigurationResponse has binding name '_ns7__SetPaneConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns7__SetPaneConfigurationResponse
#define SOAP_TYPE__ns7__SetPaneConfigurationResponse (989)
#endif

/* _ns7__SetPaneConfiguration has binding name '_ns7__SetPaneConfiguration' for type '' */
#ifndef SOAP_TYPE__ns7__SetPaneConfiguration
#define SOAP_TYPE__ns7__SetPaneConfiguration (988)
#endif

/* _ns7__SetPaneConfigurationsResponse has binding name '_ns7__SetPaneConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns7__SetPaneConfigurationsResponse
#define SOAP_TYPE__ns7__SetPaneConfigurationsResponse (987)
#endif

/* _ns7__SetPaneConfigurations has binding name '_ns7__SetPaneConfigurations' for type '' */
#ifndef SOAP_TYPE__ns7__SetPaneConfigurations
#define SOAP_TYPE__ns7__SetPaneConfigurations (986)
#endif

/* _ns7__GetPaneConfigurationResponse has binding name '_ns7__GetPaneConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns7__GetPaneConfigurationResponse
#define SOAP_TYPE__ns7__GetPaneConfigurationResponse (985)
#endif

/* _ns7__GetPaneConfiguration has binding name '_ns7__GetPaneConfiguration' for type '' */
#ifndef SOAP_TYPE__ns7__GetPaneConfiguration
#define SOAP_TYPE__ns7__GetPaneConfiguration (984)
#endif

/* _ns7__GetPaneConfigurationsResponse has binding name '_ns7__GetPaneConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns7__GetPaneConfigurationsResponse
#define SOAP_TYPE__ns7__GetPaneConfigurationsResponse (983)
#endif

/* _ns7__GetPaneConfigurations has binding name '_ns7__GetPaneConfigurations' for type '' */
#ifndef SOAP_TYPE__ns7__GetPaneConfigurations
#define SOAP_TYPE__ns7__GetPaneConfigurations (982)
#endif

/* _ns7__GetDisplayOptionsResponse has binding name '_ns7__GetDisplayOptionsResponse' for type '' */
#ifndef SOAP_TYPE__ns7__GetDisplayOptionsResponse
#define SOAP_TYPE__ns7__GetDisplayOptionsResponse (981)
#endif

/* _ns7__GetDisplayOptions has binding name '_ns7__GetDisplayOptions' for type '' */
#ifndef SOAP_TYPE__ns7__GetDisplayOptions
#define SOAP_TYPE__ns7__GetDisplayOptions (980)
#endif

/* _ns7__SetLayoutResponse has binding name '_ns7__SetLayoutResponse' for type '' */
#ifndef SOAP_TYPE__ns7__SetLayoutResponse
#define SOAP_TYPE__ns7__SetLayoutResponse (979)
#endif

/* _ns7__SetLayout has binding name '_ns7__SetLayout' for type '' */
#ifndef SOAP_TYPE__ns7__SetLayout
#define SOAP_TYPE__ns7__SetLayout (978)
#endif

/* _ns7__GetLayoutResponse has binding name '_ns7__GetLayoutResponse' for type '' */
#ifndef SOAP_TYPE__ns7__GetLayoutResponse
#define SOAP_TYPE__ns7__GetLayoutResponse (977)
#endif

/* _ns7__GetLayout has binding name '_ns7__GetLayout' for type '' */
#ifndef SOAP_TYPE__ns7__GetLayout
#define SOAP_TYPE__ns7__GetLayout (976)
#endif

/* _ns7__GetServiceCapabilitiesResponse has binding name '_ns7__GetServiceCapabilitiesResponse' for type '' */
#ifndef SOAP_TYPE__ns7__GetServiceCapabilitiesResponse
#define SOAP_TYPE__ns7__GetServiceCapabilitiesResponse (975)
#endif

/* _ns7__GetServiceCapabilities has binding name '_ns7__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE__ns7__GetServiceCapabilities
#define SOAP_TYPE__ns7__GetServiceCapabilities (974)
#endif

/* ns7__Capabilities has binding name 'ns7__Capabilities' for type 'ns7:Capabilities' */
#ifndef SOAP_TYPE_ns7__Capabilities
#define SOAP_TYPE_ns7__Capabilities (973)
#endif

/* ns6__TopicSetType has binding name 'ns6__TopicSetType' for type 'ns6:TopicSetType' */
#ifndef SOAP_TYPE_ns6__TopicSetType
#define SOAP_TYPE_ns6__TopicSetType (972)
#endif

/* ns6__TopicType has binding name 'ns6__TopicType' for type 'ns6:TopicType' */
#ifndef SOAP_TYPE_ns6__TopicType
#define SOAP_TYPE_ns6__TopicType (971)
#endif

/* ns6__TopicNamespaceType has binding name 'ns6__TopicNamespaceType' for type 'ns6:TopicNamespaceType' */
#ifndef SOAP_TYPE_ns6__TopicNamespaceType
#define SOAP_TYPE_ns6__TopicNamespaceType (970)
#endif

/* ns6__QueryExpressionType has binding name 'ns6__QueryExpressionType' for type 'ns6:QueryExpressionType' */
#ifndef SOAP_TYPE_ns6__QueryExpressionType
#define SOAP_TYPE_ns6__QueryExpressionType (969)
#endif

/* ns6__ExtensibleDocumented has binding name 'ns6__ExtensibleDocumented' for type 'ns6:ExtensibleDocumented' */
#ifndef SOAP_TYPE_ns6__ExtensibleDocumented
#define SOAP_TYPE_ns6__ExtensibleDocumented (968)
#endif

/* ns6__Documentation has binding name 'ns6__Documentation' for type 'ns6:Documentation' */
#ifndef SOAP_TYPE_ns6__Documentation
#define SOAP_TYPE_ns6__Documentation (967)
#endif

/* ns5__BaseFaultType has binding name 'ns5__BaseFaultType' for type 'ns5:BaseFaultType' */
#ifndef SOAP_TYPE_ns5__BaseFaultType
#define SOAP_TYPE_ns5__BaseFaultType (966)
#endif

/* ns4__Include has binding name 'ns4__Include' for type 'ns4:Include' */
#ifndef SOAP_TYPE_ns4__Include
#define SOAP_TYPE_ns4__Include (965)
#endif

/* _ns3__ResumeSubscriptionResponse has binding name '_ns3__ResumeSubscriptionResponse' for type '' */
#ifndef SOAP_TYPE__ns3__ResumeSubscriptionResponse
#define SOAP_TYPE__ns3__ResumeSubscriptionResponse (964)
#endif

/* _ns3__ResumeSubscription has binding name '_ns3__ResumeSubscription' for type '' */
#ifndef SOAP_TYPE__ns3__ResumeSubscription
#define SOAP_TYPE__ns3__ResumeSubscription (963)
#endif

/* _ns3__PauseSubscriptionResponse has binding name '_ns3__PauseSubscriptionResponse' for type '' */
#ifndef SOAP_TYPE__ns3__PauseSubscriptionResponse
#define SOAP_TYPE__ns3__PauseSubscriptionResponse (962)
#endif

/* _ns3__PauseSubscription has binding name '_ns3__PauseSubscription' for type '' */
#ifndef SOAP_TYPE__ns3__PauseSubscription
#define SOAP_TYPE__ns3__PauseSubscription (961)
#endif

/* _ns3__UnsubscribeResponse has binding name '_ns3__UnsubscribeResponse' for type '' */
#ifndef SOAP_TYPE__ns3__UnsubscribeResponse
#define SOAP_TYPE__ns3__UnsubscribeResponse (960)
#endif

/* _ns3__Unsubscribe has binding name '_ns3__Unsubscribe' for type '' */
#ifndef SOAP_TYPE__ns3__Unsubscribe
#define SOAP_TYPE__ns3__Unsubscribe (959)
#endif

/* _ns3__RenewResponse has binding name '_ns3__RenewResponse' for type '' */
#ifndef SOAP_TYPE__ns3__RenewResponse
#define SOAP_TYPE__ns3__RenewResponse (958)
#endif

/* _ns3__Renew has binding name '_ns3__Renew' for type '' */
#ifndef SOAP_TYPE__ns3__Renew
#define SOAP_TYPE__ns3__Renew (957)
#endif

/* _ns3__CreatePullPointResponse has binding name '_ns3__CreatePullPointResponse' for type '' */
#ifndef SOAP_TYPE__ns3__CreatePullPointResponse
#define SOAP_TYPE__ns3__CreatePullPointResponse (956)
#endif

/* _ns3__CreatePullPoint has binding name '_ns3__CreatePullPoint' for type '' */
#ifndef SOAP_TYPE__ns3__CreatePullPoint
#define SOAP_TYPE__ns3__CreatePullPoint (955)
#endif

/* _ns3__DestroyPullPointResponse has binding name '_ns3__DestroyPullPointResponse' for type '' */
#ifndef SOAP_TYPE__ns3__DestroyPullPointResponse
#define SOAP_TYPE__ns3__DestroyPullPointResponse (954)
#endif

/* _ns3__DestroyPullPoint has binding name '_ns3__DestroyPullPoint' for type '' */
#ifndef SOAP_TYPE__ns3__DestroyPullPoint
#define SOAP_TYPE__ns3__DestroyPullPoint (953)
#endif

/* _ns3__GetMessagesResponse has binding name '_ns3__GetMessagesResponse' for type '' */
#ifndef SOAP_TYPE__ns3__GetMessagesResponse
#define SOAP_TYPE__ns3__GetMessagesResponse (952)
#endif

/* _ns3__GetMessages has binding name '_ns3__GetMessages' for type '' */
#ifndef SOAP_TYPE__ns3__GetMessages
#define SOAP_TYPE__ns3__GetMessages (951)
#endif

/* _ns3__GetCurrentMessageResponse has binding name '_ns3__GetCurrentMessageResponse' for type '' */
#ifndef SOAP_TYPE__ns3__GetCurrentMessageResponse
#define SOAP_TYPE__ns3__GetCurrentMessageResponse (950)
#endif

/* _ns3__GetCurrentMessage has binding name '_ns3__GetCurrentMessage' for type '' */
#ifndef SOAP_TYPE__ns3__GetCurrentMessage
#define SOAP_TYPE__ns3__GetCurrentMessage (949)
#endif

/* _ns3__SubscribeResponse has binding name '_ns3__SubscribeResponse' for type '' */
#ifndef SOAP_TYPE__ns3__SubscribeResponse
#define SOAP_TYPE__ns3__SubscribeResponse (948)
#endif

/* _ns3__Subscribe has binding name '_ns3__Subscribe' for type '' */
#ifndef SOAP_TYPE__ns3__Subscribe
#define SOAP_TYPE__ns3__Subscribe (947)
#endif

/* _ns3__UseRaw has binding name '_ns3__UseRaw' for type '' */
#ifndef SOAP_TYPE__ns3__UseRaw
#define SOAP_TYPE__ns3__UseRaw (946)
#endif

/* _ns3__Notify has binding name '_ns3__Notify' for type '' */
#ifndef SOAP_TYPE__ns3__Notify
#define SOAP_TYPE__ns3__Notify (945)
#endif

/* _ns3__SubscriptionManagerRP has binding name '_ns3__SubscriptionManagerRP' for type '' */
#ifndef SOAP_TYPE__ns3__SubscriptionManagerRP
#define SOAP_TYPE__ns3__SubscriptionManagerRP (944)
#endif

/* _ns3__NotificationProducerRP has binding name '_ns3__NotificationProducerRP' for type '' */
#ifndef SOAP_TYPE__ns3__NotificationProducerRP
#define SOAP_TYPE__ns3__NotificationProducerRP (943)
#endif

/* ns3__ResumeFailedFaultType has binding name 'ns3__ResumeFailedFaultType' for type 'ns3:ResumeFailedFaultType' */
#ifndef SOAP_TYPE_ns3__ResumeFailedFaultType
#define SOAP_TYPE_ns3__ResumeFailedFaultType (942)
#endif

/* ns3__PauseFailedFaultType has binding name 'ns3__PauseFailedFaultType' for type 'ns3:PauseFailedFaultType' */
#ifndef SOAP_TYPE_ns3__PauseFailedFaultType
#define SOAP_TYPE_ns3__PauseFailedFaultType (941)
#endif

/* ns3__UnableToDestroySubscriptionFaultType has binding name 'ns3__UnableToDestroySubscriptionFaultType' for type 'ns3:UnableToDestroySubscriptionFaultType' */
#ifndef SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType
#define SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType (940)
#endif

/* ns3__UnacceptableTerminationTimeFaultType has binding name 'ns3__UnacceptableTerminationTimeFaultType' for type 'ns3:UnacceptableTerminationTimeFaultType' */
#ifndef SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType
#define SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType (939)
#endif

/* ns3__UnableToCreatePullPointFaultType has binding name 'ns3__UnableToCreatePullPointFaultType' for type 'ns3:UnableToCreatePullPointFaultType' */
#ifndef SOAP_TYPE_ns3__UnableToCreatePullPointFaultType
#define SOAP_TYPE_ns3__UnableToCreatePullPointFaultType (938)
#endif

/* ns3__UnableToDestroyPullPointFaultType has binding name 'ns3__UnableToDestroyPullPointFaultType' for type 'ns3:UnableToDestroyPullPointFaultType' */
#ifndef SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType
#define SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType (937)
#endif

/* ns3__UnableToGetMessagesFaultType has binding name 'ns3__UnableToGetMessagesFaultType' for type 'ns3:UnableToGetMessagesFaultType' */
#ifndef SOAP_TYPE_ns3__UnableToGetMessagesFaultType
#define SOAP_TYPE_ns3__UnableToGetMessagesFaultType (936)
#endif

/* ns3__NoCurrentMessageOnTopicFaultType has binding name 'ns3__NoCurrentMessageOnTopicFaultType' for type 'ns3:NoCurrentMessageOnTopicFaultType' */
#ifndef SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType
#define SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType (935)
#endif

/* ns3__UnacceptableInitialTerminationTimeFaultType has binding name 'ns3__UnacceptableInitialTerminationTimeFaultType' for type 'ns3:UnacceptableInitialTerminationTimeFaultType' */
#ifndef SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType
#define SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType (934)
#endif

/* ns3__NotifyMessageNotSupportedFaultType has binding name 'ns3__NotifyMessageNotSupportedFaultType' for type 'ns3:NotifyMessageNotSupportedFaultType' */
#ifndef SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType
#define SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType (933)
#endif

/* ns3__UnsupportedPolicyRequestFaultType has binding name 'ns3__UnsupportedPolicyRequestFaultType' for type 'ns3:UnsupportedPolicyRequestFaultType' */
#ifndef SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType
#define SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType (932)
#endif

/* ns3__UnrecognizedPolicyRequestFaultType has binding name 'ns3__UnrecognizedPolicyRequestFaultType' for type 'ns3:UnrecognizedPolicyRequestFaultType' */
#ifndef SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType
#define SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType (931)
#endif

/* ns3__InvalidMessageContentExpressionFaultType has binding name 'ns3__InvalidMessageContentExpressionFaultType' for type 'ns3:InvalidMessageContentExpressionFaultType' */
#ifndef SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType
#define SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType (930)
#endif

/* ns3__InvalidProducerPropertiesExpressionFaultType has binding name 'ns3__InvalidProducerPropertiesExpressionFaultType' for type 'ns3:InvalidProducerPropertiesExpressionFaultType' */
#ifndef SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType
#define SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType (929)
#endif

/* ns3__MultipleTopicsSpecifiedFaultType has binding name 'ns3__MultipleTopicsSpecifiedFaultType' for type 'ns3:MultipleTopicsSpecifiedFaultType' */
#ifndef SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType
#define SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType (928)
#endif

/* ns3__TopicNotSupportedFaultType has binding name 'ns3__TopicNotSupportedFaultType' for type 'ns3:TopicNotSupportedFaultType' */
#ifndef SOAP_TYPE_ns3__TopicNotSupportedFaultType
#define SOAP_TYPE_ns3__TopicNotSupportedFaultType (927)
#endif

/* ns3__InvalidTopicExpressionFaultType has binding name 'ns3__InvalidTopicExpressionFaultType' for type 'ns3:InvalidTopicExpressionFaultType' */
#ifndef SOAP_TYPE_ns3__InvalidTopicExpressionFaultType
#define SOAP_TYPE_ns3__InvalidTopicExpressionFaultType (926)
#endif

/* ns3__TopicExpressionDialectUnknownFaultType has binding name 'ns3__TopicExpressionDialectUnknownFaultType' for type 'ns3:TopicExpressionDialectUnknownFaultType' */
#ifndef SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType
#define SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType (925)
#endif

/* ns3__InvalidFilterFaultType has binding name 'ns3__InvalidFilterFaultType' for type 'ns3:InvalidFilterFaultType' */
#ifndef SOAP_TYPE_ns3__InvalidFilterFaultType
#define SOAP_TYPE_ns3__InvalidFilterFaultType (924)
#endif

/* ns3__SubscribeCreationFailedFaultType has binding name 'ns3__SubscribeCreationFailedFaultType' for type 'ns3:SubscribeCreationFailedFaultType' */
#ifndef SOAP_TYPE_ns3__SubscribeCreationFailedFaultType
#define SOAP_TYPE_ns3__SubscribeCreationFailedFaultType (923)
#endif

/* ns3__NotificationMessageHolderType has binding name 'ns3__NotificationMessageHolderType' for type 'ns3:NotificationMessageHolderType' */
#ifndef SOAP_TYPE_ns3__NotificationMessageHolderType
#define SOAP_TYPE_ns3__NotificationMessageHolderType (922)
#endif

/* ns3__SubscriptionPolicyType has binding name 'ns3__SubscriptionPolicyType' for type 'ns3:SubscriptionPolicyType' */
#ifndef SOAP_TYPE_ns3__SubscriptionPolicyType
#define SOAP_TYPE_ns3__SubscriptionPolicyType (921)
#endif

/* ns3__FilterType has binding name 'ns3__FilterType' for type 'ns3:FilterType' */
#ifndef SOAP_TYPE_ns3__FilterType
#define SOAP_TYPE_ns3__FilterType (920)
#endif

/* ns3__TopicExpressionType has binding name 'ns3__TopicExpressionType' for type 'ns3:TopicExpressionType' */
#ifndef SOAP_TYPE_ns3__TopicExpressionType
#define SOAP_TYPE_ns3__TopicExpressionType (919)
#endif

/* ns3__QueryExpressionType has binding name 'ns3__QueryExpressionType' for type 'ns3:QueryExpressionType' */
#ifndef SOAP_TYPE_ns3__QueryExpressionType
#define SOAP_TYPE_ns3__QueryExpressionType (918)
#endif

/* _ns2__Message has binding name '_ns2__Message' for type '' */
#ifndef SOAP_TYPE__ns2__Message
#define SOAP_TYPE__ns2__Message (917)
#endif

/* ns2__StorageReferencePathExtension has binding name 'ns2__StorageReferencePathExtension' for type 'ns2:StorageReferencePathExtension' */
#ifndef SOAP_TYPE_ns2__StorageReferencePathExtension
#define SOAP_TYPE_ns2__StorageReferencePathExtension (916)
#endif

/* ns2__StorageReferencePath has binding name 'ns2__StorageReferencePath' for type 'ns2:StorageReferencePath' */
#ifndef SOAP_TYPE_ns2__StorageReferencePath
#define SOAP_TYPE_ns2__StorageReferencePath (915)
#endif

/* ns2__ArrayOfFileProgressExtension has binding name 'ns2__ArrayOfFileProgressExtension' for type 'ns2:ArrayOfFileProgressExtension' */
#ifndef SOAP_TYPE_ns2__ArrayOfFileProgressExtension
#define SOAP_TYPE_ns2__ArrayOfFileProgressExtension (914)
#endif

/* ns2__ArrayOfFileProgress has binding name 'ns2__ArrayOfFileProgress' for type 'ns2:ArrayOfFileProgress' */
#ifndef SOAP_TYPE_ns2__ArrayOfFileProgress
#define SOAP_TYPE_ns2__ArrayOfFileProgress (913)
#endif

/* ns2__FileProgress has binding name 'ns2__FileProgress' for type 'ns2:FileProgress' */
#ifndef SOAP_TYPE_ns2__FileProgress
#define SOAP_TYPE_ns2__FileProgress (912)
#endif

/* ns2__OSDConfigurationOptionsExtension has binding name 'ns2__OSDConfigurationOptionsExtension' for type 'ns2:OSDConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_ns2__OSDConfigurationOptionsExtension
#define SOAP_TYPE_ns2__OSDConfigurationOptionsExtension (911)
#endif

/* ns2__OSDConfigurationOptions has binding name 'ns2__OSDConfigurationOptions' for type 'ns2:OSDConfigurationOptions' */
#ifndef SOAP_TYPE_ns2__OSDConfigurationOptions
#define SOAP_TYPE_ns2__OSDConfigurationOptions (910)
#endif

/* ns2__MaximumNumberOfOSDs has binding name 'ns2__MaximumNumberOfOSDs' for type 'ns2:MaximumNumberOfOSDs' */
#ifndef SOAP_TYPE_ns2__MaximumNumberOfOSDs
#define SOAP_TYPE_ns2__MaximumNumberOfOSDs (909)
#endif

/* ns2__OSDConfigurationExtension has binding name 'ns2__OSDConfigurationExtension' for type 'ns2:OSDConfigurationExtension' */
#ifndef SOAP_TYPE_ns2__OSDConfigurationExtension
#define SOAP_TYPE_ns2__OSDConfigurationExtension (908)
#endif

/* ns2__OSDConfiguration has binding name 'ns2__OSDConfiguration' for type 'ns2:OSDConfiguration' */
#ifndef SOAP_TYPE_ns2__OSDConfiguration
#define SOAP_TYPE_ns2__OSDConfiguration (907)
#endif

/* ns2__OSDImgOptionsExtension has binding name 'ns2__OSDImgOptionsExtension' for type 'ns2:OSDImgOptionsExtension' */
#ifndef SOAP_TYPE_ns2__OSDImgOptionsExtension
#define SOAP_TYPE_ns2__OSDImgOptionsExtension (906)
#endif

/* ns2__OSDImgOptions has binding name 'ns2__OSDImgOptions' for type 'ns2:OSDImgOptions' */
#ifndef SOAP_TYPE_ns2__OSDImgOptions
#define SOAP_TYPE_ns2__OSDImgOptions (905)
#endif

/* ns2__OSDTextOptionsExtension has binding name 'ns2__OSDTextOptionsExtension' for type 'ns2:OSDTextOptionsExtension' */
#ifndef SOAP_TYPE_ns2__OSDTextOptionsExtension
#define SOAP_TYPE_ns2__OSDTextOptionsExtension (904)
#endif

/* ns2__OSDTextOptions has binding name 'ns2__OSDTextOptions' for type 'ns2:OSDTextOptions' */
#ifndef SOAP_TYPE_ns2__OSDTextOptions
#define SOAP_TYPE_ns2__OSDTextOptions (903)
#endif

/* ns2__OSDColorOptionsExtension has binding name 'ns2__OSDColorOptionsExtension' for type 'ns2:OSDColorOptionsExtension' */
#ifndef SOAP_TYPE_ns2__OSDColorOptionsExtension
#define SOAP_TYPE_ns2__OSDColorOptionsExtension (902)
#endif

/* ns2__OSDColorOptions has binding name 'ns2__OSDColorOptions' for type 'ns2:OSDColorOptions' */
#ifndef SOAP_TYPE_ns2__OSDColorOptions
#define SOAP_TYPE_ns2__OSDColorOptions (901)
#endif

/* ns2__ColorOptions has binding name 'ns2__ColorOptions' for type 'ns2:ColorOptions' */
#ifndef SOAP_TYPE_ns2__ColorOptions
#define SOAP_TYPE_ns2__ColorOptions (900)
#endif

/* ns2__ColorspaceRange has binding name 'ns2__ColorspaceRange' for type 'ns2:ColorspaceRange' */
#ifndef SOAP_TYPE_ns2__ColorspaceRange
#define SOAP_TYPE_ns2__ColorspaceRange (899)
#endif

/* ns2__OSDImgConfigurationExtension has binding name 'ns2__OSDImgConfigurationExtension' for type 'ns2:OSDImgConfigurationExtension' */
#ifndef SOAP_TYPE_ns2__OSDImgConfigurationExtension
#define SOAP_TYPE_ns2__OSDImgConfigurationExtension (898)
#endif

/* ns2__OSDImgConfiguration has binding name 'ns2__OSDImgConfiguration' for type 'ns2:OSDImgConfiguration' */
#ifndef SOAP_TYPE_ns2__OSDImgConfiguration
#define SOAP_TYPE_ns2__OSDImgConfiguration (897)
#endif

/* ns2__OSDTextConfigurationExtension has binding name 'ns2__OSDTextConfigurationExtension' for type 'ns2:OSDTextConfigurationExtension' */
#ifndef SOAP_TYPE_ns2__OSDTextConfigurationExtension
#define SOAP_TYPE_ns2__OSDTextConfigurationExtension (896)
#endif

/* ns2__OSDTextConfiguration has binding name 'ns2__OSDTextConfiguration' for type 'ns2:OSDTextConfiguration' */
#ifndef SOAP_TYPE_ns2__OSDTextConfiguration
#define SOAP_TYPE_ns2__OSDTextConfiguration (895)
#endif

/* ns2__OSDColor has binding name 'ns2__OSDColor' for type 'ns2:OSDColor' */
#ifndef SOAP_TYPE_ns2__OSDColor
#define SOAP_TYPE_ns2__OSDColor (894)
#endif

/* ns2__OSDPosConfigurationExtension has binding name 'ns2__OSDPosConfigurationExtension' for type 'ns2:OSDPosConfigurationExtension' */
#ifndef SOAP_TYPE_ns2__OSDPosConfigurationExtension
#define SOAP_TYPE_ns2__OSDPosConfigurationExtension (893)
#endif

/* ns2__OSDPosConfiguration has binding name 'ns2__OSDPosConfiguration' for type 'ns2:OSDPosConfiguration' */
#ifndef SOAP_TYPE_ns2__OSDPosConfiguration
#define SOAP_TYPE_ns2__OSDPosConfiguration (892)
#endif

/* ns2__OSDReference has binding name 'ns2__OSDReference' for type 'ns2:OSDReference' */
#ifndef SOAP_TYPE_ns2__OSDReference
#define SOAP_TYPE_ns2__OSDReference (891)
#endif

/* ns2__ProfileStatusExtension has binding name 'ns2__ProfileStatusExtension' for type 'ns2:ProfileStatusExtension' */
#ifndef SOAP_TYPE_ns2__ProfileStatusExtension
#define SOAP_TYPE_ns2__ProfileStatusExtension (890)
#endif

/* ns2__ProfileStatus has binding name 'ns2__ProfileStatus' for type 'ns2:ProfileStatus' */
#ifndef SOAP_TYPE_ns2__ProfileStatus
#define SOAP_TYPE_ns2__ProfileStatus (889)
#endif

/* ns2__ActiveConnection has binding name 'ns2__ActiveConnection' for type 'ns2:ActiveConnection' */
#ifndef SOAP_TYPE_ns2__ActiveConnection
#define SOAP_TYPE_ns2__ActiveConnection (888)
#endif

/* ns2__AudioClassDescriptorExtension has binding name 'ns2__AudioClassDescriptorExtension' for type 'ns2:AudioClassDescriptorExtension' */
#ifndef SOAP_TYPE_ns2__AudioClassDescriptorExtension
#define SOAP_TYPE_ns2__AudioClassDescriptorExtension (887)
#endif

/* ns2__AudioClassDescriptor has binding name 'ns2__AudioClassDescriptor' for type 'ns2:AudioClassDescriptor' */
#ifndef SOAP_TYPE_ns2__AudioClassDescriptor
#define SOAP_TYPE_ns2__AudioClassDescriptor (886)
#endif

/* ns2__AudioClassCandidate has binding name 'ns2__AudioClassCandidate' for type 'ns2:AudioClassCandidate' */
#ifndef SOAP_TYPE_ns2__AudioClassCandidate
#define SOAP_TYPE_ns2__AudioClassCandidate (885)
#endif

/* ns2__ActionEngineEventPayloadExtension has binding name 'ns2__ActionEngineEventPayloadExtension' for type 'ns2:ActionEngineEventPayloadExtension' */
#ifndef SOAP_TYPE_ns2__ActionEngineEventPayloadExtension
#define SOAP_TYPE_ns2__ActionEngineEventPayloadExtension (884)
#endif

/* ns2__ActionEngineEventPayload has binding name 'ns2__ActionEngineEventPayload' for type 'ns2:ActionEngineEventPayload' */
#ifndef SOAP_TYPE_ns2__ActionEngineEventPayload
#define SOAP_TYPE_ns2__ActionEngineEventPayload (883)
#endif

/* ns2__AnalyticsState has binding name 'ns2__AnalyticsState' for type 'ns2:AnalyticsState' */
#ifndef SOAP_TYPE_ns2__AnalyticsState
#define SOAP_TYPE_ns2__AnalyticsState (882)
#endif

/* ns2__AnalyticsStateInformation has binding name 'ns2__AnalyticsStateInformation' for type 'ns2:AnalyticsStateInformation' */
#ifndef SOAP_TYPE_ns2__AnalyticsStateInformation
#define SOAP_TYPE_ns2__AnalyticsStateInformation (881)
#endif

/* ns2__AnalyticsEngineControl has binding name 'ns2__AnalyticsEngineControl' for type 'ns2:AnalyticsEngineControl' */
#ifndef SOAP_TYPE_ns2__AnalyticsEngineControl
#define SOAP_TYPE_ns2__AnalyticsEngineControl (880)
#endif

/* ns2__MetadataInputExtension has binding name 'ns2__MetadataInputExtension' for type 'ns2:MetadataInputExtension' */
#ifndef SOAP_TYPE_ns2__MetadataInputExtension
#define SOAP_TYPE_ns2__MetadataInputExtension (879)
#endif

/* ns2__MetadataInput has binding name 'ns2__MetadataInput' for type 'ns2:MetadataInput' */
#ifndef SOAP_TYPE_ns2__MetadataInput
#define SOAP_TYPE_ns2__MetadataInput (878)
#endif

/* ns2__SourceIdentificationExtension has binding name 'ns2__SourceIdentificationExtension' for type 'ns2:SourceIdentificationExtension' */
#ifndef SOAP_TYPE_ns2__SourceIdentificationExtension
#define SOAP_TYPE_ns2__SourceIdentificationExtension (877)
#endif

/* ns2__SourceIdentification has binding name 'ns2__SourceIdentification' for type 'ns2:SourceIdentification' */
#ifndef SOAP_TYPE_ns2__SourceIdentification
#define SOAP_TYPE_ns2__SourceIdentification (876)
#endif

/* ns2__AnalyticsEngineInput has binding name 'ns2__AnalyticsEngineInput' for type 'ns2:AnalyticsEngineInput' */
#ifndef SOAP_TYPE_ns2__AnalyticsEngineInput
#define SOAP_TYPE_ns2__AnalyticsEngineInput (875)
#endif

/* ns2__AnalyticsEngineInputInfoExtension has binding name 'ns2__AnalyticsEngineInputInfoExtension' for type 'ns2:AnalyticsEngineInputInfoExtension' */
#ifndef SOAP_TYPE_ns2__AnalyticsEngineInputInfoExtension
#define SOAP_TYPE_ns2__AnalyticsEngineInputInfoExtension (874)
#endif

/* ns2__AnalyticsEngineInputInfo has binding name 'ns2__AnalyticsEngineInputInfo' for type 'ns2:AnalyticsEngineInputInfo' */
#ifndef SOAP_TYPE_ns2__AnalyticsEngineInputInfo
#define SOAP_TYPE_ns2__AnalyticsEngineInputInfo (873)
#endif

/* ns2__EngineConfiguration has binding name 'ns2__EngineConfiguration' for type 'ns2:EngineConfiguration' */
#ifndef SOAP_TYPE_ns2__EngineConfiguration
#define SOAP_TYPE_ns2__EngineConfiguration (872)
#endif

/* ns2__AnalyticsDeviceEngineConfigurationExtension has binding name 'ns2__AnalyticsDeviceEngineConfigurationExtension' for type 'ns2:AnalyticsDeviceEngineConfigurationExtension' */
#ifndef SOAP_TYPE_ns2__AnalyticsDeviceEngineConfigurationExtension
#define SOAP_TYPE_ns2__AnalyticsDeviceEngineConfigurationExtension (871)
#endif

/* ns2__AnalyticsDeviceEngineConfiguration has binding name 'ns2__AnalyticsDeviceEngineConfiguration' for type 'ns2:AnalyticsDeviceEngineConfiguration' */
#ifndef SOAP_TYPE_ns2__AnalyticsDeviceEngineConfiguration
#define SOAP_TYPE_ns2__AnalyticsDeviceEngineConfiguration (870)
#endif

/* ns2__AnalyticsEngine has binding name 'ns2__AnalyticsEngine' for type 'ns2:AnalyticsEngine' */
#ifndef SOAP_TYPE_ns2__AnalyticsEngine
#define SOAP_TYPE_ns2__AnalyticsEngine (869)
#endif

/* ns2__ReplayConfiguration has binding name 'ns2__ReplayConfiguration' for type 'ns2:ReplayConfiguration' */
#ifndef SOAP_TYPE_ns2__ReplayConfiguration
#define SOAP_TYPE_ns2__ReplayConfiguration (868)
#endif

/* ns2__GetRecordingJobsResponseItem has binding name 'ns2__GetRecordingJobsResponseItem' for type 'ns2:GetRecordingJobsResponseItem' */
#ifndef SOAP_TYPE_ns2__GetRecordingJobsResponseItem
#define SOAP_TYPE_ns2__GetRecordingJobsResponseItem (867)
#endif

/* ns2__RecordingJobStateTrack has binding name 'ns2__RecordingJobStateTrack' for type 'ns2:RecordingJobStateTrack' */
#ifndef SOAP_TYPE_ns2__RecordingJobStateTrack
#define SOAP_TYPE_ns2__RecordingJobStateTrack (866)
#endif

/* ns2__RecordingJobStateTracks has binding name 'ns2__RecordingJobStateTracks' for type 'ns2:RecordingJobStateTracks' */
#ifndef SOAP_TYPE_ns2__RecordingJobStateTracks
#define SOAP_TYPE_ns2__RecordingJobStateTracks (865)
#endif

/* ns2__RecordingJobStateSource has binding name 'ns2__RecordingJobStateSource' for type 'ns2:RecordingJobStateSource' */
#ifndef SOAP_TYPE_ns2__RecordingJobStateSource
#define SOAP_TYPE_ns2__RecordingJobStateSource (864)
#endif

/* ns2__RecordingJobStateInformationExtension has binding name 'ns2__RecordingJobStateInformationExtension' for type 'ns2:RecordingJobStateInformationExtension' */
#ifndef SOAP_TYPE_ns2__RecordingJobStateInformationExtension
#define SOAP_TYPE_ns2__RecordingJobStateInformationExtension (863)
#endif

/* ns2__RecordingJobStateInformation has binding name 'ns2__RecordingJobStateInformation' for type 'ns2:RecordingJobStateInformation' */
#ifndef SOAP_TYPE_ns2__RecordingJobStateInformation
#define SOAP_TYPE_ns2__RecordingJobStateInformation (862)
#endif

/* ns2__RecordingJobTrack has binding name 'ns2__RecordingJobTrack' for type 'ns2:RecordingJobTrack' */
#ifndef SOAP_TYPE_ns2__RecordingJobTrack
#define SOAP_TYPE_ns2__RecordingJobTrack (861)
#endif

/* ns2__RecordingJobSourceExtension has binding name 'ns2__RecordingJobSourceExtension' for type 'ns2:RecordingJobSourceExtension' */
#ifndef SOAP_TYPE_ns2__RecordingJobSourceExtension
#define SOAP_TYPE_ns2__RecordingJobSourceExtension (860)
#endif

/* ns2__RecordingJobSource has binding name 'ns2__RecordingJobSource' for type 'ns2:RecordingJobSource' */
#ifndef SOAP_TYPE_ns2__RecordingJobSource
#define SOAP_TYPE_ns2__RecordingJobSource (859)
#endif

/* ns2__RecordingJobConfigurationExtension has binding name 'ns2__RecordingJobConfigurationExtension' for type 'ns2:RecordingJobConfigurationExtension' */
#ifndef SOAP_TYPE_ns2__RecordingJobConfigurationExtension
#define SOAP_TYPE_ns2__RecordingJobConfigurationExtension (858)
#endif

/* ns2__RecordingJobConfiguration has binding name 'ns2__RecordingJobConfiguration' for type 'ns2:RecordingJobConfiguration' */
#ifndef SOAP_TYPE_ns2__RecordingJobConfiguration
#define SOAP_TYPE_ns2__RecordingJobConfiguration (857)
#endif

/* ns2__GetTracksResponseItem has binding name 'ns2__GetTracksResponseItem' for type 'ns2:GetTracksResponseItem' */
#ifndef SOAP_TYPE_ns2__GetTracksResponseItem
#define SOAP_TYPE_ns2__GetTracksResponseItem (856)
#endif

/* ns2__GetTracksResponseList has binding name 'ns2__GetTracksResponseList' for type 'ns2:GetTracksResponseList' */
#ifndef SOAP_TYPE_ns2__GetTracksResponseList
#define SOAP_TYPE_ns2__GetTracksResponseList (855)
#endif

/* ns2__GetRecordingsResponseItem has binding name 'ns2__GetRecordingsResponseItem' for type 'ns2:GetRecordingsResponseItem' */
#ifndef SOAP_TYPE_ns2__GetRecordingsResponseItem
#define SOAP_TYPE_ns2__GetRecordingsResponseItem (854)
#endif

/* ns2__TrackConfiguration has binding name 'ns2__TrackConfiguration' for type 'ns2:TrackConfiguration' */
#ifndef SOAP_TYPE_ns2__TrackConfiguration
#define SOAP_TYPE_ns2__TrackConfiguration (853)
#endif

/* ns2__RecordingConfiguration has binding name 'ns2__RecordingConfiguration' for type 'ns2:RecordingConfiguration' */
#ifndef SOAP_TYPE_ns2__RecordingConfiguration
#define SOAP_TYPE_ns2__RecordingConfiguration (852)
#endif

/* ns2__MetadataAttributes has binding name 'ns2__MetadataAttributes' for type 'ns2:MetadataAttributes' */
#ifndef SOAP_TYPE_ns2__MetadataAttributes
#define SOAP_TYPE_ns2__MetadataAttributes (851)
#endif

/* ns2__AudioAttributes has binding name 'ns2__AudioAttributes' for type 'ns2:AudioAttributes' */
#ifndef SOAP_TYPE_ns2__AudioAttributes
#define SOAP_TYPE_ns2__AudioAttributes (850)
#endif

/* ns2__VideoAttributes has binding name 'ns2__VideoAttributes' for type 'ns2:VideoAttributes' */
#ifndef SOAP_TYPE_ns2__VideoAttributes
#define SOAP_TYPE_ns2__VideoAttributes (849)
#endif

/* ns2__TrackAttributesExtension has binding name 'ns2__TrackAttributesExtension' for type 'ns2:TrackAttributesExtension' */
#ifndef SOAP_TYPE_ns2__TrackAttributesExtension
#define SOAP_TYPE_ns2__TrackAttributesExtension (848)
#endif

/* ns2__TrackAttributes has binding name 'ns2__TrackAttributes' for type 'ns2:TrackAttributes' */
#ifndef SOAP_TYPE_ns2__TrackAttributes
#define SOAP_TYPE_ns2__TrackAttributes (847)
#endif

/* ns2__MediaAttributes has binding name 'ns2__MediaAttributes' for type 'ns2:MediaAttributes' */
#ifndef SOAP_TYPE_ns2__MediaAttributes
#define SOAP_TYPE_ns2__MediaAttributes (846)
#endif

/* ns2__TrackInformation has binding name 'ns2__TrackInformation' for type 'ns2:TrackInformation' */
#ifndef SOAP_TYPE_ns2__TrackInformation
#define SOAP_TYPE_ns2__TrackInformation (845)
#endif

/* ns2__RecordingSourceInformation has binding name 'ns2__RecordingSourceInformation' for type 'ns2:RecordingSourceInformation' */
#ifndef SOAP_TYPE_ns2__RecordingSourceInformation
#define SOAP_TYPE_ns2__RecordingSourceInformation (844)
#endif

/* ns2__RecordingInformation has binding name 'ns2__RecordingInformation' for type 'ns2:RecordingInformation' */
#ifndef SOAP_TYPE_ns2__RecordingInformation
#define SOAP_TYPE_ns2__RecordingInformation (843)
#endif

/* ns2__FindMetadataResult has binding name 'ns2__FindMetadataResult' for type 'ns2:FindMetadataResult' */
#ifndef SOAP_TYPE_ns2__FindMetadataResult
#define SOAP_TYPE_ns2__FindMetadataResult (842)
#endif

/* ns2__FindMetadataResultList has binding name 'ns2__FindMetadataResultList' for type 'ns2:FindMetadataResultList' */
#ifndef SOAP_TYPE_ns2__FindMetadataResultList
#define SOAP_TYPE_ns2__FindMetadataResultList (841)
#endif

/* ns2__FindPTZPositionResult has binding name 'ns2__FindPTZPositionResult' for type 'ns2:FindPTZPositionResult' */
#ifndef SOAP_TYPE_ns2__FindPTZPositionResult
#define SOAP_TYPE_ns2__FindPTZPositionResult (840)
#endif

/* ns2__FindPTZPositionResultList has binding name 'ns2__FindPTZPositionResultList' for type 'ns2:FindPTZPositionResultList' */
#ifndef SOAP_TYPE_ns2__FindPTZPositionResultList
#define SOAP_TYPE_ns2__FindPTZPositionResultList (839)
#endif

/* ns2__FindEventResult has binding name 'ns2__FindEventResult' for type 'ns2:FindEventResult' */
#ifndef SOAP_TYPE_ns2__FindEventResult
#define SOAP_TYPE_ns2__FindEventResult (838)
#endif

/* ns2__FindEventResultList has binding name 'ns2__FindEventResultList' for type 'ns2:FindEventResultList' */
#ifndef SOAP_TYPE_ns2__FindEventResultList
#define SOAP_TYPE_ns2__FindEventResultList (837)
#endif

/* ns2__FindRecordingResultList has binding name 'ns2__FindRecordingResultList' for type 'ns2:FindRecordingResultList' */
#ifndef SOAP_TYPE_ns2__FindRecordingResultList
#define SOAP_TYPE_ns2__FindRecordingResultList (836)
#endif

/* ns2__MetadataFilter has binding name 'ns2__MetadataFilter' for type 'ns2:MetadataFilter' */
#ifndef SOAP_TYPE_ns2__MetadataFilter
#define SOAP_TYPE_ns2__MetadataFilter (835)
#endif

/* ns2__PTZPositionFilter has binding name 'ns2__PTZPositionFilter' for type 'ns2:PTZPositionFilter' */
#ifndef SOAP_TYPE_ns2__PTZPositionFilter
#define SOAP_TYPE_ns2__PTZPositionFilter (834)
#endif

/* ns2__EventFilter has binding name 'ns2__EventFilter' for type 'ns2:EventFilter' */
#ifndef SOAP_TYPE_ns2__EventFilter
#define SOAP_TYPE_ns2__EventFilter (833)
#endif

/* ns2__SearchScopeExtension has binding name 'ns2__SearchScopeExtension' for type 'ns2:SearchScopeExtension' */
#ifndef SOAP_TYPE_ns2__SearchScopeExtension
#define SOAP_TYPE_ns2__SearchScopeExtension (832)
#endif

/* ns2__SearchScope has binding name 'ns2__SearchScope' for type 'ns2:SearchScope' */
#ifndef SOAP_TYPE_ns2__SearchScope
#define SOAP_TYPE_ns2__SearchScope (831)
#endif

/* ns2__RecordingSummary has binding name 'ns2__RecordingSummary' for type 'ns2:RecordingSummary' */
#ifndef SOAP_TYPE_ns2__RecordingSummary
#define SOAP_TYPE_ns2__RecordingSummary (830)
#endif

/* ns2__DateTimeRange has binding name 'ns2__DateTimeRange' for type 'ns2:DateTimeRange' */
#ifndef SOAP_TYPE_ns2__DateTimeRange
#define SOAP_TYPE_ns2__DateTimeRange (829)
#endif

/* ns2__SourceReference has binding name 'ns2__SourceReference' for type 'ns2:SourceReference' */
#ifndef SOAP_TYPE_ns2__SourceReference
#define SOAP_TYPE_ns2__SourceReference (828)
#endif

/* ns2__ReceiverStateInformation has binding name 'ns2__ReceiverStateInformation' for type 'ns2:ReceiverStateInformation' */
#ifndef SOAP_TYPE_ns2__ReceiverStateInformation
#define SOAP_TYPE_ns2__ReceiverStateInformation (827)
#endif

/* ns2__ReceiverConfiguration has binding name 'ns2__ReceiverConfiguration' for type 'ns2:ReceiverConfiguration' */
#ifndef SOAP_TYPE_ns2__ReceiverConfiguration
#define SOAP_TYPE_ns2__ReceiverConfiguration (826)
#endif

/* ns2__Receiver has binding name 'ns2__Receiver' for type 'ns2:Receiver' */
#ifndef SOAP_TYPE_ns2__Receiver
#define SOAP_TYPE_ns2__Receiver (825)
#endif

/* ns2__PaneOptionExtension has binding name 'ns2__PaneOptionExtension' for type 'ns2:PaneOptionExtension' */
#ifndef SOAP_TYPE_ns2__PaneOptionExtension
#define SOAP_TYPE_ns2__PaneOptionExtension (824)
#endif

/* ns2__PaneLayoutOptions has binding name 'ns2__PaneLayoutOptions' for type 'ns2:PaneLayoutOptions' */
#ifndef SOAP_TYPE_ns2__PaneLayoutOptions
#define SOAP_TYPE_ns2__PaneLayoutOptions (823)
#endif

/* ns2__LayoutOptionsExtension has binding name 'ns2__LayoutOptionsExtension' for type 'ns2:LayoutOptionsExtension' */
#ifndef SOAP_TYPE_ns2__LayoutOptionsExtension
#define SOAP_TYPE_ns2__LayoutOptionsExtension (822)
#endif

/* ns2__LayoutOptions has binding name 'ns2__LayoutOptions' for type 'ns2:LayoutOptions' */
#ifndef SOAP_TYPE_ns2__LayoutOptions
#define SOAP_TYPE_ns2__LayoutOptions (821)
#endif

/* ns2__CodingCapabilities has binding name 'ns2__CodingCapabilities' for type 'ns2:CodingCapabilities' */
#ifndef SOAP_TYPE_ns2__CodingCapabilities
#define SOAP_TYPE_ns2__CodingCapabilities (820)
#endif

/* ns2__LayoutExtension has binding name 'ns2__LayoutExtension' for type 'ns2:LayoutExtension' */
#ifndef SOAP_TYPE_ns2__LayoutExtension
#define SOAP_TYPE_ns2__LayoutExtension (819)
#endif

/* ns2__Layout has binding name 'ns2__Layout' for type 'ns2:Layout' */
#ifndef SOAP_TYPE_ns2__Layout
#define SOAP_TYPE_ns2__Layout (818)
#endif

/* ns2__PaneLayout has binding name 'ns2__PaneLayout' for type 'ns2:PaneLayout' */
#ifndef SOAP_TYPE_ns2__PaneLayout
#define SOAP_TYPE_ns2__PaneLayout (817)
#endif

/* ns2__PaneConfiguration has binding name 'ns2__PaneConfiguration' for type 'ns2:PaneConfiguration' */
#ifndef SOAP_TYPE_ns2__PaneConfiguration
#define SOAP_TYPE_ns2__PaneConfiguration (816)
#endif

/* ns2__EventStreamExtension has binding name 'ns2__EventStreamExtension' for type 'ns2:EventStreamExtension' */
#ifndef SOAP_TYPE_ns2__EventStreamExtension
#define SOAP_TYPE_ns2__EventStreamExtension (815)
#endif

/* ns2__EventStream has binding name 'ns2__EventStream' for type 'ns2:EventStream' */
#ifndef SOAP_TYPE_ns2__EventStream
#define SOAP_TYPE_ns2__EventStream (814)
#endif

/* ns2__PTZStreamExtension has binding name 'ns2__PTZStreamExtension' for type 'ns2:PTZStreamExtension' */
#ifndef SOAP_TYPE_ns2__PTZStreamExtension
#define SOAP_TYPE_ns2__PTZStreamExtension (813)
#endif

/* ns2__PTZStream has binding name 'ns2__PTZStream' for type 'ns2:PTZStream' */
#ifndef SOAP_TYPE_ns2__PTZStream
#define SOAP_TYPE_ns2__PTZStream (812)
#endif

/* ns2__VideoAnalyticsStreamExtension has binding name 'ns2__VideoAnalyticsStreamExtension' for type 'ns2:VideoAnalyticsStreamExtension' */
#ifndef SOAP_TYPE_ns2__VideoAnalyticsStreamExtension
#define SOAP_TYPE_ns2__VideoAnalyticsStreamExtension (811)
#endif

/* ns2__VideoAnalyticsStream has binding name 'ns2__VideoAnalyticsStream' for type 'ns2:VideoAnalyticsStream' */
#ifndef SOAP_TYPE_ns2__VideoAnalyticsStream
#define SOAP_TYPE_ns2__VideoAnalyticsStream (810)
#endif

/* ns2__AudioAnalyticsStreamExtension has binding name 'ns2__AudioAnalyticsStreamExtension' for type 'ns2:AudioAnalyticsStreamExtension' */
#ifndef SOAP_TYPE_ns2__AudioAnalyticsStreamExtension
#define SOAP_TYPE_ns2__AudioAnalyticsStreamExtension (809)
#endif

/* ns2__AudioDescriptor has binding name 'ns2__AudioDescriptor' for type 'ns2:AudioDescriptor' */
#ifndef SOAP_TYPE_ns2__AudioDescriptor
#define SOAP_TYPE_ns2__AudioDescriptor (808)
#endif

/* ns2__AudioAnalyticsStream has binding name 'ns2__AudioAnalyticsStream' for type 'ns2:AudioAnalyticsStream' */
#ifndef SOAP_TYPE_ns2__AudioAnalyticsStream
#define SOAP_TYPE_ns2__AudioAnalyticsStream (807)
#endif

/* ns2__MetadataStreamExtension2 has binding name 'ns2__MetadataStreamExtension2' for type 'ns2:MetadataStreamExtension2' */
#ifndef SOAP_TYPE_ns2__MetadataStreamExtension2
#define SOAP_TYPE_ns2__MetadataStreamExtension2 (806)
#endif

/* ns2__MetadataStreamExtension has binding name 'ns2__MetadataStreamExtension' for type 'ns2:MetadataStreamExtension' */
#ifndef SOAP_TYPE_ns2__MetadataStreamExtension
#define SOAP_TYPE_ns2__MetadataStreamExtension (805)
#endif

/* ns2__MetadataStream has binding name 'ns2__MetadataStream' for type 'ns2:MetadataStream' */
#ifndef SOAP_TYPE_ns2__MetadataStream
#define SOAP_TYPE_ns2__MetadataStream (804)
#endif

/* ns2__CellLayout has binding name 'ns2__CellLayout' for type 'ns2:CellLayout' */
#ifndef SOAP_TYPE_ns2__CellLayout
#define SOAP_TYPE_ns2__CellLayout (803)
#endif

/* ns2__MotionExpressionConfiguration has binding name 'ns2__MotionExpressionConfiguration' for type 'ns2:MotionExpressionConfiguration' */
#ifndef SOAP_TYPE_ns2__MotionExpressionConfiguration
#define SOAP_TYPE_ns2__MotionExpressionConfiguration (802)
#endif

/* ns2__MotionExpression has binding name 'ns2__MotionExpression' for type 'ns2:MotionExpression' */
#ifndef SOAP_TYPE_ns2__MotionExpression
#define SOAP_TYPE_ns2__MotionExpression (801)
#endif

/* ns2__PolylineArrayConfiguration has binding name 'ns2__PolylineArrayConfiguration' for type 'ns2:PolylineArrayConfiguration' */
#ifndef SOAP_TYPE_ns2__PolylineArrayConfiguration
#define SOAP_TYPE_ns2__PolylineArrayConfiguration (800)
#endif

/* ns2__PolylineArrayExtension has binding name 'ns2__PolylineArrayExtension' for type 'ns2:PolylineArrayExtension' */
#ifndef SOAP_TYPE_ns2__PolylineArrayExtension
#define SOAP_TYPE_ns2__PolylineArrayExtension (799)
#endif

/* ns2__PolylineArray has binding name 'ns2__PolylineArray' for type 'ns2:PolylineArray' */
#ifndef SOAP_TYPE_ns2__PolylineArray
#define SOAP_TYPE_ns2__PolylineArray (798)
#endif

/* ns2__PolygonConfiguration has binding name 'ns2__PolygonConfiguration' for type 'ns2:PolygonConfiguration' */
#ifndef SOAP_TYPE_ns2__PolygonConfiguration
#define SOAP_TYPE_ns2__PolygonConfiguration (797)
#endif

/* ns2__SupportedAnalyticsModulesExtension has binding name 'ns2__SupportedAnalyticsModulesExtension' for type 'ns2:SupportedAnalyticsModulesExtension' */
#ifndef SOAP_TYPE_ns2__SupportedAnalyticsModulesExtension
#define SOAP_TYPE_ns2__SupportedAnalyticsModulesExtension (796)
#endif

/* ns2__SupportedAnalyticsModules has binding name 'ns2__SupportedAnalyticsModules' for type 'ns2:SupportedAnalyticsModules' */
#ifndef SOAP_TYPE_ns2__SupportedAnalyticsModules
#define SOAP_TYPE_ns2__SupportedAnalyticsModules (795)
#endif

/* ns2__SupportedRulesExtension has binding name 'ns2__SupportedRulesExtension' for type 'ns2:SupportedRulesExtension' */
#ifndef SOAP_TYPE_ns2__SupportedRulesExtension
#define SOAP_TYPE_ns2__SupportedRulesExtension (794)
#endif

/* ns2__SupportedRules has binding name 'ns2__SupportedRules' for type 'ns2:SupportedRules' */
#ifndef SOAP_TYPE_ns2__SupportedRules
#define SOAP_TYPE_ns2__SupportedRules (793)
#endif

/* ns2__ConfigDescriptionExtension has binding name 'ns2__ConfigDescriptionExtension' for type 'ns2:ConfigDescriptionExtension' */
#ifndef SOAP_TYPE_ns2__ConfigDescriptionExtension
#define SOAP_TYPE_ns2__ConfigDescriptionExtension (792)
#endif

/* ns2__ConfigDescription has binding name 'ns2__ConfigDescription' for type 'ns2:ConfigDescription' */
#ifndef SOAP_TYPE_ns2__ConfigDescription
#define SOAP_TYPE_ns2__ConfigDescription (791)
#endif

/* ns2__Config has binding name 'ns2__Config' for type 'ns2:Config' */
#ifndef SOAP_TYPE_ns2__Config
#define SOAP_TYPE_ns2__Config (790)
#endif

/* ns2__RuleEngineConfigurationExtension has binding name 'ns2__RuleEngineConfigurationExtension' for type 'ns2:RuleEngineConfigurationExtension' */
#ifndef SOAP_TYPE_ns2__RuleEngineConfigurationExtension
#define SOAP_TYPE_ns2__RuleEngineConfigurationExtension (789)
#endif

/* ns2__RuleEngineConfiguration has binding name 'ns2__RuleEngineConfiguration' for type 'ns2:RuleEngineConfiguration' */
#ifndef SOAP_TYPE_ns2__RuleEngineConfiguration
#define SOAP_TYPE_ns2__RuleEngineConfiguration (788)
#endif

/* ns2__AnalyticsEngineConfigurationExtension has binding name 'ns2__AnalyticsEngineConfigurationExtension' for type 'ns2:AnalyticsEngineConfigurationExtension' */
#ifndef SOAP_TYPE_ns2__AnalyticsEngineConfigurationExtension
#define SOAP_TYPE_ns2__AnalyticsEngineConfigurationExtension (787)
#endif

/* ns2__AnalyticsEngineConfiguration has binding name 'ns2__AnalyticsEngineConfiguration' for type 'ns2:AnalyticsEngineConfiguration' */
#ifndef SOAP_TYPE_ns2__AnalyticsEngineConfiguration
#define SOAP_TYPE_ns2__AnalyticsEngineConfiguration (786)
#endif

/* ns2__MotionInCells has binding name 'ns2__MotionInCells' for type 'ns2:MotionInCells' */
#ifndef SOAP_TYPE_ns2__MotionInCells
#define SOAP_TYPE_ns2__MotionInCells (785)
#endif

/* ns2__ObjectTreeExtension has binding name 'ns2__ObjectTreeExtension' for type 'ns2:ObjectTreeExtension' */
#ifndef SOAP_TYPE_ns2__ObjectTreeExtension
#define SOAP_TYPE_ns2__ObjectTreeExtension (784)
#endif

/* ns2__ObjectTree has binding name 'ns2__ObjectTree' for type 'ns2:ObjectTree' */
#ifndef SOAP_TYPE_ns2__ObjectTree
#define SOAP_TYPE_ns2__ObjectTree (783)
#endif

/* ns2__BehaviourExtension has binding name 'ns2__BehaviourExtension' for type 'ns2:BehaviourExtension' */
#ifndef SOAP_TYPE_ns2__BehaviourExtension
#define SOAP_TYPE_ns2__BehaviourExtension (782)
#endif

/* ns2__Behaviour has binding name 'ns2__Behaviour' for type 'ns2:Behaviour' */
#ifndef SOAP_TYPE_ns2__Behaviour
#define SOAP_TYPE_ns2__Behaviour (781)
#endif

/* ns2__ObjectId has binding name 'ns2__ObjectId' for type 'ns2:ObjectId' */
#ifndef SOAP_TYPE_ns2__ObjectId
#define SOAP_TYPE_ns2__ObjectId (780)
#endif

/* ns2__Rename has binding name 'ns2__Rename' for type 'ns2:Rename' */
#ifndef SOAP_TYPE_ns2__Rename
#define SOAP_TYPE_ns2__Rename (779)
#endif

/* ns2__Split has binding name 'ns2__Split' for type 'ns2:Split' */
#ifndef SOAP_TYPE_ns2__Split
#define SOAP_TYPE_ns2__Split (778)
#endif

/* ns2__Merge has binding name 'ns2__Merge' for type 'ns2:Merge' */
#ifndef SOAP_TYPE_ns2__Merge
#define SOAP_TYPE_ns2__Merge (777)
#endif

/* ns2__FrameExtension2 has binding name 'ns2__FrameExtension2' for type 'ns2:FrameExtension2' */
#ifndef SOAP_TYPE_ns2__FrameExtension2
#define SOAP_TYPE_ns2__FrameExtension2 (776)
#endif

/* ns2__FrameExtension has binding name 'ns2__FrameExtension' for type 'ns2:FrameExtension' */
#ifndef SOAP_TYPE_ns2__FrameExtension
#define SOAP_TYPE_ns2__FrameExtension (775)
#endif

/* ns2__Frame has binding name 'ns2__Frame' for type 'ns2:Frame' */
#ifndef SOAP_TYPE_ns2__Frame
#define SOAP_TYPE_ns2__Frame (774)
#endif

/* ns2__TransformationExtension has binding name 'ns2__TransformationExtension' for type 'ns2:TransformationExtension' */
#ifndef SOAP_TYPE_ns2__TransformationExtension
#define SOAP_TYPE_ns2__TransformationExtension (773)
#endif

/* ns2__Transformation has binding name 'ns2__Transformation' for type 'ns2:Transformation' */
#ifndef SOAP_TYPE_ns2__Transformation
#define SOAP_TYPE_ns2__Transformation (772)
#endif

/* ns2__ObjectExtension has binding name 'ns2__ObjectExtension' for type 'ns2:ObjectExtension' */
#ifndef SOAP_TYPE_ns2__ObjectExtension
#define SOAP_TYPE_ns2__ObjectExtension (771)
#endif

/* ns2__Object has binding name 'ns2__Object' for type 'ns2:Object' */
#ifndef SOAP_TYPE_ns2__Object
#define SOAP_TYPE_ns2__Object (770)
#endif

/* ns2__OtherType has binding name 'ns2__OtherType' for type 'ns2:OtherType' */
#ifndef SOAP_TYPE_ns2__OtherType
#define SOAP_TYPE_ns2__OtherType (769)
#endif

/* ns2__ClassDescriptorExtension2 has binding name 'ns2__ClassDescriptorExtension2' for type 'ns2:ClassDescriptorExtension2' */
#ifndef SOAP_TYPE_ns2__ClassDescriptorExtension2
#define SOAP_TYPE_ns2__ClassDescriptorExtension2 (768)
#endif

/* ns2__ClassDescriptorExtension has binding name 'ns2__ClassDescriptorExtension' for type 'ns2:ClassDescriptorExtension' */
#ifndef SOAP_TYPE_ns2__ClassDescriptorExtension
#define SOAP_TYPE_ns2__ClassDescriptorExtension (767)
#endif

/* ns2__ClassDescriptor has binding name 'ns2__ClassDescriptor' for type 'ns2:ClassDescriptor' */
#ifndef SOAP_TYPE_ns2__ClassDescriptor
#define SOAP_TYPE_ns2__ClassDescriptor (766)
#endif

/* ns2__ColorDescriptorExtension has binding name 'ns2__ColorDescriptorExtension' for type 'ns2:ColorDescriptorExtension' */
#ifndef SOAP_TYPE_ns2__ColorDescriptorExtension
#define SOAP_TYPE_ns2__ColorDescriptorExtension (765)
#endif

/* ns2__ColorDescriptor has binding name 'ns2__ColorDescriptor' for type 'ns2:ColorDescriptor' */
#ifndef SOAP_TYPE_ns2__ColorDescriptor
#define SOAP_TYPE_ns2__ColorDescriptor (764)
#endif

/* ns2__ShapeDescriptorExtension has binding name 'ns2__ShapeDescriptorExtension' for type 'ns2:ShapeDescriptorExtension' */
#ifndef SOAP_TYPE_ns2__ShapeDescriptorExtension
#define SOAP_TYPE_ns2__ShapeDescriptorExtension (763)
#endif

/* ns2__ShapeDescriptor has binding name 'ns2__ShapeDescriptor' for type 'ns2:ShapeDescriptor' */
#ifndef SOAP_TYPE_ns2__ShapeDescriptor
#define SOAP_TYPE_ns2__ShapeDescriptor (762)
#endif

/* ns2__AppearanceExtension has binding name 'ns2__AppearanceExtension' for type 'ns2:AppearanceExtension' */
#ifndef SOAP_TYPE_ns2__AppearanceExtension
#define SOAP_TYPE_ns2__AppearanceExtension (761)
#endif

/* ns2__Appearance has binding name 'ns2__Appearance' for type 'ns2:Appearance' */
#ifndef SOAP_TYPE_ns2__Appearance
#define SOAP_TYPE_ns2__Appearance (760)
#endif

/* ns2__ColorCovariance has binding name 'ns2__ColorCovariance' for type 'ns2:ColorCovariance' */
#ifndef SOAP_TYPE_ns2__ColorCovariance
#define SOAP_TYPE_ns2__ColorCovariance (759)
#endif

/* ns2__Color has binding name 'ns2__Color' for type 'ns2:Color' */
#ifndef SOAP_TYPE_ns2__Color
#define SOAP_TYPE_ns2__Color (758)
#endif

/* ns2__Polyline has binding name 'ns2__Polyline' for type 'ns2:Polyline' */
#ifndef SOAP_TYPE_ns2__Polyline
#define SOAP_TYPE_ns2__Polyline (757)
#endif

/* ns2__Polygon has binding name 'ns2__Polygon' for type 'ns2:Polygon' */
#ifndef SOAP_TYPE_ns2__Polygon
#define SOAP_TYPE_ns2__Polygon (756)
#endif

/* ns2__Rectangle has binding name 'ns2__Rectangle' for type 'ns2:Rectangle' */
#ifndef SOAP_TYPE_ns2__Rectangle
#define SOAP_TYPE_ns2__Rectangle (755)
#endif

/* ns2__Vector has binding name 'ns2__Vector' for type 'ns2:Vector' */
#ifndef SOAP_TYPE_ns2__Vector
#define SOAP_TYPE_ns2__Vector (754)
#endif

/* ns2__ItemListDescriptionExtension has binding name 'ns2__ItemListDescriptionExtension' for type 'ns2:ItemListDescriptionExtension' */
#ifndef SOAP_TYPE_ns2__ItemListDescriptionExtension
#define SOAP_TYPE_ns2__ItemListDescriptionExtension (753)
#endif

/* ns2__ItemListDescription has binding name 'ns2__ItemListDescription' for type 'ns2:ItemListDescription' */
#ifndef SOAP_TYPE_ns2__ItemListDescription
#define SOAP_TYPE_ns2__ItemListDescription (752)
#endif

/* ns2__MessageDescriptionExtension has binding name 'ns2__MessageDescriptionExtension' for type 'ns2:MessageDescriptionExtension' */
#ifndef SOAP_TYPE_ns2__MessageDescriptionExtension
#define SOAP_TYPE_ns2__MessageDescriptionExtension (751)
#endif

/* ns2__MessageDescription has binding name 'ns2__MessageDescription' for type 'ns2:MessageDescription' */
#ifndef SOAP_TYPE_ns2__MessageDescription
#define SOAP_TYPE_ns2__MessageDescription (750)
#endif

/* ns2__ItemListExtension has binding name 'ns2__ItemListExtension' for type 'ns2:ItemListExtension' */
#ifndef SOAP_TYPE_ns2__ItemListExtension
#define SOAP_TYPE_ns2__ItemListExtension (749)
#endif

/* ns2__ItemList has binding name 'ns2__ItemList' for type 'ns2:ItemList' */
#ifndef SOAP_TYPE_ns2__ItemList
#define SOAP_TYPE_ns2__ItemList (748)
#endif

/* ns2__MessageExtension has binding name 'ns2__MessageExtension' for type 'ns2:MessageExtension' */
#ifndef SOAP_TYPE_ns2__MessageExtension
#define SOAP_TYPE_ns2__MessageExtension (747)
#endif

/* ns2__NoiseReductionOptions has binding name 'ns2__NoiseReductionOptions' for type 'ns2:NoiseReductionOptions' */
#ifndef SOAP_TYPE_ns2__NoiseReductionOptions
#define SOAP_TYPE_ns2__NoiseReductionOptions (746)
#endif

/* ns2__DefoggingOptions has binding name 'ns2__DefoggingOptions' for type 'ns2:DefoggingOptions' */
#ifndef SOAP_TYPE_ns2__DefoggingOptions
#define SOAP_TYPE_ns2__DefoggingOptions (745)
#endif

/* ns2__ToneCompensationOptions has binding name 'ns2__ToneCompensationOptions' for type 'ns2:ToneCompensationOptions' */
#ifndef SOAP_TYPE_ns2__ToneCompensationOptions
#define SOAP_TYPE_ns2__ToneCompensationOptions (744)
#endif

/* ns2__FocusOptions20Extension has binding name 'ns2__FocusOptions20Extension' for type 'ns2:FocusOptions20Extension' */
#ifndef SOAP_TYPE_ns2__FocusOptions20Extension
#define SOAP_TYPE_ns2__FocusOptions20Extension (743)
#endif

/* ns2__FocusOptions20 has binding name 'ns2__FocusOptions20' for type 'ns2:FocusOptions20' */
#ifndef SOAP_TYPE_ns2__FocusOptions20
#define SOAP_TYPE_ns2__FocusOptions20 (742)
#endif

/* ns2__WhiteBalanceOptions20Extension has binding name 'ns2__WhiteBalanceOptions20Extension' for type 'ns2:WhiteBalanceOptions20Extension' */
#ifndef SOAP_TYPE_ns2__WhiteBalanceOptions20Extension
#define SOAP_TYPE_ns2__WhiteBalanceOptions20Extension (741)
#endif

/* ns2__WhiteBalanceOptions20 has binding name 'ns2__WhiteBalanceOptions20' for type 'ns2:WhiteBalanceOptions20' */
#ifndef SOAP_TYPE_ns2__WhiteBalanceOptions20
#define SOAP_TYPE_ns2__WhiteBalanceOptions20 (740)
#endif

/* ns2__FocusConfiguration20Extension has binding name 'ns2__FocusConfiguration20Extension' for type 'ns2:FocusConfiguration20Extension' */
#ifndef SOAP_TYPE_ns2__FocusConfiguration20Extension
#define SOAP_TYPE_ns2__FocusConfiguration20Extension (739)
#endif

/* ns2__FocusConfiguration20 has binding name 'ns2__FocusConfiguration20' for type 'ns2:FocusConfiguration20' */
#ifndef SOAP_TYPE_ns2__FocusConfiguration20
#define SOAP_TYPE_ns2__FocusConfiguration20 (738)
#endif

/* ns2__WhiteBalance20Extension has binding name 'ns2__WhiteBalance20Extension' for type 'ns2:WhiteBalance20Extension' */
#ifndef SOAP_TYPE_ns2__WhiteBalance20Extension
#define SOAP_TYPE_ns2__WhiteBalance20Extension (737)
#endif

/* ns2__WhiteBalance20 has binding name 'ns2__WhiteBalance20' for type 'ns2:WhiteBalance20' */
#ifndef SOAP_TYPE_ns2__WhiteBalance20
#define SOAP_TYPE_ns2__WhiteBalance20 (736)
#endif

/* ns2__RelativeFocusOptions20 has binding name 'ns2__RelativeFocusOptions20' for type 'ns2:RelativeFocusOptions20' */
#ifndef SOAP_TYPE_ns2__RelativeFocusOptions20
#define SOAP_TYPE_ns2__RelativeFocusOptions20 (735)
#endif

/* ns2__MoveOptions20 has binding name 'ns2__MoveOptions20' for type 'ns2:MoveOptions20' */
#ifndef SOAP_TYPE_ns2__MoveOptions20
#define SOAP_TYPE_ns2__MoveOptions20 (734)
#endif

/* ns2__ExposureOptions20 has binding name 'ns2__ExposureOptions20' for type 'ns2:ExposureOptions20' */
#ifndef SOAP_TYPE_ns2__ExposureOptions20
#define SOAP_TYPE_ns2__ExposureOptions20 (733)
#endif

/* ns2__BacklightCompensationOptions20 has binding name 'ns2__BacklightCompensationOptions20' for type 'ns2:BacklightCompensationOptions20' */
#ifndef SOAP_TYPE_ns2__BacklightCompensationOptions20
#define SOAP_TYPE_ns2__BacklightCompensationOptions20 (732)
#endif

/* ns2__WideDynamicRangeOptions20 has binding name 'ns2__WideDynamicRangeOptions20' for type 'ns2:WideDynamicRangeOptions20' */
#ifndef SOAP_TYPE_ns2__WideDynamicRangeOptions20
#define SOAP_TYPE_ns2__WideDynamicRangeOptions20 (731)
#endif

/* ns2__IrCutFilterAutoAdjustmentOptionsExtension has binding name 'ns2__IrCutFilterAutoAdjustmentOptionsExtension' for type 'ns2:IrCutFilterAutoAdjustmentOptionsExtension' */
#ifndef SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentOptionsExtension
#define SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentOptionsExtension (730)
#endif

/* ns2__IrCutFilterAutoAdjustmentOptions has binding name 'ns2__IrCutFilterAutoAdjustmentOptions' for type 'ns2:IrCutFilterAutoAdjustmentOptions' */
#ifndef SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentOptions
#define SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentOptions (729)
#endif

/* ns2__ImageStabilizationOptionsExtension has binding name 'ns2__ImageStabilizationOptionsExtension' for type 'ns2:ImageStabilizationOptionsExtension' */
#ifndef SOAP_TYPE_ns2__ImageStabilizationOptionsExtension
#define SOAP_TYPE_ns2__ImageStabilizationOptionsExtension (728)
#endif

/* ns2__ImageStabilizationOptions has binding name 'ns2__ImageStabilizationOptions' for type 'ns2:ImageStabilizationOptions' */
#ifndef SOAP_TYPE_ns2__ImageStabilizationOptions
#define SOAP_TYPE_ns2__ImageStabilizationOptions (727)
#endif

/* ns2__ImagingOptions20Extension4 has binding name 'ns2__ImagingOptions20Extension4' for type 'ns2:ImagingOptions20Extension4' */
#ifndef SOAP_TYPE_ns2__ImagingOptions20Extension4
#define SOAP_TYPE_ns2__ImagingOptions20Extension4 (726)
#endif

/* ns2__ImagingOptions20Extension3 has binding name 'ns2__ImagingOptions20Extension3' for type 'ns2:ImagingOptions20Extension3' */
#ifndef SOAP_TYPE_ns2__ImagingOptions20Extension3
#define SOAP_TYPE_ns2__ImagingOptions20Extension3 (725)
#endif

/* ns2__ImagingOptions20Extension2 has binding name 'ns2__ImagingOptions20Extension2' for type 'ns2:ImagingOptions20Extension2' */
#ifndef SOAP_TYPE_ns2__ImagingOptions20Extension2
#define SOAP_TYPE_ns2__ImagingOptions20Extension2 (724)
#endif

/* ns2__ImagingOptions20Extension has binding name 'ns2__ImagingOptions20Extension' for type 'ns2:ImagingOptions20Extension' */
#ifndef SOAP_TYPE_ns2__ImagingOptions20Extension
#define SOAP_TYPE_ns2__ImagingOptions20Extension (723)
#endif

/* ns2__ImagingOptions20 has binding name 'ns2__ImagingOptions20' for type 'ns2:ImagingOptions20' */
#ifndef SOAP_TYPE_ns2__ImagingOptions20
#define SOAP_TYPE_ns2__ImagingOptions20 (722)
#endif

/* ns2__NoiseReduction has binding name 'ns2__NoiseReduction' for type 'ns2:NoiseReduction' */
#ifndef SOAP_TYPE_ns2__NoiseReduction
#define SOAP_TYPE_ns2__NoiseReduction (721)
#endif

/* ns2__DefoggingExtension has binding name 'ns2__DefoggingExtension' for type 'ns2:DefoggingExtension' */
#ifndef SOAP_TYPE_ns2__DefoggingExtension
#define SOAP_TYPE_ns2__DefoggingExtension (720)
#endif

/* ns2__Defogging has binding name 'ns2__Defogging' for type 'ns2:Defogging' */
#ifndef SOAP_TYPE_ns2__Defogging
#define SOAP_TYPE_ns2__Defogging (719)
#endif

/* ns2__ToneCompensationExtension has binding name 'ns2__ToneCompensationExtension' for type 'ns2:ToneCompensationExtension' */
#ifndef SOAP_TYPE_ns2__ToneCompensationExtension
#define SOAP_TYPE_ns2__ToneCompensationExtension (718)
#endif

/* ns2__ToneCompensation has binding name 'ns2__ToneCompensation' for type 'ns2:ToneCompensation' */
#ifndef SOAP_TYPE_ns2__ToneCompensation
#define SOAP_TYPE_ns2__ToneCompensation (717)
#endif

/* ns2__Exposure20 has binding name 'ns2__Exposure20' for type 'ns2:Exposure20' */
#ifndef SOAP_TYPE_ns2__Exposure20
#define SOAP_TYPE_ns2__Exposure20 (716)
#endif

/* ns2__BacklightCompensation20 has binding name 'ns2__BacklightCompensation20' for type 'ns2:BacklightCompensation20' */
#ifndef SOAP_TYPE_ns2__BacklightCompensation20
#define SOAP_TYPE_ns2__BacklightCompensation20 (715)
#endif

/* ns2__WideDynamicRange20 has binding name 'ns2__WideDynamicRange20' for type 'ns2:WideDynamicRange20' */
#ifndef SOAP_TYPE_ns2__WideDynamicRange20
#define SOAP_TYPE_ns2__WideDynamicRange20 (714)
#endif

/* ns2__IrCutFilterAutoAdjustmentExtension has binding name 'ns2__IrCutFilterAutoAdjustmentExtension' for type 'ns2:IrCutFilterAutoAdjustmentExtension' */
#ifndef SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentExtension
#define SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentExtension (713)
#endif

/* ns2__IrCutFilterAutoAdjustment has binding name 'ns2__IrCutFilterAutoAdjustment' for type 'ns2:IrCutFilterAutoAdjustment' */
#ifndef SOAP_TYPE_ns2__IrCutFilterAutoAdjustment
#define SOAP_TYPE_ns2__IrCutFilterAutoAdjustment (712)
#endif

/* ns2__ImageStabilizationExtension has binding name 'ns2__ImageStabilizationExtension' for type 'ns2:ImageStabilizationExtension' */
#ifndef SOAP_TYPE_ns2__ImageStabilizationExtension
#define SOAP_TYPE_ns2__ImageStabilizationExtension (711)
#endif

/* ns2__ImageStabilization has binding name 'ns2__ImageStabilization' for type 'ns2:ImageStabilization' */
#ifndef SOAP_TYPE_ns2__ImageStabilization
#define SOAP_TYPE_ns2__ImageStabilization (710)
#endif

/* ns2__ImagingSettingsExtension204 has binding name 'ns2__ImagingSettingsExtension204' for type 'ns2:ImagingSettingsExtension204' */
#ifndef SOAP_TYPE_ns2__ImagingSettingsExtension204
#define SOAP_TYPE_ns2__ImagingSettingsExtension204 (709)
#endif

/* ns2__ImagingSettingsExtension203 has binding name 'ns2__ImagingSettingsExtension203' for type 'ns2:ImagingSettingsExtension203' */
#ifndef SOAP_TYPE_ns2__ImagingSettingsExtension203
#define SOAP_TYPE_ns2__ImagingSettingsExtension203 (708)
#endif

/* ns2__ImagingSettingsExtension202 has binding name 'ns2__ImagingSettingsExtension202' for type 'ns2:ImagingSettingsExtension202' */
#ifndef SOAP_TYPE_ns2__ImagingSettingsExtension202
#define SOAP_TYPE_ns2__ImagingSettingsExtension202 (707)
#endif

/* ns2__ImagingSettingsExtension20 has binding name 'ns2__ImagingSettingsExtension20' for type 'ns2:ImagingSettingsExtension20' */
#ifndef SOAP_TYPE_ns2__ImagingSettingsExtension20
#define SOAP_TYPE_ns2__ImagingSettingsExtension20 (706)
#endif

/* ns2__ImagingSettings20 has binding name 'ns2__ImagingSettings20' for type 'ns2:ImagingSettings20' */
#ifndef SOAP_TYPE_ns2__ImagingSettings20
#define SOAP_TYPE_ns2__ImagingSettings20 (705)
#endif

/* ns2__FocusStatus20Extension has binding name 'ns2__FocusStatus20Extension' for type 'ns2:FocusStatus20Extension' */
#ifndef SOAP_TYPE_ns2__FocusStatus20Extension
#define SOAP_TYPE_ns2__FocusStatus20Extension (704)
#endif

/* ns2__FocusStatus20 has binding name 'ns2__FocusStatus20' for type 'ns2:FocusStatus20' */
#ifndef SOAP_TYPE_ns2__FocusStatus20
#define SOAP_TYPE_ns2__FocusStatus20 (703)
#endif

/* ns2__ImagingStatus20Extension has binding name 'ns2__ImagingStatus20Extension' for type 'ns2:ImagingStatus20Extension' */
#ifndef SOAP_TYPE_ns2__ImagingStatus20Extension
#define SOAP_TYPE_ns2__ImagingStatus20Extension (702)
#endif

/* ns2__ImagingStatus20 has binding name 'ns2__ImagingStatus20' for type 'ns2:ImagingStatus20' */
#ifndef SOAP_TYPE_ns2__ImagingStatus20
#define SOAP_TYPE_ns2__ImagingStatus20 (701)
#endif

/* ns2__WhiteBalance has binding name 'ns2__WhiteBalance' for type 'ns2:WhiteBalance' */
#ifndef SOAP_TYPE_ns2__WhiteBalance
#define SOAP_TYPE_ns2__WhiteBalance (700)
#endif

/* ns2__ContinuousFocusOptions has binding name 'ns2__ContinuousFocusOptions' for type 'ns2:ContinuousFocusOptions' */
#ifndef SOAP_TYPE_ns2__ContinuousFocusOptions
#define SOAP_TYPE_ns2__ContinuousFocusOptions (699)
#endif

/* ns2__RelativeFocusOptions has binding name 'ns2__RelativeFocusOptions' for type 'ns2:RelativeFocusOptions' */
#ifndef SOAP_TYPE_ns2__RelativeFocusOptions
#define SOAP_TYPE_ns2__RelativeFocusOptions (698)
#endif

/* ns2__AbsoluteFocusOptions has binding name 'ns2__AbsoluteFocusOptions' for type 'ns2:AbsoluteFocusOptions' */
#ifndef SOAP_TYPE_ns2__AbsoluteFocusOptions
#define SOAP_TYPE_ns2__AbsoluteFocusOptions (697)
#endif

/* ns2__MoveOptions has binding name 'ns2__MoveOptions' for type 'ns2:MoveOptions' */
#ifndef SOAP_TYPE_ns2__MoveOptions
#define SOAP_TYPE_ns2__MoveOptions (696)
#endif

/* ns2__ContinuousFocus has binding name 'ns2__ContinuousFocus' for type 'ns2:ContinuousFocus' */
#ifndef SOAP_TYPE_ns2__ContinuousFocus
#define SOAP_TYPE_ns2__ContinuousFocus (695)
#endif

/* ns2__RelativeFocus has binding name 'ns2__RelativeFocus' for type 'ns2:RelativeFocus' */
#ifndef SOAP_TYPE_ns2__RelativeFocus
#define SOAP_TYPE_ns2__RelativeFocus (694)
#endif

/* ns2__AbsoluteFocus has binding name 'ns2__AbsoluteFocus' for type 'ns2:AbsoluteFocus' */
#ifndef SOAP_TYPE_ns2__AbsoluteFocus
#define SOAP_TYPE_ns2__AbsoluteFocus (693)
#endif

/* ns2__FocusMove has binding name 'ns2__FocusMove' for type 'ns2:FocusMove' */
#ifndef SOAP_TYPE_ns2__FocusMove
#define SOAP_TYPE_ns2__FocusMove (692)
#endif

/* ns2__WhiteBalanceOptions has binding name 'ns2__WhiteBalanceOptions' for type 'ns2:WhiteBalanceOptions' */
#ifndef SOAP_TYPE_ns2__WhiteBalanceOptions
#define SOAP_TYPE_ns2__WhiteBalanceOptions (691)
#endif

/* ns2__ExposureOptions has binding name 'ns2__ExposureOptions' for type 'ns2:ExposureOptions' */
#ifndef SOAP_TYPE_ns2__ExposureOptions
#define SOAP_TYPE_ns2__ExposureOptions (690)
#endif

/* ns2__FocusOptions has binding name 'ns2__FocusOptions' for type 'ns2:FocusOptions' */
#ifndef SOAP_TYPE_ns2__FocusOptions
#define SOAP_TYPE_ns2__FocusOptions (689)
#endif

/* ns2__BacklightCompensationOptions has binding name 'ns2__BacklightCompensationOptions' for type 'ns2:BacklightCompensationOptions' */
#ifndef SOAP_TYPE_ns2__BacklightCompensationOptions
#define SOAP_TYPE_ns2__BacklightCompensationOptions (688)
#endif

/* ns2__WideDynamicRangeOptions has binding name 'ns2__WideDynamicRangeOptions' for type 'ns2:WideDynamicRangeOptions' */
#ifndef SOAP_TYPE_ns2__WideDynamicRangeOptions
#define SOAP_TYPE_ns2__WideDynamicRangeOptions (687)
#endif

/* ns2__ImagingOptions has binding name 'ns2__ImagingOptions' for type 'ns2:ImagingOptions' */
#ifndef SOAP_TYPE_ns2__ImagingOptions
#define SOAP_TYPE_ns2__ImagingOptions (686)
#endif

/* ns2__BacklightCompensation has binding name 'ns2__BacklightCompensation' for type 'ns2:BacklightCompensation' */
#ifndef SOAP_TYPE_ns2__BacklightCompensation
#define SOAP_TYPE_ns2__BacklightCompensation (685)
#endif

/* ns2__WideDynamicRange has binding name 'ns2__WideDynamicRange' for type 'ns2:WideDynamicRange' */
#ifndef SOAP_TYPE_ns2__WideDynamicRange
#define SOAP_TYPE_ns2__WideDynamicRange (684)
#endif

/* ns2__Exposure has binding name 'ns2__Exposure' for type 'ns2:Exposure' */
#ifndef SOAP_TYPE_ns2__Exposure
#define SOAP_TYPE_ns2__Exposure (683)
#endif

/* ns2__ImagingSettingsExtension has binding name 'ns2__ImagingSettingsExtension' for type 'ns2:ImagingSettingsExtension' */
#ifndef SOAP_TYPE_ns2__ImagingSettingsExtension
#define SOAP_TYPE_ns2__ImagingSettingsExtension (682)
#endif

/* ns2__ImagingSettings has binding name 'ns2__ImagingSettings' for type 'ns2:ImagingSettings' */
#ifndef SOAP_TYPE_ns2__ImagingSettings
#define SOAP_TYPE_ns2__ImagingSettings (681)
#endif

/* ns2__FocusConfiguration has binding name 'ns2__FocusConfiguration' for type 'ns2:FocusConfiguration' */
#ifndef SOAP_TYPE_ns2__FocusConfiguration
#define SOAP_TYPE_ns2__FocusConfiguration (680)
#endif

/* ns2__FocusStatus has binding name 'ns2__FocusStatus' for type 'ns2:FocusStatus' */
#ifndef SOAP_TYPE_ns2__FocusStatus
#define SOAP_TYPE_ns2__FocusStatus (679)
#endif

/* ns2__ImagingStatus has binding name 'ns2__ImagingStatus' for type 'ns2:ImagingStatus' */
#ifndef SOAP_TYPE_ns2__ImagingStatus
#define SOAP_TYPE_ns2__ImagingStatus (678)
#endif

/* ns2__PTZPresetTourStartingConditionOptionsExtension has binding name 'ns2__PTZPresetTourStartingConditionOptionsExtension' for type 'ns2:PTZPresetTourStartingConditionOptionsExtension' */
#ifndef SOAP_TYPE_ns2__PTZPresetTourStartingConditionOptionsExtension
#define SOAP_TYPE_ns2__PTZPresetTourStartingConditionOptionsExtension (677)
#endif

/* ns2__PTZPresetTourStartingConditionOptions has binding name 'ns2__PTZPresetTourStartingConditionOptions' for type 'ns2:PTZPresetTourStartingConditionOptions' */
#ifndef SOAP_TYPE_ns2__PTZPresetTourStartingConditionOptions
#define SOAP_TYPE_ns2__PTZPresetTourStartingConditionOptions (676)
#endif

/* ns2__PTZPresetTourPresetDetailOptionsExtension has binding name 'ns2__PTZPresetTourPresetDetailOptionsExtension' for type 'ns2:PTZPresetTourPresetDetailOptionsExtension' */
#ifndef SOAP_TYPE_ns2__PTZPresetTourPresetDetailOptionsExtension
#define SOAP_TYPE_ns2__PTZPresetTourPresetDetailOptionsExtension (675)
#endif

/* ns2__PTZPresetTourPresetDetailOptions has binding name 'ns2__PTZPresetTourPresetDetailOptions' for type 'ns2:PTZPresetTourPresetDetailOptions' */
#ifndef SOAP_TYPE_ns2__PTZPresetTourPresetDetailOptions
#define SOAP_TYPE_ns2__PTZPresetTourPresetDetailOptions (674)
#endif

/* ns2__PTZPresetTourSpotOptions has binding name 'ns2__PTZPresetTourSpotOptions' for type 'ns2:PTZPresetTourSpotOptions' */
#ifndef SOAP_TYPE_ns2__PTZPresetTourSpotOptions
#define SOAP_TYPE_ns2__PTZPresetTourSpotOptions (673)
#endif

/* ns2__PTZPresetTourOptions has binding name 'ns2__PTZPresetTourOptions' for type 'ns2:PTZPresetTourOptions' */
#ifndef SOAP_TYPE_ns2__PTZPresetTourOptions
#define SOAP_TYPE_ns2__PTZPresetTourOptions (672)
#endif

/* ns2__PTZPresetTourStartingConditionExtension has binding name 'ns2__PTZPresetTourStartingConditionExtension' for type 'ns2:PTZPresetTourStartingConditionExtension' */
#ifndef SOAP_TYPE_ns2__PTZPresetTourStartingConditionExtension
#define SOAP_TYPE_ns2__PTZPresetTourStartingConditionExtension (671)
#endif

/* ns2__PTZPresetTourStartingCondition has binding name 'ns2__PTZPresetTourStartingCondition' for type 'ns2:PTZPresetTourStartingCondition' */
#ifndef SOAP_TYPE_ns2__PTZPresetTourStartingCondition
#define SOAP_TYPE_ns2__PTZPresetTourStartingCondition (670)
#endif

/* ns2__PTZPresetTourStatusExtension has binding name 'ns2__PTZPresetTourStatusExtension' for type 'ns2:PTZPresetTourStatusExtension' */
#ifndef SOAP_TYPE_ns2__PTZPresetTourStatusExtension
#define SOAP_TYPE_ns2__PTZPresetTourStatusExtension (669)
#endif

/* ns2__PTZPresetTourStatus has binding name 'ns2__PTZPresetTourStatus' for type 'ns2:PTZPresetTourStatus' */
#ifndef SOAP_TYPE_ns2__PTZPresetTourStatus
#define SOAP_TYPE_ns2__PTZPresetTourStatus (668)
#endif

/* ns2__PTZPresetTourTypeExtension has binding name 'ns2__PTZPresetTourTypeExtension' for type 'ns2:PTZPresetTourTypeExtension' */
#ifndef SOAP_TYPE_ns2__PTZPresetTourTypeExtension
#define SOAP_TYPE_ns2__PTZPresetTourTypeExtension (667)
#endif

/* ns2__PTZPresetTourPresetDetail has binding name 'ns2__PTZPresetTourPresetDetail' for type 'ns2:PTZPresetTourPresetDetail' */
#ifndef SOAP_TYPE_ns2__PTZPresetTourPresetDetail
#define SOAP_TYPE_ns2__PTZPresetTourPresetDetail (666)
#endif

/* ns2__PTZPresetTourSpotExtension has binding name 'ns2__PTZPresetTourSpotExtension' for type 'ns2:PTZPresetTourSpotExtension' */
#ifndef SOAP_TYPE_ns2__PTZPresetTourSpotExtension
#define SOAP_TYPE_ns2__PTZPresetTourSpotExtension (665)
#endif

/* ns2__PTZPresetTourSpot has binding name 'ns2__PTZPresetTourSpot' for type 'ns2:PTZPresetTourSpot' */
#ifndef SOAP_TYPE_ns2__PTZPresetTourSpot
#define SOAP_TYPE_ns2__PTZPresetTourSpot (664)
#endif

/* ns2__PTZPresetTourExtension has binding name 'ns2__PTZPresetTourExtension' for type 'ns2:PTZPresetTourExtension' */
#ifndef SOAP_TYPE_ns2__PTZPresetTourExtension
#define SOAP_TYPE_ns2__PTZPresetTourExtension (663)
#endif

/* ns2__PresetTour has binding name 'ns2__PresetTour' for type 'ns2:PresetTour' */
#ifndef SOAP_TYPE_ns2__PresetTour
#define SOAP_TYPE_ns2__PresetTour (662)
#endif

/* ns2__PTZMoveStatus has binding name 'ns2__PTZMoveStatus' for type 'ns2:PTZMoveStatus' */
#ifndef SOAP_TYPE_ns2__PTZMoveStatus
#define SOAP_TYPE_ns2__PTZMoveStatus (661)
#endif

/* ns2__PTZPreset has binding name 'ns2__PTZPreset' for type 'ns2:PTZPreset' */
#ifndef SOAP_TYPE_ns2__PTZPreset
#define SOAP_TYPE_ns2__PTZPreset (660)
#endif

/* ns2__PTZStatus has binding name 'ns2__PTZStatus' for type 'ns2:PTZStatus' */
#ifndef SOAP_TYPE_ns2__PTZStatus
#define SOAP_TYPE_ns2__PTZStatus (659)
#endif

/* ns2__PTZSpeed has binding name 'ns2__PTZSpeed' for type 'ns2:PTZSpeed' */
#ifndef SOAP_TYPE_ns2__PTZSpeed
#define SOAP_TYPE_ns2__PTZSpeed (658)
#endif

/* ns2__PTZVector has binding name 'ns2__PTZVector' for type 'ns2:PTZVector' */
#ifndef SOAP_TYPE_ns2__PTZVector
#define SOAP_TYPE_ns2__PTZVector (657)
#endif

/* ns2__Vector1D has binding name 'ns2__Vector1D' for type 'ns2:Vector1D' */
#ifndef SOAP_TYPE_ns2__Vector1D
#define SOAP_TYPE_ns2__Vector1D (656)
#endif

/* ns2__Vector2D has binding name 'ns2__Vector2D' for type 'ns2:Vector2D' */
#ifndef SOAP_TYPE_ns2__Vector2D
#define SOAP_TYPE_ns2__Vector2D (655)
#endif

/* ns2__Space1DDescription has binding name 'ns2__Space1DDescription' for type 'ns2:Space1DDescription' */
#ifndef SOAP_TYPE_ns2__Space1DDescription
#define SOAP_TYPE_ns2__Space1DDescription (654)
#endif

/* ns2__Space2DDescription has binding name 'ns2__Space2DDescription' for type 'ns2:Space2DDescription' */
#ifndef SOAP_TYPE_ns2__Space2DDescription
#define SOAP_TYPE_ns2__Space2DDescription (653)
#endif

/* ns2__PTZSpacesExtension has binding name 'ns2__PTZSpacesExtension' for type 'ns2:PTZSpacesExtension' */
#ifndef SOAP_TYPE_ns2__PTZSpacesExtension
#define SOAP_TYPE_ns2__PTZSpacesExtension (652)
#endif

/* ns2__PTZSpaces has binding name 'ns2__PTZSpaces' for type 'ns2:PTZSpaces' */
#ifndef SOAP_TYPE_ns2__PTZSpaces
#define SOAP_TYPE_ns2__PTZSpaces (651)
#endif

/* ns2__ZoomLimits has binding name 'ns2__ZoomLimits' for type 'ns2:ZoomLimits' */
#ifndef SOAP_TYPE_ns2__ZoomLimits
#define SOAP_TYPE_ns2__ZoomLimits (650)
#endif

/* ns2__PanTiltLimits has binding name 'ns2__PanTiltLimits' for type 'ns2:PanTiltLimits' */
#ifndef SOAP_TYPE_ns2__PanTiltLimits
#define SOAP_TYPE_ns2__PanTiltLimits (649)
#endif

/* ns2__ReverseOptionsExtension has binding name 'ns2__ReverseOptionsExtension' for type 'ns2:ReverseOptionsExtension' */
#ifndef SOAP_TYPE_ns2__ReverseOptionsExtension
#define SOAP_TYPE_ns2__ReverseOptionsExtension (648)
#endif

/* ns2__ReverseOptions has binding name 'ns2__ReverseOptions' for type 'ns2:ReverseOptions' */
#ifndef SOAP_TYPE_ns2__ReverseOptions
#define SOAP_TYPE_ns2__ReverseOptions (647)
#endif

/* ns2__EFlipOptionsExtension has binding name 'ns2__EFlipOptionsExtension' for type 'ns2:EFlipOptionsExtension' */
#ifndef SOAP_TYPE_ns2__EFlipOptionsExtension
#define SOAP_TYPE_ns2__EFlipOptionsExtension (646)
#endif

/* ns2__EFlipOptions has binding name 'ns2__EFlipOptions' for type 'ns2:EFlipOptions' */
#ifndef SOAP_TYPE_ns2__EFlipOptions
#define SOAP_TYPE_ns2__EFlipOptions (645)
#endif

/* ns2__PTControlDirectionOptionsExtension has binding name 'ns2__PTControlDirectionOptionsExtension' for type 'ns2:PTControlDirectionOptionsExtension' */
#ifndef SOAP_TYPE_ns2__PTControlDirectionOptionsExtension
#define SOAP_TYPE_ns2__PTControlDirectionOptionsExtension (644)
#endif

/* ns2__PTControlDirectionOptions has binding name 'ns2__PTControlDirectionOptions' for type 'ns2:PTControlDirectionOptions' */
#ifndef SOAP_TYPE_ns2__PTControlDirectionOptions
#define SOAP_TYPE_ns2__PTControlDirectionOptions (643)
#endif

/* ns2__PTZConfigurationOptions2 has binding name 'ns2__PTZConfigurationOptions2' for type 'ns2:PTZConfigurationOptions2' */
#ifndef SOAP_TYPE_ns2__PTZConfigurationOptions2
#define SOAP_TYPE_ns2__PTZConfigurationOptions2 (642)
#endif

/* ns2__PTZConfigurationOptions has binding name 'ns2__PTZConfigurationOptions' for type 'ns2:PTZConfigurationOptions' */
#ifndef SOAP_TYPE_ns2__PTZConfigurationOptions
#define SOAP_TYPE_ns2__PTZConfigurationOptions (641)
#endif

/* ns2__Reverse has binding name 'ns2__Reverse' for type 'ns2:Reverse' */
#ifndef SOAP_TYPE_ns2__Reverse
#define SOAP_TYPE_ns2__Reverse (640)
#endif

/* ns2__EFlip has binding name 'ns2__EFlip' for type 'ns2:EFlip' */
#ifndef SOAP_TYPE_ns2__EFlip
#define SOAP_TYPE_ns2__EFlip (639)
#endif

/* ns2__PTControlDirectionExtension has binding name 'ns2__PTControlDirectionExtension' for type 'ns2:PTControlDirectionExtension' */
#ifndef SOAP_TYPE_ns2__PTControlDirectionExtension
#define SOAP_TYPE_ns2__PTControlDirectionExtension (638)
#endif

/* ns2__PTControlDirection has binding name 'ns2__PTControlDirection' for type 'ns2:PTControlDirection' */
#ifndef SOAP_TYPE_ns2__PTControlDirection
#define SOAP_TYPE_ns2__PTControlDirection (637)
#endif

/* ns2__PTZConfigurationExtension2 has binding name 'ns2__PTZConfigurationExtension2' for type 'ns2:PTZConfigurationExtension2' */
#ifndef SOAP_TYPE_ns2__PTZConfigurationExtension2
#define SOAP_TYPE_ns2__PTZConfigurationExtension2 (636)
#endif

/* ns2__PTZConfigurationExtension has binding name 'ns2__PTZConfigurationExtension' for type 'ns2:PTZConfigurationExtension' */
#ifndef SOAP_TYPE_ns2__PTZConfigurationExtension
#define SOAP_TYPE_ns2__PTZConfigurationExtension (635)
#endif

/* ns2__PTZConfiguration has binding name 'ns2__PTZConfiguration' for type 'ns2:PTZConfiguration' */
#ifndef SOAP_TYPE_ns2__PTZConfiguration
#define SOAP_TYPE_ns2__PTZConfiguration (634)
#endif

/* ns2__PTZPresetTourSupportedExtension has binding name 'ns2__PTZPresetTourSupportedExtension' for type 'ns2:PTZPresetTourSupportedExtension' */
#ifndef SOAP_TYPE_ns2__PTZPresetTourSupportedExtension
#define SOAP_TYPE_ns2__PTZPresetTourSupportedExtension (633)
#endif

/* ns2__PTZPresetTourSupported has binding name 'ns2__PTZPresetTourSupported' for type 'ns2:PTZPresetTourSupported' */
#ifndef SOAP_TYPE_ns2__PTZPresetTourSupported
#define SOAP_TYPE_ns2__PTZPresetTourSupported (632)
#endif

/* ns2__PTZNodeExtension2 has binding name 'ns2__PTZNodeExtension2' for type 'ns2:PTZNodeExtension2' */
#ifndef SOAP_TYPE_ns2__PTZNodeExtension2
#define SOAP_TYPE_ns2__PTZNodeExtension2 (631)
#endif

/* ns2__PTZNodeExtension has binding name 'ns2__PTZNodeExtension' for type 'ns2:PTZNodeExtension' */
#ifndef SOAP_TYPE_ns2__PTZNodeExtension
#define SOAP_TYPE_ns2__PTZNodeExtension (630)
#endif

/* ns2__PTZNode has binding name 'ns2__PTZNode' for type 'ns2:PTZNode' */
#ifndef SOAP_TYPE_ns2__PTZNode
#define SOAP_TYPE_ns2__PTZNode (629)
#endif

/* ns2__DigitalInput has binding name 'ns2__DigitalInput' for type 'ns2:DigitalInput' */
#ifndef SOAP_TYPE_ns2__DigitalInput
#define SOAP_TYPE_ns2__DigitalInput (628)
#endif

/* ns2__RelayOutput has binding name 'ns2__RelayOutput' for type 'ns2:RelayOutput' */
#ifndef SOAP_TYPE_ns2__RelayOutput
#define SOAP_TYPE_ns2__RelayOutput (627)
#endif

/* ns2__RelayOutputSettings has binding name 'ns2__RelayOutputSettings' for type 'ns2:RelayOutputSettings' */
#ifndef SOAP_TYPE_ns2__RelayOutputSettings
#define SOAP_TYPE_ns2__RelayOutputSettings (626)
#endif

/* ns2__GenericEapPwdConfigurationExtension has binding name 'ns2__GenericEapPwdConfigurationExtension' for type 'ns2:GenericEapPwdConfigurationExtension' */
#ifndef SOAP_TYPE_ns2__GenericEapPwdConfigurationExtension
#define SOAP_TYPE_ns2__GenericEapPwdConfigurationExtension (625)
#endif

/* ns2__TLSConfiguration has binding name 'ns2__TLSConfiguration' for type 'ns2:TLSConfiguration' */
#ifndef SOAP_TYPE_ns2__TLSConfiguration
#define SOAP_TYPE_ns2__TLSConfiguration (624)
#endif

/* ns2__EapMethodExtension has binding name 'ns2__EapMethodExtension' for type 'ns2:EapMethodExtension' */
#ifndef SOAP_TYPE_ns2__EapMethodExtension
#define SOAP_TYPE_ns2__EapMethodExtension (623)
#endif

/* ns2__EAPMethodConfiguration has binding name 'ns2__EAPMethodConfiguration' for type 'ns2:EAPMethodConfiguration' */
#ifndef SOAP_TYPE_ns2__EAPMethodConfiguration
#define SOAP_TYPE_ns2__EAPMethodConfiguration (622)
#endif

/* ns2__Dot1XConfigurationExtension has binding name 'ns2__Dot1XConfigurationExtension' for type 'ns2:Dot1XConfigurationExtension' */
#ifndef SOAP_TYPE_ns2__Dot1XConfigurationExtension
#define SOAP_TYPE_ns2__Dot1XConfigurationExtension (621)
#endif

/* ns2__Dot1XConfiguration has binding name 'ns2__Dot1XConfiguration' for type 'ns2:Dot1XConfiguration' */
#ifndef SOAP_TYPE_ns2__Dot1XConfiguration
#define SOAP_TYPE_ns2__Dot1XConfiguration (620)
#endif

/* ns2__CertificateInformationExtension has binding name 'ns2__CertificateInformationExtension' for type 'ns2:CertificateInformationExtension' */
#ifndef SOAP_TYPE_ns2__CertificateInformationExtension
#define SOAP_TYPE_ns2__CertificateInformationExtension (619)
#endif

/* ns2__CertificateUsage has binding name 'ns2__CertificateUsage' for type 'ns2:CertificateUsage' */
#ifndef SOAP_TYPE_ns2__CertificateUsage
#define SOAP_TYPE_ns2__CertificateUsage (618)
#endif

/* ns2__CertificateInformation has binding name 'ns2__CertificateInformation' for type 'ns2:CertificateInformation' */
#ifndef SOAP_TYPE_ns2__CertificateInformation
#define SOAP_TYPE_ns2__CertificateInformation (617)
#endif

/* ns2__CertificateWithPrivateKey has binding name 'ns2__CertificateWithPrivateKey' for type 'ns2:CertificateWithPrivateKey' */
#ifndef SOAP_TYPE_ns2__CertificateWithPrivateKey
#define SOAP_TYPE_ns2__CertificateWithPrivateKey (616)
#endif

/* ns2__CertificateStatus has binding name 'ns2__CertificateStatus' for type 'ns2:CertificateStatus' */
#ifndef SOAP_TYPE_ns2__CertificateStatus
#define SOAP_TYPE_ns2__CertificateStatus (615)
#endif

/* ns2__Certificate has binding name 'ns2__Certificate' for type 'ns2:Certificate' */
#ifndef SOAP_TYPE_ns2__Certificate
#define SOAP_TYPE_ns2__Certificate (614)
#endif

/* ns2__CertificateGenerationParametersExtension has binding name 'ns2__CertificateGenerationParametersExtension' for type 'ns2:CertificateGenerationParametersExtension' */
#ifndef SOAP_TYPE_ns2__CertificateGenerationParametersExtension
#define SOAP_TYPE_ns2__CertificateGenerationParametersExtension (613)
#endif

/* ns2__CertificateGenerationParameters has binding name 'ns2__CertificateGenerationParameters' for type 'ns2:CertificateGenerationParameters' */
#ifndef SOAP_TYPE_ns2__CertificateGenerationParameters
#define SOAP_TYPE_ns2__CertificateGenerationParameters (612)
#endif

/* ns2__UserExtension has binding name 'ns2__UserExtension' for type 'ns2:UserExtension' */
#ifndef SOAP_TYPE_ns2__UserExtension
#define SOAP_TYPE_ns2__UserExtension (611)
#endif

/* ns2__User has binding name 'ns2__User' for type 'ns2:User' */
#ifndef SOAP_TYPE_ns2__User
#define SOAP_TYPE_ns2__User (610)
#endif

/* ns2__RemoteUser has binding name 'ns2__RemoteUser' for type 'ns2:RemoteUser' */
#ifndef SOAP_TYPE_ns2__RemoteUser
#define SOAP_TYPE_ns2__RemoteUser (609)
#endif

/* ns2__TimeZone has binding name 'ns2__TimeZone' for type 'ns2:TimeZone' */
#ifndef SOAP_TYPE_ns2__TimeZone
#define SOAP_TYPE_ns2__TimeZone (608)
#endif

/* ns2__Time has binding name 'ns2__Time' for type 'ns2:Time' */
#ifndef SOAP_TYPE_ns2__Time
#define SOAP_TYPE_ns2__Time (607)
#endif

/* ns2__Date has binding name 'ns2__Date' for type 'ns2:Date' */
#ifndef SOAP_TYPE_ns2__Date
#define SOAP_TYPE_ns2__Date (606)
#endif

/* ns2__DateTime has binding name 'ns2__DateTime' for type 'ns2:DateTime' */
#ifndef SOAP_TYPE_ns2__DateTime
#define SOAP_TYPE_ns2__DateTime (605)
#endif

/* ns2__SystemDateTimeExtension has binding name 'ns2__SystemDateTimeExtension' for type 'ns2:SystemDateTimeExtension' */
#ifndef SOAP_TYPE_ns2__SystemDateTimeExtension
#define SOAP_TYPE_ns2__SystemDateTimeExtension (604)
#endif

/* ns2__SystemDateTime has binding name 'ns2__SystemDateTime' for type 'ns2:SystemDateTime' */
#ifndef SOAP_TYPE_ns2__SystemDateTime
#define SOAP_TYPE_ns2__SystemDateTime (603)
#endif

/* ns2__SystemLogUri has binding name 'ns2__SystemLogUri' for type 'ns2:SystemLogUri' */
#ifndef SOAP_TYPE_ns2__SystemLogUri
#define SOAP_TYPE_ns2__SystemLogUri (602)
#endif

/* ns2__SystemLogUriList has binding name 'ns2__SystemLogUriList' for type 'ns2:SystemLogUriList' */
#ifndef SOAP_TYPE_ns2__SystemLogUriList
#define SOAP_TYPE_ns2__SystemLogUriList (601)
#endif

/* ns2__BackupFile has binding name 'ns2__BackupFile' for type 'ns2:BackupFile' */
#ifndef SOAP_TYPE_ns2__BackupFile
#define SOAP_TYPE_ns2__BackupFile (600)
#endif

/* ns2__AttachmentData has binding name 'ns2__AttachmentData' for type 'ns2:AttachmentData' */
#ifndef SOAP_TYPE_ns2__AttachmentData
#define SOAP_TYPE_ns2__AttachmentData (599)
#endif

/* ns2__BinaryData has binding name 'ns2__BinaryData' for type 'ns2:BinaryData' */
#ifndef SOAP_TYPE_ns2__BinaryData
#define SOAP_TYPE_ns2__BinaryData (598)
#endif

/* ns2__SupportInformation has binding name 'ns2__SupportInformation' for type 'ns2:SupportInformation' */
#ifndef SOAP_TYPE_ns2__SupportInformation
#define SOAP_TYPE_ns2__SupportInformation (597)
#endif

/* ns2__SystemLog has binding name 'ns2__SystemLog' for type 'ns2:SystemLog' */
#ifndef SOAP_TYPE_ns2__SystemLog
#define SOAP_TYPE_ns2__SystemLog (596)
#endif

/* ns2__AnalyticsDeviceExtension has binding name 'ns2__AnalyticsDeviceExtension' for type 'ns2:AnalyticsDeviceExtension' */
#ifndef SOAP_TYPE_ns2__AnalyticsDeviceExtension
#define SOAP_TYPE_ns2__AnalyticsDeviceExtension (595)
#endif

/* ns2__AnalyticsDeviceCapabilities has binding name 'ns2__AnalyticsDeviceCapabilities' for type 'ns2:AnalyticsDeviceCapabilities' */
#ifndef SOAP_TYPE_ns2__AnalyticsDeviceCapabilities
#define SOAP_TYPE_ns2__AnalyticsDeviceCapabilities (594)
#endif

/* ns2__ReceiverCapabilities has binding name 'ns2__ReceiverCapabilities' for type 'ns2:ReceiverCapabilities' */
#ifndef SOAP_TYPE_ns2__ReceiverCapabilities
#define SOAP_TYPE_ns2__ReceiverCapabilities (593)
#endif

/* ns2__ReplayCapabilities has binding name 'ns2__ReplayCapabilities' for type 'ns2:ReplayCapabilities' */
#ifndef SOAP_TYPE_ns2__ReplayCapabilities
#define SOAP_TYPE_ns2__ReplayCapabilities (592)
#endif

/* ns2__SearchCapabilities has binding name 'ns2__SearchCapabilities' for type 'ns2:SearchCapabilities' */
#ifndef SOAP_TYPE_ns2__SearchCapabilities
#define SOAP_TYPE_ns2__SearchCapabilities (591)
#endif

/* ns2__RecordingCapabilities has binding name 'ns2__RecordingCapabilities' for type 'ns2:RecordingCapabilities' */
#ifndef SOAP_TYPE_ns2__RecordingCapabilities
#define SOAP_TYPE_ns2__RecordingCapabilities (590)
#endif

/* ns2__DisplayCapabilities has binding name 'ns2__DisplayCapabilities' for type 'ns2:DisplayCapabilities' */
#ifndef SOAP_TYPE_ns2__DisplayCapabilities
#define SOAP_TYPE_ns2__DisplayCapabilities (589)
#endif

/* ns2__DeviceIOCapabilities has binding name 'ns2__DeviceIOCapabilities' for type 'ns2:DeviceIOCapabilities' */
#ifndef SOAP_TYPE_ns2__DeviceIOCapabilities
#define SOAP_TYPE_ns2__DeviceIOCapabilities (588)
#endif

/* ns2__PTZCapabilities has binding name 'ns2__PTZCapabilities' for type 'ns2:PTZCapabilities' */
#ifndef SOAP_TYPE_ns2__PTZCapabilities
#define SOAP_TYPE_ns2__PTZCapabilities (587)
#endif

/* ns2__ImagingCapabilities has binding name 'ns2__ImagingCapabilities' for type 'ns2:ImagingCapabilities' */
#ifndef SOAP_TYPE_ns2__ImagingCapabilities
#define SOAP_TYPE_ns2__ImagingCapabilities (586)
#endif

/* ns2__OnvifVersion has binding name 'ns2__OnvifVersion' for type 'ns2:OnvifVersion' */
#ifndef SOAP_TYPE_ns2__OnvifVersion
#define SOAP_TYPE_ns2__OnvifVersion (585)
#endif

/* ns2__SystemCapabilitiesExtension2 has binding name 'ns2__SystemCapabilitiesExtension2' for type 'ns2:SystemCapabilitiesExtension2' */
#ifndef SOAP_TYPE_ns2__SystemCapabilitiesExtension2
#define SOAP_TYPE_ns2__SystemCapabilitiesExtension2 (584)
#endif

/* ns2__SystemCapabilitiesExtension has binding name 'ns2__SystemCapabilitiesExtension' for type 'ns2:SystemCapabilitiesExtension' */
#ifndef SOAP_TYPE_ns2__SystemCapabilitiesExtension
#define SOAP_TYPE_ns2__SystemCapabilitiesExtension (583)
#endif

/* ns2__SystemCapabilities has binding name 'ns2__SystemCapabilities' for type 'ns2:SystemCapabilities' */
#ifndef SOAP_TYPE_ns2__SystemCapabilities
#define SOAP_TYPE_ns2__SystemCapabilities (582)
#endif

/* ns2__SecurityCapabilitiesExtension2 has binding name 'ns2__SecurityCapabilitiesExtension2' for type 'ns2:SecurityCapabilitiesExtension2' */
#ifndef SOAP_TYPE_ns2__SecurityCapabilitiesExtension2
#define SOAP_TYPE_ns2__SecurityCapabilitiesExtension2 (581)
#endif

/* ns2__SecurityCapabilitiesExtension has binding name 'ns2__SecurityCapabilitiesExtension' for type 'ns2:SecurityCapabilitiesExtension' */
#ifndef SOAP_TYPE_ns2__SecurityCapabilitiesExtension
#define SOAP_TYPE_ns2__SecurityCapabilitiesExtension (580)
#endif

/* ns2__SecurityCapabilities has binding name 'ns2__SecurityCapabilities' for type 'ns2:SecurityCapabilities' */
#ifndef SOAP_TYPE_ns2__SecurityCapabilities
#define SOAP_TYPE_ns2__SecurityCapabilities (579)
#endif

/* ns2__NetworkCapabilitiesExtension2 has binding name 'ns2__NetworkCapabilitiesExtension2' for type 'ns2:NetworkCapabilitiesExtension2' */
#ifndef SOAP_TYPE_ns2__NetworkCapabilitiesExtension2
#define SOAP_TYPE_ns2__NetworkCapabilitiesExtension2 (578)
#endif

/* ns2__NetworkCapabilitiesExtension has binding name 'ns2__NetworkCapabilitiesExtension' for type 'ns2:NetworkCapabilitiesExtension' */
#ifndef SOAP_TYPE_ns2__NetworkCapabilitiesExtension
#define SOAP_TYPE_ns2__NetworkCapabilitiesExtension (577)
#endif

/* ns2__NetworkCapabilities has binding name 'ns2__NetworkCapabilities' for type 'ns2:NetworkCapabilities' */
#ifndef SOAP_TYPE_ns2__NetworkCapabilities
#define SOAP_TYPE_ns2__NetworkCapabilities (576)
#endif

/* ns2__ProfileCapabilities has binding name 'ns2__ProfileCapabilities' for type 'ns2:ProfileCapabilities' */
#ifndef SOAP_TYPE_ns2__ProfileCapabilities
#define SOAP_TYPE_ns2__ProfileCapabilities (575)
#endif

/* ns2__RealTimeStreamingCapabilitiesExtension has binding name 'ns2__RealTimeStreamingCapabilitiesExtension' for type 'ns2:RealTimeStreamingCapabilitiesExtension' */
#ifndef SOAP_TYPE_ns2__RealTimeStreamingCapabilitiesExtension
#define SOAP_TYPE_ns2__RealTimeStreamingCapabilitiesExtension (574)
#endif

/* ns2__RealTimeStreamingCapabilities has binding name 'ns2__RealTimeStreamingCapabilities' for type 'ns2:RealTimeStreamingCapabilities' */
#ifndef SOAP_TYPE_ns2__RealTimeStreamingCapabilities
#define SOAP_TYPE_ns2__RealTimeStreamingCapabilities (573)
#endif

/* ns2__MediaCapabilitiesExtension has binding name 'ns2__MediaCapabilitiesExtension' for type 'ns2:MediaCapabilitiesExtension' */
#ifndef SOAP_TYPE_ns2__MediaCapabilitiesExtension
#define SOAP_TYPE_ns2__MediaCapabilitiesExtension (572)
#endif

/* ns2__MediaCapabilities has binding name 'ns2__MediaCapabilities' for type 'ns2:MediaCapabilities' */
#ifndef SOAP_TYPE_ns2__MediaCapabilities
#define SOAP_TYPE_ns2__MediaCapabilities (571)
#endif

/* ns2__IOCapabilitiesExtension2 has binding name 'ns2__IOCapabilitiesExtension2' for type 'ns2:IOCapabilitiesExtension2' */
#ifndef SOAP_TYPE_ns2__IOCapabilitiesExtension2
#define SOAP_TYPE_ns2__IOCapabilitiesExtension2 (570)
#endif

/* ns2__IOCapabilitiesExtension has binding name 'ns2__IOCapabilitiesExtension' for type 'ns2:IOCapabilitiesExtension' */
#ifndef SOAP_TYPE_ns2__IOCapabilitiesExtension
#define SOAP_TYPE_ns2__IOCapabilitiesExtension (569)
#endif

/* ns2__IOCapabilities has binding name 'ns2__IOCapabilities' for type 'ns2:IOCapabilities' */
#ifndef SOAP_TYPE_ns2__IOCapabilities
#define SOAP_TYPE_ns2__IOCapabilities (568)
#endif

/* ns2__EventCapabilities has binding name 'ns2__EventCapabilities' for type 'ns2:EventCapabilities' */
#ifndef SOAP_TYPE_ns2__EventCapabilities
#define SOAP_TYPE_ns2__EventCapabilities (567)
#endif

/* ns2__DeviceCapabilitiesExtension has binding name 'ns2__DeviceCapabilitiesExtension' for type 'ns2:DeviceCapabilitiesExtension' */
#ifndef SOAP_TYPE_ns2__DeviceCapabilitiesExtension
#define SOAP_TYPE_ns2__DeviceCapabilitiesExtension (566)
#endif

/* ns2__DeviceCapabilities has binding name 'ns2__DeviceCapabilities' for type 'ns2:DeviceCapabilities' */
#ifndef SOAP_TYPE_ns2__DeviceCapabilities
#define SOAP_TYPE_ns2__DeviceCapabilities (565)
#endif

/* ns2__AnalyticsCapabilities has binding name 'ns2__AnalyticsCapabilities' for type 'ns2:AnalyticsCapabilities' */
#ifndef SOAP_TYPE_ns2__AnalyticsCapabilities
#define SOAP_TYPE_ns2__AnalyticsCapabilities (564)
#endif

/* ns2__CapabilitiesExtension2 has binding name 'ns2__CapabilitiesExtension2' for type 'ns2:CapabilitiesExtension2' */
#ifndef SOAP_TYPE_ns2__CapabilitiesExtension2
#define SOAP_TYPE_ns2__CapabilitiesExtension2 (563)
#endif

/* ns2__CapabilitiesExtension has binding name 'ns2__CapabilitiesExtension' for type 'ns2:CapabilitiesExtension' */
#ifndef SOAP_TYPE_ns2__CapabilitiesExtension
#define SOAP_TYPE_ns2__CapabilitiesExtension (562)
#endif

/* ns2__Capabilities has binding name 'ns2__Capabilities' for type 'ns2:Capabilities' */
#ifndef SOAP_TYPE_ns2__Capabilities
#define SOAP_TYPE_ns2__Capabilities (561)
#endif

/* ns2__Dot11AvailableNetworksExtension has binding name 'ns2__Dot11AvailableNetworksExtension' for type 'ns2:Dot11AvailableNetworksExtension' */
#ifndef SOAP_TYPE_ns2__Dot11AvailableNetworksExtension
#define SOAP_TYPE_ns2__Dot11AvailableNetworksExtension (560)
#endif

/* ns2__Dot11AvailableNetworks has binding name 'ns2__Dot11AvailableNetworks' for type 'ns2:Dot11AvailableNetworks' */
#ifndef SOAP_TYPE_ns2__Dot11AvailableNetworks
#define SOAP_TYPE_ns2__Dot11AvailableNetworks (559)
#endif

/* ns2__Dot11Status has binding name 'ns2__Dot11Status' for type 'ns2:Dot11Status' */
#ifndef SOAP_TYPE_ns2__Dot11Status
#define SOAP_TYPE_ns2__Dot11Status (558)
#endif

/* ns2__Dot11Capabilities has binding name 'ns2__Dot11Capabilities' for type 'ns2:Dot11Capabilities' */
#ifndef SOAP_TYPE_ns2__Dot11Capabilities
#define SOAP_TYPE_ns2__Dot11Capabilities (557)
#endif

/* ns2__NetworkInterfaceSetConfigurationExtension2 has binding name 'ns2__NetworkInterfaceSetConfigurationExtension2' for type 'ns2:NetworkInterfaceSetConfigurationExtension2' */
#ifndef SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension2
#define SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension2 (556)
#endif

/* ns2__Dot11PSKSetExtension has binding name 'ns2__Dot11PSKSetExtension' for type 'ns2:Dot11PSKSetExtension' */
#ifndef SOAP_TYPE_ns2__Dot11PSKSetExtension
#define SOAP_TYPE_ns2__Dot11PSKSetExtension (555)
#endif

/* ns2__Dot11PSKSet has binding name 'ns2__Dot11PSKSet' for type 'ns2:Dot11PSKSet' */
#ifndef SOAP_TYPE_ns2__Dot11PSKSet
#define SOAP_TYPE_ns2__Dot11PSKSet (554)
#endif

/* ns2__Dot11SecurityConfigurationExtension has binding name 'ns2__Dot11SecurityConfigurationExtension' for type 'ns2:Dot11SecurityConfigurationExtension' */
#ifndef SOAP_TYPE_ns2__Dot11SecurityConfigurationExtension
#define SOAP_TYPE_ns2__Dot11SecurityConfigurationExtension (553)
#endif

/* ns2__Dot11SecurityConfiguration has binding name 'ns2__Dot11SecurityConfiguration' for type 'ns2:Dot11SecurityConfiguration' */
#ifndef SOAP_TYPE_ns2__Dot11SecurityConfiguration
#define SOAP_TYPE_ns2__Dot11SecurityConfiguration (552)
#endif

/* ns2__Dot11Configuration has binding name 'ns2__Dot11Configuration' for type 'ns2:Dot11Configuration' */
#ifndef SOAP_TYPE_ns2__Dot11Configuration
#define SOAP_TYPE_ns2__Dot11Configuration (551)
#endif

/* ns2__IPAddressFilterExtension has binding name 'ns2__IPAddressFilterExtension' for type 'ns2:IPAddressFilterExtension' */
#ifndef SOAP_TYPE_ns2__IPAddressFilterExtension
#define SOAP_TYPE_ns2__IPAddressFilterExtension (550)
#endif

/* ns2__IPAddressFilter has binding name 'ns2__IPAddressFilter' for type 'ns2:IPAddressFilter' */
#ifndef SOAP_TYPE_ns2__IPAddressFilter
#define SOAP_TYPE_ns2__IPAddressFilter (549)
#endif

/* ns2__NetworkZeroConfigurationExtension2 has binding name 'ns2__NetworkZeroConfigurationExtension2' for type 'ns2:NetworkZeroConfigurationExtension2' */
#ifndef SOAP_TYPE_ns2__NetworkZeroConfigurationExtension2
#define SOAP_TYPE_ns2__NetworkZeroConfigurationExtension2 (548)
#endif

/* ns2__NetworkZeroConfigurationExtension has binding name 'ns2__NetworkZeroConfigurationExtension' for type 'ns2:NetworkZeroConfigurationExtension' */
#ifndef SOAP_TYPE_ns2__NetworkZeroConfigurationExtension
#define SOAP_TYPE_ns2__NetworkZeroConfigurationExtension (547)
#endif

/* ns2__NetworkZeroConfiguration has binding name 'ns2__NetworkZeroConfiguration' for type 'ns2:NetworkZeroConfiguration' */
#ifndef SOAP_TYPE_ns2__NetworkZeroConfiguration
#define SOAP_TYPE_ns2__NetworkZeroConfiguration (546)
#endif

/* ns2__NetworkGateway has binding name 'ns2__NetworkGateway' for type 'ns2:NetworkGateway' */
#ifndef SOAP_TYPE_ns2__NetworkGateway
#define SOAP_TYPE_ns2__NetworkGateway (545)
#endif

/* ns2__IPv4NetworkInterfaceSetConfiguration has binding name 'ns2__IPv4NetworkInterfaceSetConfiguration' for type 'ns2:IPv4NetworkInterfaceSetConfiguration' */
#ifndef SOAP_TYPE_ns2__IPv4NetworkInterfaceSetConfiguration
#define SOAP_TYPE_ns2__IPv4NetworkInterfaceSetConfiguration (544)
#endif

/* ns2__IPv6NetworkInterfaceSetConfiguration has binding name 'ns2__IPv6NetworkInterfaceSetConfiguration' for type 'ns2:IPv6NetworkInterfaceSetConfiguration' */
#ifndef SOAP_TYPE_ns2__IPv6NetworkInterfaceSetConfiguration
#define SOAP_TYPE_ns2__IPv6NetworkInterfaceSetConfiguration (543)
#endif

/* ns2__NetworkInterfaceSetConfigurationExtension has binding name 'ns2__NetworkInterfaceSetConfigurationExtension' for type 'ns2:NetworkInterfaceSetConfigurationExtension' */
#ifndef SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension
#define SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension (542)
#endif

/* ns2__NetworkInterfaceSetConfiguration has binding name 'ns2__NetworkInterfaceSetConfiguration' for type 'ns2:NetworkInterfaceSetConfiguration' */
#ifndef SOAP_TYPE_ns2__NetworkInterfaceSetConfiguration
#define SOAP_TYPE_ns2__NetworkInterfaceSetConfiguration (541)
#endif

/* ns2__DynamicDNSInformationExtension has binding name 'ns2__DynamicDNSInformationExtension' for type 'ns2:DynamicDNSInformationExtension' */
#ifndef SOAP_TYPE_ns2__DynamicDNSInformationExtension
#define SOAP_TYPE_ns2__DynamicDNSInformationExtension (540)
#endif

/* ns2__DynamicDNSInformation has binding name 'ns2__DynamicDNSInformation' for type 'ns2:DynamicDNSInformation' */
#ifndef SOAP_TYPE_ns2__DynamicDNSInformation
#define SOAP_TYPE_ns2__DynamicDNSInformation (539)
#endif

/* ns2__NTPInformationExtension has binding name 'ns2__NTPInformationExtension' for type 'ns2:NTPInformationExtension' */
#ifndef SOAP_TYPE_ns2__NTPInformationExtension
#define SOAP_TYPE_ns2__NTPInformationExtension (538)
#endif

/* ns2__NTPInformation has binding name 'ns2__NTPInformation' for type 'ns2:NTPInformation' */
#ifndef SOAP_TYPE_ns2__NTPInformation
#define SOAP_TYPE_ns2__NTPInformation (537)
#endif

/* ns2__DNSInformationExtension has binding name 'ns2__DNSInformationExtension' for type 'ns2:DNSInformationExtension' */
#ifndef SOAP_TYPE_ns2__DNSInformationExtension
#define SOAP_TYPE_ns2__DNSInformationExtension (536)
#endif

/* ns2__DNSInformation has binding name 'ns2__DNSInformation' for type 'ns2:DNSInformation' */
#ifndef SOAP_TYPE_ns2__DNSInformation
#define SOAP_TYPE_ns2__DNSInformation (535)
#endif

/* ns2__HostnameInformationExtension has binding name 'ns2__HostnameInformationExtension' for type 'ns2:HostnameInformationExtension' */
#ifndef SOAP_TYPE_ns2__HostnameInformationExtension
#define SOAP_TYPE_ns2__HostnameInformationExtension (534)
#endif

/* ns2__HostnameInformation has binding name 'ns2__HostnameInformation' for type 'ns2:HostnameInformation' */
#ifndef SOAP_TYPE_ns2__HostnameInformation
#define SOAP_TYPE_ns2__HostnameInformation (533)
#endif

/* ns2__PrefixedIPv6Address has binding name 'ns2__PrefixedIPv6Address' for type 'ns2:PrefixedIPv6Address' */
#ifndef SOAP_TYPE_ns2__PrefixedIPv6Address
#define SOAP_TYPE_ns2__PrefixedIPv6Address (532)
#endif

/* ns2__PrefixedIPv4Address has binding name 'ns2__PrefixedIPv4Address' for type 'ns2:PrefixedIPv4Address' */
#ifndef SOAP_TYPE_ns2__PrefixedIPv4Address
#define SOAP_TYPE_ns2__PrefixedIPv4Address (531)
#endif

/* ns2__IPAddress has binding name 'ns2__IPAddress' for type 'ns2:IPAddress' */
#ifndef SOAP_TYPE_ns2__IPAddress
#define SOAP_TYPE_ns2__IPAddress (530)
#endif

/* ns2__NetworkHostExtension has binding name 'ns2__NetworkHostExtension' for type 'ns2:NetworkHostExtension' */
#ifndef SOAP_TYPE_ns2__NetworkHostExtension
#define SOAP_TYPE_ns2__NetworkHostExtension (529)
#endif

/* ns2__NetworkHost has binding name 'ns2__NetworkHost' for type 'ns2:NetworkHost' */
#ifndef SOAP_TYPE_ns2__NetworkHost
#define SOAP_TYPE_ns2__NetworkHost (528)
#endif

/* ns2__NetworkProtocolExtension has binding name 'ns2__NetworkProtocolExtension' for type 'ns2:NetworkProtocolExtension' */
#ifndef SOAP_TYPE_ns2__NetworkProtocolExtension
#define SOAP_TYPE_ns2__NetworkProtocolExtension (527)
#endif

/* ns2__NetworkProtocol has binding name 'ns2__NetworkProtocol' for type 'ns2:NetworkProtocol' */
#ifndef SOAP_TYPE_ns2__NetworkProtocol
#define SOAP_TYPE_ns2__NetworkProtocol (526)
#endif

/* ns2__IPv6ConfigurationExtension has binding name 'ns2__IPv6ConfigurationExtension' for type 'ns2:IPv6ConfigurationExtension' */
#ifndef SOAP_TYPE_ns2__IPv6ConfigurationExtension
#define SOAP_TYPE_ns2__IPv6ConfigurationExtension (525)
#endif

/* ns2__IPv6Configuration has binding name 'ns2__IPv6Configuration' for type 'ns2:IPv6Configuration' */
#ifndef SOAP_TYPE_ns2__IPv6Configuration
#define SOAP_TYPE_ns2__IPv6Configuration (524)
#endif

/* ns2__IPv4Configuration has binding name 'ns2__IPv4Configuration' for type 'ns2:IPv4Configuration' */
#ifndef SOAP_TYPE_ns2__IPv4Configuration
#define SOAP_TYPE_ns2__IPv4Configuration (523)
#endif

/* ns2__IPv4NetworkInterface has binding name 'ns2__IPv4NetworkInterface' for type 'ns2:IPv4NetworkInterface' */
#ifndef SOAP_TYPE_ns2__IPv4NetworkInterface
#define SOAP_TYPE_ns2__IPv4NetworkInterface (522)
#endif

/* ns2__IPv6NetworkInterface has binding name 'ns2__IPv6NetworkInterface' for type 'ns2:IPv6NetworkInterface' */
#ifndef SOAP_TYPE_ns2__IPv6NetworkInterface
#define SOAP_TYPE_ns2__IPv6NetworkInterface (521)
#endif

/* ns2__NetworkInterfaceInfo has binding name 'ns2__NetworkInterfaceInfo' for type 'ns2:NetworkInterfaceInfo' */
#ifndef SOAP_TYPE_ns2__NetworkInterfaceInfo
#define SOAP_TYPE_ns2__NetworkInterfaceInfo (520)
#endif

/* ns2__NetworkInterfaceConnectionSetting has binding name 'ns2__NetworkInterfaceConnectionSetting' for type 'ns2:NetworkInterfaceConnectionSetting' */
#ifndef SOAP_TYPE_ns2__NetworkInterfaceConnectionSetting
#define SOAP_TYPE_ns2__NetworkInterfaceConnectionSetting (519)
#endif

/* ns2__NetworkInterfaceLink has binding name 'ns2__NetworkInterfaceLink' for type 'ns2:NetworkInterfaceLink' */
#ifndef SOAP_TYPE_ns2__NetworkInterfaceLink
#define SOAP_TYPE_ns2__NetworkInterfaceLink (518)
#endif

/* ns2__NetworkInterfaceExtension2 has binding name 'ns2__NetworkInterfaceExtension2' for type 'ns2:NetworkInterfaceExtension2' */
#ifndef SOAP_TYPE_ns2__NetworkInterfaceExtension2
#define SOAP_TYPE_ns2__NetworkInterfaceExtension2 (517)
#endif

/* ns2__Dot3Configuration has binding name 'ns2__Dot3Configuration' for type 'ns2:Dot3Configuration' */
#ifndef SOAP_TYPE_ns2__Dot3Configuration
#define SOAP_TYPE_ns2__Dot3Configuration (516)
#endif

/* ns2__NetworkInterfaceExtension has binding name 'ns2__NetworkInterfaceExtension' for type 'ns2:NetworkInterfaceExtension' */
#ifndef SOAP_TYPE_ns2__NetworkInterfaceExtension
#define SOAP_TYPE_ns2__NetworkInterfaceExtension (515)
#endif

/* ns2__NetworkInterface has binding name 'ns2__NetworkInterface' for type 'ns2:NetworkInterface' */
#ifndef SOAP_TYPE_ns2__NetworkInterface
#define SOAP_TYPE_ns2__NetworkInterface (514)
#endif

/* ns2__Scope has binding name 'ns2__Scope' for type 'ns2:Scope' */
#ifndef SOAP_TYPE_ns2__Scope
#define SOAP_TYPE_ns2__Scope (513)
#endif

/* ns2__MediaUri has binding name 'ns2__MediaUri' for type 'ns2:MediaUri' */
#ifndef SOAP_TYPE_ns2__MediaUri
#define SOAP_TYPE_ns2__MediaUri (512)
#endif

/* ns2__Transport has binding name 'ns2__Transport' for type 'ns2:Transport' */
#ifndef SOAP_TYPE_ns2__Transport
#define SOAP_TYPE_ns2__Transport (511)
#endif

/* ns2__StreamSetup has binding name 'ns2__StreamSetup' for type 'ns2:StreamSetup' */
#ifndef SOAP_TYPE_ns2__StreamSetup
#define SOAP_TYPE_ns2__StreamSetup (510)
#endif

/* ns2__MulticastConfiguration has binding name 'ns2__MulticastConfiguration' for type 'ns2:MulticastConfiguration' */
#ifndef SOAP_TYPE_ns2__MulticastConfiguration
#define SOAP_TYPE_ns2__MulticastConfiguration (509)
#endif

/* ns2__AudioDecoderConfigurationOptionsExtension has binding name 'ns2__AudioDecoderConfigurationOptionsExtension' for type 'ns2:AudioDecoderConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_ns2__AudioDecoderConfigurationOptionsExtension
#define SOAP_TYPE_ns2__AudioDecoderConfigurationOptionsExtension (508)
#endif

/* ns2__G726DecOptions has binding name 'ns2__G726DecOptions' for type 'ns2:G726DecOptions' */
#ifndef SOAP_TYPE_ns2__G726DecOptions
#define SOAP_TYPE_ns2__G726DecOptions (507)
#endif

/* ns2__AACDecOptions has binding name 'ns2__AACDecOptions' for type 'ns2:AACDecOptions' */
#ifndef SOAP_TYPE_ns2__AACDecOptions
#define SOAP_TYPE_ns2__AACDecOptions (506)
#endif

/* ns2__G711DecOptions has binding name 'ns2__G711DecOptions' for type 'ns2:G711DecOptions' */
#ifndef SOAP_TYPE_ns2__G711DecOptions
#define SOAP_TYPE_ns2__G711DecOptions (505)
#endif

/* ns2__AudioDecoderConfigurationOptions has binding name 'ns2__AudioDecoderConfigurationOptions' for type 'ns2:AudioDecoderConfigurationOptions' */
#ifndef SOAP_TYPE_ns2__AudioDecoderConfigurationOptions
#define SOAP_TYPE_ns2__AudioDecoderConfigurationOptions (504)
#endif

/* ns2__AudioDecoderConfiguration has binding name 'ns2__AudioDecoderConfiguration' for type 'ns2:AudioDecoderConfiguration' */
#ifndef SOAP_TYPE_ns2__AudioDecoderConfiguration
#define SOAP_TYPE_ns2__AudioDecoderConfiguration (503)
#endif

/* ns2__AudioOutputConfigurationOptions has binding name 'ns2__AudioOutputConfigurationOptions' for type 'ns2:AudioOutputConfigurationOptions' */
#ifndef SOAP_TYPE_ns2__AudioOutputConfigurationOptions
#define SOAP_TYPE_ns2__AudioOutputConfigurationOptions (502)
#endif

/* ns2__AudioOutputConfiguration has binding name 'ns2__AudioOutputConfiguration' for type 'ns2:AudioOutputConfiguration' */
#ifndef SOAP_TYPE_ns2__AudioOutputConfiguration
#define SOAP_TYPE_ns2__AudioOutputConfiguration (501)
#endif

/* ns2__AudioOutput has binding name 'ns2__AudioOutput' for type 'ns2:AudioOutput' */
#ifndef SOAP_TYPE_ns2__AudioOutput
#define SOAP_TYPE_ns2__AudioOutput (500)
#endif

/* ns2__VideoDecoderConfigurationOptionsExtension has binding name 'ns2__VideoDecoderConfigurationOptionsExtension' for type 'ns2:VideoDecoderConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_ns2__VideoDecoderConfigurationOptionsExtension
#define SOAP_TYPE_ns2__VideoDecoderConfigurationOptionsExtension (499)
#endif

/* ns2__Mpeg4DecOptions has binding name 'ns2__Mpeg4DecOptions' for type 'ns2:Mpeg4DecOptions' */
#ifndef SOAP_TYPE_ns2__Mpeg4DecOptions
#define SOAP_TYPE_ns2__Mpeg4DecOptions (498)
#endif

/* ns2__JpegDecOptions has binding name 'ns2__JpegDecOptions' for type 'ns2:JpegDecOptions' */
#ifndef SOAP_TYPE_ns2__JpegDecOptions
#define SOAP_TYPE_ns2__JpegDecOptions (497)
#endif

/* ns2__H264DecOptions has binding name 'ns2__H264DecOptions' for type 'ns2:H264DecOptions' */
#ifndef SOAP_TYPE_ns2__H264DecOptions
#define SOAP_TYPE_ns2__H264DecOptions (496)
#endif

/* ns2__VideoDecoderConfigurationOptions has binding name 'ns2__VideoDecoderConfigurationOptions' for type 'ns2:VideoDecoderConfigurationOptions' */
#ifndef SOAP_TYPE_ns2__VideoDecoderConfigurationOptions
#define SOAP_TYPE_ns2__VideoDecoderConfigurationOptions (495)
#endif

/* ns2__VideoOutputConfigurationOptions has binding name 'ns2__VideoOutputConfigurationOptions' for type 'ns2:VideoOutputConfigurationOptions' */
#ifndef SOAP_TYPE_ns2__VideoOutputConfigurationOptions
#define SOAP_TYPE_ns2__VideoOutputConfigurationOptions (494)
#endif

/* ns2__VideoOutputConfiguration has binding name 'ns2__VideoOutputConfiguration' for type 'ns2:VideoOutputConfiguration' */
#ifndef SOAP_TYPE_ns2__VideoOutputConfiguration
#define SOAP_TYPE_ns2__VideoOutputConfiguration (493)
#endif

/* ns2__VideoOutputExtension has binding name 'ns2__VideoOutputExtension' for type 'ns2:VideoOutputExtension' */
#ifndef SOAP_TYPE_ns2__VideoOutputExtension
#define SOAP_TYPE_ns2__VideoOutputExtension (492)
#endif

/* ns2__VideoOutput has binding name 'ns2__VideoOutput' for type 'ns2:VideoOutput' */
#ifndef SOAP_TYPE_ns2__VideoOutput
#define SOAP_TYPE_ns2__VideoOutput (491)
#endif

/* ns2__PTZStatusFilterOptionsExtension has binding name 'ns2__PTZStatusFilterOptionsExtension' for type 'ns2:PTZStatusFilterOptionsExtension' */
#ifndef SOAP_TYPE_ns2__PTZStatusFilterOptionsExtension
#define SOAP_TYPE_ns2__PTZStatusFilterOptionsExtension (490)
#endif

/* ns2__PTZStatusFilterOptions has binding name 'ns2__PTZStatusFilterOptions' for type 'ns2:PTZStatusFilterOptions' */
#ifndef SOAP_TYPE_ns2__PTZStatusFilterOptions
#define SOAP_TYPE_ns2__PTZStatusFilterOptions (489)
#endif

/* ns2__MetadataConfigurationOptionsExtension2 has binding name 'ns2__MetadataConfigurationOptionsExtension2' for type 'ns2:MetadataConfigurationOptionsExtension2' */
#ifndef SOAP_TYPE_ns2__MetadataConfigurationOptionsExtension2
#define SOAP_TYPE_ns2__MetadataConfigurationOptionsExtension2 (488)
#endif

/* ns2__MetadataConfigurationOptionsExtension has binding name 'ns2__MetadataConfigurationOptionsExtension' for type 'ns2:MetadataConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_ns2__MetadataConfigurationOptionsExtension
#define SOAP_TYPE_ns2__MetadataConfigurationOptionsExtension (487)
#endif

/* ns2__MetadataConfigurationOptions has binding name 'ns2__MetadataConfigurationOptions' for type 'ns2:MetadataConfigurationOptions' */
#ifndef SOAP_TYPE_ns2__MetadataConfigurationOptions
#define SOAP_TYPE_ns2__MetadataConfigurationOptions (486)
#endif

/* ns2__EventSubscription has binding name 'ns2__EventSubscription' for type 'ns2:EventSubscription' */
#ifndef SOAP_TYPE_ns2__EventSubscription
#define SOAP_TYPE_ns2__EventSubscription (485)
#endif

/* ns2__PTZFilter has binding name 'ns2__PTZFilter' for type 'ns2:PTZFilter' */
#ifndef SOAP_TYPE_ns2__PTZFilter
#define SOAP_TYPE_ns2__PTZFilter (484)
#endif

/* ns2__MetadataConfigurationExtension has binding name 'ns2__MetadataConfigurationExtension' for type 'ns2:MetadataConfigurationExtension' */
#ifndef SOAP_TYPE_ns2__MetadataConfigurationExtension
#define SOAP_TYPE_ns2__MetadataConfigurationExtension (483)
#endif

/* ns2__MetadataConfiguration has binding name 'ns2__MetadataConfiguration' for type 'ns2:MetadataConfiguration' */
#ifndef SOAP_TYPE_ns2__MetadataConfiguration
#define SOAP_TYPE_ns2__MetadataConfiguration (482)
#endif

/* ns2__VideoAnalyticsConfiguration has binding name 'ns2__VideoAnalyticsConfiguration' for type 'ns2:VideoAnalyticsConfiguration' */
#ifndef SOAP_TYPE_ns2__VideoAnalyticsConfiguration
#define SOAP_TYPE_ns2__VideoAnalyticsConfiguration (481)
#endif

/* ns2__AudioEncoder2ConfigurationOptions has binding name 'ns2__AudioEncoder2ConfigurationOptions' for type 'ns2:AudioEncoder2ConfigurationOptions' */
#ifndef SOAP_TYPE_ns2__AudioEncoder2ConfigurationOptions
#define SOAP_TYPE_ns2__AudioEncoder2ConfigurationOptions (480)
#endif

/* ns2__AudioEncoder2Configuration has binding name 'ns2__AudioEncoder2Configuration' for type 'ns2:AudioEncoder2Configuration' */
#ifndef SOAP_TYPE_ns2__AudioEncoder2Configuration
#define SOAP_TYPE_ns2__AudioEncoder2Configuration (479)
#endif

/* ns2__AudioEncoderConfigurationOption has binding name 'ns2__AudioEncoderConfigurationOption' for type 'ns2:AudioEncoderConfigurationOption' */
#ifndef SOAP_TYPE_ns2__AudioEncoderConfigurationOption
#define SOAP_TYPE_ns2__AudioEncoderConfigurationOption (478)
#endif

/* ns2__AudioEncoderConfigurationOptions has binding name 'ns2__AudioEncoderConfigurationOptions' for type 'ns2:AudioEncoderConfigurationOptions' */
#ifndef SOAP_TYPE_ns2__AudioEncoderConfigurationOptions
#define SOAP_TYPE_ns2__AudioEncoderConfigurationOptions (477)
#endif

/* ns2__AudioEncoderConfiguration has binding name 'ns2__AudioEncoderConfiguration' for type 'ns2:AudioEncoderConfiguration' */
#ifndef SOAP_TYPE_ns2__AudioEncoderConfiguration
#define SOAP_TYPE_ns2__AudioEncoderConfiguration (476)
#endif

/* ns2__AudioSourceOptionsExtension has binding name 'ns2__AudioSourceOptionsExtension' for type 'ns2:AudioSourceOptionsExtension' */
#ifndef SOAP_TYPE_ns2__AudioSourceOptionsExtension
#define SOAP_TYPE_ns2__AudioSourceOptionsExtension (475)
#endif

/* ns2__AudioSourceConfigurationOptions has binding name 'ns2__AudioSourceConfigurationOptions' for type 'ns2:AudioSourceConfigurationOptions' */
#ifndef SOAP_TYPE_ns2__AudioSourceConfigurationOptions
#define SOAP_TYPE_ns2__AudioSourceConfigurationOptions (474)
#endif

/* ns2__AudioSourceConfiguration has binding name 'ns2__AudioSourceConfiguration' for type 'ns2:AudioSourceConfiguration' */
#ifndef SOAP_TYPE_ns2__AudioSourceConfiguration
#define SOAP_TYPE_ns2__AudioSourceConfiguration (473)
#endif

/* ns2__VideoEncoder2ConfigurationOptions has binding name 'ns2__VideoEncoder2ConfigurationOptions' for type 'ns2:VideoEncoder2ConfigurationOptions' */
#ifndef SOAP_TYPE_ns2__VideoEncoder2ConfigurationOptions
#define SOAP_TYPE_ns2__VideoEncoder2ConfigurationOptions (472)
#endif

/* ns2__VideoRateControl2 has binding name 'ns2__VideoRateControl2' for type 'ns2:VideoRateControl2' */
#ifndef SOAP_TYPE_ns2__VideoRateControl2
#define SOAP_TYPE_ns2__VideoRateControl2 (471)
#endif

/* ns2__VideoResolution2 has binding name 'ns2__VideoResolution2' for type 'ns2:VideoResolution2' */
#ifndef SOAP_TYPE_ns2__VideoResolution2
#define SOAP_TYPE_ns2__VideoResolution2 (470)
#endif

/* ns2__VideoEncoder2Configuration has binding name 'ns2__VideoEncoder2Configuration' for type 'ns2:VideoEncoder2Configuration' */
#ifndef SOAP_TYPE_ns2__VideoEncoder2Configuration
#define SOAP_TYPE_ns2__VideoEncoder2Configuration (469)
#endif

/* ns2__H264Options2 has binding name 'ns2__H264Options2' for type 'ns2:H264Options2' */
#ifndef SOAP_TYPE_ns2__H264Options2
#define SOAP_TYPE_ns2__H264Options2 (468)
#endif

/* ns2__H264Options has binding name 'ns2__H264Options' for type 'ns2:H264Options' */
#ifndef SOAP_TYPE_ns2__H264Options
#define SOAP_TYPE_ns2__H264Options (467)
#endif

/* ns2__Mpeg4Options2 has binding name 'ns2__Mpeg4Options2' for type 'ns2:Mpeg4Options2' */
#ifndef SOAP_TYPE_ns2__Mpeg4Options2
#define SOAP_TYPE_ns2__Mpeg4Options2 (466)
#endif

/* ns2__Mpeg4Options has binding name 'ns2__Mpeg4Options' for type 'ns2:Mpeg4Options' */
#ifndef SOAP_TYPE_ns2__Mpeg4Options
#define SOAP_TYPE_ns2__Mpeg4Options (465)
#endif

/* ns2__JpegOptions2 has binding name 'ns2__JpegOptions2' for type 'ns2:JpegOptions2' */
#ifndef SOAP_TYPE_ns2__JpegOptions2
#define SOAP_TYPE_ns2__JpegOptions2 (464)
#endif

/* ns2__JpegOptions has binding name 'ns2__JpegOptions' for type 'ns2:JpegOptions' */
#ifndef SOAP_TYPE_ns2__JpegOptions
#define SOAP_TYPE_ns2__JpegOptions (463)
#endif

/* ns2__VideoEncoderOptionsExtension2 has binding name 'ns2__VideoEncoderOptionsExtension2' for type 'ns2:VideoEncoderOptionsExtension2' */
#ifndef SOAP_TYPE_ns2__VideoEncoderOptionsExtension2
#define SOAP_TYPE_ns2__VideoEncoderOptionsExtension2 (462)
#endif

/* ns2__VideoEncoderOptionsExtension has binding name 'ns2__VideoEncoderOptionsExtension' for type 'ns2:VideoEncoderOptionsExtension' */
#ifndef SOAP_TYPE_ns2__VideoEncoderOptionsExtension
#define SOAP_TYPE_ns2__VideoEncoderOptionsExtension (461)
#endif

/* ns2__VideoEncoderConfigurationOptions has binding name 'ns2__VideoEncoderConfigurationOptions' for type 'ns2:VideoEncoderConfigurationOptions' */
#ifndef SOAP_TYPE_ns2__VideoEncoderConfigurationOptions
#define SOAP_TYPE_ns2__VideoEncoderConfigurationOptions (460)
#endif

/* ns2__H264Configuration has binding name 'ns2__H264Configuration' for type 'ns2:H264Configuration' */
#ifndef SOAP_TYPE_ns2__H264Configuration
#define SOAP_TYPE_ns2__H264Configuration (459)
#endif

/* ns2__Mpeg4Configuration has binding name 'ns2__Mpeg4Configuration' for type 'ns2:Mpeg4Configuration' */
#ifndef SOAP_TYPE_ns2__Mpeg4Configuration
#define SOAP_TYPE_ns2__Mpeg4Configuration (458)
#endif

/* ns2__VideoRateControl has binding name 'ns2__VideoRateControl' for type 'ns2:VideoRateControl' */
#ifndef SOAP_TYPE_ns2__VideoRateControl
#define SOAP_TYPE_ns2__VideoRateControl (457)
#endif

/* ns2__VideoResolution has binding name 'ns2__VideoResolution' for type 'ns2:VideoResolution' */
#ifndef SOAP_TYPE_ns2__VideoResolution
#define SOAP_TYPE_ns2__VideoResolution (456)
#endif

/* ns2__VideoEncoderConfiguration has binding name 'ns2__VideoEncoderConfiguration' for type 'ns2:VideoEncoderConfiguration' */
#ifndef SOAP_TYPE_ns2__VideoEncoderConfiguration
#define SOAP_TYPE_ns2__VideoEncoderConfiguration (455)
#endif

/* ns2__RotateOptionsExtension has binding name 'ns2__RotateOptionsExtension' for type 'ns2:RotateOptionsExtension' */
#ifndef SOAP_TYPE_ns2__RotateOptionsExtension
#define SOAP_TYPE_ns2__RotateOptionsExtension (454)
#endif

/* ns2__RotateOptions has binding name 'ns2__RotateOptions' for type 'ns2:RotateOptions' */
#ifndef SOAP_TYPE_ns2__RotateOptions
#define SOAP_TYPE_ns2__RotateOptions (453)
#endif

/* ns2__VideoSourceConfigurationOptionsExtension2 has binding name 'ns2__VideoSourceConfigurationOptionsExtension2' for type 'ns2:VideoSourceConfigurationOptionsExtension2' */
#ifndef SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension2
#define SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension2 (452)
#endif

/* ns2__VideoSourceConfigurationOptionsExtension has binding name 'ns2__VideoSourceConfigurationOptionsExtension' for type 'ns2:VideoSourceConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension
#define SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension (451)
#endif

/* ns2__VideoSourceConfigurationOptions has binding name 'ns2__VideoSourceConfigurationOptions' for type 'ns2:VideoSourceConfigurationOptions' */
#ifndef SOAP_TYPE_ns2__VideoSourceConfigurationOptions
#define SOAP_TYPE_ns2__VideoSourceConfigurationOptions (450)
#endif

/* ns2__LensDescription has binding name 'ns2__LensDescription' for type 'ns2:LensDescription' */
#ifndef SOAP_TYPE_ns2__LensDescription
#define SOAP_TYPE_ns2__LensDescription (449)
#endif

/* ns2__LensOffset has binding name 'ns2__LensOffset' for type 'ns2:LensOffset' */
#ifndef SOAP_TYPE_ns2__LensOffset
#define SOAP_TYPE_ns2__LensOffset (448)
#endif

/* ns2__LensProjection has binding name 'ns2__LensProjection' for type 'ns2:LensProjection' */
#ifndef SOAP_TYPE_ns2__LensProjection
#define SOAP_TYPE_ns2__LensProjection (447)
#endif

/* ns2__RotateExtension has binding name 'ns2__RotateExtension' for type 'ns2:RotateExtension' */
#ifndef SOAP_TYPE_ns2__RotateExtension
#define SOAP_TYPE_ns2__RotateExtension (446)
#endif

/* ns2__Rotate has binding name 'ns2__Rotate' for type 'ns2:Rotate' */
#ifndef SOAP_TYPE_ns2__Rotate
#define SOAP_TYPE_ns2__Rotate (445)
#endif

/* ns2__VideoSourceConfigurationExtension2 has binding name 'ns2__VideoSourceConfigurationExtension2' for type 'ns2:VideoSourceConfigurationExtension2' */
#ifndef SOAP_TYPE_ns2__VideoSourceConfigurationExtension2
#define SOAP_TYPE_ns2__VideoSourceConfigurationExtension2 (444)
#endif

/* ns2__VideoSourceConfigurationExtension has binding name 'ns2__VideoSourceConfigurationExtension' for type 'ns2:VideoSourceConfigurationExtension' */
#ifndef SOAP_TYPE_ns2__VideoSourceConfigurationExtension
#define SOAP_TYPE_ns2__VideoSourceConfigurationExtension (443)
#endif

/* ns2__VideoSourceConfiguration has binding name 'ns2__VideoSourceConfiguration' for type 'ns2:VideoSourceConfiguration' */
#ifndef SOAP_TYPE_ns2__VideoSourceConfiguration
#define SOAP_TYPE_ns2__VideoSourceConfiguration (442)
#endif

/* ns2__ConfigurationEntity has binding name 'ns2__ConfigurationEntity' for type 'ns2:ConfigurationEntity' */
#ifndef SOAP_TYPE_ns2__ConfigurationEntity
#define SOAP_TYPE_ns2__ConfigurationEntity (441)
#endif

/* ns2__ProfileExtension2 has binding name 'ns2__ProfileExtension2' for type 'ns2:ProfileExtension2' */
#ifndef SOAP_TYPE_ns2__ProfileExtension2
#define SOAP_TYPE_ns2__ProfileExtension2 (440)
#endif

/* ns2__ProfileExtension has binding name 'ns2__ProfileExtension' for type 'ns2:ProfileExtension' */
#ifndef SOAP_TYPE_ns2__ProfileExtension
#define SOAP_TYPE_ns2__ProfileExtension (439)
#endif

/* ns2__Profile has binding name 'ns2__Profile' for type 'ns2:Profile' */
#ifndef SOAP_TYPE_ns2__Profile
#define SOAP_TYPE_ns2__Profile (438)
#endif

/* ns2__AudioSource has binding name 'ns2__AudioSource' for type 'ns2:AudioSource' */
#ifndef SOAP_TYPE_ns2__AudioSource
#define SOAP_TYPE_ns2__AudioSource (437)
#endif

/* ns2__VideoSourceExtension2 has binding name 'ns2__VideoSourceExtension2' for type 'ns2:VideoSourceExtension2' */
#ifndef SOAP_TYPE_ns2__VideoSourceExtension2
#define SOAP_TYPE_ns2__VideoSourceExtension2 (436)
#endif

/* ns2__VideoSourceExtension has binding name 'ns2__VideoSourceExtension' for type 'ns2:VideoSourceExtension' */
#ifndef SOAP_TYPE_ns2__VideoSourceExtension
#define SOAP_TYPE_ns2__VideoSourceExtension (435)
#endif

/* ns2__VideoSource has binding name 'ns2__VideoSource' for type 'ns2:VideoSource' */
#ifndef SOAP_TYPE_ns2__VideoSource
#define SOAP_TYPE_ns2__VideoSource (434)
#endif

/* ns2__AnyHolder has binding name 'ns2__AnyHolder' for type 'ns2:AnyHolder' */
#ifndef SOAP_TYPE_ns2__AnyHolder
#define SOAP_TYPE_ns2__AnyHolder (433)
#endif

/* ns2__FloatList has binding name 'ns2__FloatList' for type 'ns2:FloatList' */
#ifndef SOAP_TYPE_ns2__FloatList
#define SOAP_TYPE_ns2__FloatList (432)
#endif

/* ns2__IntList has binding name 'ns2__IntList' for type 'ns2:IntList' */
#ifndef SOAP_TYPE_ns2__IntList
#define SOAP_TYPE_ns2__IntList (431)
#endif

/* ns2__DurationRange has binding name 'ns2__DurationRange' for type 'ns2:DurationRange' */
#ifndef SOAP_TYPE_ns2__DurationRange
#define SOAP_TYPE_ns2__DurationRange (430)
#endif

/* ns2__FloatRange has binding name 'ns2__FloatRange' for type 'ns2:FloatRange' */
#ifndef SOAP_TYPE_ns2__FloatRange
#define SOAP_TYPE_ns2__FloatRange (429)
#endif

/* ns2__IntRange has binding name 'ns2__IntRange' for type 'ns2:IntRange' */
#ifndef SOAP_TYPE_ns2__IntRange
#define SOAP_TYPE_ns2__IntRange (428)
#endif

/* ns2__IntRectangleRange has binding name 'ns2__IntRectangleRange' for type 'ns2:IntRectangleRange' */
#ifndef SOAP_TYPE_ns2__IntRectangleRange
#define SOAP_TYPE_ns2__IntRectangleRange (427)
#endif

/* ns2__IntRectangle has binding name 'ns2__IntRectangle' for type 'ns2:IntRectangle' */
#ifndef SOAP_TYPE_ns2__IntRectangle
#define SOAP_TYPE_ns2__IntRectangle (426)
#endif

/* ns2__DeviceEntity has binding name 'ns2__DeviceEntity' for type 'ns2:DeviceEntity' */
#ifndef SOAP_TYPE_ns2__DeviceEntity
#define SOAP_TYPE_ns2__DeviceEntity (425)
#endif

/* _ns1__DeleteStorageConfigurationResponse has binding name '_ns1__DeleteStorageConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__DeleteStorageConfigurationResponse
#define SOAP_TYPE__ns1__DeleteStorageConfigurationResponse (424)
#endif

/* _ns1__DeleteStorageConfiguration has binding name '_ns1__DeleteStorageConfiguration' for type '' */
#ifndef SOAP_TYPE__ns1__DeleteStorageConfiguration
#define SOAP_TYPE__ns1__DeleteStorageConfiguration (423)
#endif

/* _ns1__SetStorageConfigurationResponse has binding name '_ns1__SetStorageConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetStorageConfigurationResponse
#define SOAP_TYPE__ns1__SetStorageConfigurationResponse (422)
#endif

/* _ns1__SetStorageConfiguration has binding name '_ns1__SetStorageConfiguration' for type '' */
#ifndef SOAP_TYPE__ns1__SetStorageConfiguration
#define SOAP_TYPE__ns1__SetStorageConfiguration (421)
#endif

/* _ns1__GetStorageConfigurationResponse has binding name '_ns1__GetStorageConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetStorageConfigurationResponse
#define SOAP_TYPE__ns1__GetStorageConfigurationResponse (420)
#endif

/* _ns1__GetStorageConfiguration has binding name '_ns1__GetStorageConfiguration' for type '' */
#ifndef SOAP_TYPE__ns1__GetStorageConfiguration
#define SOAP_TYPE__ns1__GetStorageConfiguration (419)
#endif

/* _ns1__CreateStorageConfigurationResponse has binding name '_ns1__CreateStorageConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CreateStorageConfigurationResponse
#define SOAP_TYPE__ns1__CreateStorageConfigurationResponse (418)
#endif

/* _ns1__CreateStorageConfiguration has binding name '_ns1__CreateStorageConfiguration' for type '' */
#ifndef SOAP_TYPE__ns1__CreateStorageConfiguration
#define SOAP_TYPE__ns1__CreateStorageConfiguration (417)
#endif

/* _ns1__GetStorageConfigurationsResponse has binding name '_ns1__GetStorageConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetStorageConfigurationsResponse
#define SOAP_TYPE__ns1__GetStorageConfigurationsResponse (416)
#endif

/* _ns1__GetStorageConfigurations has binding name '_ns1__GetStorageConfigurations' for type '' */
#ifndef SOAP_TYPE__ns1__GetStorageConfigurations
#define SOAP_TYPE__ns1__GetStorageConfigurations (415)
#endif

/* _ns1__StartSystemRestoreResponse has binding name '_ns1__StartSystemRestoreResponse' for type '' */
#ifndef SOAP_TYPE__ns1__StartSystemRestoreResponse
#define SOAP_TYPE__ns1__StartSystemRestoreResponse (414)
#endif

/* _ns1__StartSystemRestore has binding name '_ns1__StartSystemRestore' for type '' */
#ifndef SOAP_TYPE__ns1__StartSystemRestore
#define SOAP_TYPE__ns1__StartSystemRestore (413)
#endif

/* _ns1__StartFirmwareUpgradeResponse has binding name '_ns1__StartFirmwareUpgradeResponse' for type '' */
#ifndef SOAP_TYPE__ns1__StartFirmwareUpgradeResponse
#define SOAP_TYPE__ns1__StartFirmwareUpgradeResponse (412)
#endif

/* _ns1__StartFirmwareUpgrade has binding name '_ns1__StartFirmwareUpgrade' for type '' */
#ifndef SOAP_TYPE__ns1__StartFirmwareUpgrade
#define SOAP_TYPE__ns1__StartFirmwareUpgrade (411)
#endif

/* _ns1__GetSystemUrisResponse has binding name '_ns1__GetSystemUrisResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetSystemUrisResponse
#define SOAP_TYPE__ns1__GetSystemUrisResponse (410)
#endif

/* _ns1__GetSystemUris has binding name '_ns1__GetSystemUris' for type '' */
#ifndef SOAP_TYPE__ns1__GetSystemUris
#define SOAP_TYPE__ns1__GetSystemUris (409)
#endif

/* _ns1__ScanAvailableDot11NetworksResponse has binding name '_ns1__ScanAvailableDot11NetworksResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ScanAvailableDot11NetworksResponse
#define SOAP_TYPE__ns1__ScanAvailableDot11NetworksResponse (408)
#endif

/* _ns1__ScanAvailableDot11Networks has binding name '_ns1__ScanAvailableDot11Networks' for type '' */
#ifndef SOAP_TYPE__ns1__ScanAvailableDot11Networks
#define SOAP_TYPE__ns1__ScanAvailableDot11Networks (407)
#endif

/* _ns1__GetDot11StatusResponse has binding name '_ns1__GetDot11StatusResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetDot11StatusResponse
#define SOAP_TYPE__ns1__GetDot11StatusResponse (406)
#endif

/* _ns1__GetDot11Status has binding name '_ns1__GetDot11Status' for type '' */
#ifndef SOAP_TYPE__ns1__GetDot11Status
#define SOAP_TYPE__ns1__GetDot11Status (405)
#endif

/* _ns1__GetDot11CapabilitiesResponse has binding name '_ns1__GetDot11CapabilitiesResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetDot11CapabilitiesResponse
#define SOAP_TYPE__ns1__GetDot11CapabilitiesResponse (404)
#endif

/* _ns1__GetDot11Capabilities has binding name '_ns1__GetDot11Capabilities' for type '' */
#ifndef SOAP_TYPE__ns1__GetDot11Capabilities
#define SOAP_TYPE__ns1__GetDot11Capabilities (403)
#endif

/* _ns1__SendAuxiliaryCommandResponse has binding name '_ns1__SendAuxiliaryCommandResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SendAuxiliaryCommandResponse
#define SOAP_TYPE__ns1__SendAuxiliaryCommandResponse (402)
#endif

/* _ns1__SendAuxiliaryCommand has binding name '_ns1__SendAuxiliaryCommand' for type '' */
#ifndef SOAP_TYPE__ns1__SendAuxiliaryCommand
#define SOAP_TYPE__ns1__SendAuxiliaryCommand (401)
#endif

/* _ns1__SetRelayOutputStateResponse has binding name '_ns1__SetRelayOutputStateResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetRelayOutputStateResponse
#define SOAP_TYPE__ns1__SetRelayOutputStateResponse (400)
#endif

/* _ns1__SetRelayOutputState has binding name '_ns1__SetRelayOutputState' for type '' */
#ifndef SOAP_TYPE__ns1__SetRelayOutputState
#define SOAP_TYPE__ns1__SetRelayOutputState (399)
#endif

/* _ns1__SetRelayOutputSettingsResponse has binding name '_ns1__SetRelayOutputSettingsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetRelayOutputSettingsResponse
#define SOAP_TYPE__ns1__SetRelayOutputSettingsResponse (398)
#endif

/* _ns1__SetRelayOutputSettings has binding name '_ns1__SetRelayOutputSettings' for type '' */
#ifndef SOAP_TYPE__ns1__SetRelayOutputSettings
#define SOAP_TYPE__ns1__SetRelayOutputSettings (397)
#endif

/* _ns1__GetRelayOutputsResponse has binding name '_ns1__GetRelayOutputsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetRelayOutputsResponse
#define SOAP_TYPE__ns1__GetRelayOutputsResponse (396)
#endif

/* _ns1__GetRelayOutputs has binding name '_ns1__GetRelayOutputs' for type '' */
#ifndef SOAP_TYPE__ns1__GetRelayOutputs
#define SOAP_TYPE__ns1__GetRelayOutputs (395)
#endif

/* _ns1__DeleteDot1XConfigurationResponse has binding name '_ns1__DeleteDot1XConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__DeleteDot1XConfigurationResponse
#define SOAP_TYPE__ns1__DeleteDot1XConfigurationResponse (394)
#endif

/* _ns1__DeleteDot1XConfiguration has binding name '_ns1__DeleteDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE__ns1__DeleteDot1XConfiguration
#define SOAP_TYPE__ns1__DeleteDot1XConfiguration (393)
#endif

/* _ns1__GetDot1XConfigurationsResponse has binding name '_ns1__GetDot1XConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetDot1XConfigurationsResponse
#define SOAP_TYPE__ns1__GetDot1XConfigurationsResponse (392)
#endif

/* _ns1__GetDot1XConfigurations has binding name '_ns1__GetDot1XConfigurations' for type '' */
#ifndef SOAP_TYPE__ns1__GetDot1XConfigurations
#define SOAP_TYPE__ns1__GetDot1XConfigurations (391)
#endif

/* _ns1__GetDot1XConfigurationResponse has binding name '_ns1__GetDot1XConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetDot1XConfigurationResponse
#define SOAP_TYPE__ns1__GetDot1XConfigurationResponse (390)
#endif

/* _ns1__GetDot1XConfiguration has binding name '_ns1__GetDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE__ns1__GetDot1XConfiguration
#define SOAP_TYPE__ns1__GetDot1XConfiguration (389)
#endif

/* _ns1__SetDot1XConfigurationResponse has binding name '_ns1__SetDot1XConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetDot1XConfigurationResponse
#define SOAP_TYPE__ns1__SetDot1XConfigurationResponse (388)
#endif

/* _ns1__SetDot1XConfiguration has binding name '_ns1__SetDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE__ns1__SetDot1XConfiguration
#define SOAP_TYPE__ns1__SetDot1XConfiguration (387)
#endif

/* _ns1__CreateDot1XConfigurationResponse has binding name '_ns1__CreateDot1XConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CreateDot1XConfigurationResponse
#define SOAP_TYPE__ns1__CreateDot1XConfigurationResponse (386)
#endif

/* _ns1__CreateDot1XConfiguration has binding name '_ns1__CreateDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE__ns1__CreateDot1XConfiguration
#define SOAP_TYPE__ns1__CreateDot1XConfiguration (385)
#endif

/* _ns1__LoadCACertificatesResponse has binding name '_ns1__LoadCACertificatesResponse' for type '' */
#ifndef SOAP_TYPE__ns1__LoadCACertificatesResponse
#define SOAP_TYPE__ns1__LoadCACertificatesResponse (384)
#endif

/* _ns1__LoadCACertificates has binding name '_ns1__LoadCACertificates' for type '' */
#ifndef SOAP_TYPE__ns1__LoadCACertificates
#define SOAP_TYPE__ns1__LoadCACertificates (383)
#endif

/* _ns1__GetCertificateInformationResponse has binding name '_ns1__GetCertificateInformationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetCertificateInformationResponse
#define SOAP_TYPE__ns1__GetCertificateInformationResponse (382)
#endif

/* _ns1__GetCertificateInformation has binding name '_ns1__GetCertificateInformation' for type '' */
#ifndef SOAP_TYPE__ns1__GetCertificateInformation
#define SOAP_TYPE__ns1__GetCertificateInformation (381)
#endif

/* _ns1__LoadCertificateWithPrivateKeyResponse has binding name '_ns1__LoadCertificateWithPrivateKeyResponse' for type '' */
#ifndef SOAP_TYPE__ns1__LoadCertificateWithPrivateKeyResponse
#define SOAP_TYPE__ns1__LoadCertificateWithPrivateKeyResponse (380)
#endif

/* _ns1__LoadCertificateWithPrivateKey has binding name '_ns1__LoadCertificateWithPrivateKey' for type '' */
#ifndef SOAP_TYPE__ns1__LoadCertificateWithPrivateKey
#define SOAP_TYPE__ns1__LoadCertificateWithPrivateKey (379)
#endif

/* _ns1__GetCACertificatesResponse has binding name '_ns1__GetCACertificatesResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetCACertificatesResponse
#define SOAP_TYPE__ns1__GetCACertificatesResponse (378)
#endif

/* _ns1__GetCACertificates has binding name '_ns1__GetCACertificates' for type '' */
#ifndef SOAP_TYPE__ns1__GetCACertificates
#define SOAP_TYPE__ns1__GetCACertificates (377)
#endif

/* _ns1__SetClientCertificateModeResponse has binding name '_ns1__SetClientCertificateModeResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetClientCertificateModeResponse
#define SOAP_TYPE__ns1__SetClientCertificateModeResponse (376)
#endif

/* _ns1__SetClientCertificateMode has binding name '_ns1__SetClientCertificateMode' for type '' */
#ifndef SOAP_TYPE__ns1__SetClientCertificateMode
#define SOAP_TYPE__ns1__SetClientCertificateMode (375)
#endif

/* _ns1__GetClientCertificateModeResponse has binding name '_ns1__GetClientCertificateModeResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetClientCertificateModeResponse
#define SOAP_TYPE__ns1__GetClientCertificateModeResponse (374)
#endif

/* _ns1__GetClientCertificateMode has binding name '_ns1__GetClientCertificateMode' for type '' */
#ifndef SOAP_TYPE__ns1__GetClientCertificateMode
#define SOAP_TYPE__ns1__GetClientCertificateMode (373)
#endif

/* _ns1__LoadCertificatesResponse has binding name '_ns1__LoadCertificatesResponse' for type '' */
#ifndef SOAP_TYPE__ns1__LoadCertificatesResponse
#define SOAP_TYPE__ns1__LoadCertificatesResponse (372)
#endif

/* _ns1__LoadCertificates has binding name '_ns1__LoadCertificates' for type '' */
#ifndef SOAP_TYPE__ns1__LoadCertificates
#define SOAP_TYPE__ns1__LoadCertificates (371)
#endif

/* _ns1__GetPkcs10RequestResponse has binding name '_ns1__GetPkcs10RequestResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetPkcs10RequestResponse
#define SOAP_TYPE__ns1__GetPkcs10RequestResponse (370)
#endif

/* _ns1__GetPkcs10Request has binding name '_ns1__GetPkcs10Request' for type '' */
#ifndef SOAP_TYPE__ns1__GetPkcs10Request
#define SOAP_TYPE__ns1__GetPkcs10Request (369)
#endif

/* _ns1__DeleteCertificatesResponse has binding name '_ns1__DeleteCertificatesResponse' for type '' */
#ifndef SOAP_TYPE__ns1__DeleteCertificatesResponse
#define SOAP_TYPE__ns1__DeleteCertificatesResponse (368)
#endif

/* _ns1__DeleteCertificates has binding name '_ns1__DeleteCertificates' for type '' */
#ifndef SOAP_TYPE__ns1__DeleteCertificates
#define SOAP_TYPE__ns1__DeleteCertificates (367)
#endif

/* _ns1__SetCertificatesStatusResponse has binding name '_ns1__SetCertificatesStatusResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetCertificatesStatusResponse
#define SOAP_TYPE__ns1__SetCertificatesStatusResponse (366)
#endif

/* _ns1__SetCertificatesStatus has binding name '_ns1__SetCertificatesStatus' for type '' */
#ifndef SOAP_TYPE__ns1__SetCertificatesStatus
#define SOAP_TYPE__ns1__SetCertificatesStatus (365)
#endif

/* _ns1__GetCertificatesStatusResponse has binding name '_ns1__GetCertificatesStatusResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetCertificatesStatusResponse
#define SOAP_TYPE__ns1__GetCertificatesStatusResponse (364)
#endif

/* _ns1__GetCertificatesStatus has binding name '_ns1__GetCertificatesStatus' for type '' */
#ifndef SOAP_TYPE__ns1__GetCertificatesStatus
#define SOAP_TYPE__ns1__GetCertificatesStatus (363)
#endif

/* _ns1__GetCertificatesResponse has binding name '_ns1__GetCertificatesResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetCertificatesResponse
#define SOAP_TYPE__ns1__GetCertificatesResponse (362)
#endif

/* _ns1__GetCertificates has binding name '_ns1__GetCertificates' for type '' */
#ifndef SOAP_TYPE__ns1__GetCertificates
#define SOAP_TYPE__ns1__GetCertificates (361)
#endif

/* _ns1__CreateCertificateResponse has binding name '_ns1__CreateCertificateResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CreateCertificateResponse
#define SOAP_TYPE__ns1__CreateCertificateResponse (360)
#endif

/* _ns1__CreateCertificate has binding name '_ns1__CreateCertificate' for type '' */
#ifndef SOAP_TYPE__ns1__CreateCertificate
#define SOAP_TYPE__ns1__CreateCertificate (359)
#endif

/* _ns1__SetAccessPolicyResponse has binding name '_ns1__SetAccessPolicyResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetAccessPolicyResponse
#define SOAP_TYPE__ns1__SetAccessPolicyResponse (358)
#endif

/* _ns1__SetAccessPolicy has binding name '_ns1__SetAccessPolicy' for type '' */
#ifndef SOAP_TYPE__ns1__SetAccessPolicy
#define SOAP_TYPE__ns1__SetAccessPolicy (357)
#endif

/* _ns1__GetAccessPolicyResponse has binding name '_ns1__GetAccessPolicyResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetAccessPolicyResponse
#define SOAP_TYPE__ns1__GetAccessPolicyResponse (356)
#endif

/* _ns1__GetAccessPolicy has binding name '_ns1__GetAccessPolicy' for type '' */
#ifndef SOAP_TYPE__ns1__GetAccessPolicy
#define SOAP_TYPE__ns1__GetAccessPolicy (355)
#endif

/* _ns1__RemoveIPAddressFilterResponse has binding name '_ns1__RemoveIPAddressFilterResponse' for type '' */
#ifndef SOAP_TYPE__ns1__RemoveIPAddressFilterResponse
#define SOAP_TYPE__ns1__RemoveIPAddressFilterResponse (354)
#endif

/* _ns1__RemoveIPAddressFilter has binding name '_ns1__RemoveIPAddressFilter' for type '' */
#ifndef SOAP_TYPE__ns1__RemoveIPAddressFilter
#define SOAP_TYPE__ns1__RemoveIPAddressFilter (353)
#endif

/* _ns1__AddIPAddressFilterResponse has binding name '_ns1__AddIPAddressFilterResponse' for type '' */
#ifndef SOAP_TYPE__ns1__AddIPAddressFilterResponse
#define SOAP_TYPE__ns1__AddIPAddressFilterResponse (352)
#endif

/* _ns1__AddIPAddressFilter has binding name '_ns1__AddIPAddressFilter' for type '' */
#ifndef SOAP_TYPE__ns1__AddIPAddressFilter
#define SOAP_TYPE__ns1__AddIPAddressFilter (351)
#endif

/* _ns1__SetIPAddressFilterResponse has binding name '_ns1__SetIPAddressFilterResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetIPAddressFilterResponse
#define SOAP_TYPE__ns1__SetIPAddressFilterResponse (350)
#endif

/* _ns1__SetIPAddressFilter has binding name '_ns1__SetIPAddressFilter' for type '' */
#ifndef SOAP_TYPE__ns1__SetIPAddressFilter
#define SOAP_TYPE__ns1__SetIPAddressFilter (349)
#endif

/* _ns1__GetIPAddressFilterResponse has binding name '_ns1__GetIPAddressFilterResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetIPAddressFilterResponse
#define SOAP_TYPE__ns1__GetIPAddressFilterResponse (348)
#endif

/* _ns1__GetIPAddressFilter has binding name '_ns1__GetIPAddressFilter' for type '' */
#ifndef SOAP_TYPE__ns1__GetIPAddressFilter
#define SOAP_TYPE__ns1__GetIPAddressFilter (347)
#endif

/* _ns1__SetZeroConfigurationResponse has binding name '_ns1__SetZeroConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetZeroConfigurationResponse
#define SOAP_TYPE__ns1__SetZeroConfigurationResponse (346)
#endif

/* _ns1__SetZeroConfiguration has binding name '_ns1__SetZeroConfiguration' for type '' */
#ifndef SOAP_TYPE__ns1__SetZeroConfiguration
#define SOAP_TYPE__ns1__SetZeroConfiguration (345)
#endif

/* _ns1__GetZeroConfigurationResponse has binding name '_ns1__GetZeroConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetZeroConfigurationResponse
#define SOAP_TYPE__ns1__GetZeroConfigurationResponse (344)
#endif

/* _ns1__GetZeroConfiguration has binding name '_ns1__GetZeroConfiguration' for type '' */
#ifndef SOAP_TYPE__ns1__GetZeroConfiguration
#define SOAP_TYPE__ns1__GetZeroConfiguration (343)
#endif

/* _ns1__SetNetworkDefaultGatewayResponse has binding name '_ns1__SetNetworkDefaultGatewayResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetNetworkDefaultGatewayResponse
#define SOAP_TYPE__ns1__SetNetworkDefaultGatewayResponse (342)
#endif

/* _ns1__SetNetworkDefaultGateway has binding name '_ns1__SetNetworkDefaultGateway' for type '' */
#ifndef SOAP_TYPE__ns1__SetNetworkDefaultGateway
#define SOAP_TYPE__ns1__SetNetworkDefaultGateway (341)
#endif

/* _ns1__GetNetworkDefaultGatewayResponse has binding name '_ns1__GetNetworkDefaultGatewayResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetNetworkDefaultGatewayResponse
#define SOAP_TYPE__ns1__GetNetworkDefaultGatewayResponse (340)
#endif

/* _ns1__GetNetworkDefaultGateway has binding name '_ns1__GetNetworkDefaultGateway' for type '' */
#ifndef SOAP_TYPE__ns1__GetNetworkDefaultGateway
#define SOAP_TYPE__ns1__GetNetworkDefaultGateway (339)
#endif

/* _ns1__SetNetworkProtocolsResponse has binding name '_ns1__SetNetworkProtocolsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetNetworkProtocolsResponse
#define SOAP_TYPE__ns1__SetNetworkProtocolsResponse (338)
#endif

/* _ns1__SetNetworkProtocols has binding name '_ns1__SetNetworkProtocols' for type '' */
#ifndef SOAP_TYPE__ns1__SetNetworkProtocols
#define SOAP_TYPE__ns1__SetNetworkProtocols (337)
#endif

/* _ns1__GetNetworkProtocolsResponse has binding name '_ns1__GetNetworkProtocolsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetNetworkProtocolsResponse
#define SOAP_TYPE__ns1__GetNetworkProtocolsResponse (336)
#endif

/* _ns1__GetNetworkProtocols has binding name '_ns1__GetNetworkProtocols' for type '' */
#ifndef SOAP_TYPE__ns1__GetNetworkProtocols
#define SOAP_TYPE__ns1__GetNetworkProtocols (335)
#endif

/* _ns1__SetNetworkInterfacesResponse has binding name '_ns1__SetNetworkInterfacesResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetNetworkInterfacesResponse
#define SOAP_TYPE__ns1__SetNetworkInterfacesResponse (334)
#endif

/* _ns1__SetNetworkInterfaces has binding name '_ns1__SetNetworkInterfaces' for type '' */
#ifndef SOAP_TYPE__ns1__SetNetworkInterfaces
#define SOAP_TYPE__ns1__SetNetworkInterfaces (333)
#endif

/* _ns1__GetNetworkInterfacesResponse has binding name '_ns1__GetNetworkInterfacesResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetNetworkInterfacesResponse
#define SOAP_TYPE__ns1__GetNetworkInterfacesResponse (332)
#endif

/* _ns1__GetNetworkInterfaces has binding name '_ns1__GetNetworkInterfaces' for type '' */
#ifndef SOAP_TYPE__ns1__GetNetworkInterfaces
#define SOAP_TYPE__ns1__GetNetworkInterfaces (331)
#endif

/* _ns1__SetDynamicDNSResponse has binding name '_ns1__SetDynamicDNSResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetDynamicDNSResponse
#define SOAP_TYPE__ns1__SetDynamicDNSResponse (330)
#endif

/* _ns1__SetDynamicDNS has binding name '_ns1__SetDynamicDNS' for type '' */
#ifndef SOAP_TYPE__ns1__SetDynamicDNS
#define SOAP_TYPE__ns1__SetDynamicDNS (329)
#endif

/* _ns1__GetDynamicDNSResponse has binding name '_ns1__GetDynamicDNSResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetDynamicDNSResponse
#define SOAP_TYPE__ns1__GetDynamicDNSResponse (328)
#endif

/* _ns1__GetDynamicDNS has binding name '_ns1__GetDynamicDNS' for type '' */
#ifndef SOAP_TYPE__ns1__GetDynamicDNS
#define SOAP_TYPE__ns1__GetDynamicDNS (327)
#endif

/* _ns1__SetNTPResponse has binding name '_ns1__SetNTPResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetNTPResponse
#define SOAP_TYPE__ns1__SetNTPResponse (326)
#endif

/* _ns1__SetNTP has binding name '_ns1__SetNTP' for type '' */
#ifndef SOAP_TYPE__ns1__SetNTP
#define SOAP_TYPE__ns1__SetNTP (325)
#endif

/* _ns1__GetNTPResponse has binding name '_ns1__GetNTPResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetNTPResponse
#define SOAP_TYPE__ns1__GetNTPResponse (324)
#endif

/* _ns1__GetNTP has binding name '_ns1__GetNTP' for type '' */
#ifndef SOAP_TYPE__ns1__GetNTP
#define SOAP_TYPE__ns1__GetNTP (323)
#endif

/* _ns1__SetDNSResponse has binding name '_ns1__SetDNSResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetDNSResponse
#define SOAP_TYPE__ns1__SetDNSResponse (322)
#endif

/* _ns1__SetDNS has binding name '_ns1__SetDNS' for type '' */
#ifndef SOAP_TYPE__ns1__SetDNS
#define SOAP_TYPE__ns1__SetDNS (321)
#endif

/* _ns1__GetDNSResponse has binding name '_ns1__GetDNSResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetDNSResponse
#define SOAP_TYPE__ns1__GetDNSResponse (320)
#endif

/* _ns1__GetDNS has binding name '_ns1__GetDNS' for type '' */
#ifndef SOAP_TYPE__ns1__GetDNS
#define SOAP_TYPE__ns1__GetDNS (319)
#endif

/* _ns1__SetHostnameFromDHCPResponse has binding name '_ns1__SetHostnameFromDHCPResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetHostnameFromDHCPResponse
#define SOAP_TYPE__ns1__SetHostnameFromDHCPResponse (318)
#endif

/* _ns1__SetHostnameFromDHCP has binding name '_ns1__SetHostnameFromDHCP' for type '' */
#ifndef SOAP_TYPE__ns1__SetHostnameFromDHCP
#define SOAP_TYPE__ns1__SetHostnameFromDHCP (317)
#endif

/* _ns1__SetHostnameResponse has binding name '_ns1__SetHostnameResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetHostnameResponse
#define SOAP_TYPE__ns1__SetHostnameResponse (316)
#endif

/* _ns1__SetHostname has binding name '_ns1__SetHostname' for type '' */
#ifndef SOAP_TYPE__ns1__SetHostname
#define SOAP_TYPE__ns1__SetHostname (315)
#endif

/* _ns1__GetHostnameResponse has binding name '_ns1__GetHostnameResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetHostnameResponse
#define SOAP_TYPE__ns1__GetHostnameResponse (314)
#endif

/* _ns1__GetHostname has binding name '_ns1__GetHostname' for type '' */
#ifndef SOAP_TYPE__ns1__GetHostname
#define SOAP_TYPE__ns1__GetHostname (313)
#endif

/* _ns1__GetCapabilitiesResponse has binding name '_ns1__GetCapabilitiesResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetCapabilitiesResponse
#define SOAP_TYPE__ns1__GetCapabilitiesResponse (312)
#endif

/* _ns1__GetCapabilities has binding name '_ns1__GetCapabilities' for type '' */
#ifndef SOAP_TYPE__ns1__GetCapabilities
#define SOAP_TYPE__ns1__GetCapabilities (311)
#endif

/* _ns1__GetWsdlUrlResponse has binding name '_ns1__GetWsdlUrlResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetWsdlUrlResponse
#define SOAP_TYPE__ns1__GetWsdlUrlResponse (310)
#endif

/* _ns1__GetWsdlUrl has binding name '_ns1__GetWsdlUrl' for type '' */
#ifndef SOAP_TYPE__ns1__GetWsdlUrl
#define SOAP_TYPE__ns1__GetWsdlUrl (309)
#endif

/* _ns1__SetUserResponse has binding name '_ns1__SetUserResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetUserResponse
#define SOAP_TYPE__ns1__SetUserResponse (308)
#endif

/* _ns1__SetUser has binding name '_ns1__SetUser' for type '' */
#ifndef SOAP_TYPE__ns1__SetUser
#define SOAP_TYPE__ns1__SetUser (307)
#endif

/* _ns1__DeleteUsersResponse has binding name '_ns1__DeleteUsersResponse' for type '' */
#ifndef SOAP_TYPE__ns1__DeleteUsersResponse
#define SOAP_TYPE__ns1__DeleteUsersResponse (306)
#endif

/* _ns1__DeleteUsers has binding name '_ns1__DeleteUsers' for type '' */
#ifndef SOAP_TYPE__ns1__DeleteUsers
#define SOAP_TYPE__ns1__DeleteUsers (305)
#endif

/* _ns1__CreateUsersResponse has binding name '_ns1__CreateUsersResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CreateUsersResponse
#define SOAP_TYPE__ns1__CreateUsersResponse (304)
#endif

/* _ns1__CreateUsers has binding name '_ns1__CreateUsers' for type '' */
#ifndef SOAP_TYPE__ns1__CreateUsers
#define SOAP_TYPE__ns1__CreateUsers (303)
#endif

/* _ns1__GetUsersResponse has binding name '_ns1__GetUsersResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetUsersResponse
#define SOAP_TYPE__ns1__GetUsersResponse (302)
#endif

/* _ns1__GetUsers has binding name '_ns1__GetUsers' for type '' */
#ifndef SOAP_TYPE__ns1__GetUsers
#define SOAP_TYPE__ns1__GetUsers (301)
#endif

/* _ns1__SetRemoteUserResponse has binding name '_ns1__SetRemoteUserResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetRemoteUserResponse
#define SOAP_TYPE__ns1__SetRemoteUserResponse (300)
#endif

/* _ns1__SetRemoteUser has binding name '_ns1__SetRemoteUser' for type '' */
#ifndef SOAP_TYPE__ns1__SetRemoteUser
#define SOAP_TYPE__ns1__SetRemoteUser (299)
#endif

/* _ns1__GetRemoteUserResponse has binding name '_ns1__GetRemoteUserResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetRemoteUserResponse
#define SOAP_TYPE__ns1__GetRemoteUserResponse (298)
#endif

/* _ns1__GetRemoteUser has binding name '_ns1__GetRemoteUser' for type '' */
#ifndef SOAP_TYPE__ns1__GetRemoteUser
#define SOAP_TYPE__ns1__GetRemoteUser (297)
#endif

/* _ns1__GetEndpointReferenceResponse has binding name '_ns1__GetEndpointReferenceResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetEndpointReferenceResponse
#define SOAP_TYPE__ns1__GetEndpointReferenceResponse (296)
#endif

/* _ns1__GetEndpointReference has binding name '_ns1__GetEndpointReference' for type '' */
#ifndef SOAP_TYPE__ns1__GetEndpointReference
#define SOAP_TYPE__ns1__GetEndpointReference (295)
#endif

/* _ns1__SetDPAddressesResponse has binding name '_ns1__SetDPAddressesResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetDPAddressesResponse
#define SOAP_TYPE__ns1__SetDPAddressesResponse (294)
#endif

/* _ns1__SetDPAddresses has binding name '_ns1__SetDPAddresses' for type '' */
#ifndef SOAP_TYPE__ns1__SetDPAddresses
#define SOAP_TYPE__ns1__SetDPAddresses (293)
#endif

/* _ns1__GetDPAddressesResponse has binding name '_ns1__GetDPAddressesResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetDPAddressesResponse
#define SOAP_TYPE__ns1__GetDPAddressesResponse (292)
#endif

/* _ns1__GetDPAddresses has binding name '_ns1__GetDPAddresses' for type '' */
#ifndef SOAP_TYPE__ns1__GetDPAddresses
#define SOAP_TYPE__ns1__GetDPAddresses (291)
#endif

/* _ns1__SetRemoteDiscoveryModeResponse has binding name '_ns1__SetRemoteDiscoveryModeResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetRemoteDiscoveryModeResponse
#define SOAP_TYPE__ns1__SetRemoteDiscoveryModeResponse (290)
#endif

/* _ns1__SetRemoteDiscoveryMode has binding name '_ns1__SetRemoteDiscoveryMode' for type '' */
#ifndef SOAP_TYPE__ns1__SetRemoteDiscoveryMode
#define SOAP_TYPE__ns1__SetRemoteDiscoveryMode (289)
#endif

/* _ns1__GetRemoteDiscoveryModeResponse has binding name '_ns1__GetRemoteDiscoveryModeResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetRemoteDiscoveryModeResponse
#define SOAP_TYPE__ns1__GetRemoteDiscoveryModeResponse (288)
#endif

/* _ns1__GetRemoteDiscoveryMode has binding name '_ns1__GetRemoteDiscoveryMode' for type '' */
#ifndef SOAP_TYPE__ns1__GetRemoteDiscoveryMode
#define SOAP_TYPE__ns1__GetRemoteDiscoveryMode (287)
#endif

/* _ns1__SetDiscoveryModeResponse has binding name '_ns1__SetDiscoveryModeResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetDiscoveryModeResponse
#define SOAP_TYPE__ns1__SetDiscoveryModeResponse (286)
#endif

/* _ns1__SetDiscoveryMode has binding name '_ns1__SetDiscoveryMode' for type '' */
#ifndef SOAP_TYPE__ns1__SetDiscoveryMode
#define SOAP_TYPE__ns1__SetDiscoveryMode (285)
#endif

/* _ns1__GetDiscoveryModeResponse has binding name '_ns1__GetDiscoveryModeResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetDiscoveryModeResponse
#define SOAP_TYPE__ns1__GetDiscoveryModeResponse (284)
#endif

/* _ns1__GetDiscoveryMode has binding name '_ns1__GetDiscoveryMode' for type '' */
#ifndef SOAP_TYPE__ns1__GetDiscoveryMode
#define SOAP_TYPE__ns1__GetDiscoveryMode (283)
#endif

/* _ns1__RemoveScopesResponse has binding name '_ns1__RemoveScopesResponse' for type '' */
#ifndef SOAP_TYPE__ns1__RemoveScopesResponse
#define SOAP_TYPE__ns1__RemoveScopesResponse (282)
#endif

/* _ns1__RemoveScopes has binding name '_ns1__RemoveScopes' for type '' */
#ifndef SOAP_TYPE__ns1__RemoveScopes
#define SOAP_TYPE__ns1__RemoveScopes (281)
#endif

/* _ns1__AddScopesResponse has binding name '_ns1__AddScopesResponse' for type '' */
#ifndef SOAP_TYPE__ns1__AddScopesResponse
#define SOAP_TYPE__ns1__AddScopesResponse (280)
#endif

/* _ns1__AddScopes has binding name '_ns1__AddScopes' for type '' */
#ifndef SOAP_TYPE__ns1__AddScopes
#define SOAP_TYPE__ns1__AddScopes (279)
#endif

/* _ns1__SetScopesResponse has binding name '_ns1__SetScopesResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetScopesResponse
#define SOAP_TYPE__ns1__SetScopesResponse (278)
#endif

/* _ns1__SetScopes has binding name '_ns1__SetScopes' for type '' */
#ifndef SOAP_TYPE__ns1__SetScopes
#define SOAP_TYPE__ns1__SetScopes (277)
#endif

/* _ns1__GetScopesResponse has binding name '_ns1__GetScopesResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetScopesResponse
#define SOAP_TYPE__ns1__GetScopesResponse (276)
#endif

/* _ns1__GetScopes has binding name '_ns1__GetScopes' for type '' */
#ifndef SOAP_TYPE__ns1__GetScopes
#define SOAP_TYPE__ns1__GetScopes (275)
#endif

/* _ns1__GetSystemLogResponse has binding name '_ns1__GetSystemLogResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetSystemLogResponse
#define SOAP_TYPE__ns1__GetSystemLogResponse (274)
#endif

/* _ns1__GetSystemLog has binding name '_ns1__GetSystemLog' for type '' */
#ifndef SOAP_TYPE__ns1__GetSystemLog
#define SOAP_TYPE__ns1__GetSystemLog (273)
#endif

/* _ns1__GetSystemSupportInformationResponse has binding name '_ns1__GetSystemSupportInformationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetSystemSupportInformationResponse
#define SOAP_TYPE__ns1__GetSystemSupportInformationResponse (272)
#endif

/* _ns1__GetSystemSupportInformation has binding name '_ns1__GetSystemSupportInformation' for type '' */
#ifndef SOAP_TYPE__ns1__GetSystemSupportInformation
#define SOAP_TYPE__ns1__GetSystemSupportInformation (271)
#endif

/* _ns1__GetSystemBackupResponse has binding name '_ns1__GetSystemBackupResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetSystemBackupResponse
#define SOAP_TYPE__ns1__GetSystemBackupResponse (270)
#endif

/* _ns1__GetSystemBackup has binding name '_ns1__GetSystemBackup' for type '' */
#ifndef SOAP_TYPE__ns1__GetSystemBackup
#define SOAP_TYPE__ns1__GetSystemBackup (269)
#endif

/* _ns1__RestoreSystemResponse has binding name '_ns1__RestoreSystemResponse' for type '' */
#ifndef SOAP_TYPE__ns1__RestoreSystemResponse
#define SOAP_TYPE__ns1__RestoreSystemResponse (268)
#endif

/* _ns1__RestoreSystem has binding name '_ns1__RestoreSystem' for type '' */
#ifndef SOAP_TYPE__ns1__RestoreSystem
#define SOAP_TYPE__ns1__RestoreSystem (267)
#endif

/* _ns1__SystemRebootResponse has binding name '_ns1__SystemRebootResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SystemRebootResponse
#define SOAP_TYPE__ns1__SystemRebootResponse (266)
#endif

/* _ns1__SystemReboot has binding name '_ns1__SystemReboot' for type '' */
#ifndef SOAP_TYPE__ns1__SystemReboot
#define SOAP_TYPE__ns1__SystemReboot (265)
#endif

/* _ns1__UpgradeSystemFirmwareResponse has binding name '_ns1__UpgradeSystemFirmwareResponse' for type '' */
#ifndef SOAP_TYPE__ns1__UpgradeSystemFirmwareResponse
#define SOAP_TYPE__ns1__UpgradeSystemFirmwareResponse (264)
#endif

/* _ns1__UpgradeSystemFirmware has binding name '_ns1__UpgradeSystemFirmware' for type '' */
#ifndef SOAP_TYPE__ns1__UpgradeSystemFirmware
#define SOAP_TYPE__ns1__UpgradeSystemFirmware (263)
#endif

/* _ns1__SetSystemFactoryDefaultResponse has binding name '_ns1__SetSystemFactoryDefaultResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetSystemFactoryDefaultResponse
#define SOAP_TYPE__ns1__SetSystemFactoryDefaultResponse (262)
#endif

/* _ns1__SetSystemFactoryDefault has binding name '_ns1__SetSystemFactoryDefault' for type '' */
#ifndef SOAP_TYPE__ns1__SetSystemFactoryDefault
#define SOAP_TYPE__ns1__SetSystemFactoryDefault (261)
#endif

/* _ns1__GetSystemDateAndTimeResponse has binding name '_ns1__GetSystemDateAndTimeResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetSystemDateAndTimeResponse
#define SOAP_TYPE__ns1__GetSystemDateAndTimeResponse (260)
#endif

/* _ns1__GetSystemDateAndTime has binding name '_ns1__GetSystemDateAndTime' for type '' */
#ifndef SOAP_TYPE__ns1__GetSystemDateAndTime
#define SOAP_TYPE__ns1__GetSystemDateAndTime (259)
#endif

/* _ns1__SetSystemDateAndTimeResponse has binding name '_ns1__SetSystemDateAndTimeResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetSystemDateAndTimeResponse
#define SOAP_TYPE__ns1__SetSystemDateAndTimeResponse (258)
#endif

/* _ns1__SetSystemDateAndTime has binding name '_ns1__SetSystemDateAndTime' for type '' */
#ifndef SOAP_TYPE__ns1__SetSystemDateAndTime
#define SOAP_TYPE__ns1__SetSystemDateAndTime (257)
#endif

/* _ns1__GetDeviceInformationResponse has binding name '_ns1__GetDeviceInformationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetDeviceInformationResponse
#define SOAP_TYPE__ns1__GetDeviceInformationResponse (256)
#endif

/* _ns1__GetDeviceInformation has binding name '_ns1__GetDeviceInformation' for type '' */
#ifndef SOAP_TYPE__ns1__GetDeviceInformation
#define SOAP_TYPE__ns1__GetDeviceInformation (255)
#endif

/* _ns1__GetServiceCapabilitiesResponse has binding name '_ns1__GetServiceCapabilitiesResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetServiceCapabilitiesResponse
#define SOAP_TYPE__ns1__GetServiceCapabilitiesResponse (254)
#endif

/* _ns1__GetServiceCapabilities has binding name '_ns1__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE__ns1__GetServiceCapabilities
#define SOAP_TYPE__ns1__GetServiceCapabilities (253)
#endif

/* _ns1__GetServicesResponse has binding name '_ns1__GetServicesResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetServicesResponse
#define SOAP_TYPE__ns1__GetServicesResponse (252)
#endif

/* _ns1__GetServices has binding name '_ns1__GetServices' for type '' */
#ifndef SOAP_TYPE__ns1__GetServices
#define SOAP_TYPE__ns1__GetServices (251)
#endif

/* ns1__StorageConfiguration has binding name 'ns1__StorageConfiguration' for type 'ns1:StorageConfiguration' */
#ifndef SOAP_TYPE_ns1__StorageConfiguration
#define SOAP_TYPE_ns1__StorageConfiguration (250)
#endif

/* ns1__StorageConfigurationData has binding name 'ns1__StorageConfigurationData' for type 'ns1:StorageConfigurationData' */
#ifndef SOAP_TYPE_ns1__StorageConfigurationData
#define SOAP_TYPE_ns1__StorageConfigurationData (249)
#endif

/* ns1__UserCredential has binding name 'ns1__UserCredential' for type 'ns1:UserCredential' */
#ifndef SOAP_TYPE_ns1__UserCredential
#define SOAP_TYPE_ns1__UserCredential (248)
#endif

/* ns1__MiscCapabilities has binding name 'ns1__MiscCapabilities' for type 'ns1:MiscCapabilities' */
#ifndef SOAP_TYPE_ns1__MiscCapabilities
#define SOAP_TYPE_ns1__MiscCapabilities (247)
#endif

/* ns1__SystemCapabilities has binding name 'ns1__SystemCapabilities' for type 'ns1:SystemCapabilities' */
#ifndef SOAP_TYPE_ns1__SystemCapabilities
#define SOAP_TYPE_ns1__SystemCapabilities (246)
#endif

/* ns1__SecurityCapabilities has binding name 'ns1__SecurityCapabilities' for type 'ns1:SecurityCapabilities' */
#ifndef SOAP_TYPE_ns1__SecurityCapabilities
#define SOAP_TYPE_ns1__SecurityCapabilities (245)
#endif

/* ns1__NetworkCapabilities has binding name 'ns1__NetworkCapabilities' for type 'ns1:NetworkCapabilities' */
#ifndef SOAP_TYPE_ns1__NetworkCapabilities
#define SOAP_TYPE_ns1__NetworkCapabilities (244)
#endif

/* ns1__DeviceServiceCapabilities has binding name 'ns1__DeviceServiceCapabilities' for type 'ns1:DeviceServiceCapabilities' */
#ifndef SOAP_TYPE_ns1__DeviceServiceCapabilities
#define SOAP_TYPE_ns1__DeviceServiceCapabilities (243)
#endif

/* ns1__Service has binding name 'ns1__Service' for type 'ns1:Service' */
#ifndef SOAP_TYPE_ns1__Service
#define SOAP_TYPE_ns1__Service (242)
#endif

/* _xml__lang has binding name '_xml__lang' for type '' */
#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (241)
#endif

/* _xmime__contentType has binding name '_xmime__contentType' for type '' */
#ifndef SOAP_TYPE__xmime__contentType
#define SOAP_TYPE__xmime__contentType (240)
#endif

/* xsd__token has binding name 'xsd__token' for type 'xsd:token' */
#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (239)
#endif

/* xsd__nonNegativeInteger has binding name 'xsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (238)
#endif

/* xsd__integer has binding name 'xsd__integer' for type 'xsd:integer' */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (237)
#endif

/* xsd__duration has binding name 'xsd__duration' for type 'xsd:duration' */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (236)
#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (235)
#endif

/* xsd__anySimpleType has binding name 'xsd__anySimpleType' for type 'xsd:anySimpleType' */
#ifndef SOAP_TYPE_xsd__anySimpleType
#define SOAP_TYPE_xsd__anySimpleType (234)
#endif

/* xsd__NCName has binding name 'xsd__NCName' for type 'xsd:NCName' */
#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (233)
#endif

/* SOAP_ENV__Envelope has binding name 'SOAP_ENV__Envelope' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Envelope
#define SOAP_TYPE_SOAP_ENV__Envelope (232)
#endif

/* xsd__hexBinary has binding name 'xsd__hexBinary' for type 'xsd:hexBinary' */
#ifndef SOAP_TYPE_xsd__hexBinary
#define SOAP_TYPE_xsd__hexBinary (231)
#endif

/* xsd__base64Binary has binding name 'xsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (226)
#endif

/* xsd__QName has binding name 'xsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (225)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (224)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (3294)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (3291)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (3289)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (2011)
#endif

/* xsd__anyAttribute has binding name 'xsd__anyAttribute' for type 'xsd:anyAttribute' */
#ifndef SOAP_TYPE_xsd__anyAttribute
#define SOAP_TYPE_xsd__anyAttribute (223)
#endif

/* xsd__anyType has binding name 'xsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (221)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (214)
#endif

/* struct _wsse__Security has binding name '_wsse__Security' for type '' */
#ifndef SOAP_TYPE__wsse__Security
#define SOAP_TYPE__wsse__Security (208)
#endif

/* struct saml2__AttributeType has binding name 'saml2__AttributeType' for type 'saml2:AttributeType' */
#ifndef SOAP_TYPE_saml2__AttributeType
#define SOAP_TYPE_saml2__AttributeType (171)
#endif

/* struct saml2__AttributeStatementType has binding name 'saml2__AttributeStatementType' for type 'saml2:AttributeStatementType' */
#ifndef SOAP_TYPE_saml2__AttributeStatementType
#define SOAP_TYPE_saml2__AttributeStatementType (170)
#endif

/* struct saml2__EvidenceType has binding name 'saml2__EvidenceType' for type 'saml2:EvidenceType' */
#ifndef SOAP_TYPE_saml2__EvidenceType
#define SOAP_TYPE_saml2__EvidenceType (169)
#endif

/* struct saml2__ActionType has binding name 'saml2__ActionType' for type 'saml2:ActionType' */
#ifndef SOAP_TYPE_saml2__ActionType
#define SOAP_TYPE_saml2__ActionType (168)
#endif

/* struct saml2__AuthzDecisionStatementType has binding name 'saml2__AuthzDecisionStatementType' for type 'saml2:AuthzDecisionStatementType' */
#ifndef SOAP_TYPE_saml2__AuthzDecisionStatementType
#define SOAP_TYPE_saml2__AuthzDecisionStatementType (167)
#endif

/* struct saml2__AuthnContextType has binding name 'saml2__AuthnContextType' for type 'saml2:AuthnContextType' */
#ifndef SOAP_TYPE_saml2__AuthnContextType
#define SOAP_TYPE_saml2__AuthnContextType (166)
#endif

/* struct saml2__SubjectLocalityType has binding name 'saml2__SubjectLocalityType' for type 'saml2:SubjectLocalityType' */
#ifndef SOAP_TYPE_saml2__SubjectLocalityType
#define SOAP_TYPE_saml2__SubjectLocalityType (165)
#endif

/* struct saml2__AuthnStatementType has binding name 'saml2__AuthnStatementType' for type 'saml2:AuthnStatementType' */
#ifndef SOAP_TYPE_saml2__AuthnStatementType
#define SOAP_TYPE_saml2__AuthnStatementType (164)
#endif

/* struct saml2__StatementAbstractType has binding name 'saml2__StatementAbstractType' for type 'saml2:StatementAbstractType' */
#ifndef SOAP_TYPE_saml2__StatementAbstractType
#define SOAP_TYPE_saml2__StatementAbstractType (163)
#endif

/* struct saml2__AdviceType has binding name 'saml2__AdviceType' for type 'saml2:AdviceType' */
#ifndef SOAP_TYPE_saml2__AdviceType
#define SOAP_TYPE_saml2__AdviceType (162)
#endif

/* struct saml2__ProxyRestrictionType has binding name 'saml2__ProxyRestrictionType' for type 'saml2:ProxyRestrictionType' */
#ifndef SOAP_TYPE_saml2__ProxyRestrictionType
#define SOAP_TYPE_saml2__ProxyRestrictionType (161)
#endif

/* struct saml2__OneTimeUseType has binding name 'saml2__OneTimeUseType' for type 'saml2:OneTimeUseType' */
#ifndef SOAP_TYPE_saml2__OneTimeUseType
#define SOAP_TYPE_saml2__OneTimeUseType (160)
#endif

/* struct saml2__AudienceRestrictionType has binding name 'saml2__AudienceRestrictionType' for type 'saml2:AudienceRestrictionType' */
#ifndef SOAP_TYPE_saml2__AudienceRestrictionType
#define SOAP_TYPE_saml2__AudienceRestrictionType (159)
#endif

/* struct saml2__ConditionAbstractType has binding name 'saml2__ConditionAbstractType' for type 'saml2:ConditionAbstractType' */
#ifndef SOAP_TYPE_saml2__ConditionAbstractType
#define SOAP_TYPE_saml2__ConditionAbstractType (158)
#endif

/* struct saml2__ConditionsType has binding name 'saml2__ConditionsType' for type 'saml2:ConditionsType' */
#ifndef SOAP_TYPE_saml2__ConditionsType
#define SOAP_TYPE_saml2__ConditionsType (157)
#endif

/* struct saml2__KeyInfoConfirmationDataType has binding name 'saml2__KeyInfoConfirmationDataType' for type 'saml2:KeyInfoConfirmationDataType' */
#ifndef SOAP_TYPE_saml2__KeyInfoConfirmationDataType
#define SOAP_TYPE_saml2__KeyInfoConfirmationDataType (156)
#endif

/* struct saml2__SubjectConfirmationDataType has binding name 'saml2__SubjectConfirmationDataType' for type 'saml2:SubjectConfirmationDataType' */
#ifndef SOAP_TYPE_saml2__SubjectConfirmationDataType
#define SOAP_TYPE_saml2__SubjectConfirmationDataType (155)
#endif

/* struct saml2__SubjectConfirmationType has binding name 'saml2__SubjectConfirmationType' for type 'saml2:SubjectConfirmationType' */
#ifndef SOAP_TYPE_saml2__SubjectConfirmationType
#define SOAP_TYPE_saml2__SubjectConfirmationType (154)
#endif

/* struct saml2__SubjectType has binding name 'saml2__SubjectType' for type 'saml2:SubjectType' */
#ifndef SOAP_TYPE_saml2__SubjectType
#define SOAP_TYPE_saml2__SubjectType (153)
#endif

/* struct saml2__AssertionType has binding name 'saml2__AssertionType' for type 'saml2:AssertionType' */
#ifndef SOAP_TYPE_saml2__AssertionType
#define SOAP_TYPE_saml2__AssertionType (152)
#endif

/* struct saml2__EncryptedElementType has binding name 'saml2__EncryptedElementType' for type 'saml2:EncryptedElementType' */
#ifndef SOAP_TYPE_saml2__EncryptedElementType
#define SOAP_TYPE_saml2__EncryptedElementType (151)
#endif

/* struct saml2__NameIDType has binding name 'saml2__NameIDType' for type 'saml2:NameIDType' */
#ifndef SOAP_TYPE_saml2__NameIDType
#define SOAP_TYPE_saml2__NameIDType (150)
#endif

/* struct saml2__BaseIDAbstractType has binding name 'saml2__BaseIDAbstractType' for type 'saml2:BaseIDAbstractType' */
#ifndef SOAP_TYPE_saml2__BaseIDAbstractType
#define SOAP_TYPE_saml2__BaseIDAbstractType (149)
#endif

/* struct saml1__AttributeType has binding name 'saml1__AttributeType' for type 'saml1:AttributeType' */
#ifndef SOAP_TYPE_saml1__AttributeType
#define SOAP_TYPE_saml1__AttributeType (115)
#endif

/* struct saml1__AttributeDesignatorType has binding name 'saml1__AttributeDesignatorType' for type 'saml1:AttributeDesignatorType' */
#ifndef SOAP_TYPE_saml1__AttributeDesignatorType
#define SOAP_TYPE_saml1__AttributeDesignatorType (114)
#endif

/* struct saml1__AttributeStatementType has binding name 'saml1__AttributeStatementType' for type 'saml1:AttributeStatementType' */
#ifndef SOAP_TYPE_saml1__AttributeStatementType
#define SOAP_TYPE_saml1__AttributeStatementType (113)
#endif

/* struct saml1__EvidenceType has binding name 'saml1__EvidenceType' for type 'saml1:EvidenceType' */
#ifndef SOAP_TYPE_saml1__EvidenceType
#define SOAP_TYPE_saml1__EvidenceType (112)
#endif

/* struct saml1__ActionType has binding name 'saml1__ActionType' for type 'saml1:ActionType' */
#ifndef SOAP_TYPE_saml1__ActionType
#define SOAP_TYPE_saml1__ActionType (111)
#endif

/* struct saml1__AuthorizationDecisionStatementType has binding name 'saml1__AuthorizationDecisionStatementType' for type 'saml1:AuthorizationDecisionStatementType' */
#ifndef SOAP_TYPE_saml1__AuthorizationDecisionStatementType
#define SOAP_TYPE_saml1__AuthorizationDecisionStatementType (110)
#endif

/* struct saml1__AuthorityBindingType has binding name 'saml1__AuthorityBindingType' for type 'saml1:AuthorityBindingType' */
#ifndef SOAP_TYPE_saml1__AuthorityBindingType
#define SOAP_TYPE_saml1__AuthorityBindingType (109)
#endif

/* struct saml1__SubjectLocalityType has binding name 'saml1__SubjectLocalityType' for type 'saml1:SubjectLocalityType' */
#ifndef SOAP_TYPE_saml1__SubjectLocalityType
#define SOAP_TYPE_saml1__SubjectLocalityType (108)
#endif

/* struct saml1__AuthenticationStatementType has binding name 'saml1__AuthenticationStatementType' for type 'saml1:AuthenticationStatementType' */
#ifndef SOAP_TYPE_saml1__AuthenticationStatementType
#define SOAP_TYPE_saml1__AuthenticationStatementType (107)
#endif

/* struct saml1__SubjectConfirmationType has binding name 'saml1__SubjectConfirmationType' for type 'saml1:SubjectConfirmationType' */
#ifndef SOAP_TYPE_saml1__SubjectConfirmationType
#define SOAP_TYPE_saml1__SubjectConfirmationType (106)
#endif

/* struct saml1__NameIdentifierType has binding name 'saml1__NameIdentifierType' for type 'saml1:NameIdentifierType' */
#ifndef SOAP_TYPE_saml1__NameIdentifierType
#define SOAP_TYPE_saml1__NameIdentifierType (105)
#endif

/* struct saml1__SubjectType has binding name 'saml1__SubjectType' for type 'saml1:SubjectType' */
#ifndef SOAP_TYPE_saml1__SubjectType
#define SOAP_TYPE_saml1__SubjectType (104)
#endif

/* struct saml1__SubjectStatementAbstractType has binding name 'saml1__SubjectStatementAbstractType' for type 'saml1:SubjectStatementAbstractType' */
#ifndef SOAP_TYPE_saml1__SubjectStatementAbstractType
#define SOAP_TYPE_saml1__SubjectStatementAbstractType (103)
#endif

/* struct saml1__StatementAbstractType has binding name 'saml1__StatementAbstractType' for type 'saml1:StatementAbstractType' */
#ifndef SOAP_TYPE_saml1__StatementAbstractType
#define SOAP_TYPE_saml1__StatementAbstractType (102)
#endif

/* struct saml1__AdviceType has binding name 'saml1__AdviceType' for type 'saml1:AdviceType' */
#ifndef SOAP_TYPE_saml1__AdviceType
#define SOAP_TYPE_saml1__AdviceType (101)
#endif

/* struct saml1__DoNotCacheConditionType has binding name 'saml1__DoNotCacheConditionType' for type 'saml1:DoNotCacheConditionType' */
#ifndef SOAP_TYPE_saml1__DoNotCacheConditionType
#define SOAP_TYPE_saml1__DoNotCacheConditionType (100)
#endif

/* struct saml1__AudienceRestrictionConditionType has binding name 'saml1__AudienceRestrictionConditionType' for type 'saml1:AudienceRestrictionConditionType' */
#ifndef SOAP_TYPE_saml1__AudienceRestrictionConditionType
#define SOAP_TYPE_saml1__AudienceRestrictionConditionType (99)
#endif

/* struct saml1__ConditionAbstractType has binding name 'saml1__ConditionAbstractType' for type 'saml1:ConditionAbstractType' */
#ifndef SOAP_TYPE_saml1__ConditionAbstractType
#define SOAP_TYPE_saml1__ConditionAbstractType (98)
#endif

/* struct saml1__ConditionsType has binding name 'saml1__ConditionsType' for type 'saml1:ConditionsType' */
#ifndef SOAP_TYPE_saml1__ConditionsType
#define SOAP_TYPE_saml1__ConditionsType (97)
#endif

/* struct saml1__AssertionType has binding name 'saml1__AssertionType' for type 'saml1:AssertionType' */
#ifndef SOAP_TYPE_saml1__AssertionType
#define SOAP_TYPE_saml1__AssertionType (96)
#endif

/* struct wsc__PropertiesType has binding name 'wsc__PropertiesType' for type 'wsc:PropertiesType' */
#ifndef SOAP_TYPE_wsc__PropertiesType
#define SOAP_TYPE_wsc__PropertiesType (89)
#endif

/* struct wsc__DerivedKeyTokenType has binding name 'wsc__DerivedKeyTokenType' for type 'wsc:DerivedKeyTokenType' */
#ifndef SOAP_TYPE_wsc__DerivedKeyTokenType
#define SOAP_TYPE_wsc__DerivedKeyTokenType (88)
#endif

/* struct wsc__SecurityContextTokenType has binding name 'wsc__SecurityContextTokenType' for type 'wsc:SecurityContextTokenType' */
#ifndef SOAP_TYPE_wsc__SecurityContextTokenType
#define SOAP_TYPE_wsc__SecurityContextTokenType (87)
#endif

/* struct _xenc__ReferenceList has binding name '_xenc__ReferenceList' for type '' */
#ifndef SOAP_TYPE__xenc__ReferenceList
#define SOAP_TYPE__xenc__ReferenceList (73)
#endif

/* struct xenc__EncryptionPropertyType has binding name 'xenc__EncryptionPropertyType' for type 'xenc:EncryptionPropertyType' */
#ifndef SOAP_TYPE_xenc__EncryptionPropertyType
#define SOAP_TYPE_xenc__EncryptionPropertyType (72)
#endif

/* struct xenc__EncryptionPropertiesType has binding name 'xenc__EncryptionPropertiesType' for type 'xenc:EncryptionPropertiesType' */
#ifndef SOAP_TYPE_xenc__EncryptionPropertiesType
#define SOAP_TYPE_xenc__EncryptionPropertiesType (71)
#endif

/* struct xenc__ReferenceType has binding name 'xenc__ReferenceType' for type 'xenc:ReferenceType' */
#ifndef SOAP_TYPE_xenc__ReferenceType
#define SOAP_TYPE_xenc__ReferenceType (70)
#endif

/* struct xenc__AgreementMethodType has binding name 'xenc__AgreementMethodType' for type 'xenc:AgreementMethodType' */
#ifndef SOAP_TYPE_xenc__AgreementMethodType
#define SOAP_TYPE_xenc__AgreementMethodType (69)
#endif

/* struct xenc__EncryptedKeyType has binding name 'xenc__EncryptedKeyType' for type 'xenc:EncryptedKeyType' */
#ifndef SOAP_TYPE_xenc__EncryptedKeyType
#define SOAP_TYPE_xenc__EncryptedKeyType (68)
#endif

/* struct xenc__EncryptedDataType has binding name 'xenc__EncryptedDataType' for type 'xenc:EncryptedDataType' */
#ifndef SOAP_TYPE_xenc__EncryptedDataType
#define SOAP_TYPE_xenc__EncryptedDataType (67)
#endif

/* struct xenc__TransformsType has binding name 'xenc__TransformsType' for type 'xenc:TransformsType' */
#ifndef SOAP_TYPE_xenc__TransformsType
#define SOAP_TYPE_xenc__TransformsType (66)
#endif

/* struct xenc__CipherReferenceType has binding name 'xenc__CipherReferenceType' for type 'xenc:CipherReferenceType' */
#ifndef SOAP_TYPE_xenc__CipherReferenceType
#define SOAP_TYPE_xenc__CipherReferenceType (65)
#endif

/* struct xenc__CipherDataType has binding name 'xenc__CipherDataType' for type 'xenc:CipherDataType' */
#ifndef SOAP_TYPE_xenc__CipherDataType
#define SOAP_TYPE_xenc__CipherDataType (64)
#endif

/* struct xenc__EncryptionMethodType has binding name 'xenc__EncryptionMethodType' for type 'xenc:EncryptionMethodType' */
#ifndef SOAP_TYPE_xenc__EncryptionMethodType
#define SOAP_TYPE_xenc__EncryptionMethodType (63)
#endif

/* struct xenc__EncryptedType has binding name 'xenc__EncryptedType' for type 'xenc:EncryptedType' */
#ifndef SOAP_TYPE_xenc__EncryptedType
#define SOAP_TYPE_xenc__EncryptedType (62)
#endif

/* struct ds__RSAKeyValueType has binding name 'ds__RSAKeyValueType' for type 'ds:RSAKeyValueType' */
#ifndef SOAP_TYPE_ds__RSAKeyValueType
#define SOAP_TYPE_ds__RSAKeyValueType (50)
#endif

/* struct ds__DSAKeyValueType has binding name 'ds__DSAKeyValueType' for type 'ds:DSAKeyValueType' */
#ifndef SOAP_TYPE_ds__DSAKeyValueType
#define SOAP_TYPE_ds__DSAKeyValueType (49)
#endif

/* struct ds__X509IssuerSerialType has binding name 'ds__X509IssuerSerialType' for type 'ds:X509IssuerSerialType' */
#ifndef SOAP_TYPE_ds__X509IssuerSerialType
#define SOAP_TYPE_ds__X509IssuerSerialType (48)
#endif

/* _ds__KeyInfo has binding name '_ds__KeyInfo' for type '' */
#ifndef SOAP_TYPE__ds__KeyInfo
#define SOAP_TYPE__ds__KeyInfo (47)
#endif

/* struct ds__RetrievalMethodType has binding name 'ds__RetrievalMethodType' for type 'ds:RetrievalMethodType' */
#ifndef SOAP_TYPE_ds__RetrievalMethodType
#define SOAP_TYPE_ds__RetrievalMethodType (44)
#endif

/* struct ds__KeyValueType has binding name 'ds__KeyValueType' for type 'ds:KeyValueType' */
#ifndef SOAP_TYPE_ds__KeyValueType
#define SOAP_TYPE_ds__KeyValueType (42)
#endif

/* struct ds__DigestMethodType has binding name 'ds__DigestMethodType' for type 'ds:DigestMethodType' */
#ifndef SOAP_TYPE_ds__DigestMethodType
#define SOAP_TYPE_ds__DigestMethodType (41)
#endif

/* _ds__Transform has binding name '_ds__Transform' for type '' */
#ifndef SOAP_TYPE__ds__Transform
#define SOAP_TYPE__ds__Transform (40)
#endif

/* struct ds__TransformType has binding name 'ds__TransformType' for type 'ds:TransformType' */
#ifndef SOAP_TYPE_ds__TransformType
#define SOAP_TYPE_ds__TransformType (38)
#endif

/* struct _c14n__InclusiveNamespaces has binding name '_c14n__InclusiveNamespaces' for type '' */
#ifndef SOAP_TYPE__c14n__InclusiveNamespaces
#define SOAP_TYPE__c14n__InclusiveNamespaces (37)
#endif

/* struct ds__TransformsType has binding name 'ds__TransformsType' for type 'ds:TransformsType' */
#ifndef SOAP_TYPE_ds__TransformsType
#define SOAP_TYPE_ds__TransformsType (36)
#endif

/* struct ds__ReferenceType has binding name 'ds__ReferenceType' for type 'ds:ReferenceType' */
#ifndef SOAP_TYPE_ds__ReferenceType
#define SOAP_TYPE_ds__ReferenceType (35)
#endif

/* struct ds__SignatureMethodType has binding name 'ds__SignatureMethodType' for type 'ds:SignatureMethodType' */
#ifndef SOAP_TYPE_ds__SignatureMethodType
#define SOAP_TYPE_ds__SignatureMethodType (34)
#endif

/* struct ds__CanonicalizationMethodType has binding name 'ds__CanonicalizationMethodType' for type 'ds:CanonicalizationMethodType' */
#ifndef SOAP_TYPE_ds__CanonicalizationMethodType
#define SOAP_TYPE_ds__CanonicalizationMethodType (33)
#endif

/* _ds__Signature has binding name '_ds__Signature' for type '' */
#ifndef SOAP_TYPE__ds__Signature
#define SOAP_TYPE__ds__Signature (32)
#endif

/* struct ds__KeyInfoType has binding name 'ds__KeyInfoType' for type 'ds:KeyInfoType' */
#ifndef SOAP_TYPE_ds__KeyInfoType
#define SOAP_TYPE_ds__KeyInfoType (30)
#endif

/* struct ds__SignedInfoType has binding name 'ds__SignedInfoType' for type 'ds:SignedInfoType' */
#ifndef SOAP_TYPE_ds__SignedInfoType
#define SOAP_TYPE_ds__SignedInfoType (28)
#endif

/* struct ds__SignatureType has binding name 'ds__SignatureType' for type 'ds:SignatureType' */
#ifndef SOAP_TYPE_ds__SignatureType
#define SOAP_TYPE_ds__SignatureType (27)
#endif

/* struct ds__X509DataType has binding name 'ds__X509DataType' for type 'ds:X509DataType' */
#ifndef SOAP_TYPE_ds__X509DataType
#define SOAP_TYPE_ds__X509DataType (24)
#endif

/* struct _wsse__SecurityTokenReference has binding name '_wsse__SecurityTokenReference' for type '' */
#ifndef SOAP_TYPE__wsse__SecurityTokenReference
#define SOAP_TYPE__wsse__SecurityTokenReference (20)
#endif

/* struct _wsse__KeyIdentifier has binding name '_wsse__KeyIdentifier' for type '' */
#ifndef SOAP_TYPE__wsse__KeyIdentifier
#define SOAP_TYPE__wsse__KeyIdentifier (19)
#endif

/* struct _wsse__Embedded has binding name '_wsse__Embedded' for type '' */
#ifndef SOAP_TYPE__wsse__Embedded
#define SOAP_TYPE__wsse__Embedded (18)
#endif

/* struct _wsse__Reference has binding name '_wsse__Reference' for type '' */
#ifndef SOAP_TYPE__wsse__Reference
#define SOAP_TYPE__wsse__Reference (17)
#endif

/* struct _wsse__BinarySecurityToken has binding name '_wsse__BinarySecurityToken' for type '' */
#ifndef SOAP_TYPE__wsse__BinarySecurityToken
#define SOAP_TYPE__wsse__BinarySecurityToken (16)
#endif

/* struct _wsse__Password has binding name '_wsse__Password' for type '' */
#ifndef SOAP_TYPE__wsse__Password
#define SOAP_TYPE__wsse__Password (13)
#endif

/* struct _wsse__UsernameToken has binding name '_wsse__UsernameToken' for type '' */
#ifndef SOAP_TYPE__wsse__UsernameToken
#define SOAP_TYPE__wsse__UsernameToken (12)
#endif

/* struct wsse__EncodedString has binding name 'wsse__EncodedString' for type 'wsse:EncodedString' */
#ifndef SOAP_TYPE_wsse__EncodedString
#define SOAP_TYPE_wsse__EncodedString (10)
#endif

/* struct _wsu__Timestamp has binding name '_wsu__Timestamp' for type '' */
#ifndef SOAP_TYPE__wsu__Timestamp
#define SOAP_TYPE__wsu__Timestamp (9)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (3296)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (3295)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (3290)
#endif

/* _ns9__DeleteOSD * has binding name 'PointerTo_ns9__DeleteOSD' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__DeleteOSD
#define SOAP_TYPE_PointerTo_ns9__DeleteOSD (3285)
#endif

/* _ns9__CreateOSD * has binding name 'PointerTo_ns9__CreateOSD' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__CreateOSD
#define SOAP_TYPE_PointerTo_ns9__CreateOSD (3281)
#endif

/* _ns9__SetOSD * has binding name 'PointerTo_ns9__SetOSD' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__SetOSD
#define SOAP_TYPE_PointerTo_ns9__SetOSD (3277)
#endif

/* _ns9__GetOSDOptions * has binding name 'PointerTo_ns9__GetOSDOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetOSDOptions
#define SOAP_TYPE_PointerTo_ns9__GetOSDOptions (3273)
#endif

/* _ns9__GetOSD * has binding name 'PointerTo_ns9__GetOSD' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetOSD
#define SOAP_TYPE_PointerTo_ns9__GetOSD (3269)
#endif

/* _ns9__GetOSDs * has binding name 'PointerTo_ns9__GetOSDs' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetOSDs
#define SOAP_TYPE_PointerTo_ns9__GetOSDs (3265)
#endif

/* _ns9__SetVideoSourceMode * has binding name 'PointerTo_ns9__SetVideoSourceMode' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__SetVideoSourceMode
#define SOAP_TYPE_PointerTo_ns9__SetVideoSourceMode (3261)
#endif

/* _ns9__GetVideoSourceModes * has binding name 'PointerTo_ns9__GetVideoSourceModes' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetVideoSourceModes
#define SOAP_TYPE_PointerTo_ns9__GetVideoSourceModes (3257)
#endif

/* _ns9__GetSnapshotUri * has binding name 'PointerTo_ns9__GetSnapshotUri' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetSnapshotUri
#define SOAP_TYPE_PointerTo_ns9__GetSnapshotUri (3253)
#endif

/* _ns9__SetSynchronizationPoint * has binding name 'PointerTo_ns9__SetSynchronizationPoint' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__SetSynchronizationPoint
#define SOAP_TYPE_PointerTo_ns9__SetSynchronizationPoint (3249)
#endif

/* _ns9__StopMulticastStreaming * has binding name 'PointerTo_ns9__StopMulticastStreaming' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__StopMulticastStreaming
#define SOAP_TYPE_PointerTo_ns9__StopMulticastStreaming (3245)
#endif

/* _ns9__StartMulticastStreaming * has binding name 'PointerTo_ns9__StartMulticastStreaming' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__StartMulticastStreaming
#define SOAP_TYPE_PointerTo_ns9__StartMulticastStreaming (3241)
#endif

/* _ns9__GetStreamUri * has binding name 'PointerTo_ns9__GetStreamUri' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetStreamUri
#define SOAP_TYPE_PointerTo_ns9__GetStreamUri (3237)
#endif

/* _ns9__GetGuaranteedNumberOfVideoEncoderInstances * has binding name 'PointerTo_ns9__GetGuaranteedNumberOfVideoEncoderInstances' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetGuaranteedNumberOfVideoEncoderInstances
#define SOAP_TYPE_PointerTo_ns9__GetGuaranteedNumberOfVideoEncoderInstances (3233)
#endif

/* _ns9__GetAudioDecoderConfigurationOptions * has binding name 'PointerTo_ns9__GetAudioDecoderConfigurationOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetAudioDecoderConfigurationOptions
#define SOAP_TYPE_PointerTo_ns9__GetAudioDecoderConfigurationOptions (3229)
#endif

/* _ns9__GetAudioOutputConfigurationOptions * has binding name 'PointerTo_ns9__GetAudioOutputConfigurationOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetAudioOutputConfigurationOptions
#define SOAP_TYPE_PointerTo_ns9__GetAudioOutputConfigurationOptions (3225)
#endif

/* _ns9__GetMetadataConfigurationOptions * has binding name 'PointerTo_ns9__GetMetadataConfigurationOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetMetadataConfigurationOptions
#define SOAP_TYPE_PointerTo_ns9__GetMetadataConfigurationOptions (3221)
#endif

/* _ns9__GetAudioEncoderConfigurationOptions * has binding name 'PointerTo_ns9__GetAudioEncoderConfigurationOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetAudioEncoderConfigurationOptions
#define SOAP_TYPE_PointerTo_ns9__GetAudioEncoderConfigurationOptions (3217)
#endif

/* _ns9__GetAudioSourceConfigurationOptions * has binding name 'PointerTo_ns9__GetAudioSourceConfigurationOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetAudioSourceConfigurationOptions
#define SOAP_TYPE_PointerTo_ns9__GetAudioSourceConfigurationOptions (3213)
#endif

/* _ns9__GetVideoEncoderConfigurationOptions * has binding name 'PointerTo_ns9__GetVideoEncoderConfigurationOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetVideoEncoderConfigurationOptions
#define SOAP_TYPE_PointerTo_ns9__GetVideoEncoderConfigurationOptions (3209)
#endif

/* _ns9__GetVideoSourceConfigurationOptions * has binding name 'PointerTo_ns9__GetVideoSourceConfigurationOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetVideoSourceConfigurationOptions
#define SOAP_TYPE_PointerTo_ns9__GetVideoSourceConfigurationOptions (3205)
#endif

/* _ns9__SetAudioDecoderConfiguration * has binding name 'PointerTo_ns9__SetAudioDecoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__SetAudioDecoderConfiguration
#define SOAP_TYPE_PointerTo_ns9__SetAudioDecoderConfiguration (3201)
#endif

/* _ns9__SetAudioOutputConfiguration * has binding name 'PointerTo_ns9__SetAudioOutputConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__SetAudioOutputConfiguration
#define SOAP_TYPE_PointerTo_ns9__SetAudioOutputConfiguration (3197)
#endif

/* _ns9__SetMetadataConfiguration * has binding name 'PointerTo_ns9__SetMetadataConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__SetMetadataConfiguration
#define SOAP_TYPE_PointerTo_ns9__SetMetadataConfiguration (3193)
#endif

/* _ns9__SetVideoAnalyticsConfiguration * has binding name 'PointerTo_ns9__SetVideoAnalyticsConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__SetVideoAnalyticsConfiguration
#define SOAP_TYPE_PointerTo_ns9__SetVideoAnalyticsConfiguration (3189)
#endif

/* _ns9__SetAudioEncoderConfiguration * has binding name 'PointerTo_ns9__SetAudioEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__SetAudioEncoderConfiguration
#define SOAP_TYPE_PointerTo_ns9__SetAudioEncoderConfiguration (3185)
#endif

/* _ns9__SetAudioSourceConfiguration * has binding name 'PointerTo_ns9__SetAudioSourceConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__SetAudioSourceConfiguration
#define SOAP_TYPE_PointerTo_ns9__SetAudioSourceConfiguration (3181)
#endif

/* _ns9__SetVideoEncoderConfiguration * has binding name 'PointerTo_ns9__SetVideoEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__SetVideoEncoderConfiguration
#define SOAP_TYPE_PointerTo_ns9__SetVideoEncoderConfiguration (3177)
#endif

/* _ns9__SetVideoSourceConfiguration * has binding name 'PointerTo_ns9__SetVideoSourceConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__SetVideoSourceConfiguration
#define SOAP_TYPE_PointerTo_ns9__SetVideoSourceConfiguration (3173)
#endif

/* _ns9__GetCompatibleAudioDecoderConfigurations * has binding name 'PointerTo_ns9__GetCompatibleAudioDecoderConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetCompatibleAudioDecoderConfigurations
#define SOAP_TYPE_PointerTo_ns9__GetCompatibleAudioDecoderConfigurations (3169)
#endif

/* _ns9__GetCompatibleAudioOutputConfigurations * has binding name 'PointerTo_ns9__GetCompatibleAudioOutputConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetCompatibleAudioOutputConfigurations
#define SOAP_TYPE_PointerTo_ns9__GetCompatibleAudioOutputConfigurations (3165)
#endif

/* _ns9__GetCompatibleMetadataConfigurations * has binding name 'PointerTo_ns9__GetCompatibleMetadataConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetCompatibleMetadataConfigurations
#define SOAP_TYPE_PointerTo_ns9__GetCompatibleMetadataConfigurations (3161)
#endif

/* _ns9__GetCompatibleVideoAnalyticsConfigurations * has binding name 'PointerTo_ns9__GetCompatibleVideoAnalyticsConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetCompatibleVideoAnalyticsConfigurations
#define SOAP_TYPE_PointerTo_ns9__GetCompatibleVideoAnalyticsConfigurations (3157)
#endif

/* _ns9__GetCompatibleAudioSourceConfigurations * has binding name 'PointerTo_ns9__GetCompatibleAudioSourceConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetCompatibleAudioSourceConfigurations
#define SOAP_TYPE_PointerTo_ns9__GetCompatibleAudioSourceConfigurations (3153)
#endif

/* _ns9__GetCompatibleAudioEncoderConfigurations * has binding name 'PointerTo_ns9__GetCompatibleAudioEncoderConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetCompatibleAudioEncoderConfigurations
#define SOAP_TYPE_PointerTo_ns9__GetCompatibleAudioEncoderConfigurations (3149)
#endif

/* _ns9__GetCompatibleVideoSourceConfigurations * has binding name 'PointerTo_ns9__GetCompatibleVideoSourceConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetCompatibleVideoSourceConfigurations
#define SOAP_TYPE_PointerTo_ns9__GetCompatibleVideoSourceConfigurations (3145)
#endif

/* _ns9__GetCompatibleVideoEncoderConfigurations * has binding name 'PointerTo_ns9__GetCompatibleVideoEncoderConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetCompatibleVideoEncoderConfigurations
#define SOAP_TYPE_PointerTo_ns9__GetCompatibleVideoEncoderConfigurations (3141)
#endif

/* _ns9__GetAudioDecoderConfiguration * has binding name 'PointerTo_ns9__GetAudioDecoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetAudioDecoderConfiguration
#define SOAP_TYPE_PointerTo_ns9__GetAudioDecoderConfiguration (3137)
#endif

/* _ns9__GetAudioOutputConfiguration * has binding name 'PointerTo_ns9__GetAudioOutputConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetAudioOutputConfiguration
#define SOAP_TYPE_PointerTo_ns9__GetAudioOutputConfiguration (3133)
#endif

/* _ns9__GetMetadataConfiguration * has binding name 'PointerTo_ns9__GetMetadataConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetMetadataConfiguration
#define SOAP_TYPE_PointerTo_ns9__GetMetadataConfiguration (3129)
#endif

/* _ns9__GetVideoAnalyticsConfiguration * has binding name 'PointerTo_ns9__GetVideoAnalyticsConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetVideoAnalyticsConfiguration
#define SOAP_TYPE_PointerTo_ns9__GetVideoAnalyticsConfiguration (3125)
#endif

/* _ns9__GetAudioEncoderConfiguration * has binding name 'PointerTo_ns9__GetAudioEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetAudioEncoderConfiguration
#define SOAP_TYPE_PointerTo_ns9__GetAudioEncoderConfiguration (3121)
#endif

/* _ns9__GetAudioSourceConfiguration * has binding name 'PointerTo_ns9__GetAudioSourceConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetAudioSourceConfiguration
#define SOAP_TYPE_PointerTo_ns9__GetAudioSourceConfiguration (3117)
#endif

/* _ns9__GetVideoEncoderConfiguration * has binding name 'PointerTo_ns9__GetVideoEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetVideoEncoderConfiguration
#define SOAP_TYPE_PointerTo_ns9__GetVideoEncoderConfiguration (3113)
#endif

/* _ns9__GetVideoSourceConfiguration * has binding name 'PointerTo_ns9__GetVideoSourceConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetVideoSourceConfiguration
#define SOAP_TYPE_PointerTo_ns9__GetVideoSourceConfiguration (3109)
#endif

/* _ns9__GetAudioDecoderConfigurations * has binding name 'PointerTo_ns9__GetAudioDecoderConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetAudioDecoderConfigurations
#define SOAP_TYPE_PointerTo_ns9__GetAudioDecoderConfigurations (3105)
#endif

/* _ns9__GetAudioOutputConfigurations * has binding name 'PointerTo_ns9__GetAudioOutputConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetAudioOutputConfigurations
#define SOAP_TYPE_PointerTo_ns9__GetAudioOutputConfigurations (3101)
#endif

/* _ns9__GetMetadataConfigurations * has binding name 'PointerTo_ns9__GetMetadataConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetMetadataConfigurations
#define SOAP_TYPE_PointerTo_ns9__GetMetadataConfigurations (3097)
#endif

/* _ns9__GetVideoAnalyticsConfigurations * has binding name 'PointerTo_ns9__GetVideoAnalyticsConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetVideoAnalyticsConfigurations
#define SOAP_TYPE_PointerTo_ns9__GetVideoAnalyticsConfigurations (3093)
#endif

/* _ns9__GetAudioEncoderConfigurations * has binding name 'PointerTo_ns9__GetAudioEncoderConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetAudioEncoderConfigurations
#define SOAP_TYPE_PointerTo_ns9__GetAudioEncoderConfigurations (3089)
#endif

/* _ns9__GetAudioSourceConfigurations * has binding name 'PointerTo_ns9__GetAudioSourceConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetAudioSourceConfigurations
#define SOAP_TYPE_PointerTo_ns9__GetAudioSourceConfigurations (3085)
#endif

/* _ns9__GetVideoEncoderConfigurations * has binding name 'PointerTo_ns9__GetVideoEncoderConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetVideoEncoderConfigurations
#define SOAP_TYPE_PointerTo_ns9__GetVideoEncoderConfigurations (3081)
#endif

/* _ns9__GetVideoSourceConfigurations * has binding name 'PointerTo_ns9__GetVideoSourceConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetVideoSourceConfigurations
#define SOAP_TYPE_PointerTo_ns9__GetVideoSourceConfigurations (3077)
#endif

/* _ns9__DeleteProfile * has binding name 'PointerTo_ns9__DeleteProfile' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__DeleteProfile
#define SOAP_TYPE_PointerTo_ns9__DeleteProfile (3073)
#endif

/* _ns9__RemoveAudioDecoderConfiguration * has binding name 'PointerTo_ns9__RemoveAudioDecoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__RemoveAudioDecoderConfiguration
#define SOAP_TYPE_PointerTo_ns9__RemoveAudioDecoderConfiguration (3069)
#endif

/* _ns9__RemoveAudioOutputConfiguration * has binding name 'PointerTo_ns9__RemoveAudioOutputConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__RemoveAudioOutputConfiguration
#define SOAP_TYPE_PointerTo_ns9__RemoveAudioOutputConfiguration (3065)
#endif

/* _ns9__RemoveMetadataConfiguration * has binding name 'PointerTo_ns9__RemoveMetadataConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__RemoveMetadataConfiguration
#define SOAP_TYPE_PointerTo_ns9__RemoveMetadataConfiguration (3061)
#endif

/* _ns9__RemoveVideoAnalyticsConfiguration * has binding name 'PointerTo_ns9__RemoveVideoAnalyticsConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__RemoveVideoAnalyticsConfiguration
#define SOAP_TYPE_PointerTo_ns9__RemoveVideoAnalyticsConfiguration (3057)
#endif

/* _ns9__RemovePTZConfiguration * has binding name 'PointerTo_ns9__RemovePTZConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__RemovePTZConfiguration
#define SOAP_TYPE_PointerTo_ns9__RemovePTZConfiguration (3053)
#endif

/* _ns9__RemoveAudioSourceConfiguration * has binding name 'PointerTo_ns9__RemoveAudioSourceConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__RemoveAudioSourceConfiguration
#define SOAP_TYPE_PointerTo_ns9__RemoveAudioSourceConfiguration (3049)
#endif

/* _ns9__RemoveAudioEncoderConfiguration * has binding name 'PointerTo_ns9__RemoveAudioEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__RemoveAudioEncoderConfiguration
#define SOAP_TYPE_PointerTo_ns9__RemoveAudioEncoderConfiguration (3045)
#endif

/* _ns9__RemoveVideoSourceConfiguration * has binding name 'PointerTo_ns9__RemoveVideoSourceConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__RemoveVideoSourceConfiguration
#define SOAP_TYPE_PointerTo_ns9__RemoveVideoSourceConfiguration (3041)
#endif

/* _ns9__RemoveVideoEncoderConfiguration * has binding name 'PointerTo_ns9__RemoveVideoEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__RemoveVideoEncoderConfiguration
#define SOAP_TYPE_PointerTo_ns9__RemoveVideoEncoderConfiguration (3037)
#endif

/* _ns9__AddAudioDecoderConfiguration * has binding name 'PointerTo_ns9__AddAudioDecoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__AddAudioDecoderConfiguration
#define SOAP_TYPE_PointerTo_ns9__AddAudioDecoderConfiguration (3033)
#endif

/* _ns9__AddAudioOutputConfiguration * has binding name 'PointerTo_ns9__AddAudioOutputConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__AddAudioOutputConfiguration
#define SOAP_TYPE_PointerTo_ns9__AddAudioOutputConfiguration (3029)
#endif

/* _ns9__AddMetadataConfiguration * has binding name 'PointerTo_ns9__AddMetadataConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__AddMetadataConfiguration
#define SOAP_TYPE_PointerTo_ns9__AddMetadataConfiguration (3025)
#endif

/* _ns9__AddVideoAnalyticsConfiguration * has binding name 'PointerTo_ns9__AddVideoAnalyticsConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__AddVideoAnalyticsConfiguration
#define SOAP_TYPE_PointerTo_ns9__AddVideoAnalyticsConfiguration (3021)
#endif

/* _ns9__AddPTZConfiguration * has binding name 'PointerTo_ns9__AddPTZConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__AddPTZConfiguration
#define SOAP_TYPE_PointerTo_ns9__AddPTZConfiguration (3017)
#endif

/* _ns9__AddAudioSourceConfiguration * has binding name 'PointerTo_ns9__AddAudioSourceConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__AddAudioSourceConfiguration
#define SOAP_TYPE_PointerTo_ns9__AddAudioSourceConfiguration (3013)
#endif

/* _ns9__AddAudioEncoderConfiguration * has binding name 'PointerTo_ns9__AddAudioEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__AddAudioEncoderConfiguration
#define SOAP_TYPE_PointerTo_ns9__AddAudioEncoderConfiguration (3009)
#endif

/* _ns9__AddVideoSourceConfiguration * has binding name 'PointerTo_ns9__AddVideoSourceConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__AddVideoSourceConfiguration
#define SOAP_TYPE_PointerTo_ns9__AddVideoSourceConfiguration (3005)
#endif

/* _ns9__AddVideoEncoderConfiguration * has binding name 'PointerTo_ns9__AddVideoEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__AddVideoEncoderConfiguration
#define SOAP_TYPE_PointerTo_ns9__AddVideoEncoderConfiguration (3001)
#endif

/* _ns9__GetProfiles * has binding name 'PointerTo_ns9__GetProfiles' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetProfiles
#define SOAP_TYPE_PointerTo_ns9__GetProfiles (2997)
#endif

/* _ns9__GetProfile * has binding name 'PointerTo_ns9__GetProfile' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetProfile
#define SOAP_TYPE_PointerTo_ns9__GetProfile (2993)
#endif

/* _ns9__CreateProfile * has binding name 'PointerTo_ns9__CreateProfile' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__CreateProfile
#define SOAP_TYPE_PointerTo_ns9__CreateProfile (2989)
#endif

/* _ns9__GetAudioOutputs * has binding name 'PointerTo_ns9__GetAudioOutputs' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetAudioOutputs
#define SOAP_TYPE_PointerTo_ns9__GetAudioOutputs (2985)
#endif

/* _ns9__GetAudioSources * has binding name 'PointerTo_ns9__GetAudioSources' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetAudioSources
#define SOAP_TYPE_PointerTo_ns9__GetAudioSources (2981)
#endif

/* _ns9__GetVideoSources * has binding name 'PointerTo_ns9__GetVideoSources' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetVideoSources
#define SOAP_TYPE_PointerTo_ns9__GetVideoSources (2977)
#endif

/* _ns9__GetServiceCapabilities * has binding name 'PointerTo_ns9__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns9__GetServiceCapabilities
#define SOAP_TYPE_PointerTo_ns9__GetServiceCapabilities (2973)
#endif

/* _ns8__SetCurrentPreset * has binding name 'PointerTo_ns8__SetCurrentPreset' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns8__SetCurrentPreset
#define SOAP_TYPE_PointerTo_ns8__SetCurrentPreset (2969)
#endif

/* _ns8__GetCurrentPreset * has binding name 'PointerTo_ns8__GetCurrentPreset' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns8__GetCurrentPreset
#define SOAP_TYPE_PointerTo_ns8__GetCurrentPreset (2965)
#endif

/* _ns8__GetPresets * has binding name 'PointerTo_ns8__GetPresets' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns8__GetPresets
#define SOAP_TYPE_PointerTo_ns8__GetPresets (2961)
#endif

/* _ns8__GetMoveOptions * has binding name 'PointerTo_ns8__GetMoveOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns8__GetMoveOptions
#define SOAP_TYPE_PointerTo_ns8__GetMoveOptions (2957)
#endif

/* _ns8__GetStatus * has binding name 'PointerTo_ns8__GetStatus' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns8__GetStatus
#define SOAP_TYPE_PointerTo_ns8__GetStatus (2953)
#endif

/* _ns8__Stop * has binding name 'PointerTo_ns8__Stop' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns8__Stop
#define SOAP_TYPE_PointerTo_ns8__Stop (2949)
#endif

/* _ns8__Move * has binding name 'PointerTo_ns8__Move' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns8__Move
#define SOAP_TYPE_PointerTo_ns8__Move (2945)
#endif

/* _ns8__GetOptions * has binding name 'PointerTo_ns8__GetOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns8__GetOptions
#define SOAP_TYPE_PointerTo_ns8__GetOptions (2941)
#endif

/* _ns8__SetImagingSettings * has binding name 'PointerTo_ns8__SetImagingSettings' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns8__SetImagingSettings
#define SOAP_TYPE_PointerTo_ns8__SetImagingSettings (2937)
#endif

/* _ns8__GetImagingSettings * has binding name 'PointerTo_ns8__GetImagingSettings' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns8__GetImagingSettings
#define SOAP_TYPE_PointerTo_ns8__GetImagingSettings (2933)
#endif

/* _ns8__GetServiceCapabilities * has binding name 'PointerTo_ns8__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns8__GetServiceCapabilities
#define SOAP_TYPE_PointerTo_ns8__GetServiceCapabilities (2929)
#endif

/* _ns7__DeletePaneConfiguration * has binding name 'PointerTo_ns7__DeletePaneConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__DeletePaneConfiguration
#define SOAP_TYPE_PointerTo_ns7__DeletePaneConfiguration (2925)
#endif

/* _ns7__CreatePaneConfiguration * has binding name 'PointerTo_ns7__CreatePaneConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__CreatePaneConfiguration
#define SOAP_TYPE_PointerTo_ns7__CreatePaneConfiguration (2921)
#endif

/* _ns7__SetPaneConfiguration * has binding name 'PointerTo_ns7__SetPaneConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__SetPaneConfiguration
#define SOAP_TYPE_PointerTo_ns7__SetPaneConfiguration (2917)
#endif

/* _ns7__SetPaneConfigurations * has binding name 'PointerTo_ns7__SetPaneConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__SetPaneConfigurations
#define SOAP_TYPE_PointerTo_ns7__SetPaneConfigurations (2913)
#endif

/* _ns7__GetPaneConfiguration * has binding name 'PointerTo_ns7__GetPaneConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__GetPaneConfiguration
#define SOAP_TYPE_PointerTo_ns7__GetPaneConfiguration (2909)
#endif

/* _ns7__GetPaneConfigurations * has binding name 'PointerTo_ns7__GetPaneConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__GetPaneConfigurations
#define SOAP_TYPE_PointerTo_ns7__GetPaneConfigurations (2905)
#endif

/* _ns7__GetDisplayOptions * has binding name 'PointerTo_ns7__GetDisplayOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__GetDisplayOptions
#define SOAP_TYPE_PointerTo_ns7__GetDisplayOptions (2901)
#endif

/* _ns7__SetLayout * has binding name 'PointerTo_ns7__SetLayout' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__SetLayout
#define SOAP_TYPE_PointerTo_ns7__SetLayout (2897)
#endif

/* _ns7__GetLayout * has binding name 'PointerTo_ns7__GetLayout' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__GetLayout
#define SOAP_TYPE_PointerTo_ns7__GetLayout (2893)
#endif

/* _ns7__GetServiceCapabilities * has binding name 'PointerTo_ns7__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__GetServiceCapabilities
#define SOAP_TYPE_PointerTo_ns7__GetServiceCapabilities (2889)
#endif

/* _ns12__DeleteCredentialAccessProfiles * has binding name 'PointerTo_ns12__DeleteCredentialAccessProfiles' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns12__DeleteCredentialAccessProfiles
#define SOAP_TYPE_PointerTo_ns12__DeleteCredentialAccessProfiles (2885)
#endif

/* _ns12__SetCredentialAccessProfiles * has binding name 'PointerTo_ns12__SetCredentialAccessProfiles' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns12__SetCredentialAccessProfiles
#define SOAP_TYPE_PointerTo_ns12__SetCredentialAccessProfiles (2881)
#endif

/* _ns12__GetCredentialAccessProfiles * has binding name 'PointerTo_ns12__GetCredentialAccessProfiles' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns12__GetCredentialAccessProfiles
#define SOAP_TYPE_PointerTo_ns12__GetCredentialAccessProfiles (2877)
#endif

/* _ns12__DeleteCredentialIdentifier * has binding name 'PointerTo_ns12__DeleteCredentialIdentifier' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns12__DeleteCredentialIdentifier
#define SOAP_TYPE_PointerTo_ns12__DeleteCredentialIdentifier (2873)
#endif

/* _ns12__SetCredentialIdentifier * has binding name 'PointerTo_ns12__SetCredentialIdentifier' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns12__SetCredentialIdentifier
#define SOAP_TYPE_PointerTo_ns12__SetCredentialIdentifier (2869)
#endif

/* _ns12__GetCredentialIdentifiers * has binding name 'PointerTo_ns12__GetCredentialIdentifiers' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns12__GetCredentialIdentifiers
#define SOAP_TYPE_PointerTo_ns12__GetCredentialIdentifiers (2865)
#endif

/* _ns12__ResetAntipassbackViolation * has binding name 'PointerTo_ns12__ResetAntipassbackViolation' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns12__ResetAntipassbackViolation
#define SOAP_TYPE_PointerTo_ns12__ResetAntipassbackViolation (2861)
#endif

/* _ns12__DisableCredential * has binding name 'PointerTo_ns12__DisableCredential' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns12__DisableCredential
#define SOAP_TYPE_PointerTo_ns12__DisableCredential (2857)
#endif

/* _ns12__EnableCredential * has binding name 'PointerTo_ns12__EnableCredential' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns12__EnableCredential
#define SOAP_TYPE_PointerTo_ns12__EnableCredential (2853)
#endif

/* _ns12__GetCredentialState * has binding name 'PointerTo_ns12__GetCredentialState' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns12__GetCredentialState
#define SOAP_TYPE_PointerTo_ns12__GetCredentialState (2849)
#endif

/* _ns12__DeleteCredential * has binding name 'PointerTo_ns12__DeleteCredential' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns12__DeleteCredential
#define SOAP_TYPE_PointerTo_ns12__DeleteCredential (2845)
#endif

/* _ns12__ModifyCredential * has binding name 'PointerTo_ns12__ModifyCredential' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns12__ModifyCredential
#define SOAP_TYPE_PointerTo_ns12__ModifyCredential (2841)
#endif

/* _ns12__CreateCredential * has binding name 'PointerTo_ns12__CreateCredential' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns12__CreateCredential
#define SOAP_TYPE_PointerTo_ns12__CreateCredential (2837)
#endif

/* _ns12__GetCredentialList * has binding name 'PointerTo_ns12__GetCredentialList' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns12__GetCredentialList
#define SOAP_TYPE_PointerTo_ns12__GetCredentialList (2833)
#endif

/* _ns12__GetCredentials * has binding name 'PointerTo_ns12__GetCredentials' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns12__GetCredentials
#define SOAP_TYPE_PointerTo_ns12__GetCredentials (2829)
#endif

/* _ns12__GetCredentialInfoList * has binding name 'PointerTo_ns12__GetCredentialInfoList' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns12__GetCredentialInfoList
#define SOAP_TYPE_PointerTo_ns12__GetCredentialInfoList (2825)
#endif

/* _ns12__GetCredentialInfo * has binding name 'PointerTo_ns12__GetCredentialInfo' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns12__GetCredentialInfo
#define SOAP_TYPE_PointerTo_ns12__GetCredentialInfo (2821)
#endif

/* _ns12__GetSupportedFormatTypes * has binding name 'PointerTo_ns12__GetSupportedFormatTypes' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns12__GetSupportedFormatTypes
#define SOAP_TYPE_PointerTo_ns12__GetSupportedFormatTypes (2817)
#endif

/* _ns12__GetServiceCapabilities * has binding name 'PointerTo_ns12__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns12__GetServiceCapabilities
#define SOAP_TYPE_PointerTo_ns12__GetServiceCapabilities (2813)
#endif

/* _ns11__GetCompatibleConfigurations * has binding name 'PointerTo_ns11__GetCompatibleConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__GetCompatibleConfigurations
#define SOAP_TYPE_PointerTo_ns11__GetCompatibleConfigurations (2809)
#endif

/* _ns11__RemovePresetTour * has binding name 'PointerTo_ns11__RemovePresetTour' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__RemovePresetTour
#define SOAP_TYPE_PointerTo_ns11__RemovePresetTour (2805)
#endif

/* _ns11__OperatePresetTour * has binding name 'PointerTo_ns11__OperatePresetTour' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__OperatePresetTour
#define SOAP_TYPE_PointerTo_ns11__OperatePresetTour (2801)
#endif

/* _ns11__ModifyPresetTour * has binding name 'PointerTo_ns11__ModifyPresetTour' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__ModifyPresetTour
#define SOAP_TYPE_PointerTo_ns11__ModifyPresetTour (2797)
#endif

/* _ns11__CreatePresetTour * has binding name 'PointerTo_ns11__CreatePresetTour' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__CreatePresetTour
#define SOAP_TYPE_PointerTo_ns11__CreatePresetTour (2793)
#endif

/* _ns11__GetPresetTourOptions * has binding name 'PointerTo_ns11__GetPresetTourOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__GetPresetTourOptions
#define SOAP_TYPE_PointerTo_ns11__GetPresetTourOptions (2789)
#endif

/* _ns11__GetPresetTour * has binding name 'PointerTo_ns11__GetPresetTour' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__GetPresetTour
#define SOAP_TYPE_PointerTo_ns11__GetPresetTour (2785)
#endif

/* _ns11__GetPresetTours * has binding name 'PointerTo_ns11__GetPresetTours' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__GetPresetTours
#define SOAP_TYPE_PointerTo_ns11__GetPresetTours (2781)
#endif

/* _ns11__Stop * has binding name 'PointerTo_ns11__Stop' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__Stop
#define SOAP_TYPE_PointerTo_ns11__Stop (2777)
#endif

/* _ns11__AbsoluteMove * has binding name 'PointerTo_ns11__AbsoluteMove' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__AbsoluteMove
#define SOAP_TYPE_PointerTo_ns11__AbsoluteMove (2773)
#endif

/* _ns11__SendAuxiliaryCommand * has binding name 'PointerTo_ns11__SendAuxiliaryCommand' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__SendAuxiliaryCommand
#define SOAP_TYPE_PointerTo_ns11__SendAuxiliaryCommand (2769)
#endif

/* _ns11__RelativeMove * has binding name 'PointerTo_ns11__RelativeMove' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__RelativeMove
#define SOAP_TYPE_PointerTo_ns11__RelativeMove (2765)
#endif

/* _ns11__ContinuousMove * has binding name 'PointerTo_ns11__ContinuousMove' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__ContinuousMove
#define SOAP_TYPE_PointerTo_ns11__ContinuousMove (2761)
#endif

/* _ns11__SetHomePosition * has binding name 'PointerTo_ns11__SetHomePosition' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__SetHomePosition
#define SOAP_TYPE_PointerTo_ns11__SetHomePosition (2757)
#endif

/* _ns11__GotoHomePosition * has binding name 'PointerTo_ns11__GotoHomePosition' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__GotoHomePosition
#define SOAP_TYPE_PointerTo_ns11__GotoHomePosition (2753)
#endif

/* _ns11__GetConfigurationOptions * has binding name 'PointerTo_ns11__GetConfigurationOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__GetConfigurationOptions
#define SOAP_TYPE_PointerTo_ns11__GetConfigurationOptions (2749)
#endif

/* _ns11__SetConfiguration * has binding name 'PointerTo_ns11__SetConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__SetConfiguration
#define SOAP_TYPE_PointerTo_ns11__SetConfiguration (2745)
#endif

/* _ns11__GetNode * has binding name 'PointerTo_ns11__GetNode' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__GetNode
#define SOAP_TYPE_PointerTo_ns11__GetNode (2741)
#endif

/* _ns11__GetNodes * has binding name 'PointerTo_ns11__GetNodes' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__GetNodes
#define SOAP_TYPE_PointerTo_ns11__GetNodes (2737)
#endif

/* _ns11__GetConfiguration * has binding name 'PointerTo_ns11__GetConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__GetConfiguration
#define SOAP_TYPE_PointerTo_ns11__GetConfiguration (2733)
#endif

/* _ns11__GetStatus * has binding name 'PointerTo_ns11__GetStatus' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__GetStatus
#define SOAP_TYPE_PointerTo_ns11__GetStatus (2729)
#endif

/* _ns11__GotoPreset * has binding name 'PointerTo_ns11__GotoPreset' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__GotoPreset
#define SOAP_TYPE_PointerTo_ns11__GotoPreset (2725)
#endif

/* _ns11__RemovePreset * has binding name 'PointerTo_ns11__RemovePreset' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__RemovePreset
#define SOAP_TYPE_PointerTo_ns11__RemovePreset (2721)
#endif

/* _ns11__SetPreset * has binding name 'PointerTo_ns11__SetPreset' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__SetPreset
#define SOAP_TYPE_PointerTo_ns11__SetPreset (2717)
#endif

/* _ns11__GetPresets * has binding name 'PointerTo_ns11__GetPresets' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__GetPresets
#define SOAP_TYPE_PointerTo_ns11__GetPresets (2713)
#endif

/* _ns11__GetConfigurations * has binding name 'PointerTo_ns11__GetConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__GetConfigurations
#define SOAP_TYPE_PointerTo_ns11__GetConfigurations (2709)
#endif

/* _ns11__GetServiceCapabilities * has binding name 'PointerTo_ns11__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns11__GetServiceCapabilities
#define SOAP_TYPE_PointerTo_ns11__GetServiceCapabilities (2705)
#endif

/* _ns10__DeleteOSD * has binding name 'PointerTo_ns10__DeleteOSD' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns10__DeleteOSD
#define SOAP_TYPE_PointerTo_ns10__DeleteOSD (2702)
#endif

/* _ns10__CreateOSD * has binding name 'PointerTo_ns10__CreateOSD' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns10__CreateOSD
#define SOAP_TYPE_PointerTo_ns10__CreateOSD (2698)
#endif

/* _ns10__SetOSD * has binding name 'PointerTo_ns10__SetOSD' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns10__SetOSD
#define SOAP_TYPE_PointerTo_ns10__SetOSD (2695)
#endif

/* _ns10__GetOSDOptions * has binding name 'PointerTo_ns10__GetOSDOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns10__GetOSDOptions
#define SOAP_TYPE_PointerTo_ns10__GetOSDOptions (2691)
#endif

/* _ns10__GetOSDs * has binding name 'PointerTo_ns10__GetOSDs' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns10__GetOSDs
#define SOAP_TYPE_PointerTo_ns10__GetOSDs (2687)
#endif

/* _ns10__SetVideoSourceMode * has binding name 'PointerTo_ns10__SetVideoSourceMode' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns10__SetVideoSourceMode
#define SOAP_TYPE_PointerTo_ns10__SetVideoSourceMode (2683)
#endif

/* _ns10__GetVideoSourceModes * has binding name 'PointerTo_ns10__GetVideoSourceModes' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns10__GetVideoSourceModes
#define SOAP_TYPE_PointerTo_ns10__GetVideoSourceModes (2679)
#endif

/* _ns10__GetSnapshotUri * has binding name 'PointerTo_ns10__GetSnapshotUri' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns10__GetSnapshotUri
#define SOAP_TYPE_PointerTo_ns10__GetSnapshotUri (2675)
#endif

/* _ns10__SetSynchronizationPoint * has binding name 'PointerTo_ns10__SetSynchronizationPoint' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns10__SetSynchronizationPoint
#define SOAP_TYPE_PointerTo_ns10__SetSynchronizationPoint (2671)
#endif

/* ns10__StartStopMulticastStreaming * has binding name 'PointerTons10__StartStopMulticastStreaming' for type 'ns10:StartStopMulticastStreaming' */
#ifndef SOAP_TYPE_PointerTons10__StartStopMulticastStreaming
#define SOAP_TYPE_PointerTons10__StartStopMulticastStreaming (2665)
#endif

/* _ns10__GetStreamUri * has binding name 'PointerTo_ns10__GetStreamUri' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns10__GetStreamUri
#define SOAP_TYPE_PointerTo_ns10__GetStreamUri (2661)
#endif

/* _ns10__GetVideoEncoderInstances * has binding name 'PointerTo_ns10__GetVideoEncoderInstances' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns10__GetVideoEncoderInstances
#define SOAP_TYPE_PointerTo_ns10__GetVideoEncoderInstances (2657)
#endif

/* _ns10__SetAudioDecoderConfiguration * has binding name 'PointerTo_ns10__SetAudioDecoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns10__SetAudioDecoderConfiguration
#define SOAP_TYPE_PointerTo_ns10__SetAudioDecoderConfiguration (2633)
#endif

/* _ns10__SetAudioOutputConfiguration * has binding name 'PointerTo_ns10__SetAudioOutputConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns10__SetAudioOutputConfiguration
#define SOAP_TYPE_PointerTo_ns10__SetAudioOutputConfiguration (2630)
#endif

/* _ns10__SetMetadataConfiguration * has binding name 'PointerTo_ns10__SetMetadataConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns10__SetMetadataConfiguration
#define SOAP_TYPE_PointerTo_ns10__SetMetadataConfiguration (2627)
#endif

/* _ns10__SetAudioEncoderConfiguration * has binding name 'PointerTo_ns10__SetAudioEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns10__SetAudioEncoderConfiguration
#define SOAP_TYPE_PointerTo_ns10__SetAudioEncoderConfiguration (2624)
#endif

/* _ns10__SetAudioSourceConfiguration * has binding name 'PointerTo_ns10__SetAudioSourceConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns10__SetAudioSourceConfiguration
#define SOAP_TYPE_PointerTo_ns10__SetAudioSourceConfiguration (2621)
#endif

/* _ns10__SetVideoEncoderConfiguration * has binding name 'PointerTo_ns10__SetVideoEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns10__SetVideoEncoderConfiguration
#define SOAP_TYPE_PointerTo_ns10__SetVideoEncoderConfiguration (2618)
#endif

/* _ns10__SetVideoSourceConfiguration * has binding name 'PointerTo_ns10__SetVideoSourceConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns10__SetVideoSourceConfiguration
#define SOAP_TYPE_PointerTo_ns10__SetVideoSourceConfiguration (2614)
#endif

/* ns10__GetConfiguration * has binding name 'PointerTons10__GetConfiguration' for type 'ns10:GetConfiguration' */
#ifndef SOAP_TYPE_PointerTons10__GetConfiguration
#define SOAP_TYPE_PointerTons10__GetConfiguration (2589)
#endif

/* _ns10__DeleteProfile * has binding name 'PointerTo_ns10__DeleteProfile' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns10__DeleteProfile
#define SOAP_TYPE_PointerTo_ns10__DeleteProfile (2585)
#endif

/* _ns10__RemoveConfiguration * has binding name 'PointerTo_ns10__RemoveConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns10__RemoveConfiguration
#define SOAP_TYPE_PointerTo_ns10__RemoveConfiguration (2581)
#endif

/* _ns10__AddConfiguration * has binding name 'PointerTo_ns10__AddConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns10__AddConfiguration
#define SOAP_TYPE_PointerTo_ns10__AddConfiguration (2577)
#endif

/* _ns10__GetProfiles * has binding name 'PointerTo_ns10__GetProfiles' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns10__GetProfiles
#define SOAP_TYPE_PointerTo_ns10__GetProfiles (2573)
#endif

/* _ns10__CreateProfile * has binding name 'PointerTo_ns10__CreateProfile' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns10__CreateProfile
#define SOAP_TYPE_PointerTo_ns10__CreateProfile (2569)
#endif

/* _ns10__GetServiceCapabilities * has binding name 'PointerTo_ns10__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns10__GetServiceCapabilities
#define SOAP_TYPE_PointerTo_ns10__GetServiceCapabilities (2565)
#endif

/* _ns1__DeleteStorageConfiguration * has binding name 'PointerTo_ns1__DeleteStorageConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DeleteStorageConfiguration
#define SOAP_TYPE_PointerTo_ns1__DeleteStorageConfiguration (2561)
#endif

/* _ns1__SetStorageConfiguration * has binding name 'PointerTo_ns1__SetStorageConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetStorageConfiguration
#define SOAP_TYPE_PointerTo_ns1__SetStorageConfiguration (2557)
#endif

/* _ns1__GetStorageConfiguration * has binding name 'PointerTo_ns1__GetStorageConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetStorageConfiguration
#define SOAP_TYPE_PointerTo_ns1__GetStorageConfiguration (2553)
#endif

/* _ns1__CreateStorageConfiguration * has binding name 'PointerTo_ns1__CreateStorageConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CreateStorageConfiguration
#define SOAP_TYPE_PointerTo_ns1__CreateStorageConfiguration (2549)
#endif

/* _ns1__GetStorageConfigurations * has binding name 'PointerTo_ns1__GetStorageConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetStorageConfigurations
#define SOAP_TYPE_PointerTo_ns1__GetStorageConfigurations (2545)
#endif

/* _ns1__StartSystemRestore * has binding name 'PointerTo_ns1__StartSystemRestore' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__StartSystemRestore
#define SOAP_TYPE_PointerTo_ns1__StartSystemRestore (2541)
#endif

/* _ns1__StartFirmwareUpgrade * has binding name 'PointerTo_ns1__StartFirmwareUpgrade' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__StartFirmwareUpgrade
#define SOAP_TYPE_PointerTo_ns1__StartFirmwareUpgrade (2537)
#endif

/* _ns1__GetSystemUris * has binding name 'PointerTo_ns1__GetSystemUris' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetSystemUris
#define SOAP_TYPE_PointerTo_ns1__GetSystemUris (2533)
#endif

/* _ns1__ScanAvailableDot11Networks * has binding name 'PointerTo_ns1__ScanAvailableDot11Networks' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ScanAvailableDot11Networks
#define SOAP_TYPE_PointerTo_ns1__ScanAvailableDot11Networks (2529)
#endif

/* _ns1__GetDot11Status * has binding name 'PointerTo_ns1__GetDot11Status' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetDot11Status
#define SOAP_TYPE_PointerTo_ns1__GetDot11Status (2525)
#endif

/* _ns1__GetDot11Capabilities * has binding name 'PointerTo_ns1__GetDot11Capabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetDot11Capabilities
#define SOAP_TYPE_PointerTo_ns1__GetDot11Capabilities (2521)
#endif

/* _ns1__DeleteDot1XConfiguration * has binding name 'PointerTo_ns1__DeleteDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DeleteDot1XConfiguration
#define SOAP_TYPE_PointerTo_ns1__DeleteDot1XConfiguration (2517)
#endif

/* _ns1__GetDot1XConfigurations * has binding name 'PointerTo_ns1__GetDot1XConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetDot1XConfigurations
#define SOAP_TYPE_PointerTo_ns1__GetDot1XConfigurations (2513)
#endif

/* _ns1__GetDot1XConfiguration * has binding name 'PointerTo_ns1__GetDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetDot1XConfiguration
#define SOAP_TYPE_PointerTo_ns1__GetDot1XConfiguration (2509)
#endif

/* _ns1__SetDot1XConfiguration * has binding name 'PointerTo_ns1__SetDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetDot1XConfiguration
#define SOAP_TYPE_PointerTo_ns1__SetDot1XConfiguration (2505)
#endif

/* _ns1__CreateDot1XConfiguration * has binding name 'PointerTo_ns1__CreateDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CreateDot1XConfiguration
#define SOAP_TYPE_PointerTo_ns1__CreateDot1XConfiguration (2501)
#endif

/* _ns1__LoadCACertificates * has binding name 'PointerTo_ns1__LoadCACertificates' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__LoadCACertificates
#define SOAP_TYPE_PointerTo_ns1__LoadCACertificates (2497)
#endif

/* _ns1__GetCertificateInformation * has binding name 'PointerTo_ns1__GetCertificateInformation' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetCertificateInformation
#define SOAP_TYPE_PointerTo_ns1__GetCertificateInformation (2493)
#endif

/* _ns1__LoadCertificateWithPrivateKey * has binding name 'PointerTo_ns1__LoadCertificateWithPrivateKey' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__LoadCertificateWithPrivateKey
#define SOAP_TYPE_PointerTo_ns1__LoadCertificateWithPrivateKey (2489)
#endif

/* _ns1__GetCACertificates * has binding name 'PointerTo_ns1__GetCACertificates' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetCACertificates
#define SOAP_TYPE_PointerTo_ns1__GetCACertificates (2485)
#endif

/* _ns1__SendAuxiliaryCommand * has binding name 'PointerTo_ns1__SendAuxiliaryCommand' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SendAuxiliaryCommand
#define SOAP_TYPE_PointerTo_ns1__SendAuxiliaryCommand (2481)
#endif

/* _ns1__SetRelayOutputState * has binding name 'PointerTo_ns1__SetRelayOutputState' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetRelayOutputState
#define SOAP_TYPE_PointerTo_ns1__SetRelayOutputState (2477)
#endif

/* _ns1__SetRelayOutputSettings * has binding name 'PointerTo_ns1__SetRelayOutputSettings' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetRelayOutputSettings
#define SOAP_TYPE_PointerTo_ns1__SetRelayOutputSettings (2473)
#endif

/* _ns1__GetRelayOutputs * has binding name 'PointerTo_ns1__GetRelayOutputs' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetRelayOutputs
#define SOAP_TYPE_PointerTo_ns1__GetRelayOutputs (2469)
#endif

/* _ns1__SetClientCertificateMode * has binding name 'PointerTo_ns1__SetClientCertificateMode' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetClientCertificateMode
#define SOAP_TYPE_PointerTo_ns1__SetClientCertificateMode (2465)
#endif

/* _ns1__GetClientCertificateMode * has binding name 'PointerTo_ns1__GetClientCertificateMode' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetClientCertificateMode
#define SOAP_TYPE_PointerTo_ns1__GetClientCertificateMode (2461)
#endif

/* _ns1__LoadCertificates * has binding name 'PointerTo_ns1__LoadCertificates' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__LoadCertificates
#define SOAP_TYPE_PointerTo_ns1__LoadCertificates (2457)
#endif

/* _ns1__GetPkcs10Request * has binding name 'PointerTo_ns1__GetPkcs10Request' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetPkcs10Request
#define SOAP_TYPE_PointerTo_ns1__GetPkcs10Request (2453)
#endif

/* _ns1__DeleteCertificates * has binding name 'PointerTo_ns1__DeleteCertificates' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DeleteCertificates
#define SOAP_TYPE_PointerTo_ns1__DeleteCertificates (2449)
#endif

/* _ns1__SetCertificatesStatus * has binding name 'PointerTo_ns1__SetCertificatesStatus' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetCertificatesStatus
#define SOAP_TYPE_PointerTo_ns1__SetCertificatesStatus (2445)
#endif

/* _ns1__GetCertificatesStatus * has binding name 'PointerTo_ns1__GetCertificatesStatus' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetCertificatesStatus
#define SOAP_TYPE_PointerTo_ns1__GetCertificatesStatus (2441)
#endif

/* _ns1__GetCertificates * has binding name 'PointerTo_ns1__GetCertificates' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetCertificates
#define SOAP_TYPE_PointerTo_ns1__GetCertificates (2437)
#endif

/* _ns1__CreateCertificate * has binding name 'PointerTo_ns1__CreateCertificate' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CreateCertificate
#define SOAP_TYPE_PointerTo_ns1__CreateCertificate (2433)
#endif

/* _ns1__SetAccessPolicy * has binding name 'PointerTo_ns1__SetAccessPolicy' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetAccessPolicy
#define SOAP_TYPE_PointerTo_ns1__SetAccessPolicy (2429)
#endif

/* _ns1__GetAccessPolicy * has binding name 'PointerTo_ns1__GetAccessPolicy' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetAccessPolicy
#define SOAP_TYPE_PointerTo_ns1__GetAccessPolicy (2425)
#endif

/* _ns1__RemoveIPAddressFilter * has binding name 'PointerTo_ns1__RemoveIPAddressFilter' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__RemoveIPAddressFilter
#define SOAP_TYPE_PointerTo_ns1__RemoveIPAddressFilter (2421)
#endif

/* _ns1__AddIPAddressFilter * has binding name 'PointerTo_ns1__AddIPAddressFilter' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__AddIPAddressFilter
#define SOAP_TYPE_PointerTo_ns1__AddIPAddressFilter (2417)
#endif

/* _ns1__SetIPAddressFilter * has binding name 'PointerTo_ns1__SetIPAddressFilter' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetIPAddressFilter
#define SOAP_TYPE_PointerTo_ns1__SetIPAddressFilter (2413)
#endif

/* _ns1__GetIPAddressFilter * has binding name 'PointerTo_ns1__GetIPAddressFilter' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetIPAddressFilter
#define SOAP_TYPE_PointerTo_ns1__GetIPAddressFilter (2409)
#endif

/* _ns1__SetZeroConfiguration * has binding name 'PointerTo_ns1__SetZeroConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetZeroConfiguration
#define SOAP_TYPE_PointerTo_ns1__SetZeroConfiguration (2405)
#endif

/* _ns1__GetZeroConfiguration * has binding name 'PointerTo_ns1__GetZeroConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetZeroConfiguration
#define SOAP_TYPE_PointerTo_ns1__GetZeroConfiguration (2401)
#endif

/* _ns1__SetNetworkDefaultGateway * has binding name 'PointerTo_ns1__SetNetworkDefaultGateway' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetNetworkDefaultGateway
#define SOAP_TYPE_PointerTo_ns1__SetNetworkDefaultGateway (2397)
#endif

/* _ns1__GetNetworkDefaultGateway * has binding name 'PointerTo_ns1__GetNetworkDefaultGateway' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetNetworkDefaultGateway
#define SOAP_TYPE_PointerTo_ns1__GetNetworkDefaultGateway (2393)
#endif

/* _ns1__SetNetworkProtocols * has binding name 'PointerTo_ns1__SetNetworkProtocols' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetNetworkProtocols
#define SOAP_TYPE_PointerTo_ns1__SetNetworkProtocols (2389)
#endif

/* _ns1__GetNetworkProtocols * has binding name 'PointerTo_ns1__GetNetworkProtocols' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetNetworkProtocols
#define SOAP_TYPE_PointerTo_ns1__GetNetworkProtocols (2385)
#endif

/* _ns1__SetNetworkInterfaces * has binding name 'PointerTo_ns1__SetNetworkInterfaces' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetNetworkInterfaces
#define SOAP_TYPE_PointerTo_ns1__SetNetworkInterfaces (2381)
#endif

/* _ns1__GetNetworkInterfaces * has binding name 'PointerTo_ns1__GetNetworkInterfaces' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetNetworkInterfaces
#define SOAP_TYPE_PointerTo_ns1__GetNetworkInterfaces (2377)
#endif

/* _ns1__SetDynamicDNS * has binding name 'PointerTo_ns1__SetDynamicDNS' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetDynamicDNS
#define SOAP_TYPE_PointerTo_ns1__SetDynamicDNS (2373)
#endif

/* _ns1__GetDynamicDNS * has binding name 'PointerTo_ns1__GetDynamicDNS' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetDynamicDNS
#define SOAP_TYPE_PointerTo_ns1__GetDynamicDNS (2369)
#endif

/* _ns1__SetNTP * has binding name 'PointerTo_ns1__SetNTP' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetNTP
#define SOAP_TYPE_PointerTo_ns1__SetNTP (2365)
#endif

/* _ns1__GetNTP * has binding name 'PointerTo_ns1__GetNTP' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetNTP
#define SOAP_TYPE_PointerTo_ns1__GetNTP (2361)
#endif

/* _ns1__SetDNS * has binding name 'PointerTo_ns1__SetDNS' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetDNS
#define SOAP_TYPE_PointerTo_ns1__SetDNS (2357)
#endif

/* _ns1__GetDNS * has binding name 'PointerTo_ns1__GetDNS' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetDNS
#define SOAP_TYPE_PointerTo_ns1__GetDNS (2353)
#endif

/* _ns1__SetHostnameFromDHCP * has binding name 'PointerTo_ns1__SetHostnameFromDHCP' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetHostnameFromDHCP
#define SOAP_TYPE_PointerTo_ns1__SetHostnameFromDHCP (2349)
#endif

/* _ns1__SetHostname * has binding name 'PointerTo_ns1__SetHostname' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetHostname
#define SOAP_TYPE_PointerTo_ns1__SetHostname (2345)
#endif

/* _ns1__GetHostname * has binding name 'PointerTo_ns1__GetHostname' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetHostname
#define SOAP_TYPE_PointerTo_ns1__GetHostname (2341)
#endif

/* _ns1__SetDPAddresses * has binding name 'PointerTo_ns1__SetDPAddresses' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetDPAddresses
#define SOAP_TYPE_PointerTo_ns1__SetDPAddresses (2337)
#endif

/* _ns1__GetCapabilities * has binding name 'PointerTo_ns1__GetCapabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetCapabilities
#define SOAP_TYPE_PointerTo_ns1__GetCapabilities (2333)
#endif

/* _ns1__GetWsdlUrl * has binding name 'PointerTo_ns1__GetWsdlUrl' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetWsdlUrl
#define SOAP_TYPE_PointerTo_ns1__GetWsdlUrl (2329)
#endif

/* _ns1__SetUser * has binding name 'PointerTo_ns1__SetUser' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetUser
#define SOAP_TYPE_PointerTo_ns1__SetUser (2325)
#endif

/* _ns1__DeleteUsers * has binding name 'PointerTo_ns1__DeleteUsers' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DeleteUsers
#define SOAP_TYPE_PointerTo_ns1__DeleteUsers (2321)
#endif

/* _ns1__CreateUsers * has binding name 'PointerTo_ns1__CreateUsers' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CreateUsers
#define SOAP_TYPE_PointerTo_ns1__CreateUsers (2317)
#endif

/* _ns1__GetUsers * has binding name 'PointerTo_ns1__GetUsers' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetUsers
#define SOAP_TYPE_PointerTo_ns1__GetUsers (2313)
#endif

/* _ns1__SetRemoteUser * has binding name 'PointerTo_ns1__SetRemoteUser' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetRemoteUser
#define SOAP_TYPE_PointerTo_ns1__SetRemoteUser (2309)
#endif

/* _ns1__GetRemoteUser * has binding name 'PointerTo_ns1__GetRemoteUser' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetRemoteUser
#define SOAP_TYPE_PointerTo_ns1__GetRemoteUser (2305)
#endif

/* _ns1__GetEndpointReference * has binding name 'PointerTo_ns1__GetEndpointReference' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetEndpointReference
#define SOAP_TYPE_PointerTo_ns1__GetEndpointReference (2301)
#endif

/* _ns1__GetDPAddresses * has binding name 'PointerTo_ns1__GetDPAddresses' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetDPAddresses
#define SOAP_TYPE_PointerTo_ns1__GetDPAddresses (2297)
#endif

/* _ns1__SetRemoteDiscoveryMode * has binding name 'PointerTo_ns1__SetRemoteDiscoveryMode' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetRemoteDiscoveryMode
#define SOAP_TYPE_PointerTo_ns1__SetRemoteDiscoveryMode (2293)
#endif

/* _ns1__GetRemoteDiscoveryMode * has binding name 'PointerTo_ns1__GetRemoteDiscoveryMode' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetRemoteDiscoveryMode
#define SOAP_TYPE_PointerTo_ns1__GetRemoteDiscoveryMode (2289)
#endif

/* _ns1__SetDiscoveryMode * has binding name 'PointerTo_ns1__SetDiscoveryMode' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetDiscoveryMode
#define SOAP_TYPE_PointerTo_ns1__SetDiscoveryMode (2285)
#endif

/* _ns1__GetDiscoveryMode * has binding name 'PointerTo_ns1__GetDiscoveryMode' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetDiscoveryMode
#define SOAP_TYPE_PointerTo_ns1__GetDiscoveryMode (2281)
#endif

/* _ns1__RemoveScopes * has binding name 'PointerTo_ns1__RemoveScopes' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__RemoveScopes
#define SOAP_TYPE_PointerTo_ns1__RemoveScopes (2277)
#endif

/* _ns1__AddScopes * has binding name 'PointerTo_ns1__AddScopes' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__AddScopes
#define SOAP_TYPE_PointerTo_ns1__AddScopes (2273)
#endif

/* _ns1__SetScopes * has binding name 'PointerTo_ns1__SetScopes' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetScopes
#define SOAP_TYPE_PointerTo_ns1__SetScopes (2269)
#endif

/* _ns1__GetScopes * has binding name 'PointerTo_ns1__GetScopes' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetScopes
#define SOAP_TYPE_PointerTo_ns1__GetScopes (2265)
#endif

/* _ns1__GetSystemSupportInformation * has binding name 'PointerTo_ns1__GetSystemSupportInformation' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetSystemSupportInformation
#define SOAP_TYPE_PointerTo_ns1__GetSystemSupportInformation (2261)
#endif

/* _ns1__GetSystemLog * has binding name 'PointerTo_ns1__GetSystemLog' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetSystemLog
#define SOAP_TYPE_PointerTo_ns1__GetSystemLog (2257)
#endif

/* _ns1__GetSystemBackup * has binding name 'PointerTo_ns1__GetSystemBackup' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetSystemBackup
#define SOAP_TYPE_PointerTo_ns1__GetSystemBackup (2253)
#endif

/* _ns1__RestoreSystem * has binding name 'PointerTo_ns1__RestoreSystem' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__RestoreSystem
#define SOAP_TYPE_PointerTo_ns1__RestoreSystem (2249)
#endif

/* _ns1__SystemReboot * has binding name 'PointerTo_ns1__SystemReboot' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SystemReboot
#define SOAP_TYPE_PointerTo_ns1__SystemReboot (2245)
#endif

/* _ns1__UpgradeSystemFirmware * has binding name 'PointerTo_ns1__UpgradeSystemFirmware' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__UpgradeSystemFirmware
#define SOAP_TYPE_PointerTo_ns1__UpgradeSystemFirmware (2241)
#endif

/* _ns1__SetSystemFactoryDefault * has binding name 'PointerTo_ns1__SetSystemFactoryDefault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetSystemFactoryDefault
#define SOAP_TYPE_PointerTo_ns1__SetSystemFactoryDefault (2237)
#endif

/* _ns1__GetSystemDateAndTime * has binding name 'PointerTo_ns1__GetSystemDateAndTime' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetSystemDateAndTime
#define SOAP_TYPE_PointerTo_ns1__GetSystemDateAndTime (2233)
#endif

/* _ns1__SetSystemDateAndTime * has binding name 'PointerTo_ns1__SetSystemDateAndTime' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetSystemDateAndTime
#define SOAP_TYPE_PointerTo_ns1__SetSystemDateAndTime (2229)
#endif

/* _ns1__GetDeviceInformation * has binding name 'PointerTo_ns1__GetDeviceInformation' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetDeviceInformation
#define SOAP_TYPE_PointerTo_ns1__GetDeviceInformation (2225)
#endif

/* _ns1__GetServiceCapabilities * has binding name 'PointerTo_ns1__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetServiceCapabilities
#define SOAP_TYPE_PointerTo_ns1__GetServiceCapabilities (2221)
#endif

/* _ns1__GetServices * has binding name 'PointerTo_ns1__GetServices' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetServices
#define SOAP_TYPE_PointerTo_ns1__GetServices (2217)
#endif

/* ns13__Attribute * has binding name 'PointerTons13__Attribute' for type 'ns13:Attribute' */
#ifndef SOAP_TYPE_PointerTons13__Attribute
#define SOAP_TYPE_PointerTons13__Attribute (2215)
#endif

/* std::string * has binding name 'PointerTons13__Description' for type 'ns13:Description' */
#ifndef SOAP_TYPE_PointerTons13__Description
#define SOAP_TYPE_PointerTons13__Description (2214)
#endif

/* std::string * has binding name 'PointerToxsd__NCName' for type 'xsd:NCName' */
#ifndef SOAP_TYPE_PointerToxsd__NCName
#define SOAP_TYPE_PointerToxsd__NCName (2213)
#endif

/* std::vector<_ns6__TopicNamespaceType_Topic> * has binding name 'PointerTostd__vectorTemplateOf_ns6__TopicNamespaceType_Topic' for type '' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOf_ns6__TopicNamespaceType_Topic
#define SOAP_TYPE_PointerTostd__vectorTemplateOf_ns6__TopicNamespaceType_Topic (2212)
#endif

/* std::string * has binding name 'PointerTons6__ConcreteTopicExpression' for type 'ns6:ConcreteTopicExpression' */
#ifndef SOAP_TYPE_PointerTons6__ConcreteTopicExpression
#define SOAP_TYPE_PointerTons6__ConcreteTopicExpression (2210)
#endif

/* std::string * has binding name 'PointerToxsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_PointerToxsd__QName
#define SOAP_TYPE_PointerToxsd__QName (2209)
#endif

/* ns6__TopicType * has binding name 'PointerTons6__TopicType' for type 'ns6:TopicType' */
#ifndef SOAP_TYPE_PointerTons6__TopicType
#define SOAP_TYPE_PointerTons6__TopicType (2207)
#endif

/* ns6__QueryExpressionType * has binding name 'PointerTons6__QueryExpressionType' for type 'ns6:QueryExpressionType' */
#ifndef SOAP_TYPE_PointerTons6__QueryExpressionType
#define SOAP_TYPE_PointerTons6__QueryExpressionType (2206)
#endif

/* ns2__OSDConfigurationExtension * has binding name 'PointerTons2__OSDConfigurationExtension' for type 'ns2:OSDConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTons2__OSDConfigurationExtension
#define SOAP_TYPE_PointerTons2__OSDConfigurationExtension (2203)
#endif

/* ns2__OSDImgConfiguration * has binding name 'PointerTons2__OSDImgConfiguration' for type 'ns2:OSDImgConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__OSDImgConfiguration
#define SOAP_TYPE_PointerTons2__OSDImgConfiguration (2202)
#endif

/* ns2__OSDTextConfiguration * has binding name 'PointerTons2__OSDTextConfiguration' for type 'ns2:OSDTextConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__OSDTextConfiguration
#define SOAP_TYPE_PointerTons2__OSDTextConfiguration (2201)
#endif

/* ns2__OSDPosConfiguration * has binding name 'PointerTons2__OSDPosConfiguration' for type 'ns2:OSDPosConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__OSDPosConfiguration
#define SOAP_TYPE_PointerTons2__OSDPosConfiguration (2200)
#endif

/* ns2__OSDReference * has binding name 'PointerTons2__OSDReference' for type 'ns2:OSDReference' */
#ifndef SOAP_TYPE_PointerTons2__OSDReference
#define SOAP_TYPE_PointerTons2__OSDReference (2199)
#endif

/* ns2__MetadataInput * has binding name 'PointerTons2__MetadataInput' for type 'ns2:MetadataInput' */
#ifndef SOAP_TYPE_PointerTons2__MetadataInput
#define SOAP_TYPE_PointerTons2__MetadataInput (2198)
#endif

/* ns2__SourceIdentification * has binding name 'PointerTons2__SourceIdentification' for type 'ns2:SourceIdentification' */
#ifndef SOAP_TYPE_PointerTons2__SourceIdentification
#define SOAP_TYPE_PointerTons2__SourceIdentification (2197)
#endif

/* ns2__AnalyticsDeviceEngineConfiguration * has binding name 'PointerTons2__AnalyticsDeviceEngineConfiguration' for type 'ns2:AnalyticsDeviceEngineConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__AnalyticsDeviceEngineConfiguration
#define SOAP_TYPE_PointerTons2__AnalyticsDeviceEngineConfiguration (2196)
#endif

/* ns2__ObjectExtension * has binding name 'PointerTons2__ObjectExtension' for type 'ns2:ObjectExtension' */
#ifndef SOAP_TYPE_PointerTons2__ObjectExtension
#define SOAP_TYPE_PointerTons2__ObjectExtension (2195)
#endif

/* ns2__Behaviour * has binding name 'PointerTons2__Behaviour' for type 'ns2:Behaviour' */
#ifndef SOAP_TYPE_PointerTons2__Behaviour
#define SOAP_TYPE_PointerTons2__Behaviour (2194)
#endif

/* ns2__Appearance * has binding name 'PointerTons2__Appearance' for type 'ns2:Appearance' */
#ifndef SOAP_TYPE_PointerTons2__Appearance
#define SOAP_TYPE_PointerTons2__Appearance (2193)
#endif

/* ns2__PTZConfigurationExtension * has binding name 'PointerTons2__PTZConfigurationExtension' for type 'ns2:PTZConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTons2__PTZConfigurationExtension
#define SOAP_TYPE_PointerTons2__PTZConfigurationExtension (2192)
#endif

/* ns2__ZoomLimits * has binding name 'PointerTons2__ZoomLimits' for type 'ns2:ZoomLimits' */
#ifndef SOAP_TYPE_PointerTons2__ZoomLimits
#define SOAP_TYPE_PointerTons2__ZoomLimits (2191)
#endif

/* ns2__PanTiltLimits * has binding name 'PointerTons2__PanTiltLimits' for type 'ns2:PanTiltLimits' */
#ifndef SOAP_TYPE_PointerTons2__PanTiltLimits
#define SOAP_TYPE_PointerTons2__PanTiltLimits (2190)
#endif

/* ns2__PTZNodeExtension * has binding name 'PointerTons2__PTZNodeExtension' for type 'ns2:PTZNodeExtension' */
#ifndef SOAP_TYPE_PointerTons2__PTZNodeExtension
#define SOAP_TYPE_PointerTons2__PTZNodeExtension (2189)
#endif

/* ns2__DigitalIdleState * has binding name 'PointerTons2__DigitalIdleState' for type 'ns2:DigitalIdleState' */
#ifndef SOAP_TYPE_PointerTons2__DigitalIdleState
#define SOAP_TYPE_PointerTons2__DigitalIdleState (2188)
#endif

/* ns2__NetworkInterfaceExtension * has binding name 'PointerTons2__NetworkInterfaceExtension' for type 'ns2:NetworkInterfaceExtension' */
#ifndef SOAP_TYPE_PointerTons2__NetworkInterfaceExtension
#define SOAP_TYPE_PointerTons2__NetworkInterfaceExtension (2187)
#endif

/* ns2__IPv6NetworkInterface * has binding name 'PointerTons2__IPv6NetworkInterface' for type 'ns2:IPv6NetworkInterface' */
#ifndef SOAP_TYPE_PointerTons2__IPv6NetworkInterface
#define SOAP_TYPE_PointerTons2__IPv6NetworkInterface (2186)
#endif

/* ns2__IPv4NetworkInterface * has binding name 'PointerTons2__IPv4NetworkInterface' for type 'ns2:IPv4NetworkInterface' */
#ifndef SOAP_TYPE_PointerTons2__IPv4NetworkInterface
#define SOAP_TYPE_PointerTons2__IPv4NetworkInterface (2185)
#endif

/* ns2__NetworkInterfaceLink * has binding name 'PointerTons2__NetworkInterfaceLink' for type 'ns2:NetworkInterfaceLink' */
#ifndef SOAP_TYPE_PointerTons2__NetworkInterfaceLink
#define SOAP_TYPE_PointerTons2__NetworkInterfaceLink (2184)
#endif

/* ns2__NetworkInterfaceInfo * has binding name 'PointerTons2__NetworkInterfaceInfo' for type 'ns2:NetworkInterfaceInfo' */
#ifndef SOAP_TYPE_PointerTons2__NetworkInterfaceInfo
#define SOAP_TYPE_PointerTons2__NetworkInterfaceInfo (2183)
#endif

/* ns2__VideoOutputExtension * has binding name 'PointerTons2__VideoOutputExtension' for type 'ns2:VideoOutputExtension' */
#ifndef SOAP_TYPE_PointerTons2__VideoOutputExtension
#define SOAP_TYPE_PointerTons2__VideoOutputExtension (2182)
#endif

/* ns2__MetadataConfigurationExtension * has binding name 'PointerTons2__MetadataConfigurationExtension' for type 'ns2:MetadataConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTons2__MetadataConfigurationExtension
#define SOAP_TYPE_PointerTons2__MetadataConfigurationExtension (2181)
#endif

/* ns2__EventSubscription * has binding name 'PointerTons2__EventSubscription' for type 'ns2:EventSubscription' */
#ifndef SOAP_TYPE_PointerTons2__EventSubscription
#define SOAP_TYPE_PointerTons2__EventSubscription (2180)
#endif

/* ns2__PTZFilter * has binding name 'PointerTons2__PTZFilter' for type 'ns2:PTZFilter' */
#ifndef SOAP_TYPE_PointerTons2__PTZFilter
#define SOAP_TYPE_PointerTons2__PTZFilter (2179)
#endif

/* ns2__RuleEngineConfiguration * has binding name 'PointerTons2__RuleEngineConfiguration' for type 'ns2:RuleEngineConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__RuleEngineConfiguration
#define SOAP_TYPE_PointerTons2__RuleEngineConfiguration (2178)
#endif

/* ns2__AnalyticsEngineConfiguration * has binding name 'PointerTons2__AnalyticsEngineConfiguration' for type 'ns2:AnalyticsEngineConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__AnalyticsEngineConfiguration
#define SOAP_TYPE_PointerTons2__AnalyticsEngineConfiguration (2177)
#endif

/* ns2__VideoRateControl2 * has binding name 'PointerTons2__VideoRateControl2' for type 'ns2:VideoRateControl2' */
#ifndef SOAP_TYPE_PointerTons2__VideoRateControl2
#define SOAP_TYPE_PointerTons2__VideoRateControl2 (2176)
#endif

/* ns2__MulticastConfiguration * has binding name 'PointerTons2__MulticastConfiguration' for type 'ns2:MulticastConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__MulticastConfiguration
#define SOAP_TYPE_PointerTons2__MulticastConfiguration (2175)
#endif

/* ns2__H264Configuration * has binding name 'PointerTons2__H264Configuration' for type 'ns2:H264Configuration' */
#ifndef SOAP_TYPE_PointerTons2__H264Configuration
#define SOAP_TYPE_PointerTons2__H264Configuration (2174)
#endif

/* ns2__Mpeg4Configuration * has binding name 'PointerTons2__Mpeg4Configuration' for type 'ns2:Mpeg4Configuration' */
#ifndef SOAP_TYPE_PointerTons2__Mpeg4Configuration
#define SOAP_TYPE_PointerTons2__Mpeg4Configuration (2173)
#endif

/* ns2__VideoRateControl * has binding name 'PointerTons2__VideoRateControl' for type 'ns2:VideoRateControl' */
#ifndef SOAP_TYPE_PointerTons2__VideoRateControl
#define SOAP_TYPE_PointerTons2__VideoRateControl (2172)
#endif

/* ns2__VideoSourceConfigurationExtension * has binding name 'PointerTons2__VideoSourceConfigurationExtension' for type 'ns2:VideoSourceConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTons2__VideoSourceConfigurationExtension
#define SOAP_TYPE_PointerTons2__VideoSourceConfigurationExtension (2171)
#endif

/* ns2__IntRectangle * has binding name 'PointerTons2__IntRectangle' for type 'ns2:IntRectangle' */
#ifndef SOAP_TYPE_PointerTons2__IntRectangle
#define SOAP_TYPE_PointerTons2__IntRectangle (2170)
#endif

/* ns2__VideoSourceExtension * has binding name 'PointerTons2__VideoSourceExtension' for type 'ns2:VideoSourceExtension' */
#ifndef SOAP_TYPE_PointerTons2__VideoSourceExtension
#define SOAP_TYPE_PointerTons2__VideoSourceExtension (2169)
#endif

/* ns2__ImagingSettings * has binding name 'PointerTons2__ImagingSettings' for type 'ns2:ImagingSettings' */
#ifndef SOAP_TYPE_PointerTons2__ImagingSettings
#define SOAP_TYPE_PointerTons2__ImagingSettings (2168)
#endif

/* ns14__MetadataType * has binding name 'PointerTons14__MetadataType' for type 'ns14:MetadataType' */
#ifndef SOAP_TYPE_PointerTons14__MetadataType
#define SOAP_TYPE_PointerTons14__MetadataType (2167)
#endif

/* ns14__ReferenceParametersType * has binding name 'PointerTons14__ReferenceParametersType' for type 'ns14:ReferenceParametersType' */
#ifndef SOAP_TYPE_PointerTons14__ReferenceParametersType
#define SOAP_TYPE_PointerTons14__ReferenceParametersType (2166)
#endif

/* ns14__AttributedURIType * has binding name 'PointerTons14__AttributedURIType' for type 'ns14:AttributedURIType' */
#ifndef SOAP_TYPE_PointerTons14__AttributedURIType
#define SOAP_TYPE_PointerTons14__AttributedURIType (2165)
#endif

/* ns12__CredentialAccessProfile * has binding name 'PointerTons12__CredentialAccessProfile' for type 'ns12:CredentialAccessProfile' */
#ifndef SOAP_TYPE_PointerTons12__CredentialAccessProfile
#define SOAP_TYPE_PointerTons12__CredentialAccessProfile (2163)
#endif

/* ns12__CredentialIdentifier * has binding name 'PointerTons12__CredentialIdentifier' for type 'ns12:CredentialIdentifier' */
#ifndef SOAP_TYPE_PointerTons12__CredentialIdentifier
#define SOAP_TYPE_PointerTons12__CredentialIdentifier (2161)
#endif

/* ns12__CredentialState * has binding name 'PointerTons12__CredentialState' for type 'ns12:CredentialState' */
#ifndef SOAP_TYPE_PointerTons12__CredentialState
#define SOAP_TYPE_PointerTons12__CredentialState (2160)
#endif

/* ns12__Credential * has binding name 'PointerTons12__Credential' for type 'ns12:Credential' */
#ifndef SOAP_TYPE_PointerTons12__Credential
#define SOAP_TYPE_PointerTons12__Credential (2158)
#endif

/* ns12__CredentialInfo * has binding name 'PointerTons12__CredentialInfo' for type 'ns12:CredentialInfo' */
#ifndef SOAP_TYPE_PointerTons12__CredentialInfo
#define SOAP_TYPE_PointerTons12__CredentialInfo (2156)
#endif

/* ns12__CredentialIdentifierFormatTypeInfo * has binding name 'PointerTons12__CredentialIdentifierFormatTypeInfo' for type 'ns12:CredentialIdentifierFormatTypeInfo' */
#ifndef SOAP_TYPE_PointerTons12__CredentialIdentifierFormatTypeInfo
#define SOAP_TYPE_PointerTons12__CredentialIdentifierFormatTypeInfo (2153)
#endif

/* ns12__ServiceCapabilities * has binding name 'PointerTons12__ServiceCapabilities' for type 'ns12:ServiceCapabilities' */
#ifndef SOAP_TYPE_PointerTons12__ServiceCapabilities
#define SOAP_TYPE_PointerTons12__ServiceCapabilities (2152)
#endif

/* ns12__CredentialIdentifierFormatTypeInfoExtension * has binding name 'PointerTons12__CredentialIdentifierFormatTypeInfoExtension' for type 'ns12:CredentialIdentifierFormatTypeInfoExtension' */
#ifndef SOAP_TYPE_PointerTons12__CredentialIdentifierFormatTypeInfoExtension
#define SOAP_TYPE_PointerTons12__CredentialIdentifierFormatTypeInfoExtension (2151)
#endif

/* ns12__CredentialExtension * has binding name 'PointerTons12__CredentialExtension' for type 'ns12:CredentialExtension' */
#ifndef SOAP_TYPE_PointerTons12__CredentialExtension
#define SOAP_TYPE_PointerTons12__CredentialExtension (2150)
#endif

/* ns12__AntipassbackState * has binding name 'PointerTons12__AntipassbackState' for type 'ns12:AntipassbackState' */
#ifndef SOAP_TYPE_PointerTons12__AntipassbackState
#define SOAP_TYPE_PointerTons12__AntipassbackState (2149)
#endif

/* std::string * has binding name 'PointerTons13__Name' for type 'ns13:Name' */
#ifndef SOAP_TYPE_PointerTons13__Name
#define SOAP_TYPE_PointerTons13__Name (2148)
#endif

/* ns12__CredentialIdentifierType * has binding name 'PointerTons12__CredentialIdentifierType' for type 'ns12:CredentialIdentifierType' */
#ifndef SOAP_TYPE_PointerTons12__CredentialIdentifierType
#define SOAP_TYPE_PointerTons12__CredentialIdentifierType (2147)
#endif

/* ns12__ServiceCapabilitiesExtension * has binding name 'PointerTons12__ServiceCapabilitiesExtension' for type 'ns12:ServiceCapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTons12__ServiceCapabilitiesExtension
#define SOAP_TYPE_PointerTons12__ServiceCapabilitiesExtension (2146)
#endif

/* ns2__PTZPresetTourOptions * has binding name 'PointerTons2__PTZPresetTourOptions' for type 'ns2:PTZPresetTourOptions' */
#ifndef SOAP_TYPE_PointerTons2__PTZPresetTourOptions
#define SOAP_TYPE_PointerTons2__PTZPresetTourOptions (2144)
#endif

/* ns2__PresetTour * has binding name 'PointerTons2__PresetTour' for type 'ns2:PresetTour' */
#ifndef SOAP_TYPE_PointerTons2__PresetTour
#define SOAP_TYPE_PointerTons2__PresetTour (2142)
#endif

/* ns2__PTZPreset * has binding name 'PointerTons2__PTZPreset' for type 'ns2:PTZPreset' */
#ifndef SOAP_TYPE_PointerTons2__PTZPreset
#define SOAP_TYPE_PointerTons2__PTZPreset (2140)
#endif

/* ns2__PTZConfigurationOptions * has binding name 'PointerTons2__PTZConfigurationOptions' for type 'ns2:PTZConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTons2__PTZConfigurationOptions
#define SOAP_TYPE_PointerTons2__PTZConfigurationOptions (2139)
#endif

/* __ns11__SetConfigurationResponse_sequence * has binding name 'PointerTo__ns11__SetConfigurationResponse_sequence' for type '-ns11:SetConfigurationResponse-sequence' */
#ifndef SOAP_TYPE_PointerTo__ns11__SetConfigurationResponse_sequence
#define SOAP_TYPE_PointerTo__ns11__SetConfigurationResponse_sequence (2138)
#endif

/* ns2__PTZNode * has binding name 'PointerTons2__PTZNode' for type 'ns2:PTZNode' */
#ifndef SOAP_TYPE_PointerTons2__PTZNode
#define SOAP_TYPE_PointerTons2__PTZNode (2134)
#endif

/* ns11__Capabilities * has binding name 'PointerTons11__Capabilities' for type 'ns11:Capabilities' */
#ifndef SOAP_TYPE_PointerTons11__Capabilities
#define SOAP_TYPE_PointerTons11__Capabilities (2133)
#endif

/* ns10__VideoSourceMode * has binding name 'PointerTons10__VideoSourceMode' for type 'ns10:VideoSourceMode' */
#ifndef SOAP_TYPE_PointerTons10__VideoSourceMode
#define SOAP_TYPE_PointerTons10__VideoSourceMode (2131)
#endif

/* ns10__EncoderInstanceInfo * has binding name 'PointerTons10__EncoderInstanceInfo' for type 'ns10:EncoderInstanceInfo' */
#ifndef SOAP_TYPE_PointerTons10__EncoderInstanceInfo
#define SOAP_TYPE_PointerTons10__EncoderInstanceInfo (2130)
#endif

/* ns2__AudioEncoder2ConfigurationOptions * has binding name 'PointerTons2__AudioEncoder2ConfigurationOptions' for type 'ns2:AudioEncoder2ConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTons2__AudioEncoder2ConfigurationOptions
#define SOAP_TYPE_PointerTons2__AudioEncoder2ConfigurationOptions (2128)
#endif

/* ns2__VideoEncoder2ConfigurationOptions * has binding name 'PointerTons2__VideoEncoder2ConfigurationOptions' for type 'ns2:VideoEncoder2ConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTons2__VideoEncoder2ConfigurationOptions
#define SOAP_TYPE_PointerTons2__VideoEncoder2ConfigurationOptions (2126)
#endif

/* ns10__MediaProfile * has binding name 'PointerTons10__MediaProfile' for type 'ns10:MediaProfile' */
#ifndef SOAP_TYPE_PointerTons10__MediaProfile
#define SOAP_TYPE_PointerTons10__MediaProfile (2122)
#endif

/* ns10__ConfigurationRef * has binding name 'PointerTons10__ConfigurationRef' for type 'ns10:ConfigurationRef' */
#ifndef SOAP_TYPE_PointerTons10__ConfigurationRef
#define SOAP_TYPE_PointerTons10__ConfigurationRef (2120)
#endif

/* ns10__Capabilities2 * has binding name 'PointerTons10__Capabilities2' for type 'ns10:Capabilities2' */
#ifndef SOAP_TYPE_PointerTons10__Capabilities2
#define SOAP_TYPE_PointerTons10__Capabilities2 (2119)
#endif

/* ns10__EncoderInstance * has binding name 'PointerTons10__EncoderInstance' for type 'ns10:EncoderInstance' */
#ifndef SOAP_TYPE_PointerTons10__EncoderInstance
#define SOAP_TYPE_PointerTons10__EncoderInstance (2117)
#endif

/* ns10__ConfigurationSet * has binding name 'PointerTons10__ConfigurationSet' for type 'ns10:ConfigurationSet' */
#ifndef SOAP_TYPE_PointerTons10__ConfigurationSet
#define SOAP_TYPE_PointerTons10__ConfigurationSet (2116)
#endif

/* ns2__ConfigurationEntity * has binding name 'PointerTons2__ConfigurationEntity' for type 'ns2:ConfigurationEntity' */
#ifndef SOAP_TYPE_PointerTons2__ConfigurationEntity
#define SOAP_TYPE_PointerTons2__ConfigurationEntity (2115)
#endif

/* ns2__AudioEncoder2Configuration * has binding name 'PointerTons2__AudioEncoder2Configuration' for type 'ns2:AudioEncoder2Configuration' */
#ifndef SOAP_TYPE_PointerTons2__AudioEncoder2Configuration
#define SOAP_TYPE_PointerTons2__AudioEncoder2Configuration (2114)
#endif

/* ns2__VideoEncoder2Configuration * has binding name 'PointerTons2__VideoEncoder2Configuration' for type 'ns2:VideoEncoder2Configuration' */
#ifndef SOAP_TYPE_PointerTons2__VideoEncoder2Configuration
#define SOAP_TYPE_PointerTons2__VideoEncoder2Configuration (2113)
#endif

/* ns10__StreamingCapabilities * has binding name 'PointerTons10__StreamingCapabilities' for type 'ns10:StreamingCapabilities' */
#ifndef SOAP_TYPE_PointerTons10__StreamingCapabilities
#define SOAP_TYPE_PointerTons10__StreamingCapabilities (2112)
#endif

/* ns10__ProfileCapabilities * has binding name 'PointerTons10__ProfileCapabilities' for type 'ns10:ProfileCapabilities' */
#ifndef SOAP_TYPE_PointerTons10__ProfileCapabilities
#define SOAP_TYPE_PointerTons10__ProfileCapabilities (2111)
#endif

/* ns2__OSDConfigurationOptions * has binding name 'PointerTons2__OSDConfigurationOptions' for type 'ns2:OSDConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTons2__OSDConfigurationOptions
#define SOAP_TYPE_PointerTons2__OSDConfigurationOptions (2110)
#endif

/* ns2__OSDConfiguration * has binding name 'PointerTons2__OSDConfiguration' for type 'ns2:OSDConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__OSDConfiguration
#define SOAP_TYPE_PointerTons2__OSDConfiguration (2108)
#endif

/* ns9__VideoSourceMode * has binding name 'PointerTons9__VideoSourceMode' for type 'ns9:VideoSourceMode' */
#ifndef SOAP_TYPE_PointerTons9__VideoSourceMode
#define SOAP_TYPE_PointerTons9__VideoSourceMode (2106)
#endif

/* ns2__MediaUri * has binding name 'PointerTons2__MediaUri' for type 'ns2:MediaUri' */
#ifndef SOAP_TYPE_PointerTons2__MediaUri
#define SOAP_TYPE_PointerTons2__MediaUri (2105)
#endif

/* ns2__AudioOutputConfigurationOptions * has binding name 'PointerTons2__AudioOutputConfigurationOptions' for type 'ns2:AudioOutputConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTons2__AudioOutputConfigurationOptions
#define SOAP_TYPE_PointerTons2__AudioOutputConfigurationOptions (2104)
#endif

/* ns2__MetadataConfigurationOptions * has binding name 'PointerTons2__MetadataConfigurationOptions' for type 'ns2:MetadataConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTons2__MetadataConfigurationOptions
#define SOAP_TYPE_PointerTons2__MetadataConfigurationOptions (2103)
#endif

/* ns2__AudioSourceConfigurationOptions * has binding name 'PointerTons2__AudioSourceConfigurationOptions' for type 'ns2:AudioSourceConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTons2__AudioSourceConfigurationOptions
#define SOAP_TYPE_PointerTons2__AudioSourceConfigurationOptions (2102)
#endif

/* ns2__VideoEncoderConfigurationOptions * has binding name 'PointerTons2__VideoEncoderConfigurationOptions' for type 'ns2:VideoEncoderConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTons2__VideoEncoderConfigurationOptions
#define SOAP_TYPE_PointerTons2__VideoEncoderConfigurationOptions (2101)
#endif

/* ns2__VideoSourceConfigurationOptions * has binding name 'PointerTons2__VideoSourceConfigurationOptions' for type 'ns2:VideoSourceConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTons2__VideoSourceConfigurationOptions
#define SOAP_TYPE_PointerTons2__VideoSourceConfigurationOptions (2100)
#endif

/* ns2__Profile * has binding name 'PointerTons2__Profile' for type 'ns2:Profile' */
#ifndef SOAP_TYPE_PointerTons2__Profile
#define SOAP_TYPE_PointerTons2__Profile (2090)
#endif

/* ns2__AudioOutput * has binding name 'PointerTons2__AudioOutput' for type 'ns2:AudioOutput' */
#ifndef SOAP_TYPE_PointerTons2__AudioOutput
#define SOAP_TYPE_PointerTons2__AudioOutput (2088)
#endif

/* ns2__AudioSource * has binding name 'PointerTons2__AudioSource' for type 'ns2:AudioSource' */
#ifndef SOAP_TYPE_PointerTons2__AudioSource
#define SOAP_TYPE_PointerTons2__AudioSource (2086)
#endif

/* ns2__VideoSource * has binding name 'PointerTons2__VideoSource' for type 'ns2:VideoSource' */
#ifndef SOAP_TYPE_PointerTons2__VideoSource
#define SOAP_TYPE_PointerTons2__VideoSource (2084)
#endif

/* ns9__Capabilities * has binding name 'PointerTons9__Capabilities' for type 'ns9:Capabilities' */
#ifndef SOAP_TYPE_PointerTons9__Capabilities
#define SOAP_TYPE_PointerTons9__Capabilities (2083)
#endif

/* ns9__VideoSourceModeExtension * has binding name 'PointerTons9__VideoSourceModeExtension' for type 'ns9:VideoSourceModeExtension' */
#ifndef SOAP_TYPE_PointerTons9__VideoSourceModeExtension
#define SOAP_TYPE_PointerTons9__VideoSourceModeExtension (2082)
#endif

/* std::string * has binding name 'PointerTons2__Description' for type 'ns2:Description' */
#ifndef SOAP_TYPE_PointerTons2__Description
#define SOAP_TYPE_PointerTons2__Description (2081)
#endif

/* ns9__StreamingCapabilities * has binding name 'PointerTons9__StreamingCapabilities' for type 'ns9:StreamingCapabilities' */
#ifndef SOAP_TYPE_PointerTons9__StreamingCapabilities
#define SOAP_TYPE_PointerTons9__StreamingCapabilities (2080)
#endif

/* ns9__ProfileCapabilities * has binding name 'PointerTons9__ProfileCapabilities' for type 'ns9:ProfileCapabilities' */
#ifndef SOAP_TYPE_PointerTons9__ProfileCapabilities
#define SOAP_TYPE_PointerTons9__ProfileCapabilities (2079)
#endif

/* ns8__ImagingPreset * has binding name 'PointerTons8__ImagingPreset' for type 'ns8:ImagingPreset' */
#ifndef SOAP_TYPE_PointerTons8__ImagingPreset
#define SOAP_TYPE_PointerTons8__ImagingPreset (2077)
#endif

/* ns2__ImagingStatus20 * has binding name 'PointerTons2__ImagingStatus20' for type 'ns2:ImagingStatus20' */
#ifndef SOAP_TYPE_PointerTons2__ImagingStatus20
#define SOAP_TYPE_PointerTons2__ImagingStatus20 (2076)
#endif

/* ns2__MoveOptions20 * has binding name 'PointerTons2__MoveOptions20' for type 'ns2:MoveOptions20' */
#ifndef SOAP_TYPE_PointerTons2__MoveOptions20
#define SOAP_TYPE_PointerTons2__MoveOptions20 (2075)
#endif

/* ns2__FocusMove * has binding name 'PointerTons2__FocusMove' for type 'ns2:FocusMove' */
#ifndef SOAP_TYPE_PointerTons2__FocusMove
#define SOAP_TYPE_PointerTons2__FocusMove (2074)
#endif

/* ns2__ImagingOptions20 * has binding name 'PointerTons2__ImagingOptions20' for type 'ns2:ImagingOptions20' */
#ifndef SOAP_TYPE_PointerTons2__ImagingOptions20
#define SOAP_TYPE_PointerTons2__ImagingOptions20 (2073)
#endif

/* ns8__Capabilities * has binding name 'PointerTons8__Capabilities' for type 'ns8:Capabilities' */
#ifndef SOAP_TYPE_PointerTons8__Capabilities
#define SOAP_TYPE_PointerTons8__Capabilities (2072)
#endif

/* ns2__PaneConfiguration * has binding name 'PointerTons2__PaneConfiguration' for type 'ns2:PaneConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__PaneConfiguration
#define SOAP_TYPE_PointerTons2__PaneConfiguration (2070)
#endif

/* ns2__CodingCapabilities * has binding name 'PointerTons2__CodingCapabilities' for type 'ns2:CodingCapabilities' */
#ifndef SOAP_TYPE_PointerTons2__CodingCapabilities
#define SOAP_TYPE_PointerTons2__CodingCapabilities (2069)
#endif

/* ns2__LayoutOptions * has binding name 'PointerTons2__LayoutOptions' for type 'ns2:LayoutOptions' */
#ifndef SOAP_TYPE_PointerTons2__LayoutOptions
#define SOAP_TYPE_PointerTons2__LayoutOptions (2068)
#endif

/* ns2__Layout * has binding name 'PointerTons2__Layout' for type 'ns2:Layout' */
#ifndef SOAP_TYPE_PointerTons2__Layout
#define SOAP_TYPE_PointerTons2__Layout (2067)
#endif

/* ns7__Capabilities * has binding name 'PointerTons7__Capabilities' for type 'ns7:Capabilities' */
#ifndef SOAP_TYPE_PointerTons7__Capabilities
#define SOAP_TYPE_PointerTons7__Capabilities (2066)
#endif

/* ns6__Documentation * has binding name 'PointerTons6__Documentation' for type 'ns6:Documentation' */
#ifndef SOAP_TYPE_PointerTons6__Documentation
#define SOAP_TYPE_PointerTons6__Documentation (2065)
#endif

/* _ns5__BaseFaultType_FaultCause * has binding name 'PointerTo_ns5__BaseFaultType_FaultCause' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns5__BaseFaultType_FaultCause
#define SOAP_TYPE_PointerTo_ns5__BaseFaultType_FaultCause (2064)
#endif

/* std::vector<_ns5__BaseFaultType_Description> * has binding name 'PointerTostd__vectorTemplateOf_ns5__BaseFaultType_Description' for type '' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOf_ns5__BaseFaultType_Description
#define SOAP_TYPE_PointerTostd__vectorTemplateOf_ns5__BaseFaultType_Description (2062)
#endif

/* std::string * has binding name 'PointerTo_xml__lang' for type '' */
#ifndef SOAP_TYPE_PointerTo_xml__lang
#define SOAP_TYPE_PointerTo_xml__lang (2060)
#endif

/* _ns5__BaseFaultType_ErrorCode * has binding name 'PointerTo_ns5__BaseFaultType_ErrorCode' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns5__BaseFaultType_ErrorCode
#define SOAP_TYPE_PointerTo_ns5__BaseFaultType_ErrorCode (2058)
#endif

/* std::string * has binding name 'PointerToxsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_PointerToxsd__nonNegativeInteger
#define SOAP_TYPE_PointerToxsd__nonNegativeInteger (2056)
#endif

/* _ns3__Subscribe_SubscriptionPolicy * has binding name 'PointerTo_ns3__Subscribe_SubscriptionPolicy' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns3__Subscribe_SubscriptionPolicy
#define SOAP_TYPE_PointerTo_ns3__Subscribe_SubscriptionPolicy (2055)
#endif

/* std::string * has binding name 'PointerTons3__AbsoluteOrRelativeTimeType' for type 'ns3:AbsoluteOrRelativeTimeType' */
#ifndef SOAP_TYPE_PointerTons3__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_PointerTons3__AbsoluteOrRelativeTimeType (2053)
#endif

/* ns3__SubscriptionPolicyType * has binding name 'PointerTons3__SubscriptionPolicyType' for type 'ns3:SubscriptionPolicyType' */
#ifndef SOAP_TYPE_PointerTons3__SubscriptionPolicyType
#define SOAP_TYPE_PointerTons3__SubscriptionPolicyType (2051)
#endif

/* ns6__TopicSetType * has binding name 'PointerTons6__TopicSetType' for type 'ns6:TopicSetType' */
#ifndef SOAP_TYPE_PointerTons6__TopicSetType
#define SOAP_TYPE_PointerTons6__TopicSetType (2050)
#endif

/* ns3__TopicExpressionType * has binding name 'PointerTons3__TopicExpressionType' for type 'ns3:TopicExpressionType' */
#ifndef SOAP_TYPE_PointerTons3__TopicExpressionType
#define SOAP_TYPE_PointerTons3__TopicExpressionType (2047)
#endif

/* ns14__EndpointReferenceType * has binding name 'PointerTons14__EndpointReferenceType' for type 'ns14:EndpointReferenceType' */
#ifndef SOAP_TYPE_PointerTons14__EndpointReferenceType
#define SOAP_TYPE_PointerTons14__EndpointReferenceType (2046)
#endif

/* ns2__PropertyOperation * has binding name 'PointerTons2__PropertyOperation' for type 'ns2:PropertyOperation' */
#ifndef SOAP_TYPE_PointerTons2__PropertyOperation
#define SOAP_TYPE_PointerTons2__PropertyOperation (2045)
#endif

/* ns2__MessageExtension * has binding name 'PointerTons2__MessageExtension' for type 'ns2:MessageExtension' */
#ifndef SOAP_TYPE_PointerTons2__MessageExtension
#define SOAP_TYPE_PointerTons2__MessageExtension (2044)
#endif

/* ns2__StorageReferencePathExtension * has binding name 'PointerTons2__StorageReferencePathExtension' for type 'ns2:StorageReferencePathExtension' */
#ifndef SOAP_TYPE_PointerTons2__StorageReferencePathExtension
#define SOAP_TYPE_PointerTons2__StorageReferencePathExtension (2043)
#endif

/* ns2__ArrayOfFileProgressExtension * has binding name 'PointerTons2__ArrayOfFileProgressExtension' for type 'ns2:ArrayOfFileProgressExtension' */
#ifndef SOAP_TYPE_PointerTons2__ArrayOfFileProgressExtension
#define SOAP_TYPE_PointerTons2__ArrayOfFileProgressExtension (2042)
#endif

/* ns2__FileProgress * has binding name 'PointerTons2__FileProgress' for type 'ns2:FileProgress' */
#ifndef SOAP_TYPE_PointerTons2__FileProgress
#define SOAP_TYPE_PointerTons2__FileProgress (2040)
#endif

/* ns2__OSDConfigurationOptionsExtension * has binding name 'PointerTons2__OSDConfigurationOptionsExtension' for type 'ns2:OSDConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_PointerTons2__OSDConfigurationOptionsExtension
#define SOAP_TYPE_PointerTons2__OSDConfigurationOptionsExtension (2039)
#endif

/* ns2__OSDImgOptions * has binding name 'PointerTons2__OSDImgOptions' for type 'ns2:OSDImgOptions' */
#ifndef SOAP_TYPE_PointerTons2__OSDImgOptions
#define SOAP_TYPE_PointerTons2__OSDImgOptions (2038)
#endif

/* ns2__OSDTextOptions * has binding name 'PointerTons2__OSDTextOptions' for type 'ns2:OSDTextOptions' */
#ifndef SOAP_TYPE_PointerTons2__OSDTextOptions
#define SOAP_TYPE_PointerTons2__OSDTextOptions (2037)
#endif

/* ns2__MaximumNumberOfOSDs * has binding name 'PointerTons2__MaximumNumberOfOSDs' for type 'ns2:MaximumNumberOfOSDs' */
#ifndef SOAP_TYPE_PointerTons2__MaximumNumberOfOSDs
#define SOAP_TYPE_PointerTons2__MaximumNumberOfOSDs (2035)
#endif

/* ns2__OSDImgOptionsExtension * has binding name 'PointerTons2__OSDImgOptionsExtension' for type 'ns2:OSDImgOptionsExtension' */
#ifndef SOAP_TYPE_PointerTons2__OSDImgOptionsExtension
#define SOAP_TYPE_PointerTons2__OSDImgOptionsExtension (2034)
#endif

/* ns2__OSDTextOptionsExtension * has binding name 'PointerTons2__OSDTextOptionsExtension' for type 'ns2:OSDTextOptionsExtension' */
#ifndef SOAP_TYPE_PointerTons2__OSDTextOptionsExtension
#define SOAP_TYPE_PointerTons2__OSDTextOptionsExtension (2033)
#endif

/* ns2__OSDColorOptions * has binding name 'PointerTons2__OSDColorOptions' for type 'ns2:OSDColorOptions' */
#ifndef SOAP_TYPE_PointerTons2__OSDColorOptions
#define SOAP_TYPE_PointerTons2__OSDColorOptions (2032)
#endif

/* ns2__OSDColorOptionsExtension * has binding name 'PointerTons2__OSDColorOptionsExtension' for type 'ns2:OSDColorOptionsExtension' */
#ifndef SOAP_TYPE_PointerTons2__OSDColorOptionsExtension
#define SOAP_TYPE_PointerTons2__OSDColorOptionsExtension (2031)
#endif

/* ns2__ColorOptions * has binding name 'PointerTons2__ColorOptions' for type 'ns2:ColorOptions' */
#ifndef SOAP_TYPE_PointerTons2__ColorOptions
#define SOAP_TYPE_PointerTons2__ColorOptions (2030)
#endif

/* std::vector<ns2__ColorspaceRange *> * has binding name 'PointerTostd__vectorTemplateOfPointerTons2__ColorspaceRange' for type 'ns2:ColorspaceRange' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons2__ColorspaceRange
#define SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons2__ColorspaceRange (2028)
#endif

/* ns2__ColorspaceRange * has binding name 'PointerTons2__ColorspaceRange' for type 'ns2:ColorspaceRange' */
#ifndef SOAP_TYPE_PointerTons2__ColorspaceRange
#define SOAP_TYPE_PointerTons2__ColorspaceRange (2026)
#endif

/* std::vector<ns2__Color *> * has binding name 'PointerTostd__vectorTemplateOfPointerTons2__Color' for type 'ns2:Color' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons2__Color
#define SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons2__Color (2025)
#endif

/* ns2__OSDImgConfigurationExtension * has binding name 'PointerTons2__OSDImgConfigurationExtension' for type 'ns2:OSDImgConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTons2__OSDImgConfigurationExtension
#define SOAP_TYPE_PointerTons2__OSDImgConfigurationExtension (2023)
#endif

/* ns2__OSDTextConfigurationExtension * has binding name 'PointerTons2__OSDTextConfigurationExtension' for type 'ns2:OSDTextConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTons2__OSDTextConfigurationExtension
#define SOAP_TYPE_PointerTons2__OSDTextConfigurationExtension (2022)
#endif

/* ns2__OSDColor * has binding name 'PointerTons2__OSDColor' for type 'ns2:OSDColor' */
#ifndef SOAP_TYPE_PointerTons2__OSDColor
#define SOAP_TYPE_PointerTons2__OSDColor (2021)
#endif

/* ns2__OSDPosConfigurationExtension * has binding name 'PointerTons2__OSDPosConfigurationExtension' for type 'ns2:OSDPosConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTons2__OSDPosConfigurationExtension
#define SOAP_TYPE_PointerTons2__OSDPosConfigurationExtension (2020)
#endif

/* ns2__ProfileStatusExtension * has binding name 'PointerTons2__ProfileStatusExtension' for type 'ns2:ProfileStatusExtension' */
#ifndef SOAP_TYPE_PointerTons2__ProfileStatusExtension
#define SOAP_TYPE_PointerTons2__ProfileStatusExtension (2019)
#endif

/* ns2__ActiveConnection * has binding name 'PointerTons2__ActiveConnection' for type 'ns2:ActiveConnection' */
#ifndef SOAP_TYPE_PointerTons2__ActiveConnection
#define SOAP_TYPE_PointerTons2__ActiveConnection (2017)
#endif

/* ns2__AudioClassDescriptorExtension * has binding name 'PointerTons2__AudioClassDescriptorExtension' for type 'ns2:AudioClassDescriptorExtension' */
#ifndef SOAP_TYPE_PointerTons2__AudioClassDescriptorExtension
#define SOAP_TYPE_PointerTons2__AudioClassDescriptorExtension (2016)
#endif

/* ns2__AudioClassCandidate * has binding name 'PointerTons2__AudioClassCandidate' for type 'ns2:AudioClassCandidate' */
#ifndef SOAP_TYPE_PointerTons2__AudioClassCandidate
#define SOAP_TYPE_PointerTons2__AudioClassCandidate (2014)
#endif

/* ns2__ActionEngineEventPayloadExtension * has binding name 'PointerTons2__ActionEngineEventPayloadExtension' for type 'ns2:ActionEngineEventPayloadExtension' */
#ifndef SOAP_TYPE_PointerTons2__ActionEngineEventPayloadExtension
#define SOAP_TYPE_PointerTons2__ActionEngineEventPayloadExtension (2013)
#endif

/* struct SOAP_ENV__Fault * has binding name 'PointerToSOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Fault
#define SOAP_TYPE_PointerToSOAP_ENV__Fault (2012)
#endif

/* std::string * has binding name 'PointerToSOAP_ENV__Envelope' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Envelope
#define SOAP_TYPE_PointerToSOAP_ENV__Envelope (2010)
#endif

/* ns2__AnalyticsState * has binding name 'PointerTons2__AnalyticsState' for type 'ns2:AnalyticsState' */
#ifndef SOAP_TYPE_PointerTons2__AnalyticsState
#define SOAP_TYPE_PointerTons2__AnalyticsState (2009)
#endif

/* ns2__MetadataInputExtension * has binding name 'PointerTons2__MetadataInputExtension' for type 'ns2:MetadataInputExtension' */
#ifndef SOAP_TYPE_PointerTons2__MetadataInputExtension
#define SOAP_TYPE_PointerTons2__MetadataInputExtension (2008)
#endif

/* ns2__SourceIdentificationExtension * has binding name 'PointerTons2__SourceIdentificationExtension' for type 'ns2:SourceIdentificationExtension' */
#ifndef SOAP_TYPE_PointerTons2__SourceIdentificationExtension
#define SOAP_TYPE_PointerTons2__SourceIdentificationExtension (2007)
#endif

/* ns2__AnalyticsEngineInputInfoExtension * has binding name 'PointerTons2__AnalyticsEngineInputInfoExtension' for type 'ns2:AnalyticsEngineInputInfoExtension' */
#ifndef SOAP_TYPE_PointerTons2__AnalyticsEngineInputInfoExtension
#define SOAP_TYPE_PointerTons2__AnalyticsEngineInputInfoExtension (2006)
#endif

/* ns2__AnalyticsEngineInputInfo * has binding name 'PointerTons2__AnalyticsEngineInputInfo' for type 'ns2:AnalyticsEngineInputInfo' */
#ifndef SOAP_TYPE_PointerTons2__AnalyticsEngineInputInfo
#define SOAP_TYPE_PointerTons2__AnalyticsEngineInputInfo (2005)
#endif

/* ns2__AnalyticsDeviceEngineConfigurationExtension * has binding name 'PointerTons2__AnalyticsDeviceEngineConfigurationExtension' for type 'ns2:AnalyticsDeviceEngineConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTons2__AnalyticsDeviceEngineConfigurationExtension
#define SOAP_TYPE_PointerTons2__AnalyticsDeviceEngineConfigurationExtension (2004)
#endif

/* ns2__EngineConfiguration * has binding name 'PointerTons2__EngineConfiguration' for type 'ns2:EngineConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__EngineConfiguration
#define SOAP_TYPE_PointerTons2__EngineConfiguration (2002)
#endif

/* ns2__RecordingJobConfiguration * has binding name 'PointerTons2__RecordingJobConfiguration' for type 'ns2:RecordingJobConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__RecordingJobConfiguration
#define SOAP_TYPE_PointerTons2__RecordingJobConfiguration (2001)
#endif

/* ns2__RecordingJobStateTrack * has binding name 'PointerTons2__RecordingJobStateTrack' for type 'ns2:RecordingJobStateTrack' */
#ifndef SOAP_TYPE_PointerTons2__RecordingJobStateTrack
#define SOAP_TYPE_PointerTons2__RecordingJobStateTrack (1999)
#endif

/* ns2__RecordingJobStateTracks * has binding name 'PointerTons2__RecordingJobStateTracks' for type 'ns2:RecordingJobStateTracks' */
#ifndef SOAP_TYPE_PointerTons2__RecordingJobStateTracks
#define SOAP_TYPE_PointerTons2__RecordingJobStateTracks (1998)
#endif

/* ns2__RecordingJobStateInformationExtension * has binding name 'PointerTons2__RecordingJobStateInformationExtension' for type 'ns2:RecordingJobStateInformationExtension' */
#ifndef SOAP_TYPE_PointerTons2__RecordingJobStateInformationExtension
#define SOAP_TYPE_PointerTons2__RecordingJobStateInformationExtension (1997)
#endif

/* ns2__RecordingJobStateSource * has binding name 'PointerTons2__RecordingJobStateSource' for type 'ns2:RecordingJobStateSource' */
#ifndef SOAP_TYPE_PointerTons2__RecordingJobStateSource
#define SOAP_TYPE_PointerTons2__RecordingJobStateSource (1995)
#endif

/* ns2__RecordingJobSourceExtension * has binding name 'PointerTons2__RecordingJobSourceExtension' for type 'ns2:RecordingJobSourceExtension' */
#ifndef SOAP_TYPE_PointerTons2__RecordingJobSourceExtension
#define SOAP_TYPE_PointerTons2__RecordingJobSourceExtension (1994)
#endif

/* ns2__RecordingJobTrack * has binding name 'PointerTons2__RecordingJobTrack' for type 'ns2:RecordingJobTrack' */
#ifndef SOAP_TYPE_PointerTons2__RecordingJobTrack
#define SOAP_TYPE_PointerTons2__RecordingJobTrack (1992)
#endif

/* ns2__RecordingJobConfigurationExtension * has binding name 'PointerTons2__RecordingJobConfigurationExtension' for type 'ns2:RecordingJobConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTons2__RecordingJobConfigurationExtension
#define SOAP_TYPE_PointerTons2__RecordingJobConfigurationExtension (1991)
#endif

/* ns2__RecordingJobSource * has binding name 'PointerTons2__RecordingJobSource' for type 'ns2:RecordingJobSource' */
#ifndef SOAP_TYPE_PointerTons2__RecordingJobSource
#define SOAP_TYPE_PointerTons2__RecordingJobSource (1989)
#endif

/* ns2__TrackConfiguration * has binding name 'PointerTons2__TrackConfiguration' for type 'ns2:TrackConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__TrackConfiguration
#define SOAP_TYPE_PointerTons2__TrackConfiguration (1988)
#endif

/* ns2__GetTracksResponseItem * has binding name 'PointerTons2__GetTracksResponseItem' for type 'ns2:GetTracksResponseItem' */
#ifndef SOAP_TYPE_PointerTons2__GetTracksResponseItem
#define SOAP_TYPE_PointerTons2__GetTracksResponseItem (1986)
#endif

/* ns2__GetTracksResponseList * has binding name 'PointerTons2__GetTracksResponseList' for type 'ns2:GetTracksResponseList' */
#ifndef SOAP_TYPE_PointerTons2__GetTracksResponseList
#define SOAP_TYPE_PointerTons2__GetTracksResponseList (1985)
#endif

/* ns2__RecordingConfiguration * has binding name 'PointerTons2__RecordingConfiguration' for type 'ns2:RecordingConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__RecordingConfiguration
#define SOAP_TYPE_PointerTons2__RecordingConfiguration (1984)
#endif

/* ns2__TrackAttributesExtension * has binding name 'PointerTons2__TrackAttributesExtension' for type 'ns2:TrackAttributesExtension' */
#ifndef SOAP_TYPE_PointerTons2__TrackAttributesExtension
#define SOAP_TYPE_PointerTons2__TrackAttributesExtension (1983)
#endif

/* ns2__MetadataAttributes * has binding name 'PointerTons2__MetadataAttributes' for type 'ns2:MetadataAttributes' */
#ifndef SOAP_TYPE_PointerTons2__MetadataAttributes
#define SOAP_TYPE_PointerTons2__MetadataAttributes (1982)
#endif

/* ns2__AudioAttributes * has binding name 'PointerTons2__AudioAttributes' for type 'ns2:AudioAttributes' */
#ifndef SOAP_TYPE_PointerTons2__AudioAttributes
#define SOAP_TYPE_PointerTons2__AudioAttributes (1981)
#endif

/* ns2__VideoAttributes * has binding name 'PointerTons2__VideoAttributes' for type 'ns2:VideoAttributes' */
#ifndef SOAP_TYPE_PointerTons2__VideoAttributes
#define SOAP_TYPE_PointerTons2__VideoAttributes (1980)
#endif

/* ns2__TrackAttributes * has binding name 'PointerTons2__TrackAttributes' for type 'ns2:TrackAttributes' */
#ifndef SOAP_TYPE_PointerTons2__TrackAttributes
#define SOAP_TYPE_PointerTons2__TrackAttributes (1978)
#endif

/* ns2__TrackInformation * has binding name 'PointerTons2__TrackInformation' for type 'ns2:TrackInformation' */
#ifndef SOAP_TYPE_PointerTons2__TrackInformation
#define SOAP_TYPE_PointerTons2__TrackInformation (1976)
#endif

/* ns2__RecordingSourceInformation * has binding name 'PointerTons2__RecordingSourceInformation' for type 'ns2:RecordingSourceInformation' */
#ifndef SOAP_TYPE_PointerTons2__RecordingSourceInformation
#define SOAP_TYPE_PointerTons2__RecordingSourceInformation (1975)
#endif

/* ns2__FindMetadataResult * has binding name 'PointerTons2__FindMetadataResult' for type 'ns2:FindMetadataResult' */
#ifndef SOAP_TYPE_PointerTons2__FindMetadataResult
#define SOAP_TYPE_PointerTons2__FindMetadataResult (1973)
#endif

/* ns2__FindPTZPositionResult * has binding name 'PointerTons2__FindPTZPositionResult' for type 'ns2:FindPTZPositionResult' */
#ifndef SOAP_TYPE_PointerTons2__FindPTZPositionResult
#define SOAP_TYPE_PointerTons2__FindPTZPositionResult (1971)
#endif

/* ns2__FindEventResult * has binding name 'PointerTons2__FindEventResult' for type 'ns2:FindEventResult' */
#ifndef SOAP_TYPE_PointerTons2__FindEventResult
#define SOAP_TYPE_PointerTons2__FindEventResult (1969)
#endif

/* ns2__RecordingInformation * has binding name 'PointerTons2__RecordingInformation' for type 'ns2:RecordingInformation' */
#ifndef SOAP_TYPE_PointerTons2__RecordingInformation
#define SOAP_TYPE_PointerTons2__RecordingInformation (1967)
#endif

/* ns2__SearchScopeExtension * has binding name 'PointerTons2__SearchScopeExtension' for type 'ns2:SearchScopeExtension' */
#ifndef SOAP_TYPE_PointerTons2__SearchScopeExtension
#define SOAP_TYPE_PointerTons2__SearchScopeExtension (1966)
#endif

/* std::string * has binding name 'PointerTons2__XPathExpression' for type 'ns2:XPathExpression' */
#ifndef SOAP_TYPE_PointerTons2__XPathExpression
#define SOAP_TYPE_PointerTons2__XPathExpression (1965)
#endif

/* ns2__SourceReference * has binding name 'PointerTons2__SourceReference' for type 'ns2:SourceReference' */
#ifndef SOAP_TYPE_PointerTons2__SourceReference
#define SOAP_TYPE_PointerTons2__SourceReference (1962)
#endif

/* ns2__StreamSetup * has binding name 'PointerTons2__StreamSetup' for type 'ns2:StreamSetup' */
#ifndef SOAP_TYPE_PointerTons2__StreamSetup
#define SOAP_TYPE_PointerTons2__StreamSetup (1961)
#endif

/* ns2__ReceiverConfiguration * has binding name 'PointerTons2__ReceiverConfiguration' for type 'ns2:ReceiverConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__ReceiverConfiguration
#define SOAP_TYPE_PointerTons2__ReceiverConfiguration (1960)
#endif

/* ns2__PaneOptionExtension * has binding name 'PointerTons2__PaneOptionExtension' for type 'ns2:PaneOptionExtension' */
#ifndef SOAP_TYPE_PointerTons2__PaneOptionExtension
#define SOAP_TYPE_PointerTons2__PaneOptionExtension (1959)
#endif

/* ns2__LayoutOptionsExtension * has binding name 'PointerTons2__LayoutOptionsExtension' for type 'ns2:LayoutOptionsExtension' */
#ifndef SOAP_TYPE_PointerTons2__LayoutOptionsExtension
#define SOAP_TYPE_PointerTons2__LayoutOptionsExtension (1957)
#endif

/* ns2__PaneLayoutOptions * has binding name 'PointerTons2__PaneLayoutOptions' for type 'ns2:PaneLayoutOptions' */
#ifndef SOAP_TYPE_PointerTons2__PaneLayoutOptions
#define SOAP_TYPE_PointerTons2__PaneLayoutOptions (1955)
#endif

/* ns2__VideoDecoderConfigurationOptions * has binding name 'PointerTons2__VideoDecoderConfigurationOptions' for type 'ns2:VideoDecoderConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTons2__VideoDecoderConfigurationOptions
#define SOAP_TYPE_PointerTons2__VideoDecoderConfigurationOptions (1954)
#endif

/* ns2__AudioDecoderConfigurationOptions * has binding name 'PointerTons2__AudioDecoderConfigurationOptions' for type 'ns2:AudioDecoderConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTons2__AudioDecoderConfigurationOptions
#define SOAP_TYPE_PointerTons2__AudioDecoderConfigurationOptions (1953)
#endif

/* ns2__AudioEncoderConfigurationOptions * has binding name 'PointerTons2__AudioEncoderConfigurationOptions' for type 'ns2:AudioEncoderConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTons2__AudioEncoderConfigurationOptions
#define SOAP_TYPE_PointerTons2__AudioEncoderConfigurationOptions (1952)
#endif

/* ns2__LayoutExtension * has binding name 'PointerTons2__LayoutExtension' for type 'ns2:LayoutExtension' */
#ifndef SOAP_TYPE_PointerTons2__LayoutExtension
#define SOAP_TYPE_PointerTons2__LayoutExtension (1951)
#endif

/* ns2__PaneLayout * has binding name 'PointerTons2__PaneLayout' for type 'ns2:PaneLayout' */
#ifndef SOAP_TYPE_PointerTons2__PaneLayout
#define SOAP_TYPE_PointerTons2__PaneLayout (1949)
#endif

/* __ns2__union_EventStream * has binding name 'PointerTo__ns2__union_EventStream' for type '-ns2:union-EventStream' */
#ifndef SOAP_TYPE_PointerTo__ns2__union_EventStream
#define SOAP_TYPE_PointerTo__ns2__union_EventStream (1948)
#endif

/* ns2__EventStreamExtension * has binding name 'PointerTons2__EventStreamExtension' for type 'ns2:EventStreamExtension' */
#ifndef SOAP_TYPE_PointerTons2__EventStreamExtension
#define SOAP_TYPE_PointerTons2__EventStreamExtension (1946)
#endif

/* ns3__NotificationMessageHolderType * has binding name 'PointerTons3__NotificationMessageHolderType' for type 'ns3:NotificationMessageHolderType' */
#ifndef SOAP_TYPE_PointerTons3__NotificationMessageHolderType
#define SOAP_TYPE_PointerTons3__NotificationMessageHolderType (1945)
#endif

/* __ns2__union_PTZStream * has binding name 'PointerTo__ns2__union_PTZStream' for type '-ns2:union-PTZStream' */
#ifndef SOAP_TYPE_PointerTo__ns2__union_PTZStream
#define SOAP_TYPE_PointerTo__ns2__union_PTZStream (1943)
#endif

/* ns2__PTZStreamExtension * has binding name 'PointerTons2__PTZStreamExtension' for type 'ns2:PTZStreamExtension' */
#ifndef SOAP_TYPE_PointerTons2__PTZStreamExtension
#define SOAP_TYPE_PointerTons2__PTZStreamExtension (1941)
#endif

/* __ns2__union_VideoAnalyticsStream * has binding name 'PointerTo__ns2__union_VideoAnalyticsStream' for type '-ns2:union-VideoAnalyticsStream' */
#ifndef SOAP_TYPE_PointerTo__ns2__union_VideoAnalyticsStream
#define SOAP_TYPE_PointerTo__ns2__union_VideoAnalyticsStream (1939)
#endif

/* ns2__VideoAnalyticsStreamExtension * has binding name 'PointerTons2__VideoAnalyticsStreamExtension' for type 'ns2:VideoAnalyticsStreamExtension' */
#ifndef SOAP_TYPE_PointerTons2__VideoAnalyticsStreamExtension
#define SOAP_TYPE_PointerTons2__VideoAnalyticsStreamExtension (1937)
#endif

/* ns2__Frame * has binding name 'PointerTons2__Frame' for type 'ns2:Frame' */
#ifndef SOAP_TYPE_PointerTons2__Frame
#define SOAP_TYPE_PointerTons2__Frame (1936)
#endif

/* ns2__AudioAnalyticsStreamExtension * has binding name 'PointerTons2__AudioAnalyticsStreamExtension' for type 'ns2:AudioAnalyticsStreamExtension' */
#ifndef SOAP_TYPE_PointerTons2__AudioAnalyticsStreamExtension
#define SOAP_TYPE_PointerTons2__AudioAnalyticsStreamExtension (1934)
#endif

/* ns2__AudioDescriptor * has binding name 'PointerTons2__AudioDescriptor' for type 'ns2:AudioDescriptor' */
#ifndef SOAP_TYPE_PointerTons2__AudioDescriptor
#define SOAP_TYPE_PointerTons2__AudioDescriptor (1932)
#endif

/* ns2__MetadataStreamExtension2 * has binding name 'PointerTons2__MetadataStreamExtension2' for type 'ns2:MetadataStreamExtension2' */
#ifndef SOAP_TYPE_PointerTons2__MetadataStreamExtension2
#define SOAP_TYPE_PointerTons2__MetadataStreamExtension2 (1931)
#endif

/* ns2__AudioAnalyticsStream * has binding name 'PointerTons2__AudioAnalyticsStream' for type 'ns2:AudioAnalyticsStream' */
#ifndef SOAP_TYPE_PointerTons2__AudioAnalyticsStream
#define SOAP_TYPE_PointerTons2__AudioAnalyticsStream (1930)
#endif

/* __ns2__union_MetadataStream * has binding name 'PointerTo__ns2__union_MetadataStream' for type '-ns2:union-MetadataStream' */
#ifndef SOAP_TYPE_PointerTo__ns2__union_MetadataStream
#define SOAP_TYPE_PointerTo__ns2__union_MetadataStream (1929)
#endif

/* ns2__MetadataStreamExtension * has binding name 'PointerTons2__MetadataStreamExtension' for type 'ns2:MetadataStreamExtension' */
#ifndef SOAP_TYPE_PointerTons2__MetadataStreamExtension
#define SOAP_TYPE_PointerTons2__MetadataStreamExtension (1927)
#endif

/* ns2__EventStream * has binding name 'PointerTons2__EventStream' for type 'ns2:EventStream' */
#ifndef SOAP_TYPE_PointerTons2__EventStream
#define SOAP_TYPE_PointerTons2__EventStream (1926)
#endif

/* ns2__PTZStream * has binding name 'PointerTons2__PTZStream' for type 'ns2:PTZStream' */
#ifndef SOAP_TYPE_PointerTons2__PTZStream
#define SOAP_TYPE_PointerTons2__PTZStream (1925)
#endif

/* ns2__VideoAnalyticsStream * has binding name 'PointerTons2__VideoAnalyticsStream' for type 'ns2:VideoAnalyticsStream' */
#ifndef SOAP_TYPE_PointerTons2__VideoAnalyticsStream
#define SOAP_TYPE_PointerTons2__VideoAnalyticsStream (1924)
#endif

/* ns2__MotionExpression * has binding name 'PointerTons2__MotionExpression' for type 'ns2:MotionExpression' */
#ifndef SOAP_TYPE_PointerTons2__MotionExpression
#define SOAP_TYPE_PointerTons2__MotionExpression (1922)
#endif

/* ns2__PolylineArray * has binding name 'PointerTons2__PolylineArray' for type 'ns2:PolylineArray' */
#ifndef SOAP_TYPE_PointerTons2__PolylineArray
#define SOAP_TYPE_PointerTons2__PolylineArray (1921)
#endif

/* ns2__PolylineArrayExtension * has binding name 'PointerTons2__PolylineArrayExtension' for type 'ns2:PolylineArrayExtension' */
#ifndef SOAP_TYPE_PointerTons2__PolylineArrayExtension
#define SOAP_TYPE_PointerTons2__PolylineArrayExtension (1920)
#endif

/* ns2__Polyline * has binding name 'PointerTons2__Polyline' for type 'ns2:Polyline' */
#ifndef SOAP_TYPE_PointerTons2__Polyline
#define SOAP_TYPE_PointerTons2__Polyline (1918)
#endif

/* ns2__SupportedAnalyticsModulesExtension * has binding name 'PointerTons2__SupportedAnalyticsModulesExtension' for type 'ns2:SupportedAnalyticsModulesExtension' */
#ifndef SOAP_TYPE_PointerTons2__SupportedAnalyticsModulesExtension
#define SOAP_TYPE_PointerTons2__SupportedAnalyticsModulesExtension (1917)
#endif

/* ns2__SupportedRulesExtension * has binding name 'PointerTons2__SupportedRulesExtension' for type 'ns2:SupportedRulesExtension' */
#ifndef SOAP_TYPE_PointerTons2__SupportedRulesExtension
#define SOAP_TYPE_PointerTons2__SupportedRulesExtension (1916)
#endif

/* ns2__ConfigDescription * has binding name 'PointerTons2__ConfigDescription' for type 'ns2:ConfigDescription' */
#ifndef SOAP_TYPE_PointerTons2__ConfigDescription
#define SOAP_TYPE_PointerTons2__ConfigDescription (1914)
#endif

/* ns2__ConfigDescriptionExtension * has binding name 'PointerTons2__ConfigDescriptionExtension' for type 'ns2:ConfigDescriptionExtension' */
#ifndef SOAP_TYPE_PointerTons2__ConfigDescriptionExtension
#define SOAP_TYPE_PointerTons2__ConfigDescriptionExtension (1913)
#endif

/* std::vector<_ns2__ConfigDescription_Messages> * has binding name 'PointerTostd__vectorTemplateOf_ns2__ConfigDescription_Messages' for type '' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOf_ns2__ConfigDescription_Messages
#define SOAP_TYPE_PointerTostd__vectorTemplateOf_ns2__ConfigDescription_Messages (1912)
#endif

/* ns2__ItemList * has binding name 'PointerTons2__ItemList' for type 'ns2:ItemList' */
#ifndef SOAP_TYPE_PointerTons2__ItemList
#define SOAP_TYPE_PointerTons2__ItemList (1909)
#endif

/* ns2__RuleEngineConfigurationExtension * has binding name 'PointerTons2__RuleEngineConfigurationExtension' for type 'ns2:RuleEngineConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTons2__RuleEngineConfigurationExtension
#define SOAP_TYPE_PointerTons2__RuleEngineConfigurationExtension (1908)
#endif

/* ns2__AnalyticsEngineConfigurationExtension * has binding name 'PointerTons2__AnalyticsEngineConfigurationExtension' for type 'ns2:AnalyticsEngineConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTons2__AnalyticsEngineConfigurationExtension
#define SOAP_TYPE_PointerTons2__AnalyticsEngineConfigurationExtension (1907)
#endif

/* ns2__Config * has binding name 'PointerTons2__Config' for type 'ns2:Config' */
#ifndef SOAP_TYPE_PointerTons2__Config
#define SOAP_TYPE_PointerTons2__Config (1905)
#endif

/* ns2__ObjectTreeExtension * has binding name 'PointerTons2__ObjectTreeExtension' for type 'ns2:ObjectTreeExtension' */
#ifndef SOAP_TYPE_PointerTons2__ObjectTreeExtension
#define SOAP_TYPE_PointerTons2__ObjectTreeExtension (1904)
#endif

/* ns2__Merge * has binding name 'PointerTons2__Merge' for type 'ns2:Merge' */
#ifndef SOAP_TYPE_PointerTons2__Merge
#define SOAP_TYPE_PointerTons2__Merge (1902)
#endif

/* ns2__Split * has binding name 'PointerTons2__Split' for type 'ns2:Split' */
#ifndef SOAP_TYPE_PointerTons2__Split
#define SOAP_TYPE_PointerTons2__Split (1900)
#endif

/* ns2__Rename * has binding name 'PointerTons2__Rename' for type 'ns2:Rename' */
#ifndef SOAP_TYPE_PointerTons2__Rename
#define SOAP_TYPE_PointerTons2__Rename (1898)
#endif

/* ns2__BehaviourExtension * has binding name 'PointerTons2__BehaviourExtension' for type 'ns2:BehaviourExtension' */
#ifndef SOAP_TYPE_PointerTons2__BehaviourExtension
#define SOAP_TYPE_PointerTons2__BehaviourExtension (1897)
#endif

/* _ns2__Behaviour_Idle * has binding name 'PointerTo_ns2__Behaviour_Idle' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns2__Behaviour_Idle
#define SOAP_TYPE_PointerTo_ns2__Behaviour_Idle (1896)
#endif

/* _ns2__Behaviour_Removed * has binding name 'PointerTo_ns2__Behaviour_Removed' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns2__Behaviour_Removed
#define SOAP_TYPE_PointerTo_ns2__Behaviour_Removed (1894)
#endif

/* std::string * has binding name 'PointerToxsd__integer' for type 'xsd:integer' */
#ifndef SOAP_TYPE_PointerToxsd__integer
#define SOAP_TYPE_PointerToxsd__integer (1892)
#endif

/* ns2__ObjectId * has binding name 'PointerTons2__ObjectId' for type 'ns2:ObjectId' */
#ifndef SOAP_TYPE_PointerTons2__ObjectId
#define SOAP_TYPE_PointerTons2__ObjectId (1890)
#endif

/* ns2__FrameExtension2 * has binding name 'PointerTons2__FrameExtension2' for type 'ns2:FrameExtension2' */
#ifndef SOAP_TYPE_PointerTons2__FrameExtension2
#define SOAP_TYPE_PointerTons2__FrameExtension2 (1889)
#endif

/* ns2__MotionInCells * has binding name 'PointerTons2__MotionInCells' for type 'ns2:MotionInCells' */
#ifndef SOAP_TYPE_PointerTons2__MotionInCells
#define SOAP_TYPE_PointerTons2__MotionInCells (1888)
#endif

/* ns2__FrameExtension * has binding name 'PointerTons2__FrameExtension' for type 'ns2:FrameExtension' */
#ifndef SOAP_TYPE_PointerTons2__FrameExtension
#define SOAP_TYPE_PointerTons2__FrameExtension (1887)
#endif

/* ns2__ObjectTree * has binding name 'PointerTons2__ObjectTree' for type 'ns2:ObjectTree' */
#ifndef SOAP_TYPE_PointerTons2__ObjectTree
#define SOAP_TYPE_PointerTons2__ObjectTree (1886)
#endif

/* ns2__Object * has binding name 'PointerTons2__Object' for type 'ns2:Object' */
#ifndef SOAP_TYPE_PointerTons2__Object
#define SOAP_TYPE_PointerTons2__Object (1884)
#endif

/* ns2__PTZStatus * has binding name 'PointerTons2__PTZStatus' for type 'ns2:PTZStatus' */
#ifndef SOAP_TYPE_PointerTons2__PTZStatus
#define SOAP_TYPE_PointerTons2__PTZStatus (1883)
#endif

/* ns2__TransformationExtension * has binding name 'PointerTons2__TransformationExtension' for type 'ns2:TransformationExtension' */
#ifndef SOAP_TYPE_PointerTons2__TransformationExtension
#define SOAP_TYPE_PointerTons2__TransformationExtension (1882)
#endif

/* ns2__ClassDescriptorExtension2 * has binding name 'PointerTons2__ClassDescriptorExtension2' for type 'ns2:ClassDescriptorExtension2' */
#ifndef SOAP_TYPE_PointerTons2__ClassDescriptorExtension2
#define SOAP_TYPE_PointerTons2__ClassDescriptorExtension2 (1881)
#endif

/* ns2__OtherType * has binding name 'PointerTons2__OtherType' for type 'ns2:OtherType' */
#ifndef SOAP_TYPE_PointerTons2__OtherType
#define SOAP_TYPE_PointerTons2__OtherType (1879)
#endif

/* ns2__ClassDescriptorExtension * has binding name 'PointerTons2__ClassDescriptorExtension' for type 'ns2:ClassDescriptorExtension' */
#ifndef SOAP_TYPE_PointerTons2__ClassDescriptorExtension
#define SOAP_TYPE_PointerTons2__ClassDescriptorExtension (1878)
#endif

/* std::vector<_ns2__ClassDescriptor_ClassCandidate> * has binding name 'PointerTostd__vectorTemplateOf_ns2__ClassDescriptor_ClassCandidate' for type '' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOf_ns2__ClassDescriptor_ClassCandidate
#define SOAP_TYPE_PointerTostd__vectorTemplateOf_ns2__ClassDescriptor_ClassCandidate (1877)
#endif

/* ns2__ColorDescriptorExtension * has binding name 'PointerTons2__ColorDescriptorExtension' for type 'ns2:ColorDescriptorExtension' */
#ifndef SOAP_TYPE_PointerTons2__ColorDescriptorExtension
#define SOAP_TYPE_PointerTons2__ColorDescriptorExtension (1874)
#endif

/* std::vector<_ns2__ColorDescriptor_ColorCluster> * has binding name 'PointerTostd__vectorTemplateOf_ns2__ColorDescriptor_ColorCluster' for type '' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOf_ns2__ColorDescriptor_ColorCluster
#define SOAP_TYPE_PointerTostd__vectorTemplateOf_ns2__ColorDescriptor_ColorCluster (1873)
#endif

/* ns2__ColorCovariance * has binding name 'PointerTons2__ColorCovariance' for type 'ns2:ColorCovariance' */
#ifndef SOAP_TYPE_PointerTons2__ColorCovariance
#define SOAP_TYPE_PointerTons2__ColorCovariance (1871)
#endif

/* ns2__Color * has binding name 'PointerTons2__Color' for type 'ns2:Color' */
#ifndef SOAP_TYPE_PointerTons2__Color
#define SOAP_TYPE_PointerTons2__Color (1870)
#endif

/* ns2__ShapeDescriptorExtension * has binding name 'PointerTons2__ShapeDescriptorExtension' for type 'ns2:ShapeDescriptorExtension' */
#ifndef SOAP_TYPE_PointerTons2__ShapeDescriptorExtension
#define SOAP_TYPE_PointerTons2__ShapeDescriptorExtension (1868)
#endif

/* ns2__Polygon * has binding name 'PointerTons2__Polygon' for type 'ns2:Polygon' */
#ifndef SOAP_TYPE_PointerTons2__Polygon
#define SOAP_TYPE_PointerTons2__Polygon (1866)
#endif

/* ns2__AppearanceExtension * has binding name 'PointerTons2__AppearanceExtension' for type 'ns2:AppearanceExtension' */
#ifndef SOAP_TYPE_PointerTons2__AppearanceExtension
#define SOAP_TYPE_PointerTons2__AppearanceExtension (1865)
#endif

/* ns2__ClassDescriptor * has binding name 'PointerTons2__ClassDescriptor' for type 'ns2:ClassDescriptor' */
#ifndef SOAP_TYPE_PointerTons2__ClassDescriptor
#define SOAP_TYPE_PointerTons2__ClassDescriptor (1864)
#endif

/* ns2__ColorDescriptor * has binding name 'PointerTons2__ColorDescriptor' for type 'ns2:ColorDescriptor' */
#ifndef SOAP_TYPE_PointerTons2__ColorDescriptor
#define SOAP_TYPE_PointerTons2__ColorDescriptor (1863)
#endif

/* ns2__ShapeDescriptor * has binding name 'PointerTons2__ShapeDescriptor' for type 'ns2:ShapeDescriptor' */
#ifndef SOAP_TYPE_PointerTons2__ShapeDescriptor
#define SOAP_TYPE_PointerTons2__ShapeDescriptor (1862)
#endif

/* ns2__Transformation * has binding name 'PointerTons2__Transformation' for type 'ns2:Transformation' */
#ifndef SOAP_TYPE_PointerTons2__Transformation
#define SOAP_TYPE_PointerTons2__Transformation (1861)
#endif

/* ns2__Vector * has binding name 'PointerTons2__Vector' for type 'ns2:Vector' */
#ifndef SOAP_TYPE_PointerTons2__Vector
#define SOAP_TYPE_PointerTons2__Vector (1859)
#endif

/* ns2__ItemListDescriptionExtension * has binding name 'PointerTons2__ItemListDescriptionExtension' for type 'ns2:ItemListDescriptionExtension' */
#ifndef SOAP_TYPE_PointerTons2__ItemListDescriptionExtension
#define SOAP_TYPE_PointerTons2__ItemListDescriptionExtension (1858)
#endif

/* std::vector<_ns2__ItemListDescription_ElementItemDescription> * has binding name 'PointerTostd__vectorTemplateOf_ns2__ItemListDescription_ElementItemDescription' for type '' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOf_ns2__ItemListDescription_ElementItemDescription
#define SOAP_TYPE_PointerTostd__vectorTemplateOf_ns2__ItemListDescription_ElementItemDescription (1857)
#endif

/* std::vector<_ns2__ItemListDescription_SimpleItemDescription> * has binding name 'PointerTostd__vectorTemplateOf_ns2__ItemListDescription_SimpleItemDescription' for type '' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOf_ns2__ItemListDescription_SimpleItemDescription
#define SOAP_TYPE_PointerTostd__vectorTemplateOf_ns2__ItemListDescription_SimpleItemDescription (1854)
#endif

/* ns2__MessageDescriptionExtension * has binding name 'PointerTons2__MessageDescriptionExtension' for type 'ns2:MessageDescriptionExtension' */
#ifndef SOAP_TYPE_PointerTons2__MessageDescriptionExtension
#define SOAP_TYPE_PointerTons2__MessageDescriptionExtension (1851)
#endif

/* ns2__ItemListDescription * has binding name 'PointerTons2__ItemListDescription' for type 'ns2:ItemListDescription' */
#ifndef SOAP_TYPE_PointerTons2__ItemListDescription
#define SOAP_TYPE_PointerTons2__ItemListDescription (1850)
#endif

/* ns2__ItemListExtension * has binding name 'PointerTons2__ItemListExtension' for type 'ns2:ItemListExtension' */
#ifndef SOAP_TYPE_PointerTons2__ItemListExtension
#define SOAP_TYPE_PointerTons2__ItemListExtension (1849)
#endif

/* std::vector<_ns2__ItemList_ElementItem> * has binding name 'PointerTostd__vectorTemplateOf_ns2__ItemList_ElementItem' for type '' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOf_ns2__ItemList_ElementItem
#define SOAP_TYPE_PointerTostd__vectorTemplateOf_ns2__ItemList_ElementItem (1848)
#endif

/* std::vector<_ns2__ItemList_SimpleItem> * has binding name 'PointerTostd__vectorTemplateOf_ns2__ItemList_SimpleItem' for type '' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOf_ns2__ItemList_SimpleItem
#define SOAP_TYPE_PointerTostd__vectorTemplateOf_ns2__ItemList_SimpleItem (1845)
#endif

/* ns2__FocusOptions20Extension * has binding name 'PointerTons2__FocusOptions20Extension' for type 'ns2:FocusOptions20Extension' */
#ifndef SOAP_TYPE_PointerTons2__FocusOptions20Extension
#define SOAP_TYPE_PointerTons2__FocusOptions20Extension (1842)
#endif

/* ns2__WhiteBalanceOptions20Extension * has binding name 'PointerTons2__WhiteBalanceOptions20Extension' for type 'ns2:WhiteBalanceOptions20Extension' */
#ifndef SOAP_TYPE_PointerTons2__WhiteBalanceOptions20Extension
#define SOAP_TYPE_PointerTons2__WhiteBalanceOptions20Extension (1841)
#endif

/* ns2__FocusConfiguration20Extension * has binding name 'PointerTons2__FocusConfiguration20Extension' for type 'ns2:FocusConfiguration20Extension' */
#ifndef SOAP_TYPE_PointerTons2__FocusConfiguration20Extension
#define SOAP_TYPE_PointerTons2__FocusConfiguration20Extension (1840)
#endif

/* ns2__WhiteBalance20Extension * has binding name 'PointerTons2__WhiteBalance20Extension' for type 'ns2:WhiteBalance20Extension' */
#ifndef SOAP_TYPE_PointerTons2__WhiteBalance20Extension
#define SOAP_TYPE_PointerTons2__WhiteBalance20Extension (1839)
#endif

/* ns2__RelativeFocusOptions20 * has binding name 'PointerTons2__RelativeFocusOptions20' for type 'ns2:RelativeFocusOptions20' */
#ifndef SOAP_TYPE_PointerTons2__RelativeFocusOptions20
#define SOAP_TYPE_PointerTons2__RelativeFocusOptions20 (1838)
#endif

/* ns2__IrCutFilterAutoAdjustmentOptionsExtension * has binding name 'PointerTons2__IrCutFilterAutoAdjustmentOptionsExtension' for type 'ns2:IrCutFilterAutoAdjustmentOptionsExtension' */
#ifndef SOAP_TYPE_PointerTons2__IrCutFilterAutoAdjustmentOptionsExtension
#define SOAP_TYPE_PointerTons2__IrCutFilterAutoAdjustmentOptionsExtension (1836)
#endif

/* ns2__ImageStabilizationOptionsExtension * has binding name 'PointerTons2__ImageStabilizationOptionsExtension' for type 'ns2:ImageStabilizationOptionsExtension' */
#ifndef SOAP_TYPE_PointerTons2__ImageStabilizationOptionsExtension
#define SOAP_TYPE_PointerTons2__ImageStabilizationOptionsExtension (1835)
#endif

/* ns2__ImagingOptions20Extension4 * has binding name 'PointerTons2__ImagingOptions20Extension4' for type 'ns2:ImagingOptions20Extension4' */
#ifndef SOAP_TYPE_PointerTons2__ImagingOptions20Extension4
#define SOAP_TYPE_PointerTons2__ImagingOptions20Extension4 (1833)
#endif

/* ns2__NoiseReductionOptions * has binding name 'PointerTons2__NoiseReductionOptions' for type 'ns2:NoiseReductionOptions' */
#ifndef SOAP_TYPE_PointerTons2__NoiseReductionOptions
#define SOAP_TYPE_PointerTons2__NoiseReductionOptions (1832)
#endif

/* ns2__DefoggingOptions * has binding name 'PointerTons2__DefoggingOptions' for type 'ns2:DefoggingOptions' */
#ifndef SOAP_TYPE_PointerTons2__DefoggingOptions
#define SOAP_TYPE_PointerTons2__DefoggingOptions (1831)
#endif

/* ns2__ToneCompensationOptions * has binding name 'PointerTons2__ToneCompensationOptions' for type 'ns2:ToneCompensationOptions' */
#ifndef SOAP_TYPE_PointerTons2__ToneCompensationOptions
#define SOAP_TYPE_PointerTons2__ToneCompensationOptions (1830)
#endif

/* ns2__ImagingOptions20Extension3 * has binding name 'PointerTons2__ImagingOptions20Extension3' for type 'ns2:ImagingOptions20Extension3' */
#ifndef SOAP_TYPE_PointerTons2__ImagingOptions20Extension3
#define SOAP_TYPE_PointerTons2__ImagingOptions20Extension3 (1829)
#endif

/* ns2__IrCutFilterAutoAdjustmentOptions * has binding name 'PointerTons2__IrCutFilterAutoAdjustmentOptions' for type 'ns2:IrCutFilterAutoAdjustmentOptions' */
#ifndef SOAP_TYPE_PointerTons2__IrCutFilterAutoAdjustmentOptions
#define SOAP_TYPE_PointerTons2__IrCutFilterAutoAdjustmentOptions (1828)
#endif

/* ns2__ImagingOptions20Extension2 * has binding name 'PointerTons2__ImagingOptions20Extension2' for type 'ns2:ImagingOptions20Extension2' */
#ifndef SOAP_TYPE_PointerTons2__ImagingOptions20Extension2
#define SOAP_TYPE_PointerTons2__ImagingOptions20Extension2 (1827)
#endif

/* ns2__ImageStabilizationOptions * has binding name 'PointerTons2__ImageStabilizationOptions' for type 'ns2:ImageStabilizationOptions' */
#ifndef SOAP_TYPE_PointerTons2__ImageStabilizationOptions
#define SOAP_TYPE_PointerTons2__ImageStabilizationOptions (1826)
#endif

/* ns2__ImagingOptions20Extension * has binding name 'PointerTons2__ImagingOptions20Extension' for type 'ns2:ImagingOptions20Extension' */
#ifndef SOAP_TYPE_PointerTons2__ImagingOptions20Extension
#define SOAP_TYPE_PointerTons2__ImagingOptions20Extension (1825)
#endif

/* ns2__WhiteBalanceOptions20 * has binding name 'PointerTons2__WhiteBalanceOptions20' for type 'ns2:WhiteBalanceOptions20' */
#ifndef SOAP_TYPE_PointerTons2__WhiteBalanceOptions20
#define SOAP_TYPE_PointerTons2__WhiteBalanceOptions20 (1824)
#endif

/* ns2__WideDynamicRangeOptions20 * has binding name 'PointerTons2__WideDynamicRangeOptions20' for type 'ns2:WideDynamicRangeOptions20' */
#ifndef SOAP_TYPE_PointerTons2__WideDynamicRangeOptions20
#define SOAP_TYPE_PointerTons2__WideDynamicRangeOptions20 (1823)
#endif

/* ns2__FocusOptions20 * has binding name 'PointerTons2__FocusOptions20' for type 'ns2:FocusOptions20' */
#ifndef SOAP_TYPE_PointerTons2__FocusOptions20
#define SOAP_TYPE_PointerTons2__FocusOptions20 (1822)
#endif

/* ns2__ExposureOptions20 * has binding name 'PointerTons2__ExposureOptions20' for type 'ns2:ExposureOptions20' */
#ifndef SOAP_TYPE_PointerTons2__ExposureOptions20
#define SOAP_TYPE_PointerTons2__ExposureOptions20 (1821)
#endif

/* ns2__BacklightCompensationOptions20 * has binding name 'PointerTons2__BacklightCompensationOptions20' for type 'ns2:BacklightCompensationOptions20' */
#ifndef SOAP_TYPE_PointerTons2__BacklightCompensationOptions20
#define SOAP_TYPE_PointerTons2__BacklightCompensationOptions20 (1820)
#endif

/* ns2__DefoggingExtension * has binding name 'PointerTons2__DefoggingExtension' for type 'ns2:DefoggingExtension' */
#ifndef SOAP_TYPE_PointerTons2__DefoggingExtension
#define SOAP_TYPE_PointerTons2__DefoggingExtension (1819)
#endif

/* ns2__ToneCompensationExtension * has binding name 'PointerTons2__ToneCompensationExtension' for type 'ns2:ToneCompensationExtension' */
#ifndef SOAP_TYPE_PointerTons2__ToneCompensationExtension
#define SOAP_TYPE_PointerTons2__ToneCompensationExtension (1818)
#endif

/* ns2__ExposurePriority * has binding name 'PointerTons2__ExposurePriority' for type 'ns2:ExposurePriority' */
#ifndef SOAP_TYPE_PointerTons2__ExposurePriority
#define SOAP_TYPE_PointerTons2__ExposurePriority (1817)
#endif

/* ns2__IrCutFilterAutoAdjustmentExtension * has binding name 'PointerTons2__IrCutFilterAutoAdjustmentExtension' for type 'ns2:IrCutFilterAutoAdjustmentExtension' */
#ifndef SOAP_TYPE_PointerTons2__IrCutFilterAutoAdjustmentExtension
#define SOAP_TYPE_PointerTons2__IrCutFilterAutoAdjustmentExtension (1816)
#endif

/* ns2__ImageStabilizationExtension * has binding name 'PointerTons2__ImageStabilizationExtension' for type 'ns2:ImageStabilizationExtension' */
#ifndef SOAP_TYPE_PointerTons2__ImageStabilizationExtension
#define SOAP_TYPE_PointerTons2__ImageStabilizationExtension (1815)
#endif

/* ns2__ImagingSettingsExtension204 * has binding name 'PointerTons2__ImagingSettingsExtension204' for type 'ns2:ImagingSettingsExtension204' */
#ifndef SOAP_TYPE_PointerTons2__ImagingSettingsExtension204
#define SOAP_TYPE_PointerTons2__ImagingSettingsExtension204 (1814)
#endif

/* ns2__NoiseReduction * has binding name 'PointerTons2__NoiseReduction' for type 'ns2:NoiseReduction' */
#ifndef SOAP_TYPE_PointerTons2__NoiseReduction
#define SOAP_TYPE_PointerTons2__NoiseReduction (1813)
#endif

/* ns2__Defogging * has binding name 'PointerTons2__Defogging' for type 'ns2:Defogging' */
#ifndef SOAP_TYPE_PointerTons2__Defogging
#define SOAP_TYPE_PointerTons2__Defogging (1812)
#endif

/* ns2__ToneCompensation * has binding name 'PointerTons2__ToneCompensation' for type 'ns2:ToneCompensation' */
#ifndef SOAP_TYPE_PointerTons2__ToneCompensation
#define SOAP_TYPE_PointerTons2__ToneCompensation (1811)
#endif

/* ns2__ImagingSettingsExtension203 * has binding name 'PointerTons2__ImagingSettingsExtension203' for type 'ns2:ImagingSettingsExtension203' */
#ifndef SOAP_TYPE_PointerTons2__ImagingSettingsExtension203
#define SOAP_TYPE_PointerTons2__ImagingSettingsExtension203 (1810)
#endif

/* ns2__IrCutFilterAutoAdjustment * has binding name 'PointerTons2__IrCutFilterAutoAdjustment' for type 'ns2:IrCutFilterAutoAdjustment' */
#ifndef SOAP_TYPE_PointerTons2__IrCutFilterAutoAdjustment
#define SOAP_TYPE_PointerTons2__IrCutFilterAutoAdjustment (1808)
#endif

/* ns2__ImagingSettingsExtension202 * has binding name 'PointerTons2__ImagingSettingsExtension202' for type 'ns2:ImagingSettingsExtension202' */
#ifndef SOAP_TYPE_PointerTons2__ImagingSettingsExtension202
#define SOAP_TYPE_PointerTons2__ImagingSettingsExtension202 (1807)
#endif

/* ns2__ImageStabilization * has binding name 'PointerTons2__ImageStabilization' for type 'ns2:ImageStabilization' */
#ifndef SOAP_TYPE_PointerTons2__ImageStabilization
#define SOAP_TYPE_PointerTons2__ImageStabilization (1806)
#endif

/* ns2__ImagingSettingsExtension20 * has binding name 'PointerTons2__ImagingSettingsExtension20' for type 'ns2:ImagingSettingsExtension20' */
#ifndef SOAP_TYPE_PointerTons2__ImagingSettingsExtension20
#define SOAP_TYPE_PointerTons2__ImagingSettingsExtension20 (1805)
#endif

/* ns2__WhiteBalance20 * has binding name 'PointerTons2__WhiteBalance20' for type 'ns2:WhiteBalance20' */
#ifndef SOAP_TYPE_PointerTons2__WhiteBalance20
#define SOAP_TYPE_PointerTons2__WhiteBalance20 (1804)
#endif

/* ns2__WideDynamicRange20 * has binding name 'PointerTons2__WideDynamicRange20' for type 'ns2:WideDynamicRange20' */
#ifndef SOAP_TYPE_PointerTons2__WideDynamicRange20
#define SOAP_TYPE_PointerTons2__WideDynamicRange20 (1803)
#endif

/* ns2__FocusConfiguration20 * has binding name 'PointerTons2__FocusConfiguration20' for type 'ns2:FocusConfiguration20' */
#ifndef SOAP_TYPE_PointerTons2__FocusConfiguration20
#define SOAP_TYPE_PointerTons2__FocusConfiguration20 (1802)
#endif

/* ns2__Exposure20 * has binding name 'PointerTons2__Exposure20' for type 'ns2:Exposure20' */
#ifndef SOAP_TYPE_PointerTons2__Exposure20
#define SOAP_TYPE_PointerTons2__Exposure20 (1801)
#endif

/* ns2__BacklightCompensation20 * has binding name 'PointerTons2__BacklightCompensation20' for type 'ns2:BacklightCompensation20' */
#ifndef SOAP_TYPE_PointerTons2__BacklightCompensation20
#define SOAP_TYPE_PointerTons2__BacklightCompensation20 (1800)
#endif

/* ns2__FocusStatus20Extension * has binding name 'PointerTons2__FocusStatus20Extension' for type 'ns2:FocusStatus20Extension' */
#ifndef SOAP_TYPE_PointerTons2__FocusStatus20Extension
#define SOAP_TYPE_PointerTons2__FocusStatus20Extension (1799)
#endif

/* ns2__ImagingStatus20Extension * has binding name 'PointerTons2__ImagingStatus20Extension' for type 'ns2:ImagingStatus20Extension' */
#ifndef SOAP_TYPE_PointerTons2__ImagingStatus20Extension
#define SOAP_TYPE_PointerTons2__ImagingStatus20Extension (1798)
#endif

/* ns2__FocusStatus20 * has binding name 'PointerTons2__FocusStatus20' for type 'ns2:FocusStatus20' */
#ifndef SOAP_TYPE_PointerTons2__FocusStatus20
#define SOAP_TYPE_PointerTons2__FocusStatus20 (1797)
#endif

/* ns2__ContinuousFocusOptions * has binding name 'PointerTons2__ContinuousFocusOptions' for type 'ns2:ContinuousFocusOptions' */
#ifndef SOAP_TYPE_PointerTons2__ContinuousFocusOptions
#define SOAP_TYPE_PointerTons2__ContinuousFocusOptions (1796)
#endif

/* ns2__RelativeFocusOptions * has binding name 'PointerTons2__RelativeFocusOptions' for type 'ns2:RelativeFocusOptions' */
#ifndef SOAP_TYPE_PointerTons2__RelativeFocusOptions
#define SOAP_TYPE_PointerTons2__RelativeFocusOptions (1795)
#endif

/* ns2__AbsoluteFocusOptions * has binding name 'PointerTons2__AbsoluteFocusOptions' for type 'ns2:AbsoluteFocusOptions' */
#ifndef SOAP_TYPE_PointerTons2__AbsoluteFocusOptions
#define SOAP_TYPE_PointerTons2__AbsoluteFocusOptions (1794)
#endif

/* ns2__ContinuousFocus * has binding name 'PointerTons2__ContinuousFocus' for type 'ns2:ContinuousFocus' */
#ifndef SOAP_TYPE_PointerTons2__ContinuousFocus
#define SOAP_TYPE_PointerTons2__ContinuousFocus (1793)
#endif

/* ns2__RelativeFocus * has binding name 'PointerTons2__RelativeFocus' for type 'ns2:RelativeFocus' */
#ifndef SOAP_TYPE_PointerTons2__RelativeFocus
#define SOAP_TYPE_PointerTons2__RelativeFocus (1792)
#endif

/* ns2__AbsoluteFocus * has binding name 'PointerTons2__AbsoluteFocus' for type 'ns2:AbsoluteFocus' */
#ifndef SOAP_TYPE_PointerTons2__AbsoluteFocus
#define SOAP_TYPE_PointerTons2__AbsoluteFocus (1791)
#endif

/* ns2__WhiteBalanceOptions * has binding name 'PointerTons2__WhiteBalanceOptions' for type 'ns2:WhiteBalanceOptions' */
#ifndef SOAP_TYPE_PointerTons2__WhiteBalanceOptions
#define SOAP_TYPE_PointerTons2__WhiteBalanceOptions (1785)
#endif

/* ns2__WideDynamicRangeOptions * has binding name 'PointerTons2__WideDynamicRangeOptions' for type 'ns2:WideDynamicRangeOptions' */
#ifndef SOAP_TYPE_PointerTons2__WideDynamicRangeOptions
#define SOAP_TYPE_PointerTons2__WideDynamicRangeOptions (1784)
#endif

/* ns2__FocusOptions * has binding name 'PointerTons2__FocusOptions' for type 'ns2:FocusOptions' */
#ifndef SOAP_TYPE_PointerTons2__FocusOptions
#define SOAP_TYPE_PointerTons2__FocusOptions (1782)
#endif

/* ns2__ExposureOptions * has binding name 'PointerTons2__ExposureOptions' for type 'ns2:ExposureOptions' */
#ifndef SOAP_TYPE_PointerTons2__ExposureOptions
#define SOAP_TYPE_PointerTons2__ExposureOptions (1781)
#endif

/* ns2__BacklightCompensationOptions * has binding name 'PointerTons2__BacklightCompensationOptions' for type 'ns2:BacklightCompensationOptions' */
#ifndef SOAP_TYPE_PointerTons2__BacklightCompensationOptions
#define SOAP_TYPE_PointerTons2__BacklightCompensationOptions (1780)
#endif

/* ns2__Rectangle * has binding name 'PointerTons2__Rectangle' for type 'ns2:Rectangle' */
#ifndef SOAP_TYPE_PointerTons2__Rectangle
#define SOAP_TYPE_PointerTons2__Rectangle (1779)
#endif

/* ns2__ImagingSettingsExtension * has binding name 'PointerTons2__ImagingSettingsExtension' for type 'ns2:ImagingSettingsExtension' */
#ifndef SOAP_TYPE_PointerTons2__ImagingSettingsExtension
#define SOAP_TYPE_PointerTons2__ImagingSettingsExtension (1778)
#endif

/* ns2__WhiteBalance * has binding name 'PointerTons2__WhiteBalance' for type 'ns2:WhiteBalance' */
#ifndef SOAP_TYPE_PointerTons2__WhiteBalance
#define SOAP_TYPE_PointerTons2__WhiteBalance (1777)
#endif

/* ns2__WideDynamicRange * has binding name 'PointerTons2__WideDynamicRange' for type 'ns2:WideDynamicRange' */
#ifndef SOAP_TYPE_PointerTons2__WideDynamicRange
#define SOAP_TYPE_PointerTons2__WideDynamicRange (1776)
#endif

/* ns2__IrCutFilterMode * has binding name 'PointerTons2__IrCutFilterMode' for type 'ns2:IrCutFilterMode' */
#ifndef SOAP_TYPE_PointerTons2__IrCutFilterMode
#define SOAP_TYPE_PointerTons2__IrCutFilterMode (1775)
#endif

/* ns2__FocusConfiguration * has binding name 'PointerTons2__FocusConfiguration' for type 'ns2:FocusConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__FocusConfiguration
#define SOAP_TYPE_PointerTons2__FocusConfiguration (1774)
#endif

/* ns2__Exposure * has binding name 'PointerTons2__Exposure' for type 'ns2:Exposure' */
#ifndef SOAP_TYPE_PointerTons2__Exposure
#define SOAP_TYPE_PointerTons2__Exposure (1773)
#endif

/* ns2__BacklightCompensation * has binding name 'PointerTons2__BacklightCompensation' for type 'ns2:BacklightCompensation' */
#ifndef SOAP_TYPE_PointerTons2__BacklightCompensation
#define SOAP_TYPE_PointerTons2__BacklightCompensation (1772)
#endif

/* ns2__FocusStatus * has binding name 'PointerTons2__FocusStatus' for type 'ns2:FocusStatus' */
#ifndef SOAP_TYPE_PointerTons2__FocusStatus
#define SOAP_TYPE_PointerTons2__FocusStatus (1771)
#endif

/* ns2__PTZPresetTourStartingConditionOptionsExtension * has binding name 'PointerTons2__PTZPresetTourStartingConditionOptionsExtension' for type 'ns2:PTZPresetTourStartingConditionOptionsExtension' */
#ifndef SOAP_TYPE_PointerTons2__PTZPresetTourStartingConditionOptionsExtension
#define SOAP_TYPE_PointerTons2__PTZPresetTourStartingConditionOptionsExtension (1770)
#endif

/* ns2__PTZPresetTourPresetDetailOptionsExtension * has binding name 'PointerTons2__PTZPresetTourPresetDetailOptionsExtension' for type 'ns2:PTZPresetTourPresetDetailOptionsExtension' */
#ifndef SOAP_TYPE_PointerTons2__PTZPresetTourPresetDetailOptionsExtension
#define SOAP_TYPE_PointerTons2__PTZPresetTourPresetDetailOptionsExtension (1768)
#endif

/* ns2__PTZPresetTourPresetDetailOptions * has binding name 'PointerTons2__PTZPresetTourPresetDetailOptions' for type 'ns2:PTZPresetTourPresetDetailOptions' */
#ifndef SOAP_TYPE_PointerTons2__PTZPresetTourPresetDetailOptions
#define SOAP_TYPE_PointerTons2__PTZPresetTourPresetDetailOptions (1767)
#endif

/* ns2__PTZPresetTourSpotOptions * has binding name 'PointerTons2__PTZPresetTourSpotOptions' for type 'ns2:PTZPresetTourSpotOptions' */
#ifndef SOAP_TYPE_PointerTons2__PTZPresetTourSpotOptions
#define SOAP_TYPE_PointerTons2__PTZPresetTourSpotOptions (1766)
#endif

/* ns2__PTZPresetTourStartingConditionOptions * has binding name 'PointerTons2__PTZPresetTourStartingConditionOptions' for type 'ns2:PTZPresetTourStartingConditionOptions' */
#ifndef SOAP_TYPE_PointerTons2__PTZPresetTourStartingConditionOptions
#define SOAP_TYPE_PointerTons2__PTZPresetTourStartingConditionOptions (1765)
#endif

/* ns2__PTZPresetTourStartingConditionExtension * has binding name 'PointerTons2__PTZPresetTourStartingConditionExtension' for type 'ns2:PTZPresetTourStartingConditionExtension' */
#ifndef SOAP_TYPE_PointerTons2__PTZPresetTourStartingConditionExtension
#define SOAP_TYPE_PointerTons2__PTZPresetTourStartingConditionExtension (1764)
#endif

/* ns2__PTZPresetTourDirection * has binding name 'PointerTons2__PTZPresetTourDirection' for type 'ns2:PTZPresetTourDirection' */
#ifndef SOAP_TYPE_PointerTons2__PTZPresetTourDirection
#define SOAP_TYPE_PointerTons2__PTZPresetTourDirection (1763)
#endif

/* ns2__PTZPresetTourStatusExtension * has binding name 'PointerTons2__PTZPresetTourStatusExtension' for type 'ns2:PTZPresetTourStatusExtension' */
#ifndef SOAP_TYPE_PointerTons2__PTZPresetTourStatusExtension
#define SOAP_TYPE_PointerTons2__PTZPresetTourStatusExtension (1762)
#endif

/* ns2__PTZPresetTourTypeExtension * has binding name 'PointerTons2__PTZPresetTourTypeExtension' for type 'ns2:PTZPresetTourTypeExtension' */
#ifndef SOAP_TYPE_PointerTons2__PTZPresetTourTypeExtension
#define SOAP_TYPE_PointerTons2__PTZPresetTourTypeExtension (1760)
#endif

/* ns2__PTZPresetTourSpotExtension * has binding name 'PointerTons2__PTZPresetTourSpotExtension' for type 'ns2:PTZPresetTourSpotExtension' */
#ifndef SOAP_TYPE_PointerTons2__PTZPresetTourSpotExtension
#define SOAP_TYPE_PointerTons2__PTZPresetTourSpotExtension (1759)
#endif

/* ns2__PTZSpeed * has binding name 'PointerTons2__PTZSpeed' for type 'ns2:PTZSpeed' */
#ifndef SOAP_TYPE_PointerTons2__PTZSpeed
#define SOAP_TYPE_PointerTons2__PTZSpeed (1758)
#endif

/* ns2__PTZPresetTourPresetDetail * has binding name 'PointerTons2__PTZPresetTourPresetDetail' for type 'ns2:PTZPresetTourPresetDetail' */
#ifndef SOAP_TYPE_PointerTons2__PTZPresetTourPresetDetail
#define SOAP_TYPE_PointerTons2__PTZPresetTourPresetDetail (1757)
#endif

/* ns2__PTZPresetTourExtension * has binding name 'PointerTons2__PTZPresetTourExtension' for type 'ns2:PTZPresetTourExtension' */
#ifndef SOAP_TYPE_PointerTons2__PTZPresetTourExtension
#define SOAP_TYPE_PointerTons2__PTZPresetTourExtension (1756)
#endif

/* ns2__PTZPresetTourSpot * has binding name 'PointerTons2__PTZPresetTourSpot' for type 'ns2:PTZPresetTourSpot' */
#ifndef SOAP_TYPE_PointerTons2__PTZPresetTourSpot
#define SOAP_TYPE_PointerTons2__PTZPresetTourSpot (1754)
#endif

/* ns2__PTZPresetTourStartingCondition * has binding name 'PointerTons2__PTZPresetTourStartingCondition' for type 'ns2:PTZPresetTourStartingCondition' */
#ifndef SOAP_TYPE_PointerTons2__PTZPresetTourStartingCondition
#define SOAP_TYPE_PointerTons2__PTZPresetTourStartingCondition (1753)
#endif

/* ns2__PTZPresetTourStatus * has binding name 'PointerTons2__PTZPresetTourStatus' for type 'ns2:PTZPresetTourStatus' */
#ifndef SOAP_TYPE_PointerTons2__PTZPresetTourStatus
#define SOAP_TYPE_PointerTons2__PTZPresetTourStatus (1752)
#endif

/* ns2__MoveStatus * has binding name 'PointerTons2__MoveStatus' for type 'ns2:MoveStatus' */
#ifndef SOAP_TYPE_PointerTons2__MoveStatus
#define SOAP_TYPE_PointerTons2__MoveStatus (1751)
#endif

/* std::string * has binding name 'PointerTons2__Name' for type 'ns2:Name' */
#ifndef SOAP_TYPE_PointerTons2__Name
#define SOAP_TYPE_PointerTons2__Name (1750)
#endif

/* ns2__PTZMoveStatus * has binding name 'PointerTons2__PTZMoveStatus' for type 'ns2:PTZMoveStatus' */
#ifndef SOAP_TYPE_PointerTons2__PTZMoveStatus
#define SOAP_TYPE_PointerTons2__PTZMoveStatus (1749)
#endif

/* ns2__PTZVector * has binding name 'PointerTons2__PTZVector' for type 'ns2:PTZVector' */
#ifndef SOAP_TYPE_PointerTons2__PTZVector
#define SOAP_TYPE_PointerTons2__PTZVector (1748)
#endif

/* ns2__Vector1D * has binding name 'PointerTons2__Vector1D' for type 'ns2:Vector1D' */
#ifndef SOAP_TYPE_PointerTons2__Vector1D
#define SOAP_TYPE_PointerTons2__Vector1D (1747)
#endif

/* ns2__Vector2D * has binding name 'PointerTons2__Vector2D' for type 'ns2:Vector2D' */
#ifndef SOAP_TYPE_PointerTons2__Vector2D
#define SOAP_TYPE_PointerTons2__Vector2D (1746)
#endif

/* ns2__PTZSpacesExtension * has binding name 'PointerTons2__PTZSpacesExtension' for type 'ns2:PTZSpacesExtension' */
#ifndef SOAP_TYPE_PointerTons2__PTZSpacesExtension
#define SOAP_TYPE_PointerTons2__PTZSpacesExtension (1745)
#endif

/* ns2__Space1DDescription * has binding name 'PointerTons2__Space1DDescription' for type 'ns2:Space1DDescription' */
#ifndef SOAP_TYPE_PointerTons2__Space1DDescription
#define SOAP_TYPE_PointerTons2__Space1DDescription (1742)
#endif

/* ns2__Space2DDescription * has binding name 'PointerTons2__Space2DDescription' for type 'ns2:Space2DDescription' */
#ifndef SOAP_TYPE_PointerTons2__Space2DDescription
#define SOAP_TYPE_PointerTons2__Space2DDescription (1741)
#endif

/* ns2__ReverseOptionsExtension * has binding name 'PointerTons2__ReverseOptionsExtension' for type 'ns2:ReverseOptionsExtension' */
#ifndef SOAP_TYPE_PointerTons2__ReverseOptionsExtension
#define SOAP_TYPE_PointerTons2__ReverseOptionsExtension (1740)
#endif

/* ns2__EFlipOptionsExtension * has binding name 'PointerTons2__EFlipOptionsExtension' for type 'ns2:EFlipOptionsExtension' */
#ifndef SOAP_TYPE_PointerTons2__EFlipOptionsExtension
#define SOAP_TYPE_PointerTons2__EFlipOptionsExtension (1738)
#endif

/* ns2__PTControlDirectionOptionsExtension * has binding name 'PointerTons2__PTControlDirectionOptionsExtension' for type 'ns2:PTControlDirectionOptionsExtension' */
#ifndef SOAP_TYPE_PointerTons2__PTControlDirectionOptionsExtension
#define SOAP_TYPE_PointerTons2__PTControlDirectionOptionsExtension (1736)
#endif

/* ns2__ReverseOptions * has binding name 'PointerTons2__ReverseOptions' for type 'ns2:ReverseOptions' */
#ifndef SOAP_TYPE_PointerTons2__ReverseOptions
#define SOAP_TYPE_PointerTons2__ReverseOptions (1735)
#endif

/* ns2__EFlipOptions * has binding name 'PointerTons2__EFlipOptions' for type 'ns2:EFlipOptions' */
#ifndef SOAP_TYPE_PointerTons2__EFlipOptions
#define SOAP_TYPE_PointerTons2__EFlipOptions (1734)
#endif

/* ns2__PTZConfigurationOptions2 * has binding name 'PointerTons2__PTZConfigurationOptions2' for type 'ns2:PTZConfigurationOptions2' */
#ifndef SOAP_TYPE_PointerTons2__PTZConfigurationOptions2
#define SOAP_TYPE_PointerTons2__PTZConfigurationOptions2 (1733)
#endif

/* ns2__PTControlDirectionOptions * has binding name 'PointerTons2__PTControlDirectionOptions' for type 'ns2:PTControlDirectionOptions' */
#ifndef SOAP_TYPE_PointerTons2__PTControlDirectionOptions
#define SOAP_TYPE_PointerTons2__PTControlDirectionOptions (1732)
#endif

/* ns2__DurationRange * has binding name 'PointerTons2__DurationRange' for type 'ns2:DurationRange' */
#ifndef SOAP_TYPE_PointerTons2__DurationRange
#define SOAP_TYPE_PointerTons2__DurationRange (1731)
#endif

/* ns2__PTZSpaces * has binding name 'PointerTons2__PTZSpaces' for type 'ns2:PTZSpaces' */
#ifndef SOAP_TYPE_PointerTons2__PTZSpaces
#define SOAP_TYPE_PointerTons2__PTZSpaces (1730)
#endif

/* ns2__PTControlDirectionExtension * has binding name 'PointerTons2__PTControlDirectionExtension' for type 'ns2:PTControlDirectionExtension' */
#ifndef SOAP_TYPE_PointerTons2__PTControlDirectionExtension
#define SOAP_TYPE_PointerTons2__PTControlDirectionExtension (1729)
#endif

/* ns2__Reverse * has binding name 'PointerTons2__Reverse' for type 'ns2:Reverse' */
#ifndef SOAP_TYPE_PointerTons2__Reverse
#define SOAP_TYPE_PointerTons2__Reverse (1728)
#endif

/* ns2__EFlip * has binding name 'PointerTons2__EFlip' for type 'ns2:EFlip' */
#ifndef SOAP_TYPE_PointerTons2__EFlip
#define SOAP_TYPE_PointerTons2__EFlip (1727)
#endif

/* ns2__PTZConfigurationExtension2 * has binding name 'PointerTons2__PTZConfigurationExtension2' for type 'ns2:PTZConfigurationExtension2' */
#ifndef SOAP_TYPE_PointerTons2__PTZConfigurationExtension2
#define SOAP_TYPE_PointerTons2__PTZConfigurationExtension2 (1726)
#endif

/* ns2__PTControlDirection * has binding name 'PointerTons2__PTControlDirection' for type 'ns2:PTControlDirection' */
#ifndef SOAP_TYPE_PointerTons2__PTControlDirection
#define SOAP_TYPE_PointerTons2__PTControlDirection (1725)
#endif

/* ns2__PTZPresetTourSupportedExtension * has binding name 'PointerTons2__PTZPresetTourSupportedExtension' for type 'ns2:PTZPresetTourSupportedExtension' */
#ifndef SOAP_TYPE_PointerTons2__PTZPresetTourSupportedExtension
#define SOAP_TYPE_PointerTons2__PTZPresetTourSupportedExtension (1724)
#endif

/* ns2__PTZNodeExtension2 * has binding name 'PointerTons2__PTZNodeExtension2' for type 'ns2:PTZNodeExtension2' */
#ifndef SOAP_TYPE_PointerTons2__PTZNodeExtension2
#define SOAP_TYPE_PointerTons2__PTZNodeExtension2 (1722)
#endif

/* ns2__PTZPresetTourSupported * has binding name 'PointerTons2__PTZPresetTourSupported' for type 'ns2:PTZPresetTourSupported' */
#ifndef SOAP_TYPE_PointerTons2__PTZPresetTourSupported
#define SOAP_TYPE_PointerTons2__PTZPresetTourSupported (1721)
#endif

/* ns2__EapMethodExtension * has binding name 'PointerTons2__EapMethodExtension' for type 'ns2:EapMethodExtension' */
#ifndef SOAP_TYPE_PointerTons2__EapMethodExtension
#define SOAP_TYPE_PointerTons2__EapMethodExtension (1720)
#endif

/* ns2__TLSConfiguration * has binding name 'PointerTons2__TLSConfiguration' for type 'ns2:TLSConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__TLSConfiguration
#define SOAP_TYPE_PointerTons2__TLSConfiguration (1719)
#endif

/* ns2__Dot1XConfigurationExtension * has binding name 'PointerTons2__Dot1XConfigurationExtension' for type 'ns2:Dot1XConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTons2__Dot1XConfigurationExtension
#define SOAP_TYPE_PointerTons2__Dot1XConfigurationExtension (1718)
#endif

/* ns2__EAPMethodConfiguration * has binding name 'PointerTons2__EAPMethodConfiguration' for type 'ns2:EAPMethodConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__EAPMethodConfiguration
#define SOAP_TYPE_PointerTons2__EAPMethodConfiguration (1717)
#endif

/* ns2__CertificateInformationExtension * has binding name 'PointerTons2__CertificateInformationExtension' for type 'ns2:CertificateInformationExtension' */
#ifndef SOAP_TYPE_PointerTons2__CertificateInformationExtension
#define SOAP_TYPE_PointerTons2__CertificateInformationExtension (1716)
#endif

/* ns2__DateTimeRange * has binding name 'PointerTons2__DateTimeRange' for type 'ns2:DateTimeRange' */
#ifndef SOAP_TYPE_PointerTons2__DateTimeRange
#define SOAP_TYPE_PointerTons2__DateTimeRange (1715)
#endif

/* ns2__CertificateUsage * has binding name 'PointerTons2__CertificateUsage' for type 'ns2:CertificateUsage' */
#ifndef SOAP_TYPE_PointerTons2__CertificateUsage
#define SOAP_TYPE_PointerTons2__CertificateUsage (1714)
#endif

/* ns2__CertificateGenerationParametersExtension * has binding name 'PointerTons2__CertificateGenerationParametersExtension' for type 'ns2:CertificateGenerationParametersExtension' */
#ifndef SOAP_TYPE_PointerTons2__CertificateGenerationParametersExtension
#define SOAP_TYPE_PointerTons2__CertificateGenerationParametersExtension (1713)
#endif

/* ns2__UserExtension * has binding name 'PointerTons2__UserExtension' for type 'ns2:UserExtension' */
#ifndef SOAP_TYPE_PointerTons2__UserExtension
#define SOAP_TYPE_PointerTons2__UserExtension (1712)
#endif

/* ns2__Date * has binding name 'PointerTons2__Date' for type 'ns2:Date' */
#ifndef SOAP_TYPE_PointerTons2__Date
#define SOAP_TYPE_PointerTons2__Date (1711)
#endif

/* ns2__Time * has binding name 'PointerTons2__Time' for type 'ns2:Time' */
#ifndef SOAP_TYPE_PointerTons2__Time
#define SOAP_TYPE_PointerTons2__Time (1710)
#endif

/* ns2__SystemDateTimeExtension * has binding name 'PointerTons2__SystemDateTimeExtension' for type 'ns2:SystemDateTimeExtension' */
#ifndef SOAP_TYPE_PointerTons2__SystemDateTimeExtension
#define SOAP_TYPE_PointerTons2__SystemDateTimeExtension (1709)
#endif

/* ns2__SystemLogUri * has binding name 'PointerTons2__SystemLogUri' for type 'ns2:SystemLogUri' */
#ifndef SOAP_TYPE_PointerTons2__SystemLogUri
#define SOAP_TYPE_PointerTons2__SystemLogUri (1707)
#endif

/* ns4__Include * has binding name 'PointerTons4__Include' for type 'ns4:Include' */
#ifndef SOAP_TYPE_PointerTons4__Include
#define SOAP_TYPE_PointerTons4__Include (1706)
#endif

/* std::string * has binding name 'PointerTo_xmime__contentType' for type '' */
#ifndef SOAP_TYPE_PointerTo_xmime__contentType
#define SOAP_TYPE_PointerTo_xmime__contentType (1705)
#endif

/* ns2__AnalyticsDeviceExtension * has binding name 'PointerTons2__AnalyticsDeviceExtension' for type 'ns2:AnalyticsDeviceExtension' */
#ifndef SOAP_TYPE_PointerTons2__AnalyticsDeviceExtension
#define SOAP_TYPE_PointerTons2__AnalyticsDeviceExtension (1704)
#endif

/* ns2__SystemCapabilitiesExtension2 * has binding name 'PointerTons2__SystemCapabilitiesExtension2' for type 'ns2:SystemCapabilitiesExtension2' */
#ifndef SOAP_TYPE_PointerTons2__SystemCapabilitiesExtension2
#define SOAP_TYPE_PointerTons2__SystemCapabilitiesExtension2 (1703)
#endif

/* ns2__SystemCapabilitiesExtension * has binding name 'PointerTons2__SystemCapabilitiesExtension' for type 'ns2:SystemCapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTons2__SystemCapabilitiesExtension
#define SOAP_TYPE_PointerTons2__SystemCapabilitiesExtension (1702)
#endif

/* ns2__SecurityCapabilitiesExtension2 * has binding name 'PointerTons2__SecurityCapabilitiesExtension2' for type 'ns2:SecurityCapabilitiesExtension2' */
#ifndef SOAP_TYPE_PointerTons2__SecurityCapabilitiesExtension2
#define SOAP_TYPE_PointerTons2__SecurityCapabilitiesExtension2 (1700)
#endif

/* ns2__SecurityCapabilitiesExtension * has binding name 'PointerTons2__SecurityCapabilitiesExtension' for type 'ns2:SecurityCapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTons2__SecurityCapabilitiesExtension
#define SOAP_TYPE_PointerTons2__SecurityCapabilitiesExtension (1699)
#endif

/* ns2__NetworkCapabilitiesExtension2 * has binding name 'PointerTons2__NetworkCapabilitiesExtension2' for type 'ns2:NetworkCapabilitiesExtension2' */
#ifndef SOAP_TYPE_PointerTons2__NetworkCapabilitiesExtension2
#define SOAP_TYPE_PointerTons2__NetworkCapabilitiesExtension2 (1698)
#endif

/* ns2__NetworkCapabilitiesExtension * has binding name 'PointerTons2__NetworkCapabilitiesExtension' for type 'ns2:NetworkCapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTons2__NetworkCapabilitiesExtension
#define SOAP_TYPE_PointerTons2__NetworkCapabilitiesExtension (1697)
#endif

/* ns2__RealTimeStreamingCapabilitiesExtension * has binding name 'PointerTons2__RealTimeStreamingCapabilitiesExtension' for type 'ns2:RealTimeStreamingCapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTons2__RealTimeStreamingCapabilitiesExtension
#define SOAP_TYPE_PointerTons2__RealTimeStreamingCapabilitiesExtension (1696)
#endif

/* ns2__ProfileCapabilities * has binding name 'PointerTons2__ProfileCapabilities' for type 'ns2:ProfileCapabilities' */
#ifndef SOAP_TYPE_PointerTons2__ProfileCapabilities
#define SOAP_TYPE_PointerTons2__ProfileCapabilities (1695)
#endif

/* ns2__MediaCapabilitiesExtension * has binding name 'PointerTons2__MediaCapabilitiesExtension' for type 'ns2:MediaCapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTons2__MediaCapabilitiesExtension
#define SOAP_TYPE_PointerTons2__MediaCapabilitiesExtension (1694)
#endif

/* ns2__RealTimeStreamingCapabilities * has binding name 'PointerTons2__RealTimeStreamingCapabilities' for type 'ns2:RealTimeStreamingCapabilities' */
#ifndef SOAP_TYPE_PointerTons2__RealTimeStreamingCapabilities
#define SOAP_TYPE_PointerTons2__RealTimeStreamingCapabilities (1693)
#endif

/* ns2__IOCapabilitiesExtension2 * has binding name 'PointerTons2__IOCapabilitiesExtension2' for type 'ns2:IOCapabilitiesExtension2' */
#ifndef SOAP_TYPE_PointerTons2__IOCapabilitiesExtension2
#define SOAP_TYPE_PointerTons2__IOCapabilitiesExtension2 (1692)
#endif

/* ns2__IOCapabilitiesExtension * has binding name 'PointerTons2__IOCapabilitiesExtension' for type 'ns2:IOCapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTons2__IOCapabilitiesExtension
#define SOAP_TYPE_PointerTons2__IOCapabilitiesExtension (1690)
#endif

/* ns2__DeviceCapabilitiesExtension * has binding name 'PointerTons2__DeviceCapabilitiesExtension' for type 'ns2:DeviceCapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTons2__DeviceCapabilitiesExtension
#define SOAP_TYPE_PointerTons2__DeviceCapabilitiesExtension (1689)
#endif

/* ns2__SecurityCapabilities * has binding name 'PointerTons2__SecurityCapabilities' for type 'ns2:SecurityCapabilities' */
#ifndef SOAP_TYPE_PointerTons2__SecurityCapabilities
#define SOAP_TYPE_PointerTons2__SecurityCapabilities (1688)
#endif

/* ns2__IOCapabilities * has binding name 'PointerTons2__IOCapabilities' for type 'ns2:IOCapabilities' */
#ifndef SOAP_TYPE_PointerTons2__IOCapabilities
#define SOAP_TYPE_PointerTons2__IOCapabilities (1687)
#endif

/* ns2__SystemCapabilities * has binding name 'PointerTons2__SystemCapabilities' for type 'ns2:SystemCapabilities' */
#ifndef SOAP_TYPE_PointerTons2__SystemCapabilities
#define SOAP_TYPE_PointerTons2__SystemCapabilities (1686)
#endif

/* ns2__NetworkCapabilities * has binding name 'PointerTons2__NetworkCapabilities' for type 'ns2:NetworkCapabilities' */
#ifndef SOAP_TYPE_PointerTons2__NetworkCapabilities
#define SOAP_TYPE_PointerTons2__NetworkCapabilities (1685)
#endif

/* ns2__CapabilitiesExtension2 * has binding name 'PointerTons2__CapabilitiesExtension2' for type 'ns2:CapabilitiesExtension2' */
#ifndef SOAP_TYPE_PointerTons2__CapabilitiesExtension2
#define SOAP_TYPE_PointerTons2__CapabilitiesExtension2 (1684)
#endif

/* ns2__AnalyticsDeviceCapabilities * has binding name 'PointerTons2__AnalyticsDeviceCapabilities' for type 'ns2:AnalyticsDeviceCapabilities' */
#ifndef SOAP_TYPE_PointerTons2__AnalyticsDeviceCapabilities
#define SOAP_TYPE_PointerTons2__AnalyticsDeviceCapabilities (1683)
#endif

/* ns2__ReceiverCapabilities * has binding name 'PointerTons2__ReceiverCapabilities' for type 'ns2:ReceiverCapabilities' */
#ifndef SOAP_TYPE_PointerTons2__ReceiverCapabilities
#define SOAP_TYPE_PointerTons2__ReceiverCapabilities (1682)
#endif

/* ns2__ReplayCapabilities * has binding name 'PointerTons2__ReplayCapabilities' for type 'ns2:ReplayCapabilities' */
#ifndef SOAP_TYPE_PointerTons2__ReplayCapabilities
#define SOAP_TYPE_PointerTons2__ReplayCapabilities (1681)
#endif

/* ns2__SearchCapabilities * has binding name 'PointerTons2__SearchCapabilities' for type 'ns2:SearchCapabilities' */
#ifndef SOAP_TYPE_PointerTons2__SearchCapabilities
#define SOAP_TYPE_PointerTons2__SearchCapabilities (1680)
#endif

/* ns2__RecordingCapabilities * has binding name 'PointerTons2__RecordingCapabilities' for type 'ns2:RecordingCapabilities' */
#ifndef SOAP_TYPE_PointerTons2__RecordingCapabilities
#define SOAP_TYPE_PointerTons2__RecordingCapabilities (1679)
#endif

/* ns2__DisplayCapabilities * has binding name 'PointerTons2__DisplayCapabilities' for type 'ns2:DisplayCapabilities' */
#ifndef SOAP_TYPE_PointerTons2__DisplayCapabilities
#define SOAP_TYPE_PointerTons2__DisplayCapabilities (1678)
#endif

/* ns2__DeviceIOCapabilities * has binding name 'PointerTons2__DeviceIOCapabilities' for type 'ns2:DeviceIOCapabilities' */
#ifndef SOAP_TYPE_PointerTons2__DeviceIOCapabilities
#define SOAP_TYPE_PointerTons2__DeviceIOCapabilities (1677)
#endif

/* ns2__CapabilitiesExtension * has binding name 'PointerTons2__CapabilitiesExtension' for type 'ns2:CapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTons2__CapabilitiesExtension
#define SOAP_TYPE_PointerTons2__CapabilitiesExtension (1676)
#endif

/* ns2__PTZCapabilities * has binding name 'PointerTons2__PTZCapabilities' for type 'ns2:PTZCapabilities' */
#ifndef SOAP_TYPE_PointerTons2__PTZCapabilities
#define SOAP_TYPE_PointerTons2__PTZCapabilities (1675)
#endif

/* ns2__MediaCapabilities * has binding name 'PointerTons2__MediaCapabilities' for type 'ns2:MediaCapabilities' */
#ifndef SOAP_TYPE_PointerTons2__MediaCapabilities
#define SOAP_TYPE_PointerTons2__MediaCapabilities (1674)
#endif

/* ns2__ImagingCapabilities * has binding name 'PointerTons2__ImagingCapabilities' for type 'ns2:ImagingCapabilities' */
#ifndef SOAP_TYPE_PointerTons2__ImagingCapabilities
#define SOAP_TYPE_PointerTons2__ImagingCapabilities (1673)
#endif

/* ns2__EventCapabilities * has binding name 'PointerTons2__EventCapabilities' for type 'ns2:EventCapabilities' */
#ifndef SOAP_TYPE_PointerTons2__EventCapabilities
#define SOAP_TYPE_PointerTons2__EventCapabilities (1672)
#endif

/* ns2__DeviceCapabilities * has binding name 'PointerTons2__DeviceCapabilities' for type 'ns2:DeviceCapabilities' */
#ifndef SOAP_TYPE_PointerTons2__DeviceCapabilities
#define SOAP_TYPE_PointerTons2__DeviceCapabilities (1671)
#endif

/* ns2__AnalyticsCapabilities * has binding name 'PointerTons2__AnalyticsCapabilities' for type 'ns2:AnalyticsCapabilities' */
#ifndef SOAP_TYPE_PointerTons2__AnalyticsCapabilities
#define SOAP_TYPE_PointerTons2__AnalyticsCapabilities (1670)
#endif

/* ns2__Dot11AvailableNetworksExtension * has binding name 'PointerTons2__Dot11AvailableNetworksExtension' for type 'ns2:Dot11AvailableNetworksExtension' */
#ifndef SOAP_TYPE_PointerTons2__Dot11AvailableNetworksExtension
#define SOAP_TYPE_PointerTons2__Dot11AvailableNetworksExtension (1669)
#endif

/* ns2__Dot11SignalStrength * has binding name 'PointerTons2__Dot11SignalStrength' for type 'ns2:Dot11SignalStrength' */
#ifndef SOAP_TYPE_PointerTons2__Dot11SignalStrength
#define SOAP_TYPE_PointerTons2__Dot11SignalStrength (1666)
#endif

/* ns2__Dot11PSKSetExtension * has binding name 'PointerTons2__Dot11PSKSetExtension' for type 'ns2:Dot11PSKSetExtension' */
#ifndef SOAP_TYPE_PointerTons2__Dot11PSKSetExtension
#define SOAP_TYPE_PointerTons2__Dot11PSKSetExtension (1665)
#endif

/* std::string * has binding name 'PointerTons2__Dot11PSKPassphrase' for type 'ns2:Dot11PSKPassphrase' */
#ifndef SOAP_TYPE_PointerTons2__Dot11PSKPassphrase
#define SOAP_TYPE_PointerTons2__Dot11PSKPassphrase (1664)
#endif

/* xsd__hexBinary * has binding name 'PointerTons2__Dot11PSK' for type 'ns2:Dot11PSK' */
#ifndef SOAP_TYPE_PointerTons2__Dot11PSK
#define SOAP_TYPE_PointerTons2__Dot11PSK (1663)
#endif

/* ns2__Dot11SecurityConfigurationExtension * has binding name 'PointerTons2__Dot11SecurityConfigurationExtension' for type 'ns2:Dot11SecurityConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTons2__Dot11SecurityConfigurationExtension
#define SOAP_TYPE_PointerTons2__Dot11SecurityConfigurationExtension (1662)
#endif

/* std::string * has binding name 'PointerTons2__ReferenceToken' for type 'ns2:ReferenceToken' */
#ifndef SOAP_TYPE_PointerTons2__ReferenceToken
#define SOAP_TYPE_PointerTons2__ReferenceToken (1661)
#endif

/* ns2__Dot11PSKSet * has binding name 'PointerTons2__Dot11PSKSet' for type 'ns2:Dot11PSKSet' */
#ifndef SOAP_TYPE_PointerTons2__Dot11PSKSet
#define SOAP_TYPE_PointerTons2__Dot11PSKSet (1660)
#endif

/* ns2__Dot11Cipher * has binding name 'PointerTons2__Dot11Cipher' for type 'ns2:Dot11Cipher' */
#ifndef SOAP_TYPE_PointerTons2__Dot11Cipher
#define SOAP_TYPE_PointerTons2__Dot11Cipher (1659)
#endif

/* ns2__Dot11SecurityConfiguration * has binding name 'PointerTons2__Dot11SecurityConfiguration' for type 'ns2:Dot11SecurityConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__Dot11SecurityConfiguration
#define SOAP_TYPE_PointerTons2__Dot11SecurityConfiguration (1658)
#endif

/* ns2__IPAddressFilterExtension * has binding name 'PointerTons2__IPAddressFilterExtension' for type 'ns2:IPAddressFilterExtension' */
#ifndef SOAP_TYPE_PointerTons2__IPAddressFilterExtension
#define SOAP_TYPE_PointerTons2__IPAddressFilterExtension (1657)
#endif

/* ns2__NetworkZeroConfigurationExtension2 * has binding name 'PointerTons2__NetworkZeroConfigurationExtension2' for type 'ns2:NetworkZeroConfigurationExtension2' */
#ifndef SOAP_TYPE_PointerTons2__NetworkZeroConfigurationExtension2
#define SOAP_TYPE_PointerTons2__NetworkZeroConfigurationExtension2 (1656)
#endif

/* ns2__NetworkZeroConfigurationExtension * has binding name 'PointerTons2__NetworkZeroConfigurationExtension' for type 'ns2:NetworkZeroConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTons2__NetworkZeroConfigurationExtension
#define SOAP_TYPE_PointerTons2__NetworkZeroConfigurationExtension (1654)
#endif

/* ns2__IPv6DHCPConfiguration * has binding name 'PointerTons2__IPv6DHCPConfiguration' for type 'ns2:IPv6DHCPConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__IPv6DHCPConfiguration
#define SOAP_TYPE_PointerTons2__IPv6DHCPConfiguration (1653)
#endif

/* ns2__NetworkInterfaceSetConfigurationExtension2 * has binding name 'PointerTons2__NetworkInterfaceSetConfigurationExtension2' for type 'ns2:NetworkInterfaceSetConfigurationExtension2' */
#ifndef SOAP_TYPE_PointerTons2__NetworkInterfaceSetConfigurationExtension2
#define SOAP_TYPE_PointerTons2__NetworkInterfaceSetConfigurationExtension2 (1652)
#endif

/* ns2__NetworkInterfaceSetConfigurationExtension * has binding name 'PointerTons2__NetworkInterfaceSetConfigurationExtension' for type 'ns2:NetworkInterfaceSetConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTons2__NetworkInterfaceSetConfigurationExtension
#define SOAP_TYPE_PointerTons2__NetworkInterfaceSetConfigurationExtension (1651)
#endif

/* ns2__IPv6NetworkInterfaceSetConfiguration * has binding name 'PointerTons2__IPv6NetworkInterfaceSetConfiguration' for type 'ns2:IPv6NetworkInterfaceSetConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__IPv6NetworkInterfaceSetConfiguration
#define SOAP_TYPE_PointerTons2__IPv6NetworkInterfaceSetConfiguration (1650)
#endif

/* ns2__IPv4NetworkInterfaceSetConfiguration * has binding name 'PointerTons2__IPv4NetworkInterfaceSetConfiguration' for type 'ns2:IPv4NetworkInterfaceSetConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__IPv4NetworkInterfaceSetConfiguration
#define SOAP_TYPE_PointerTons2__IPv4NetworkInterfaceSetConfiguration (1649)
#endif

/* ns2__DynamicDNSInformationExtension * has binding name 'PointerTons2__DynamicDNSInformationExtension' for type 'ns2:DynamicDNSInformationExtension' */
#ifndef SOAP_TYPE_PointerTons2__DynamicDNSInformationExtension
#define SOAP_TYPE_PointerTons2__DynamicDNSInformationExtension (1648)
#endif

/* ns2__NTPInformationExtension * has binding name 'PointerTons2__NTPInformationExtension' for type 'ns2:NTPInformationExtension' */
#ifndef SOAP_TYPE_PointerTons2__NTPInformationExtension
#define SOAP_TYPE_PointerTons2__NTPInformationExtension (1647)
#endif

/* ns2__DNSInformationExtension * has binding name 'PointerTons2__DNSInformationExtension' for type 'ns2:DNSInformationExtension' */
#ifndef SOAP_TYPE_PointerTons2__DNSInformationExtension
#define SOAP_TYPE_PointerTons2__DNSInformationExtension (1646)
#endif

/* ns2__HostnameInformationExtension * has binding name 'PointerTons2__HostnameInformationExtension' for type 'ns2:HostnameInformationExtension' */
#ifndef SOAP_TYPE_PointerTons2__HostnameInformationExtension
#define SOAP_TYPE_PointerTons2__HostnameInformationExtension (1645)
#endif

/* ns2__NetworkHostExtension * has binding name 'PointerTons2__NetworkHostExtension' for type 'ns2:NetworkHostExtension' */
#ifndef SOAP_TYPE_PointerTons2__NetworkHostExtension
#define SOAP_TYPE_PointerTons2__NetworkHostExtension (1644)
#endif

/* std::string * has binding name 'PointerTons2__IPv6Address' for type 'ns2:IPv6Address' */
#ifndef SOAP_TYPE_PointerTons2__IPv6Address
#define SOAP_TYPE_PointerTons2__IPv6Address (1643)
#endif

/* std::string * has binding name 'PointerTons2__IPv4Address' for type 'ns2:IPv4Address' */
#ifndef SOAP_TYPE_PointerTons2__IPv4Address
#define SOAP_TYPE_PointerTons2__IPv4Address (1642)
#endif

/* ns2__NetworkProtocolExtension * has binding name 'PointerTons2__NetworkProtocolExtension' for type 'ns2:NetworkProtocolExtension' */
#ifndef SOAP_TYPE_PointerTons2__NetworkProtocolExtension
#define SOAP_TYPE_PointerTons2__NetworkProtocolExtension (1641)
#endif

/* ns2__IPv6ConfigurationExtension * has binding name 'PointerTons2__IPv6ConfigurationExtension' for type 'ns2:IPv6ConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTons2__IPv6ConfigurationExtension
#define SOAP_TYPE_PointerTons2__IPv6ConfigurationExtension (1640)
#endif

/* ns2__PrefixedIPv6Address * has binding name 'PointerTons2__PrefixedIPv6Address' for type 'ns2:PrefixedIPv6Address' */
#ifndef SOAP_TYPE_PointerTons2__PrefixedIPv6Address
#define SOAP_TYPE_PointerTons2__PrefixedIPv6Address (1638)
#endif

/* ns2__PrefixedIPv4Address * has binding name 'PointerTons2__PrefixedIPv4Address' for type 'ns2:PrefixedIPv4Address' */
#ifndef SOAP_TYPE_PointerTons2__PrefixedIPv4Address
#define SOAP_TYPE_PointerTons2__PrefixedIPv4Address (1636)
#endif

/* ns2__IPv4Configuration * has binding name 'PointerTons2__IPv4Configuration' for type 'ns2:IPv4Configuration' */
#ifndef SOAP_TYPE_PointerTons2__IPv4Configuration
#define SOAP_TYPE_PointerTons2__IPv4Configuration (1635)
#endif

/* ns2__IPv6Configuration * has binding name 'PointerTons2__IPv6Configuration' for type 'ns2:IPv6Configuration' */
#ifndef SOAP_TYPE_PointerTons2__IPv6Configuration
#define SOAP_TYPE_PointerTons2__IPv6Configuration (1634)
#endif

/* ns2__NetworkInterfaceConnectionSetting * has binding name 'PointerTons2__NetworkInterfaceConnectionSetting' for type 'ns2:NetworkInterfaceConnectionSetting' */
#ifndef SOAP_TYPE_PointerTons2__NetworkInterfaceConnectionSetting
#define SOAP_TYPE_PointerTons2__NetworkInterfaceConnectionSetting (1633)
#endif

/* ns2__NetworkInterfaceExtension2 * has binding name 'PointerTons2__NetworkInterfaceExtension2' for type 'ns2:NetworkInterfaceExtension2' */
#ifndef SOAP_TYPE_PointerTons2__NetworkInterfaceExtension2
#define SOAP_TYPE_PointerTons2__NetworkInterfaceExtension2 (1632)
#endif

/* ns2__Dot11Configuration * has binding name 'PointerTons2__Dot11Configuration' for type 'ns2:Dot11Configuration' */
#ifndef SOAP_TYPE_PointerTons2__Dot11Configuration
#define SOAP_TYPE_PointerTons2__Dot11Configuration (1630)
#endif

/* ns2__Dot3Configuration * has binding name 'PointerTons2__Dot3Configuration' for type 'ns2:Dot3Configuration' */
#ifndef SOAP_TYPE_PointerTons2__Dot3Configuration
#define SOAP_TYPE_PointerTons2__Dot3Configuration (1628)
#endif

/* ns2__Transport * has binding name 'PointerTons2__Transport' for type 'ns2:Transport' */
#ifndef SOAP_TYPE_PointerTons2__Transport
#define SOAP_TYPE_PointerTons2__Transport (1627)
#endif

/* ns2__AudioDecoderConfigurationOptionsExtension * has binding name 'PointerTons2__AudioDecoderConfigurationOptionsExtension' for type 'ns2:AudioDecoderConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_PointerTons2__AudioDecoderConfigurationOptionsExtension
#define SOAP_TYPE_PointerTons2__AudioDecoderConfigurationOptionsExtension (1626)
#endif

/* ns2__G726DecOptions * has binding name 'PointerTons2__G726DecOptions' for type 'ns2:G726DecOptions' */
#ifndef SOAP_TYPE_PointerTons2__G726DecOptions
#define SOAP_TYPE_PointerTons2__G726DecOptions (1625)
#endif

/* ns2__G711DecOptions * has binding name 'PointerTons2__G711DecOptions' for type 'ns2:G711DecOptions' */
#ifndef SOAP_TYPE_PointerTons2__G711DecOptions
#define SOAP_TYPE_PointerTons2__G711DecOptions (1624)
#endif

/* ns2__AACDecOptions * has binding name 'PointerTons2__AACDecOptions' for type 'ns2:AACDecOptions' */
#ifndef SOAP_TYPE_PointerTons2__AACDecOptions
#define SOAP_TYPE_PointerTons2__AACDecOptions (1623)
#endif

/* ns2__VideoDecoderConfigurationOptionsExtension * has binding name 'PointerTons2__VideoDecoderConfigurationOptionsExtension' for type 'ns2:VideoDecoderConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_PointerTons2__VideoDecoderConfigurationOptionsExtension
#define SOAP_TYPE_PointerTons2__VideoDecoderConfigurationOptionsExtension (1622)
#endif

/* ns2__Mpeg4DecOptions * has binding name 'PointerTons2__Mpeg4DecOptions' for type 'ns2:Mpeg4DecOptions' */
#ifndef SOAP_TYPE_PointerTons2__Mpeg4DecOptions
#define SOAP_TYPE_PointerTons2__Mpeg4DecOptions (1621)
#endif

/* ns2__H264DecOptions * has binding name 'PointerTons2__H264DecOptions' for type 'ns2:H264DecOptions' */
#ifndef SOAP_TYPE_PointerTons2__H264DecOptions
#define SOAP_TYPE_PointerTons2__H264DecOptions (1620)
#endif

/* ns2__JpegDecOptions * has binding name 'PointerTons2__JpegDecOptions' for type 'ns2:JpegDecOptions' */
#ifndef SOAP_TYPE_PointerTons2__JpegDecOptions
#define SOAP_TYPE_PointerTons2__JpegDecOptions (1619)
#endif

/* ns2__PTZStatusFilterOptionsExtension * has binding name 'PointerTons2__PTZStatusFilterOptionsExtension' for type 'ns2:PTZStatusFilterOptionsExtension' */
#ifndef SOAP_TYPE_PointerTons2__PTZStatusFilterOptionsExtension
#define SOAP_TYPE_PointerTons2__PTZStatusFilterOptionsExtension (1618)
#endif

/* ns2__MetadataConfigurationOptionsExtension2 * has binding name 'PointerTons2__MetadataConfigurationOptionsExtension2' for type 'ns2:MetadataConfigurationOptionsExtension2' */
#ifndef SOAP_TYPE_PointerTons2__MetadataConfigurationOptionsExtension2
#define SOAP_TYPE_PointerTons2__MetadataConfigurationOptionsExtension2 (1617)
#endif

/* ns2__MetadataConfigurationOptionsExtension * has binding name 'PointerTons2__MetadataConfigurationOptionsExtension' for type 'ns2:MetadataConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_PointerTons2__MetadataConfigurationOptionsExtension
#define SOAP_TYPE_PointerTons2__MetadataConfigurationOptionsExtension (1616)
#endif

/* ns2__PTZStatusFilterOptions * has binding name 'PointerTons2__PTZStatusFilterOptions' for type 'ns2:PTZStatusFilterOptions' */
#ifndef SOAP_TYPE_PointerTons2__PTZStatusFilterOptions
#define SOAP_TYPE_PointerTons2__PTZStatusFilterOptions (1615)
#endif

/* _ns2__EventSubscription_SubscriptionPolicy * has binding name 'PointerTo_ns2__EventSubscription_SubscriptionPolicy' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns2__EventSubscription_SubscriptionPolicy
#define SOAP_TYPE_PointerTo_ns2__EventSubscription_SubscriptionPolicy (1614)
#endif

/* ns3__FilterType * has binding name 'PointerTons3__FilterType' for type 'ns3:FilterType' */
#ifndef SOAP_TYPE_PointerTons3__FilterType
#define SOAP_TYPE_PointerTons3__FilterType (1612)
#endif

/* ns2__AudioEncoderConfigurationOption * has binding name 'PointerTons2__AudioEncoderConfigurationOption' for type 'ns2:AudioEncoderConfigurationOption' */
#ifndef SOAP_TYPE_PointerTons2__AudioEncoderConfigurationOption
#define SOAP_TYPE_PointerTons2__AudioEncoderConfigurationOption (1610)
#endif

/* ns2__AudioSourceOptionsExtension * has binding name 'PointerTons2__AudioSourceOptionsExtension' for type 'ns2:AudioSourceOptionsExtension' */
#ifndef SOAP_TYPE_PointerTons2__AudioSourceOptionsExtension
#define SOAP_TYPE_PointerTons2__AudioSourceOptionsExtension (1609)
#endif

/* std::string * has binding name 'PointerTons2__FloatAttrList' for type 'ns2:FloatAttrList' */
#ifndef SOAP_TYPE_PointerTons2__FloatAttrList
#define SOAP_TYPE_PointerTons2__FloatAttrList (1608)
#endif

/* std::string * has binding name 'PointerTons2__IntAttrList' for type 'ns2:IntAttrList' */
#ifndef SOAP_TYPE_PointerTons2__IntAttrList
#define SOAP_TYPE_PointerTons2__IntAttrList (1607)
#endif

/* ns2__VideoResolution2 * has binding name 'PointerTons2__VideoResolution2' for type 'ns2:VideoResolution2' */
#ifndef SOAP_TYPE_PointerTons2__VideoResolution2
#define SOAP_TYPE_PointerTons2__VideoResolution2 (1605)
#endif

/* ns2__FloatRange * has binding name 'PointerTons2__FloatRange' for type 'ns2:FloatRange' */
#ifndef SOAP_TYPE_PointerTons2__FloatRange
#define SOAP_TYPE_PointerTons2__FloatRange (1604)
#endif

/* ns2__VideoResolution * has binding name 'PointerTons2__VideoResolution' for type 'ns2:VideoResolution' */
#ifndef SOAP_TYPE_PointerTons2__VideoResolution
#define SOAP_TYPE_PointerTons2__VideoResolution (1600)
#endif

/* ns2__VideoEncoderOptionsExtension2 * has binding name 'PointerTons2__VideoEncoderOptionsExtension2' for type 'ns2:VideoEncoderOptionsExtension2' */
#ifndef SOAP_TYPE_PointerTons2__VideoEncoderOptionsExtension2
#define SOAP_TYPE_PointerTons2__VideoEncoderOptionsExtension2 (1599)
#endif

/* ns2__H264Options2 * has binding name 'PointerTons2__H264Options2' for type 'ns2:H264Options2' */
#ifndef SOAP_TYPE_PointerTons2__H264Options2
#define SOAP_TYPE_PointerTons2__H264Options2 (1598)
#endif

/* ns2__Mpeg4Options2 * has binding name 'PointerTons2__Mpeg4Options2' for type 'ns2:Mpeg4Options2' */
#ifndef SOAP_TYPE_PointerTons2__Mpeg4Options2
#define SOAP_TYPE_PointerTons2__Mpeg4Options2 (1597)
#endif

/* ns2__JpegOptions2 * has binding name 'PointerTons2__JpegOptions2' for type 'ns2:JpegOptions2' */
#ifndef SOAP_TYPE_PointerTons2__JpegOptions2
#define SOAP_TYPE_PointerTons2__JpegOptions2 (1596)
#endif

/* ns2__VideoEncoderOptionsExtension * has binding name 'PointerTons2__VideoEncoderOptionsExtension' for type 'ns2:VideoEncoderOptionsExtension' */
#ifndef SOAP_TYPE_PointerTons2__VideoEncoderOptionsExtension
#define SOAP_TYPE_PointerTons2__VideoEncoderOptionsExtension (1595)
#endif

/* ns2__H264Options * has binding name 'PointerTons2__H264Options' for type 'ns2:H264Options' */
#ifndef SOAP_TYPE_PointerTons2__H264Options
#define SOAP_TYPE_PointerTons2__H264Options (1594)
#endif

/* ns2__Mpeg4Options * has binding name 'PointerTons2__Mpeg4Options' for type 'ns2:Mpeg4Options' */
#ifndef SOAP_TYPE_PointerTons2__Mpeg4Options
#define SOAP_TYPE_PointerTons2__Mpeg4Options (1593)
#endif

/* ns2__JpegOptions * has binding name 'PointerTons2__JpegOptions' for type 'ns2:JpegOptions' */
#ifndef SOAP_TYPE_PointerTons2__JpegOptions
#define SOAP_TYPE_PointerTons2__JpegOptions (1592)
#endif

/* ns2__RotateOptionsExtension * has binding name 'PointerTons2__RotateOptionsExtension' for type 'ns2:RotateOptionsExtension' */
#ifndef SOAP_TYPE_PointerTons2__RotateOptionsExtension
#define SOAP_TYPE_PointerTons2__RotateOptionsExtension (1591)
#endif

/* ns2__IntList * has binding name 'PointerTons2__IntList' for type 'ns2:IntList' */
#ifndef SOAP_TYPE_PointerTons2__IntList
#define SOAP_TYPE_PointerTons2__IntList (1590)
#endif

/* ns2__VideoSourceConfigurationOptionsExtension2 * has binding name 'PointerTons2__VideoSourceConfigurationOptionsExtension2' for type 'ns2:VideoSourceConfigurationOptionsExtension2' */
#ifndef SOAP_TYPE_PointerTons2__VideoSourceConfigurationOptionsExtension2
#define SOAP_TYPE_PointerTons2__VideoSourceConfigurationOptionsExtension2 (1588)
#endif

/* ns2__RotateOptions * has binding name 'PointerTons2__RotateOptions' for type 'ns2:RotateOptions' */
#ifndef SOAP_TYPE_PointerTons2__RotateOptions
#define SOAP_TYPE_PointerTons2__RotateOptions (1587)
#endif

/* ns2__VideoSourceConfigurationOptionsExtension * has binding name 'PointerTons2__VideoSourceConfigurationOptionsExtension' for type 'ns2:VideoSourceConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_PointerTons2__VideoSourceConfigurationOptionsExtension
#define SOAP_TYPE_PointerTons2__VideoSourceConfigurationOptionsExtension (1586)
#endif

/* ns2__IntRectangleRange * has binding name 'PointerTons2__IntRectangleRange' for type 'ns2:IntRectangleRange' */
#ifndef SOAP_TYPE_PointerTons2__IntRectangleRange
#define SOAP_TYPE_PointerTons2__IntRectangleRange (1585)
#endif

/* ns2__LensProjection * has binding name 'PointerTons2__LensProjection' for type 'ns2:LensProjection' */
#ifndef SOAP_TYPE_PointerTons2__LensProjection
#define SOAP_TYPE_PointerTons2__LensProjection (1583)
#endif

/* ns2__LensOffset * has binding name 'PointerTons2__LensOffset' for type 'ns2:LensOffset' */
#ifndef SOAP_TYPE_PointerTons2__LensOffset
#define SOAP_TYPE_PointerTons2__LensOffset (1582)
#endif

/* float * has binding name 'PointerTofloat' for type 'xsd:float' */
#ifndef SOAP_TYPE_PointerTofloat
#define SOAP_TYPE_PointerTofloat (1581)
#endif

/* ns2__RotateExtension * has binding name 'PointerTons2__RotateExtension' for type 'ns2:RotateExtension' */
#ifndef SOAP_TYPE_PointerTons2__RotateExtension
#define SOAP_TYPE_PointerTons2__RotateExtension (1580)
#endif

/* ns2__LensDescription * has binding name 'PointerTons2__LensDescription' for type 'ns2:LensDescription' */
#ifndef SOAP_TYPE_PointerTons2__LensDescription
#define SOAP_TYPE_PointerTons2__LensDescription (1578)
#endif

/* ns2__VideoSourceConfigurationExtension2 * has binding name 'PointerTons2__VideoSourceConfigurationExtension2' for type 'ns2:VideoSourceConfigurationExtension2' */
#ifndef SOAP_TYPE_PointerTons2__VideoSourceConfigurationExtension2
#define SOAP_TYPE_PointerTons2__VideoSourceConfigurationExtension2 (1577)
#endif

/* ns2__Rotate * has binding name 'PointerTons2__Rotate' for type 'ns2:Rotate' */
#ifndef SOAP_TYPE_PointerTons2__Rotate
#define SOAP_TYPE_PointerTons2__Rotate (1576)
#endif

/* ns2__ProfileExtension2 * has binding name 'PointerTons2__ProfileExtension2' for type 'ns2:ProfileExtension2' */
#ifndef SOAP_TYPE_PointerTons2__ProfileExtension2
#define SOAP_TYPE_PointerTons2__ProfileExtension2 (1575)
#endif

/* ns2__AudioDecoderConfiguration * has binding name 'PointerTons2__AudioDecoderConfiguration' for type 'ns2:AudioDecoderConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__AudioDecoderConfiguration
#define SOAP_TYPE_PointerTons2__AudioDecoderConfiguration (1574)
#endif

/* ns2__AudioOutputConfiguration * has binding name 'PointerTons2__AudioOutputConfiguration' for type 'ns2:AudioOutputConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__AudioOutputConfiguration
#define SOAP_TYPE_PointerTons2__AudioOutputConfiguration (1573)
#endif

/* ns2__ProfileExtension * has binding name 'PointerTons2__ProfileExtension' for type 'ns2:ProfileExtension' */
#ifndef SOAP_TYPE_PointerTons2__ProfileExtension
#define SOAP_TYPE_PointerTons2__ProfileExtension (1572)
#endif

/* ns2__MetadataConfiguration * has binding name 'PointerTons2__MetadataConfiguration' for type 'ns2:MetadataConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__MetadataConfiguration
#define SOAP_TYPE_PointerTons2__MetadataConfiguration (1571)
#endif

/* ns2__PTZConfiguration * has binding name 'PointerTons2__PTZConfiguration' for type 'ns2:PTZConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__PTZConfiguration
#define SOAP_TYPE_PointerTons2__PTZConfiguration (1570)
#endif

/* ns2__VideoAnalyticsConfiguration * has binding name 'PointerTons2__VideoAnalyticsConfiguration' for type 'ns2:VideoAnalyticsConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__VideoAnalyticsConfiguration
#define SOAP_TYPE_PointerTons2__VideoAnalyticsConfiguration (1569)
#endif

/* ns2__AudioEncoderConfiguration * has binding name 'PointerTons2__AudioEncoderConfiguration' for type 'ns2:AudioEncoderConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__AudioEncoderConfiguration
#define SOAP_TYPE_PointerTons2__AudioEncoderConfiguration (1568)
#endif

/* ns2__VideoEncoderConfiguration * has binding name 'PointerTons2__VideoEncoderConfiguration' for type 'ns2:VideoEncoderConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__VideoEncoderConfiguration
#define SOAP_TYPE_PointerTons2__VideoEncoderConfiguration (1567)
#endif

/* ns2__AudioSourceConfiguration * has binding name 'PointerTons2__AudioSourceConfiguration' for type 'ns2:AudioSourceConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__AudioSourceConfiguration
#define SOAP_TYPE_PointerTons2__AudioSourceConfiguration (1566)
#endif

/* ns2__VideoSourceConfiguration * has binding name 'PointerTons2__VideoSourceConfiguration' for type 'ns2:VideoSourceConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__VideoSourceConfiguration
#define SOAP_TYPE_PointerTons2__VideoSourceConfiguration (1565)
#endif

/* ns2__VideoSourceExtension2 * has binding name 'PointerTons2__VideoSourceExtension2' for type 'ns2:VideoSourceExtension2' */
#ifndef SOAP_TYPE_PointerTons2__VideoSourceExtension2
#define SOAP_TYPE_PointerTons2__VideoSourceExtension2 (1564)
#endif

/* ns2__ImagingSettings20 * has binding name 'PointerTons2__ImagingSettings20' for type 'ns2:ImagingSettings20' */
#ifndef SOAP_TYPE_PointerTons2__ImagingSettings20
#define SOAP_TYPE_PointerTons2__ImagingSettings20 (1563)
#endif

/* ns2__IntRange * has binding name 'PointerTons2__IntRange' for type 'ns2:IntRange' */
#ifndef SOAP_TYPE_PointerTons2__IntRange
#define SOAP_TYPE_PointerTons2__IntRange (1559)
#endif

/* ns1__StorageConfigurationData * has binding name 'PointerTons1__StorageConfigurationData' for type 'ns1:StorageConfigurationData' */
#ifndef SOAP_TYPE_PointerTons1__StorageConfigurationData
#define SOAP_TYPE_PointerTons1__StorageConfigurationData (1558)
#endif

/* ns1__StorageConfiguration * has binding name 'PointerTons1__StorageConfiguration' for type 'ns1:StorageConfiguration' */
#ifndef SOAP_TYPE_PointerTons1__StorageConfiguration
#define SOAP_TYPE_PointerTons1__StorageConfiguration (1556)
#endif

/* _ns1__GetSystemUrisResponse_Extension * has binding name 'PointerTo_ns1__GetSystemUrisResponse_Extension' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetSystemUrisResponse_Extension
#define SOAP_TYPE_PointerTo_ns1__GetSystemUrisResponse_Extension (1555)
#endif

/* ns2__SystemLogUriList * has binding name 'PointerTons2__SystemLogUriList' for type 'ns2:SystemLogUriList' */
#ifndef SOAP_TYPE_PointerTons2__SystemLogUriList
#define SOAP_TYPE_PointerTons2__SystemLogUriList (1553)
#endif

/* ns2__Dot11AvailableNetworks * has binding name 'PointerTons2__Dot11AvailableNetworks' for type 'ns2:Dot11AvailableNetworks' */
#ifndef SOAP_TYPE_PointerTons2__Dot11AvailableNetworks
#define SOAP_TYPE_PointerTons2__Dot11AvailableNetworks (1551)
#endif

/* ns2__Dot11Status * has binding name 'PointerTons2__Dot11Status' for type 'ns2:Dot11Status' */
#ifndef SOAP_TYPE_PointerTons2__Dot11Status
#define SOAP_TYPE_PointerTons2__Dot11Status (1550)
#endif

/* ns2__Dot11Capabilities * has binding name 'PointerTons2__Dot11Capabilities' for type 'ns2:Dot11Capabilities' */
#ifndef SOAP_TYPE_PointerTons2__Dot11Capabilities
#define SOAP_TYPE_PointerTons2__Dot11Capabilities (1549)
#endif

/* std::string * has binding name 'PointerTons2__AuxiliaryData' for type 'ns2:AuxiliaryData' */
#ifndef SOAP_TYPE_PointerTons2__AuxiliaryData
#define SOAP_TYPE_PointerTons2__AuxiliaryData (1548)
#endif

/* ns2__RelayOutputSettings * has binding name 'PointerTons2__RelayOutputSettings' for type 'ns2:RelayOutputSettings' */
#ifndef SOAP_TYPE_PointerTons2__RelayOutputSettings
#define SOAP_TYPE_PointerTons2__RelayOutputSettings (1547)
#endif

/* ns2__RelayOutput * has binding name 'PointerTons2__RelayOutput' for type 'ns2:RelayOutput' */
#ifndef SOAP_TYPE_PointerTons2__RelayOutput
#define SOAP_TYPE_PointerTons2__RelayOutput (1545)
#endif

/* ns2__Dot1XConfiguration * has binding name 'PointerTons2__Dot1XConfiguration' for type 'ns2:Dot1XConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__Dot1XConfiguration
#define SOAP_TYPE_PointerTons2__Dot1XConfiguration (1542)
#endif

/* ns2__CertificateInformation * has binding name 'PointerTons2__CertificateInformation' for type 'ns2:CertificateInformation' */
#ifndef SOAP_TYPE_PointerTons2__CertificateInformation
#define SOAP_TYPE_PointerTons2__CertificateInformation (1541)
#endif

/* ns2__CertificateWithPrivateKey * has binding name 'PointerTons2__CertificateWithPrivateKey' for type 'ns2:CertificateWithPrivateKey' */
#ifndef SOAP_TYPE_PointerTons2__CertificateWithPrivateKey
#define SOAP_TYPE_PointerTons2__CertificateWithPrivateKey (1539)
#endif

/* ns2__CertificateStatus * has binding name 'PointerTons2__CertificateStatus' for type 'ns2:CertificateStatus' */
#ifndef SOAP_TYPE_PointerTons2__CertificateStatus
#define SOAP_TYPE_PointerTons2__CertificateStatus (1537)
#endif

/* ns2__Certificate * has binding name 'PointerTons2__Certificate' for type 'ns2:Certificate' */
#ifndef SOAP_TYPE_PointerTons2__Certificate
#define SOAP_TYPE_PointerTons2__Certificate (1535)
#endif

/* std::string * has binding name 'PointerToxsd__token' for type 'xsd:token' */
#ifndef SOAP_TYPE_PointerToxsd__token
#define SOAP_TYPE_PointerToxsd__token (1534)
#endif

/* ns2__BinaryData * has binding name 'PointerTons2__BinaryData' for type 'ns2:BinaryData' */
#ifndef SOAP_TYPE_PointerTons2__BinaryData
#define SOAP_TYPE_PointerTons2__BinaryData (1533)
#endif

/* ns2__IPAddressFilter * has binding name 'PointerTons2__IPAddressFilter' for type 'ns2:IPAddressFilter' */
#ifndef SOAP_TYPE_PointerTons2__IPAddressFilter
#define SOAP_TYPE_PointerTons2__IPAddressFilter (1532)
#endif

/* ns2__NetworkZeroConfiguration * has binding name 'PointerTons2__NetworkZeroConfiguration' for type 'ns2:NetworkZeroConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__NetworkZeroConfiguration
#define SOAP_TYPE_PointerTons2__NetworkZeroConfiguration (1531)
#endif

/* ns2__NetworkGateway * has binding name 'PointerTons2__NetworkGateway' for type 'ns2:NetworkGateway' */
#ifndef SOAP_TYPE_PointerTons2__NetworkGateway
#define SOAP_TYPE_PointerTons2__NetworkGateway (1528)
#endif

/* ns2__NetworkProtocol * has binding name 'PointerTons2__NetworkProtocol' for type 'ns2:NetworkProtocol' */
#ifndef SOAP_TYPE_PointerTons2__NetworkProtocol
#define SOAP_TYPE_PointerTons2__NetworkProtocol (1526)
#endif

/* ns2__NetworkInterfaceSetConfiguration * has binding name 'PointerTons2__NetworkInterfaceSetConfiguration' for type 'ns2:NetworkInterfaceSetConfiguration' */
#ifndef SOAP_TYPE_PointerTons2__NetworkInterfaceSetConfiguration
#define SOAP_TYPE_PointerTons2__NetworkInterfaceSetConfiguration (1525)
#endif

/* ns2__NetworkInterface * has binding name 'PointerTons2__NetworkInterface' for type 'ns2:NetworkInterface' */
#ifndef SOAP_TYPE_PointerTons2__NetworkInterface
#define SOAP_TYPE_PointerTons2__NetworkInterface (1523)
#endif

/* std::string * has binding name 'PointerToxsd__duration' for type 'xsd:duration' */
#ifndef SOAP_TYPE_PointerToxsd__duration
#define SOAP_TYPE_PointerToxsd__duration (1522)
#endif

/* std::string * has binding name 'PointerTons2__DNSName' for type 'ns2:DNSName' */
#ifndef SOAP_TYPE_PointerTons2__DNSName
#define SOAP_TYPE_PointerTons2__DNSName (1521)
#endif

/* ns2__DynamicDNSInformation * has binding name 'PointerTons2__DynamicDNSInformation' for type 'ns2:DynamicDNSInformation' */
#ifndef SOAP_TYPE_PointerTons2__DynamicDNSInformation
#define SOAP_TYPE_PointerTons2__DynamicDNSInformation (1520)
#endif

/* ns2__NTPInformation * has binding name 'PointerTons2__NTPInformation' for type 'ns2:NTPInformation' */
#ifndef SOAP_TYPE_PointerTons2__NTPInformation
#define SOAP_TYPE_PointerTons2__NTPInformation (1519)
#endif

/* ns2__IPAddress * has binding name 'PointerTons2__IPAddress' for type 'ns2:IPAddress' */
#ifndef SOAP_TYPE_PointerTons2__IPAddress
#define SOAP_TYPE_PointerTons2__IPAddress (1517)
#endif

/* ns2__DNSInformation * has binding name 'PointerTons2__DNSInformation' for type 'ns2:DNSInformation' */
#ifndef SOAP_TYPE_PointerTons2__DNSInformation
#define SOAP_TYPE_PointerTons2__DNSInformation (1515)
#endif

/* ns2__HostnameInformation * has binding name 'PointerTons2__HostnameInformation' for type 'ns2:HostnameInformation' */
#ifndef SOAP_TYPE_PointerTons2__HostnameInformation
#define SOAP_TYPE_PointerTons2__HostnameInformation (1514)
#endif

/* ns2__Capabilities * has binding name 'PointerTons2__Capabilities' for type 'ns2:Capabilities' */
#ifndef SOAP_TYPE_PointerTons2__Capabilities
#define SOAP_TYPE_PointerTons2__Capabilities (1513)
#endif

/* ns2__User * has binding name 'PointerTons2__User' for type 'ns2:User' */
#ifndef SOAP_TYPE_PointerTons2__User
#define SOAP_TYPE_PointerTons2__User (1509)
#endif

/* ns2__RemoteUser * has binding name 'PointerTons2__RemoteUser' for type 'ns2:RemoteUser' */
#ifndef SOAP_TYPE_PointerTons2__RemoteUser
#define SOAP_TYPE_PointerTons2__RemoteUser (1508)
#endif

/* ns2__NetworkHost * has binding name 'PointerTons2__NetworkHost' for type 'ns2:NetworkHost' */
#ifndef SOAP_TYPE_PointerTons2__NetworkHost
#define SOAP_TYPE_PointerTons2__NetworkHost (1506)
#endif

/* ns2__Scope * has binding name 'PointerTons2__Scope' for type 'ns2:Scope' */
#ifndef SOAP_TYPE_PointerTons2__Scope
#define SOAP_TYPE_PointerTons2__Scope (1503)
#endif

/* ns2__SystemLog * has binding name 'PointerTons2__SystemLog' for type 'ns2:SystemLog' */
#ifndef SOAP_TYPE_PointerTons2__SystemLog
#define SOAP_TYPE_PointerTons2__SystemLog (1502)
#endif

/* ns2__SupportInformation * has binding name 'PointerTons2__SupportInformation' for type 'ns2:SupportInformation' */
#ifndef SOAP_TYPE_PointerTons2__SupportInformation
#define SOAP_TYPE_PointerTons2__SupportInformation (1501)
#endif

/* ns2__BackupFile * has binding name 'PointerTons2__BackupFile' for type 'ns2:BackupFile' */
#ifndef SOAP_TYPE_PointerTons2__BackupFile
#define SOAP_TYPE_PointerTons2__BackupFile (1499)
#endif

/* ns2__AttachmentData * has binding name 'PointerTons2__AttachmentData' for type 'ns2:AttachmentData' */
#ifndef SOAP_TYPE_PointerTons2__AttachmentData
#define SOAP_TYPE_PointerTons2__AttachmentData (1498)
#endif

/* ns2__SystemDateTime * has binding name 'PointerTons2__SystemDateTime' for type 'ns2:SystemDateTime' */
#ifndef SOAP_TYPE_PointerTons2__SystemDateTime
#define SOAP_TYPE_PointerTons2__SystemDateTime (1497)
#endif

/* ns2__DateTime * has binding name 'PointerTons2__DateTime' for type 'ns2:DateTime' */
#ifndef SOAP_TYPE_PointerTons2__DateTime
#define SOAP_TYPE_PointerTons2__DateTime (1496)
#endif

/* ns2__TimeZone * has binding name 'PointerTons2__TimeZone' for type 'ns2:TimeZone' */
#ifndef SOAP_TYPE_PointerTons2__TimeZone
#define SOAP_TYPE_PointerTons2__TimeZone (1495)
#endif

/* ns1__DeviceServiceCapabilities * has binding name 'PointerTons1__DeviceServiceCapabilities' for type 'ns1:DeviceServiceCapabilities' */
#ifndef SOAP_TYPE_PointerTons1__DeviceServiceCapabilities
#define SOAP_TYPE_PointerTons1__DeviceServiceCapabilities (1494)
#endif

/* ns1__Service * has binding name 'PointerTons1__Service' for type 'ns1:Service' */
#ifndef SOAP_TYPE_PointerTons1__Service
#define SOAP_TYPE_PointerTons1__Service (1492)
#endif

/* _ns1__StorageConfigurationData_Extension * has binding name 'PointerTo_ns1__StorageConfigurationData_Extension' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__StorageConfigurationData_Extension
#define SOAP_TYPE_PointerTo_ns1__StorageConfigurationData_Extension (1491)
#endif

/* ns1__UserCredential * has binding name 'PointerTons1__UserCredential' for type 'ns1:UserCredential' */
#ifndef SOAP_TYPE_PointerTons1__UserCredential
#define SOAP_TYPE_PointerTons1__UserCredential (1489)
#endif

/* std::string * has binding name 'PointerToxsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_PointerToxsd__anyURI
#define SOAP_TYPE_PointerToxsd__anyURI (1488)
#endif

/* _ns1__UserCredential_Extension * has binding name 'PointerTo_ns1__UserCredential_Extension' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__UserCredential_Extension
#define SOAP_TYPE_PointerTo_ns1__UserCredential_Extension (1487)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (1485)
#endif

/* std::string * has binding name 'PointerTons2__StringAttrList' for type 'ns2:StringAttrList' */
#ifndef SOAP_TYPE_PointerTons2__StringAttrList
#define SOAP_TYPE_PointerTons2__StringAttrList (1484)
#endif

/* std::string * has binding name 'PointerTons1__EAPMethodTypes' for type 'ns1:EAPMethodTypes' */
#ifndef SOAP_TYPE_PointerTons1__EAPMethodTypes
#define SOAP_TYPE_PointerTons1__EAPMethodTypes (1483)
#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_PointerTobool
#define SOAP_TYPE_PointerTobool (1482)
#endif

/* ns1__MiscCapabilities * has binding name 'PointerTons1__MiscCapabilities' for type 'ns1:MiscCapabilities' */
#ifndef SOAP_TYPE_PointerTons1__MiscCapabilities
#define SOAP_TYPE_PointerTons1__MiscCapabilities (1480)
#endif

/* ns1__SystemCapabilities * has binding name 'PointerTons1__SystemCapabilities' for type 'ns1:SystemCapabilities' */
#ifndef SOAP_TYPE_PointerTons1__SystemCapabilities
#define SOAP_TYPE_PointerTons1__SystemCapabilities (1479)
#endif

/* ns1__SecurityCapabilities * has binding name 'PointerTons1__SecurityCapabilities' for type 'ns1:SecurityCapabilities' */
#ifndef SOAP_TYPE_PointerTons1__SecurityCapabilities
#define SOAP_TYPE_PointerTons1__SecurityCapabilities (1478)
#endif

/* ns1__NetworkCapabilities * has binding name 'PointerTons1__NetworkCapabilities' for type 'ns1:NetworkCapabilities' */
#ifndef SOAP_TYPE_PointerTons1__NetworkCapabilities
#define SOAP_TYPE_PointerTons1__NetworkCapabilities (1477)
#endif

/* ns2__OnvifVersion * has binding name 'PointerTons2__OnvifVersion' for type 'ns2:OnvifVersion' */
#ifndef SOAP_TYPE_PointerTons2__OnvifVersion
#define SOAP_TYPE_PointerTons2__OnvifVersion (1475)
#endif

/* _ns1__Service_Capabilities * has binding name 'PointerTo_ns1__Service_Capabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__Service_Capabilities
#define SOAP_TYPE_PointerTo_ns1__Service_Capabilities (1474)
#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_PointerTounsignedByte
#define SOAP_TYPE_PointerTounsignedByte (229)
#endif

/* struct _wsse__Security * has binding name 'PointerTo_wsse__Security' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Security
#define SOAP_TYPE_PointerTo_wsse__Security (215)
#endif

/* struct ds__SignatureType * has binding name 'PointerTods__SignatureType' for type 'ds:SignatureType' */
#ifndef SOAP_TYPE_PointerTods__SignatureType
#define SOAP_TYPE_PointerTods__SignatureType (213)
#endif

/* struct wsc__SecurityContextTokenType * has binding name 'PointerTowsc__SecurityContextTokenType' for type 'wsc:SecurityContextTokenType' */
#ifndef SOAP_TYPE_PointerTowsc__SecurityContextTokenType
#define SOAP_TYPE_PointerTowsc__SecurityContextTokenType (212)
#endif

/* struct _wsse__BinarySecurityToken * has binding name 'PointerTo_wsse__BinarySecurityToken' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__BinarySecurityToken
#define SOAP_TYPE_PointerTo_wsse__BinarySecurityToken (211)
#endif

/* struct _wsse__UsernameToken * has binding name 'PointerTo_wsse__UsernameToken' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__UsernameToken
#define SOAP_TYPE_PointerTo_wsse__UsernameToken (210)
#endif

/* struct _wsu__Timestamp * has binding name 'PointerTo_wsu__Timestamp' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsu__Timestamp
#define SOAP_TYPE_PointerTo_wsu__Timestamp (209)
#endif

/* struct ds__KeyInfoType ** has binding name 'PointerToPointerTo_ds__KeyInfo' for type '' */
#ifndef SOAP_TYPE_PointerToPointerTo_ds__KeyInfo
#define SOAP_TYPE_PointerToPointerTo_ds__KeyInfo (207)
#endif

/* struct __saml2__union_AttributeStatementType * has binding name 'PointerTo__saml2__union_AttributeStatementType' for type '-saml2:union-AttributeStatementType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_AttributeStatementType
#define SOAP_TYPE_PointerTo__saml2__union_AttributeStatementType (206)
#endif

/* struct saml2__AttributeType * has binding name 'PointerTosaml2__AttributeType' for type 'saml2:AttributeType' */
#ifndef SOAP_TYPE_PointerTosaml2__AttributeType
#define SOAP_TYPE_PointerTosaml2__AttributeType (205)
#endif

/* struct saml2__EvidenceType * has binding name 'PointerTosaml2__EvidenceType' for type 'saml2:EvidenceType' */
#ifndef SOAP_TYPE_PointerTosaml2__EvidenceType
#define SOAP_TYPE_PointerTosaml2__EvidenceType (203)
#endif

/* struct saml2__ActionType * has binding name 'PointerTosaml2__ActionType' for type 'saml2:ActionType' */
#ifndef SOAP_TYPE_PointerTosaml2__ActionType
#define SOAP_TYPE_PointerTosaml2__ActionType (202)
#endif

/* struct saml2__AuthnContextType * has binding name 'PointerTosaml2__AuthnContextType' for type 'saml2:AuthnContextType' */
#ifndef SOAP_TYPE_PointerTosaml2__AuthnContextType
#define SOAP_TYPE_PointerTosaml2__AuthnContextType (201)
#endif

/* struct saml2__SubjectLocalityType * has binding name 'PointerTosaml2__SubjectLocalityType' for type 'saml2:SubjectLocalityType' */
#ifndef SOAP_TYPE_PointerTosaml2__SubjectLocalityType
#define SOAP_TYPE_PointerTosaml2__SubjectLocalityType (200)
#endif

/* struct __saml2__union_EvidenceType * has binding name 'PointerTo__saml2__union_EvidenceType' for type '-saml2:union-EvidenceType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_EvidenceType
#define SOAP_TYPE_PointerTo__saml2__union_EvidenceType (199)
#endif

/* struct __saml2__union_AdviceType * has binding name 'PointerTo__saml2__union_AdviceType' for type '-saml2:union-AdviceType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_AdviceType
#define SOAP_TYPE_PointerTo__saml2__union_AdviceType (197)
#endif

/* struct saml2__AssertionType * has binding name 'PointerTosaml2__AssertionType' for type 'saml2:AssertionType' */
#ifndef SOAP_TYPE_PointerTosaml2__AssertionType
#define SOAP_TYPE_PointerTosaml2__AssertionType (196)
#endif

/* struct __saml2__union_ConditionsType * has binding name 'PointerTo__saml2__union_ConditionsType' for type '-saml2:union-ConditionsType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_ConditionsType
#define SOAP_TYPE_PointerTo__saml2__union_ConditionsType (194)
#endif

/* struct saml2__ProxyRestrictionType * has binding name 'PointerTosaml2__ProxyRestrictionType' for type 'saml2:ProxyRestrictionType' */
#ifndef SOAP_TYPE_PointerTosaml2__ProxyRestrictionType
#define SOAP_TYPE_PointerTosaml2__ProxyRestrictionType (193)
#endif

/* struct saml2__OneTimeUseType * has binding name 'PointerTosaml2__OneTimeUseType' for type 'saml2:OneTimeUseType' */
#ifndef SOAP_TYPE_PointerTosaml2__OneTimeUseType
#define SOAP_TYPE_PointerTosaml2__OneTimeUseType (192)
#endif

/* struct saml2__AudienceRestrictionType * has binding name 'PointerTosaml2__AudienceRestrictionType' for type 'saml2:AudienceRestrictionType' */
#ifndef SOAP_TYPE_PointerTosaml2__AudienceRestrictionType
#define SOAP_TYPE_PointerTosaml2__AudienceRestrictionType (191)
#endif

/* struct saml2__ConditionAbstractType * has binding name 'PointerTosaml2__ConditionAbstractType' for type 'saml2:ConditionAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml2__ConditionAbstractType
#define SOAP_TYPE_PointerTosaml2__ConditionAbstractType (190)
#endif

/* struct saml2__SubjectConfirmationDataType * has binding name 'PointerTosaml2__SubjectConfirmationDataType' for type 'saml2:SubjectConfirmationDataType' */
#ifndef SOAP_TYPE_PointerTosaml2__SubjectConfirmationDataType
#define SOAP_TYPE_PointerTosaml2__SubjectConfirmationDataType (188)
#endif

/* struct saml2__SubjectConfirmationType * has binding name 'PointerTosaml2__SubjectConfirmationType' for type 'saml2:SubjectConfirmationType' */
#ifndef SOAP_TYPE_PointerTosaml2__SubjectConfirmationType
#define SOAP_TYPE_PointerTosaml2__SubjectConfirmationType (187)
#endif

/* struct saml2__EncryptedElementType * has binding name 'PointerTosaml2__EncryptedElementType' for type 'saml2:EncryptedElementType' */
#ifndef SOAP_TYPE_PointerTosaml2__EncryptedElementType
#define SOAP_TYPE_PointerTosaml2__EncryptedElementType (186)
#endif

/* struct saml2__BaseIDAbstractType * has binding name 'PointerTosaml2__BaseIDAbstractType' for type 'saml2:BaseIDAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml2__BaseIDAbstractType
#define SOAP_TYPE_PointerTosaml2__BaseIDAbstractType (185)
#endif

/* struct __saml2__union_AssertionType * has binding name 'PointerTo__saml2__union_AssertionType' for type '-saml2:union-AssertionType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_AssertionType
#define SOAP_TYPE_PointerTo__saml2__union_AssertionType (184)
#endif

/* struct saml2__AttributeStatementType * has binding name 'PointerTosaml2__AttributeStatementType' for type 'saml2:AttributeStatementType' */
#ifndef SOAP_TYPE_PointerTosaml2__AttributeStatementType
#define SOAP_TYPE_PointerTosaml2__AttributeStatementType (183)
#endif

/* struct saml2__AuthzDecisionStatementType * has binding name 'PointerTosaml2__AuthzDecisionStatementType' for type 'saml2:AuthzDecisionStatementType' */
#ifndef SOAP_TYPE_PointerTosaml2__AuthzDecisionStatementType
#define SOAP_TYPE_PointerTosaml2__AuthzDecisionStatementType (182)
#endif

/* struct saml2__AuthnStatementType * has binding name 'PointerTosaml2__AuthnStatementType' for type 'saml2:AuthnStatementType' */
#ifndef SOAP_TYPE_PointerTosaml2__AuthnStatementType
#define SOAP_TYPE_PointerTosaml2__AuthnStatementType (181)
#endif

/* struct saml2__StatementAbstractType * has binding name 'PointerTosaml2__StatementAbstractType' for type 'saml2:StatementAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml2__StatementAbstractType
#define SOAP_TYPE_PointerTosaml2__StatementAbstractType (180)
#endif

/* struct saml2__AdviceType * has binding name 'PointerTosaml2__AdviceType' for type 'saml2:AdviceType' */
#ifndef SOAP_TYPE_PointerTosaml2__AdviceType
#define SOAP_TYPE_PointerTosaml2__AdviceType (178)
#endif

/* struct saml2__ConditionsType * has binding name 'PointerTosaml2__ConditionsType' for type 'saml2:ConditionsType' */
#ifndef SOAP_TYPE_PointerTosaml2__ConditionsType
#define SOAP_TYPE_PointerTosaml2__ConditionsType (177)
#endif

/* struct saml2__SubjectType * has binding name 'PointerTosaml2__SubjectType' for type 'saml2:SubjectType' */
#ifndef SOAP_TYPE_PointerTosaml2__SubjectType
#define SOAP_TYPE_PointerTosaml2__SubjectType (176)
#endif

/* struct saml2__NameIDType * has binding name 'PointerTosaml2__NameIDType' for type 'saml2:NameIDType' */
#ifndef SOAP_TYPE_PointerTosaml2__NameIDType
#define SOAP_TYPE_PointerTosaml2__NameIDType (175)
#endif

/* struct xenc__EncryptedKeyType ** has binding name 'PointerToPointerToxenc__EncryptedKeyType' for type 'xenc:EncryptedKeyType' */
#ifndef SOAP_TYPE_PointerToPointerToxenc__EncryptedKeyType
#define SOAP_TYPE_PointerToPointerToxenc__EncryptedKeyType (174)
#endif

/* struct xenc__EncryptedKeyType * has binding name 'PointerToxenc__EncryptedKeyType' for type 'xenc:EncryptedKeyType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptedKeyType
#define SOAP_TYPE_PointerToxenc__EncryptedKeyType (173)
#endif

/* struct saml1__AttributeType * has binding name 'PointerTosaml1__AttributeType' for type 'saml1:AttributeType' */
#ifndef SOAP_TYPE_PointerTosaml1__AttributeType
#define SOAP_TYPE_PointerTosaml1__AttributeType (148)
#endif

/* struct saml1__EvidenceType * has binding name 'PointerTosaml1__EvidenceType' for type 'saml1:EvidenceType' */
#ifndef SOAP_TYPE_PointerTosaml1__EvidenceType
#define SOAP_TYPE_PointerTosaml1__EvidenceType (147)
#endif

/* struct saml1__ActionType * has binding name 'PointerTosaml1__ActionType' for type 'saml1:ActionType' */
#ifndef SOAP_TYPE_PointerTosaml1__ActionType
#define SOAP_TYPE_PointerTosaml1__ActionType (146)
#endif

/* struct saml1__AuthorityBindingType * has binding name 'PointerTosaml1__AuthorityBindingType' for type 'saml1:AuthorityBindingType' */
#ifndef SOAP_TYPE_PointerTosaml1__AuthorityBindingType
#define SOAP_TYPE_PointerTosaml1__AuthorityBindingType (145)
#endif

/* struct saml1__SubjectLocalityType * has binding name 'PointerTosaml1__SubjectLocalityType' for type 'saml1:SubjectLocalityType' */
#ifndef SOAP_TYPE_PointerTosaml1__SubjectLocalityType
#define SOAP_TYPE_PointerTosaml1__SubjectLocalityType (144)
#endif

/* char ** has binding name 'PointerTo_XML' for type '' */
#ifndef SOAP_TYPE_PointerTo_XML
#define SOAP_TYPE_PointerTo_XML (143)
#endif

/* struct saml1__SubjectType * has binding name 'PointerTosaml1__SubjectType' for type 'saml1:SubjectType' */
#ifndef SOAP_TYPE_PointerTosaml1__SubjectType
#define SOAP_TYPE_PointerTosaml1__SubjectType (142)
#endif

/* struct __saml1__union_EvidenceType * has binding name 'PointerTo__saml1__union_EvidenceType' for type '-saml1:union-EvidenceType' */
#ifndef SOAP_TYPE_PointerTo__saml1__union_EvidenceType
#define SOAP_TYPE_PointerTo__saml1__union_EvidenceType (141)
#endif

/* char ** has binding name 'PointerTostring' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostring
#define SOAP_TYPE_PointerTostring (139)
#endif

/* struct saml1__SubjectConfirmationType * has binding name 'PointerTosaml1__SubjectConfirmationType' for type 'saml1:SubjectConfirmationType' */
#ifndef SOAP_TYPE_PointerTosaml1__SubjectConfirmationType
#define SOAP_TYPE_PointerTosaml1__SubjectConfirmationType (138)
#endif

/* struct saml1__NameIdentifierType * has binding name 'PointerTosaml1__NameIdentifierType' for type 'saml1:NameIdentifierType' */
#ifndef SOAP_TYPE_PointerTosaml1__NameIdentifierType
#define SOAP_TYPE_PointerTosaml1__NameIdentifierType (137)
#endif

/* struct __saml1__union_AdviceType * has binding name 'PointerTo__saml1__union_AdviceType' for type '-saml1:union-AdviceType' */
#ifndef SOAP_TYPE_PointerTo__saml1__union_AdviceType
#define SOAP_TYPE_PointerTo__saml1__union_AdviceType (136)
#endif

/* struct saml1__AssertionType * has binding name 'PointerTosaml1__AssertionType' for type 'saml1:AssertionType' */
#ifndef SOAP_TYPE_PointerTosaml1__AssertionType
#define SOAP_TYPE_PointerTosaml1__AssertionType (135)
#endif

/* time_t * has binding name 'PointerTodateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_PointerTodateTime
#define SOAP_TYPE_PointerTodateTime (133)
#endif

/* struct __saml1__union_ConditionsType * has binding name 'PointerTo__saml1__union_ConditionsType' for type '-saml1:union-ConditionsType' */
#ifndef SOAP_TYPE_PointerTo__saml1__union_ConditionsType
#define SOAP_TYPE_PointerTo__saml1__union_ConditionsType (132)
#endif

/* struct saml1__ConditionAbstractType * has binding name 'PointerTosaml1__ConditionAbstractType' for type 'saml1:ConditionAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml1__ConditionAbstractType
#define SOAP_TYPE_PointerTosaml1__ConditionAbstractType (131)
#endif

/* struct saml1__DoNotCacheConditionType * has binding name 'PointerTosaml1__DoNotCacheConditionType' for type 'saml1:DoNotCacheConditionType' */
#ifndef SOAP_TYPE_PointerTosaml1__DoNotCacheConditionType
#define SOAP_TYPE_PointerTosaml1__DoNotCacheConditionType (130)
#endif

/* struct saml1__AudienceRestrictionConditionType * has binding name 'PointerTosaml1__AudienceRestrictionConditionType' for type 'saml1:AudienceRestrictionConditionType' */
#ifndef SOAP_TYPE_PointerTosaml1__AudienceRestrictionConditionType
#define SOAP_TYPE_PointerTosaml1__AudienceRestrictionConditionType (129)
#endif

/* struct ds__SignatureType * has binding name 'PointerTo_ds__Signature' for type '' */
#ifndef SOAP_TYPE_PointerTo_ds__Signature
#define SOAP_TYPE_PointerTo_ds__Signature (126)
#endif

/* struct __saml1__union_AssertionType * has binding name 'PointerTo__saml1__union_AssertionType' for type '-saml1:union-AssertionType' */
#ifndef SOAP_TYPE_PointerTo__saml1__union_AssertionType
#define SOAP_TYPE_PointerTo__saml1__union_AssertionType (125)
#endif

/* struct saml1__AttributeStatementType * has binding name 'PointerTosaml1__AttributeStatementType' for type 'saml1:AttributeStatementType' */
#ifndef SOAP_TYPE_PointerTosaml1__AttributeStatementType
#define SOAP_TYPE_PointerTosaml1__AttributeStatementType (124)
#endif

/* struct saml1__AuthorizationDecisionStatementType * has binding name 'PointerTosaml1__AuthorizationDecisionStatementType' for type 'saml1:AuthorizationDecisionStatementType' */
#ifndef SOAP_TYPE_PointerTosaml1__AuthorizationDecisionStatementType
#define SOAP_TYPE_PointerTosaml1__AuthorizationDecisionStatementType (123)
#endif

/* struct saml1__AuthenticationStatementType * has binding name 'PointerTosaml1__AuthenticationStatementType' for type 'saml1:AuthenticationStatementType' */
#ifndef SOAP_TYPE_PointerTosaml1__AuthenticationStatementType
#define SOAP_TYPE_PointerTosaml1__AuthenticationStatementType (122)
#endif

/* struct saml1__SubjectStatementAbstractType * has binding name 'PointerTosaml1__SubjectStatementAbstractType' for type 'saml1:SubjectStatementAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml1__SubjectStatementAbstractType
#define SOAP_TYPE_PointerTosaml1__SubjectStatementAbstractType (121)
#endif

/* struct saml1__StatementAbstractType * has binding name 'PointerTosaml1__StatementAbstractType' for type 'saml1:StatementAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml1__StatementAbstractType
#define SOAP_TYPE_PointerTosaml1__StatementAbstractType (120)
#endif

/* struct saml1__AdviceType * has binding name 'PointerTosaml1__AdviceType' for type 'saml1:AdviceType' */
#ifndef SOAP_TYPE_PointerTosaml1__AdviceType
#define SOAP_TYPE_PointerTosaml1__AdviceType (118)
#endif

/* struct saml1__ConditionsType * has binding name 'PointerTosaml1__ConditionsType' for type 'saml1:ConditionsType' */
#ifndef SOAP_TYPE_PointerTosaml1__ConditionsType
#define SOAP_TYPE_PointerTosaml1__ConditionsType (117)
#endif

/* struct __wsc__DerivedKeyTokenType_sequence * has binding name 'PointerTo__wsc__DerivedKeyTokenType_sequence' for type '-wsc:DerivedKeyTokenType-sequence' */
#ifndef SOAP_TYPE_PointerTo__wsc__DerivedKeyTokenType_sequence
#define SOAP_TYPE_PointerTo__wsc__DerivedKeyTokenType_sequence (95)
#endif

/* ULONG64 * has binding name 'PointerToULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_PointerToULONG64
#define SOAP_TYPE_PointerToULONG64 (94)
#endif

/* struct wsc__PropertiesType * has binding name 'PointerTowsc__PropertiesType' for type 'wsc:PropertiesType' */
#ifndef SOAP_TYPE_PointerTowsc__PropertiesType
#define SOAP_TYPE_PointerTowsc__PropertiesType (90)
#endif

/* wsc__FaultCodeOpenEnumType has binding name 'wsc__FaultCodeOpenEnumType' for type 'wsc:FaultCodeOpenEnumType' */
#ifndef SOAP_TYPE_wsc__FaultCodeOpenEnumType
#define SOAP_TYPE_wsc__FaultCodeOpenEnumType (85)
#endif

/* struct _xenc__ReferenceList * has binding name 'PointerTo_xenc__ReferenceList' for type '' */
#ifndef SOAP_TYPE_PointerTo_xenc__ReferenceList
#define SOAP_TYPE_PointerTo_xenc__ReferenceList (84)
#endif

/* struct __xenc__union_ReferenceList * has binding name 'PointerTo__xenc__union_ReferenceList' for type '-xenc:union-ReferenceList' */
#ifndef SOAP_TYPE_PointerTo__xenc__union_ReferenceList
#define SOAP_TYPE_PointerTo__xenc__union_ReferenceList (83)
#endif

/* struct xenc__ReferenceType * has binding name 'PointerToxenc__ReferenceType' for type 'xenc:ReferenceType' */
#ifndef SOAP_TYPE_PointerToxenc__ReferenceType
#define SOAP_TYPE_PointerToxenc__ReferenceType (82)
#endif

/* struct xenc__EncryptionPropertyType * has binding name 'PointerToxenc__EncryptionPropertyType' for type 'xenc:EncryptionPropertyType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptionPropertyType
#define SOAP_TYPE_PointerToxenc__EncryptionPropertyType (80)
#endif

/* struct xenc__TransformsType * has binding name 'PointerToxenc__TransformsType' for type 'xenc:TransformsType' */
#ifndef SOAP_TYPE_PointerToxenc__TransformsType
#define SOAP_TYPE_PointerToxenc__TransformsType (79)
#endif

/* struct xenc__CipherReferenceType * has binding name 'PointerToxenc__CipherReferenceType' for type 'xenc:CipherReferenceType' */
#ifndef SOAP_TYPE_PointerToxenc__CipherReferenceType
#define SOAP_TYPE_PointerToxenc__CipherReferenceType (78)
#endif

/* struct xenc__EncryptionPropertiesType * has binding name 'PointerToxenc__EncryptionPropertiesType' for type 'xenc:EncryptionPropertiesType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptionPropertiesType
#define SOAP_TYPE_PointerToxenc__EncryptionPropertiesType (77)
#endif

/* struct xenc__CipherDataType * has binding name 'PointerToxenc__CipherDataType' for type 'xenc:CipherDataType' */
#ifndef SOAP_TYPE_PointerToxenc__CipherDataType
#define SOAP_TYPE_PointerToxenc__CipherDataType (76)
#endif

/* struct ds__KeyInfoType * has binding name 'PointerTo_ds__KeyInfo' for type '' */
#ifndef SOAP_TYPE_PointerTo_ds__KeyInfo
#define SOAP_TYPE_PointerTo_ds__KeyInfo (75)
#endif

/* struct xenc__EncryptionMethodType * has binding name 'PointerToxenc__EncryptionMethodType' for type 'xenc:EncryptionMethodType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptionMethodType
#define SOAP_TYPE_PointerToxenc__EncryptionMethodType (74)
#endif

/* struct ds__X509IssuerSerialType * has binding name 'PointerTods__X509IssuerSerialType' for type 'ds:X509IssuerSerialType' */
#ifndef SOAP_TYPE_PointerTods__X509IssuerSerialType
#define SOAP_TYPE_PointerTods__X509IssuerSerialType (61)
#endif

/* struct ds__RSAKeyValueType * has binding name 'PointerTods__RSAKeyValueType' for type 'ds:RSAKeyValueType' */
#ifndef SOAP_TYPE_PointerTods__RSAKeyValueType
#define SOAP_TYPE_PointerTods__RSAKeyValueType (60)
#endif

/* struct ds__DSAKeyValueType * has binding name 'PointerTods__DSAKeyValueType' for type 'ds:DSAKeyValueType' */
#ifndef SOAP_TYPE_PointerTods__DSAKeyValueType
#define SOAP_TYPE_PointerTods__DSAKeyValueType (59)
#endif

/* struct ds__TransformType * has binding name 'PointerTods__TransformType' for type 'ds:TransformType' */
#ifndef SOAP_TYPE_PointerTods__TransformType
#define SOAP_TYPE_PointerTods__TransformType (58)
#endif

/* struct ds__DigestMethodType * has binding name 'PointerTods__DigestMethodType' for type 'ds:DigestMethodType' */
#ifndef SOAP_TYPE_PointerTods__DigestMethodType
#define SOAP_TYPE_PointerTods__DigestMethodType (57)
#endif

/* struct ds__TransformsType * has binding name 'PointerTods__TransformsType' for type 'ds:TransformsType' */
#ifndef SOAP_TYPE_PointerTods__TransformsType
#define SOAP_TYPE_PointerTods__TransformsType (56)
#endif

/* int * has binding name 'PointerToint' for type 'xsd:int' */
#ifndef SOAP_TYPE_PointerToint
#define SOAP_TYPE_PointerToint (55)
#endif

/* struct ds__ReferenceType ** has binding name 'PointerToPointerTods__ReferenceType' for type 'ds:ReferenceType' */
#ifndef SOAP_TYPE_PointerToPointerTods__ReferenceType
#define SOAP_TYPE_PointerToPointerTods__ReferenceType (54)
#endif

/* struct ds__ReferenceType * has binding name 'PointerTods__ReferenceType' for type 'ds:ReferenceType' */
#ifndef SOAP_TYPE_PointerTods__ReferenceType
#define SOAP_TYPE_PointerTods__ReferenceType (53)
#endif

/* struct ds__SignatureMethodType * has binding name 'PointerTods__SignatureMethodType' for type 'ds:SignatureMethodType' */
#ifndef SOAP_TYPE_PointerTods__SignatureMethodType
#define SOAP_TYPE_PointerTods__SignatureMethodType (52)
#endif

/* struct ds__CanonicalizationMethodType * has binding name 'PointerTods__CanonicalizationMethodType' for type 'ds:CanonicalizationMethodType' */
#ifndef SOAP_TYPE_PointerTods__CanonicalizationMethodType
#define SOAP_TYPE_PointerTods__CanonicalizationMethodType (51)
#endif

/* struct _wsse__SecurityTokenReference * has binding name 'PointerTo_wsse__SecurityTokenReference' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__SecurityTokenReference
#define SOAP_TYPE_PointerTo_wsse__SecurityTokenReference (46)
#endif

/* struct ds__RetrievalMethodType * has binding name 'PointerTods__RetrievalMethodType' for type 'ds:RetrievalMethodType' */
#ifndef SOAP_TYPE_PointerTods__RetrievalMethodType
#define SOAP_TYPE_PointerTods__RetrievalMethodType (45)
#endif

/* struct ds__KeyValueType * has binding name 'PointerTods__KeyValueType' for type 'ds:KeyValueType' */
#ifndef SOAP_TYPE_PointerTods__KeyValueType
#define SOAP_TYPE_PointerTods__KeyValueType (43)
#endif

/* struct _c14n__InclusiveNamespaces * has binding name 'PointerTo_c14n__InclusiveNamespaces' for type '' */
#ifndef SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces
#define SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces (39)
#endif

/* struct ds__KeyInfoType * has binding name 'PointerTods__KeyInfoType' for type 'ds:KeyInfoType' */
#ifndef SOAP_TYPE_PointerTods__KeyInfoType
#define SOAP_TYPE_PointerTods__KeyInfoType (31)
#endif

/* struct ds__SignedInfoType * has binding name 'PointerTods__SignedInfoType' for type 'ds:SignedInfoType' */
#ifndef SOAP_TYPE_PointerTods__SignedInfoType
#define SOAP_TYPE_PointerTods__SignedInfoType (29)
#endif

/* _ds__SignatureValue has binding name '_ds__SignatureValue' for type '' */
#ifndef SOAP_TYPE__ds__SignatureValue
#define SOAP_TYPE__ds__SignatureValue (26)
#endif

/* struct ds__X509DataType * has binding name 'PointerTods__X509DataType' for type 'ds:X509DataType' */
#ifndef SOAP_TYPE_PointerTods__X509DataType
#define SOAP_TYPE_PointerTods__X509DataType (25)
#endif

/* struct _wsse__Embedded * has binding name 'PointerTo_wsse__Embedded' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Embedded
#define SOAP_TYPE_PointerTo_wsse__Embedded (23)
#endif

/* struct _wsse__KeyIdentifier * has binding name 'PointerTo_wsse__KeyIdentifier' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__KeyIdentifier
#define SOAP_TYPE_PointerTo_wsse__KeyIdentifier (22)
#endif

/* struct _wsse__Reference * has binding name 'PointerTo_wsse__Reference' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Reference
#define SOAP_TYPE_PointerTo_wsse__Reference (21)
#endif

/* struct wsse__EncodedString * has binding name 'PointerTowsse__EncodedString' for type 'wsse:EncodedString' */
#ifndef SOAP_TYPE_PointerTowsse__EncodedString
#define SOAP_TYPE_PointerTowsse__EncodedString (15)
#endif

/* struct _wsse__Password * has binding name 'PointerTo_wsse__Password' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Password
#define SOAP_TYPE_PointerTo_wsse__Password (14)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<ns13__Attribute *>  has binding name 'std__vectorTemplateOfPointerTons13__Attribute' for type 'ns13:Attribute' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons13__Attribute
#define SOAP_TYPE_std__vectorTemplateOfPointerTons13__Attribute (2216)
#endif

/* std::vector<_ns6__TopicNamespaceType_Topic>  has binding name 'std__vectorTemplateOf_ns6__TopicNamespaceType_Topic' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_ns6__TopicNamespaceType_Topic
#define SOAP_TYPE_std__vectorTemplateOf_ns6__TopicNamespaceType_Topic (2211)
#endif

/* std::vector<ns6__TopicType *>  has binding name 'std__vectorTemplateOfPointerTons6__TopicType' for type 'ns6:TopicType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons6__TopicType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons6__TopicType (2208)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfxsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__QName
#define SOAP_TYPE_std__vectorTemplateOfxsd__QName (2204)
#endif

/* std::vector<ns12__CredentialAccessProfile *>  has binding name 'std__vectorTemplateOfPointerTons12__CredentialAccessProfile' for type 'ns12:CredentialAccessProfile' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons12__CredentialAccessProfile
#define SOAP_TYPE_std__vectorTemplateOfPointerTons12__CredentialAccessProfile (2164)
#endif

/* std::vector<ns12__CredentialIdentifier *>  has binding name 'std__vectorTemplateOfPointerTons12__CredentialIdentifier' for type 'ns12:CredentialIdentifier' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons12__CredentialIdentifier
#define SOAP_TYPE_std__vectorTemplateOfPointerTons12__CredentialIdentifier (2162)
#endif

/* std::vector<ns12__Credential *>  has binding name 'std__vectorTemplateOfPointerTons12__Credential' for type 'ns12:Credential' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons12__Credential
#define SOAP_TYPE_std__vectorTemplateOfPointerTons12__Credential (2159)
#endif

/* std::vector<ns12__CredentialInfo *>  has binding name 'std__vectorTemplateOfPointerTons12__CredentialInfo' for type 'ns12:CredentialInfo' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons12__CredentialInfo
#define SOAP_TYPE_std__vectorTemplateOfPointerTons12__CredentialInfo (2157)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfns13__ReferenceToken' for type 'ns13:ReferenceToken' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns13__ReferenceToken
#define SOAP_TYPE_std__vectorTemplateOfns13__ReferenceToken (2155)
#endif

/* std::vector<ns12__CredentialIdentifierFormatTypeInfo *>  has binding name 'std__vectorTemplateOfPointerTons12__CredentialIdentifierFormatTypeInfo' for type 'ns12:CredentialIdentifierFormatTypeInfo' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons12__CredentialIdentifierFormatTypeInfo
#define SOAP_TYPE_std__vectorTemplateOfPointerTons12__CredentialIdentifierFormatTypeInfo (2154)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfns13__Name' for type 'ns13:Name' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns13__Name
#define SOAP_TYPE_std__vectorTemplateOfns13__Name (2145)
#endif

/* std::vector<ns2__PresetTour *>  has binding name 'std__vectorTemplateOfPointerTons2__PresetTour' for type 'ns2:PresetTour' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__PresetTour
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__PresetTour (2143)
#endif

/* std::vector<ns2__PTZPreset *>  has binding name 'std__vectorTemplateOfPointerTons2__PTZPreset' for type 'ns2:PTZPreset' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__PTZPreset
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__PTZPreset (2141)
#endif

/* std::vector<ns2__PTZConfiguration *>  has binding name 'std__vectorTemplateOfPointerTons2__PTZConfiguration' for type 'ns2:PTZConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__PTZConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__PTZConfiguration (2136)
#endif

/* std::vector<ns2__PTZNode *>  has binding name 'std__vectorTemplateOfPointerTons2__PTZNode' for type 'ns2:PTZNode' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__PTZNode
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__PTZNode (2135)
#endif

/* std::vector<ns10__VideoSourceMode *>  has binding name 'std__vectorTemplateOfPointerTons10__VideoSourceMode' for type 'ns10:VideoSourceMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons10__VideoSourceMode
#define SOAP_TYPE_std__vectorTemplateOfPointerTons10__VideoSourceMode (2132)
#endif

/* std::vector<ns2__AudioEncoder2ConfigurationOptions *>  has binding name 'std__vectorTemplateOfPointerTons2__AudioEncoder2ConfigurationOptions' for type 'ns2:AudioEncoder2ConfigurationOptions' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__AudioEncoder2ConfigurationOptions
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__AudioEncoder2ConfigurationOptions (2129)
#endif

/* std::vector<ns2__VideoEncoder2ConfigurationOptions *>  has binding name 'std__vectorTemplateOfPointerTons2__VideoEncoder2ConfigurationOptions' for type 'ns2:VideoEncoder2ConfigurationOptions' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__VideoEncoder2ConfigurationOptions
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__VideoEncoder2ConfigurationOptions (2127)
#endif

/* std::vector<ns2__AudioEncoder2Configuration *>  has binding name 'std__vectorTemplateOfPointerTons2__AudioEncoder2Configuration' for type 'ns2:AudioEncoder2Configuration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__AudioEncoder2Configuration
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__AudioEncoder2Configuration (2125)
#endif

/* std::vector<ns2__VideoEncoder2Configuration *>  has binding name 'std__vectorTemplateOfPointerTons2__VideoEncoder2Configuration' for type 'ns2:VideoEncoder2Configuration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__VideoEncoder2Configuration
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__VideoEncoder2Configuration (2124)
#endif

/* std::vector<ns10__MediaProfile *>  has binding name 'std__vectorTemplateOfPointerTons10__MediaProfile' for type 'ns10:MediaProfile' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons10__MediaProfile
#define SOAP_TYPE_std__vectorTemplateOfPointerTons10__MediaProfile (2123)
#endif

/* std::vector<ns10__ConfigurationRef *>  has binding name 'std__vectorTemplateOfPointerTons10__ConfigurationRef' for type 'ns10:ConfigurationRef' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons10__ConfigurationRef
#define SOAP_TYPE_std__vectorTemplateOfPointerTons10__ConfigurationRef (2121)
#endif

/* std::vector<ns10__EncoderInstance *>  has binding name 'std__vectorTemplateOfPointerTons10__EncoderInstance' for type 'ns10:EncoderInstance' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons10__EncoderInstance
#define SOAP_TYPE_std__vectorTemplateOfPointerTons10__EncoderInstance (2118)
#endif

/* std::vector<ns2__OSDConfiguration *>  has binding name 'std__vectorTemplateOfPointerTons2__OSDConfiguration' for type 'ns2:OSDConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__OSDConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__OSDConfiguration (2109)
#endif

/* std::vector<ns9__VideoSourceMode *>  has binding name 'std__vectorTemplateOfPointerTons9__VideoSourceMode' for type 'ns9:VideoSourceMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons9__VideoSourceMode
#define SOAP_TYPE_std__vectorTemplateOfPointerTons9__VideoSourceMode (2107)
#endif

/* std::vector<ns2__AudioDecoderConfiguration *>  has binding name 'std__vectorTemplateOfPointerTons2__AudioDecoderConfiguration' for type 'ns2:AudioDecoderConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__AudioDecoderConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__AudioDecoderConfiguration (2099)
#endif

/* std::vector<ns2__AudioOutputConfiguration *>  has binding name 'std__vectorTemplateOfPointerTons2__AudioOutputConfiguration' for type 'ns2:AudioOutputConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__AudioOutputConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__AudioOutputConfiguration (2098)
#endif

/* std::vector<ns2__MetadataConfiguration *>  has binding name 'std__vectorTemplateOfPointerTons2__MetadataConfiguration' for type 'ns2:MetadataConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__MetadataConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__MetadataConfiguration (2097)
#endif

/* std::vector<ns2__VideoAnalyticsConfiguration *>  has binding name 'std__vectorTemplateOfPointerTons2__VideoAnalyticsConfiguration' for type 'ns2:VideoAnalyticsConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__VideoAnalyticsConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__VideoAnalyticsConfiguration (2096)
#endif

/* std::vector<ns2__AudioSourceConfiguration *>  has binding name 'std__vectorTemplateOfPointerTons2__AudioSourceConfiguration' for type 'ns2:AudioSourceConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__AudioSourceConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__AudioSourceConfiguration (2095)
#endif

/* std::vector<ns2__AudioEncoderConfiguration *>  has binding name 'std__vectorTemplateOfPointerTons2__AudioEncoderConfiguration' for type 'ns2:AudioEncoderConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__AudioEncoderConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__AudioEncoderConfiguration (2094)
#endif

/* std::vector<ns2__VideoSourceConfiguration *>  has binding name 'std__vectorTemplateOfPointerTons2__VideoSourceConfiguration' for type 'ns2:VideoSourceConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__VideoSourceConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__VideoSourceConfiguration (2093)
#endif

/* std::vector<ns2__VideoEncoderConfiguration *>  has binding name 'std__vectorTemplateOfPointerTons2__VideoEncoderConfiguration' for type 'ns2:VideoEncoderConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__VideoEncoderConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__VideoEncoderConfiguration (2092)
#endif

/* std::vector<ns2__Profile *>  has binding name 'std__vectorTemplateOfPointerTons2__Profile' for type 'ns2:Profile' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__Profile
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__Profile (2091)
#endif

/* std::vector<ns2__AudioOutput *>  has binding name 'std__vectorTemplateOfPointerTons2__AudioOutput' for type 'ns2:AudioOutput' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__AudioOutput
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__AudioOutput (2089)
#endif

/* std::vector<ns2__AudioSource *>  has binding name 'std__vectorTemplateOfPointerTons2__AudioSource' for type 'ns2:AudioSource' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__AudioSource
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__AudioSource (2087)
#endif

/* std::vector<ns2__VideoSource *>  has binding name 'std__vectorTemplateOfPointerTons2__VideoSource' for type 'ns2:VideoSource' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__VideoSource
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__VideoSource (2085)
#endif

/* std::vector<ns8__ImagingPreset *>  has binding name 'std__vectorTemplateOfPointerTons8__ImagingPreset' for type 'ns8:ImagingPreset' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons8__ImagingPreset
#define SOAP_TYPE_std__vectorTemplateOfPointerTons8__ImagingPreset (2078)
#endif

/* std::vector<ns2__PaneConfiguration *>  has binding name 'std__vectorTemplateOfPointerTons2__PaneConfiguration' for type 'ns2:PaneConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__PaneConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__PaneConfiguration (2071)
#endif

/* std::vector<_ns5__BaseFaultType_Description>  has binding name 'std__vectorTemplateOf_ns5__BaseFaultType_Description' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_ns5__BaseFaultType_Description
#define SOAP_TYPE_std__vectorTemplateOf_ns5__BaseFaultType_Description (2061)
#endif

/* std::vector<ns3__NotificationMessageHolderType *>  has binding name 'std__vectorTemplateOfPointerTons3__NotificationMessageHolderType' for type 'ns3:NotificationMessageHolderType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType (2052)
#endif

/* std::vector<ns3__TopicExpressionType *>  has binding name 'std__vectorTemplateOfPointerTons3__TopicExpressionType' for type 'ns3:TopicExpressionType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__TopicExpressionType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__TopicExpressionType (2049)
#endif

/* std::vector<ns2__FileProgress *>  has binding name 'std__vectorTemplateOfPointerTons2__FileProgress' for type 'ns2:FileProgress' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__FileProgress
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__FileProgress (2041)
#endif

/* std::vector<ns2__OSDType>  has binding name 'std__vectorTemplateOfns2__OSDType' for type 'ns2:OSDType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__OSDType
#define SOAP_TYPE_std__vectorTemplateOfns2__OSDType (2036)
#endif

/* std::vector<ns2__ColorspaceRange *>  has binding name 'std__vectorTemplateOfPointerTons2__ColorspaceRange' for type 'ns2:ColorspaceRange' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__ColorspaceRange
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__ColorspaceRange (2027)
#endif

/* std::vector<ns2__Color *>  has binding name 'std__vectorTemplateOfPointerTons2__Color' for type 'ns2:Color' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__Color
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__Color (2024)
#endif

/* std::vector<ns2__ActiveConnection *>  has binding name 'std__vectorTemplateOfPointerTons2__ActiveConnection' for type 'ns2:ActiveConnection' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__ActiveConnection
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__ActiveConnection (2018)
#endif

/* std::vector<ns2__AudioClassCandidate *>  has binding name 'std__vectorTemplateOfPointerTons2__AudioClassCandidate' for type 'ns2:AudioClassCandidate' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__AudioClassCandidate
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__AudioClassCandidate (2015)
#endif

/* std::vector<ns2__EngineConfiguration *>  has binding name 'std__vectorTemplateOfPointerTons2__EngineConfiguration' for type 'ns2:EngineConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__EngineConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__EngineConfiguration (2003)
#endif

/* std::vector<ns2__RecordingJobStateTrack *>  has binding name 'std__vectorTemplateOfPointerTons2__RecordingJobStateTrack' for type 'ns2:RecordingJobStateTrack' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__RecordingJobStateTrack
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__RecordingJobStateTrack (2000)
#endif

/* std::vector<ns2__RecordingJobStateSource *>  has binding name 'std__vectorTemplateOfPointerTons2__RecordingJobStateSource' for type 'ns2:RecordingJobStateSource' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__RecordingJobStateSource
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__RecordingJobStateSource (1996)
#endif

/* std::vector<ns2__RecordingJobTrack *>  has binding name 'std__vectorTemplateOfPointerTons2__RecordingJobTrack' for type 'ns2:RecordingJobTrack' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__RecordingJobTrack
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__RecordingJobTrack (1993)
#endif

/* std::vector<ns2__RecordingJobSource *>  has binding name 'std__vectorTemplateOfPointerTons2__RecordingJobSource' for type 'ns2:RecordingJobSource' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__RecordingJobSource
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__RecordingJobSource (1990)
#endif

/* std::vector<ns2__GetTracksResponseItem *>  has binding name 'std__vectorTemplateOfPointerTons2__GetTracksResponseItem' for type 'ns2:GetTracksResponseItem' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__GetTracksResponseItem
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__GetTracksResponseItem (1987)
#endif

/* std::vector<ns2__TrackAttributes *>  has binding name 'std__vectorTemplateOfPointerTons2__TrackAttributes' for type 'ns2:TrackAttributes' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__TrackAttributes
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__TrackAttributes (1979)
#endif

/* std::vector<ns2__TrackInformation *>  has binding name 'std__vectorTemplateOfPointerTons2__TrackInformation' for type 'ns2:TrackInformation' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__TrackInformation
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__TrackInformation (1977)
#endif

/* std::vector<ns2__FindMetadataResult *>  has binding name 'std__vectorTemplateOfPointerTons2__FindMetadataResult' for type 'ns2:FindMetadataResult' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__FindMetadataResult
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__FindMetadataResult (1974)
#endif

/* std::vector<ns2__FindPTZPositionResult *>  has binding name 'std__vectorTemplateOfPointerTons2__FindPTZPositionResult' for type 'ns2:FindPTZPositionResult' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__FindPTZPositionResult
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__FindPTZPositionResult (1972)
#endif

/* std::vector<ns2__FindEventResult *>  has binding name 'std__vectorTemplateOfPointerTons2__FindEventResult' for type 'ns2:FindEventResult' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__FindEventResult
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__FindEventResult (1970)
#endif

/* std::vector<ns2__RecordingInformation *>  has binding name 'std__vectorTemplateOfPointerTons2__RecordingInformation' for type 'ns2:RecordingInformation' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__RecordingInformation
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__RecordingInformation (1968)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfns2__RecordingReference' for type 'ns2:RecordingReference' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__RecordingReference
#define SOAP_TYPE_std__vectorTemplateOfns2__RecordingReference (1964)
#endif

/* std::vector<ns2__SourceReference *>  has binding name 'std__vectorTemplateOfPointerTons2__SourceReference' for type 'ns2:SourceReference' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__SourceReference
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__SourceReference (1963)
#endif

/* std::vector<ns2__Rectangle *>  has binding name 'std__vectorTemplateOfPointerTons2__Rectangle' for type 'ns2:Rectangle' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__Rectangle
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__Rectangle (1958)
#endif

/* std::vector<ns2__PaneLayoutOptions *>  has binding name 'std__vectorTemplateOfPointerTons2__PaneLayoutOptions' for type 'ns2:PaneLayoutOptions' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__PaneLayoutOptions
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__PaneLayoutOptions (1956)
#endif

/* std::vector<ns2__PaneLayout *>  has binding name 'std__vectorTemplateOfPointerTons2__PaneLayout' for type 'ns2:PaneLayout' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__PaneLayout
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__PaneLayout (1950)
#endif

/* std::vector<ns2__AudioDescriptor *>  has binding name 'std__vectorTemplateOfPointerTons2__AudioDescriptor' for type 'ns2:AudioDescriptor' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__AudioDescriptor
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__AudioDescriptor (1933)
#endif

/* std::vector<ns2__Polyline *>  has binding name 'std__vectorTemplateOfPointerTons2__Polyline' for type 'ns2:Polyline' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__Polyline
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__Polyline (1919)
#endif

/* std::vector<ns2__ConfigDescription *>  has binding name 'std__vectorTemplateOfPointerTons2__ConfigDescription' for type 'ns2:ConfigDescription' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__ConfigDescription
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__ConfigDescription (1915)
#endif

/* std::vector<_ns2__ConfigDescription_Messages>  has binding name 'std__vectorTemplateOf_ns2__ConfigDescription_Messages' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_ns2__ConfigDescription_Messages
#define SOAP_TYPE_std__vectorTemplateOf_ns2__ConfigDescription_Messages (1911)
#endif

/* std::vector<ns2__Config *>  has binding name 'std__vectorTemplateOfPointerTons2__Config' for type 'ns2:Config' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__Config
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__Config (1906)
#endif

/* std::vector<ns2__Merge *>  has binding name 'std__vectorTemplateOfPointerTons2__Merge' for type 'ns2:Merge' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__Merge
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__Merge (1903)
#endif

/* std::vector<ns2__Split *>  has binding name 'std__vectorTemplateOfPointerTons2__Split' for type 'ns2:Split' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__Split
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__Split (1901)
#endif

/* std::vector<ns2__Rename *>  has binding name 'std__vectorTemplateOfPointerTons2__Rename' for type 'ns2:Rename' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__Rename
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__Rename (1899)
#endif

/* std::vector<ns2__ObjectId *>  has binding name 'std__vectorTemplateOfPointerTons2__ObjectId' for type 'ns2:ObjectId' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__ObjectId
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__ObjectId (1891)
#endif

/* std::vector<ns2__Object *>  has binding name 'std__vectorTemplateOfPointerTons2__Object' for type 'ns2:Object' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__Object
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__Object (1885)
#endif

/* std::vector<ns2__OtherType *>  has binding name 'std__vectorTemplateOfPointerTons2__OtherType' for type 'ns2:OtherType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__OtherType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__OtherType (1880)
#endif

/* std::vector<_ns2__ClassDescriptor_ClassCandidate>  has binding name 'std__vectorTemplateOf_ns2__ClassDescriptor_ClassCandidate' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_ns2__ClassDescriptor_ClassCandidate
#define SOAP_TYPE_std__vectorTemplateOf_ns2__ClassDescriptor_ClassCandidate (1876)
#endif

/* std::vector<_ns2__ColorDescriptor_ColorCluster>  has binding name 'std__vectorTemplateOf_ns2__ColorDescriptor_ColorCluster' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_ns2__ColorDescriptor_ColorCluster
#define SOAP_TYPE_std__vectorTemplateOf_ns2__ColorDescriptor_ColorCluster (1872)
#endif

/* std::vector<ns2__Polygon *>  has binding name 'std__vectorTemplateOfPointerTons2__Polygon' for type 'ns2:Polygon' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__Polygon
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__Polygon (1867)
#endif

/* std::vector<ns2__Vector *>  has binding name 'std__vectorTemplateOfPointerTons2__Vector' for type 'ns2:Vector' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__Vector
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__Vector (1860)
#endif

/* std::vector<_ns2__ItemListDescription_ElementItemDescription>  has binding name 'std__vectorTemplateOf_ns2__ItemListDescription_ElementItemDescription' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_ns2__ItemListDescription_ElementItemDescription
#define SOAP_TYPE_std__vectorTemplateOf_ns2__ItemListDescription_ElementItemDescription (1856)
#endif

/* std::vector<_ns2__ItemListDescription_SimpleItemDescription>  has binding name 'std__vectorTemplateOf_ns2__ItemListDescription_SimpleItemDescription' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_ns2__ItemListDescription_SimpleItemDescription
#define SOAP_TYPE_std__vectorTemplateOf_ns2__ItemListDescription_SimpleItemDescription (1853)
#endif

/* std::vector<_ns2__ItemList_ElementItem>  has binding name 'std__vectorTemplateOf_ns2__ItemList_ElementItem' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_ns2__ItemList_ElementItem
#define SOAP_TYPE_std__vectorTemplateOf_ns2__ItemList_ElementItem (1847)
#endif

/* std::vector<_ns2__ItemList_SimpleItem>  has binding name 'std__vectorTemplateOf_ns2__ItemList_SimpleItem' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_ns2__ItemList_SimpleItem
#define SOAP_TYPE_std__vectorTemplateOf_ns2__ItemList_SimpleItem (1844)
#endif

/* std::vector<ns2__BacklightCompensationMode>  has binding name 'std__vectorTemplateOfns2__BacklightCompensationMode' for type 'ns2:BacklightCompensationMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__BacklightCompensationMode
#define SOAP_TYPE_std__vectorTemplateOfns2__BacklightCompensationMode (1837)
#endif

/* std::vector<ns2__ImageStabilizationMode>  has binding name 'std__vectorTemplateOfns2__ImageStabilizationMode' for type 'ns2:ImageStabilizationMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__ImageStabilizationMode
#define SOAP_TYPE_std__vectorTemplateOfns2__ImageStabilizationMode (1834)
#endif

/* std::vector<ns2__IrCutFilterAutoAdjustment *>  has binding name 'std__vectorTemplateOfPointerTons2__IrCutFilterAutoAdjustment' for type 'ns2:IrCutFilterAutoAdjustment' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__IrCutFilterAutoAdjustment
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__IrCutFilterAutoAdjustment (1809)
#endif

/* std::vector<ns2__WhiteBalanceMode>  has binding name 'std__vectorTemplateOfns2__WhiteBalanceMode' for type 'ns2:WhiteBalanceMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__WhiteBalanceMode
#define SOAP_TYPE_std__vectorTemplateOfns2__WhiteBalanceMode (1790)
#endif

/* std::vector<ns2__ExposurePriority>  has binding name 'std__vectorTemplateOfns2__ExposurePriority' for type 'ns2:ExposurePriority' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__ExposurePriority
#define SOAP_TYPE_std__vectorTemplateOfns2__ExposurePriority (1789)
#endif

/* std::vector<ns2__ExposureMode>  has binding name 'std__vectorTemplateOfns2__ExposureMode' for type 'ns2:ExposureMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__ExposureMode
#define SOAP_TYPE_std__vectorTemplateOfns2__ExposureMode (1788)
#endif

/* std::vector<ns2__AutoFocusMode>  has binding name 'std__vectorTemplateOfns2__AutoFocusMode' for type 'ns2:AutoFocusMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__AutoFocusMode
#define SOAP_TYPE_std__vectorTemplateOfns2__AutoFocusMode (1787)
#endif

/* std::vector<ns2__WideDynamicMode>  has binding name 'std__vectorTemplateOfns2__WideDynamicMode' for type 'ns2:WideDynamicMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__WideDynamicMode
#define SOAP_TYPE_std__vectorTemplateOfns2__WideDynamicMode (1786)
#endif

/* std::vector<ns2__IrCutFilterMode>  has binding name 'std__vectorTemplateOfns2__IrCutFilterMode' for type 'ns2:IrCutFilterMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__IrCutFilterMode
#define SOAP_TYPE_std__vectorTemplateOfns2__IrCutFilterMode (1783)
#endif

/* std::vector<ns2__PTZPresetTourDirection>  has binding name 'std__vectorTemplateOfns2__PTZPresetTourDirection' for type 'ns2:PTZPresetTourDirection' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__PTZPresetTourDirection
#define SOAP_TYPE_std__vectorTemplateOfns2__PTZPresetTourDirection (1769)
#endif

/* std::vector<ns2__PTZPresetTourSpot *>  has binding name 'std__vectorTemplateOfPointerTons2__PTZPresetTourSpot' for type 'ns2:PTZPresetTourSpot' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__PTZPresetTourSpot
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__PTZPresetTourSpot (1755)
#endif

/* std::vector<ns2__Space1DDescription *>  has binding name 'std__vectorTemplateOfPointerTons2__Space1DDescription' for type 'ns2:Space1DDescription' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__Space1DDescription
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__Space1DDescription (1744)
#endif

/* std::vector<ns2__Space2DDescription *>  has binding name 'std__vectorTemplateOfPointerTons2__Space2DDescription' for type 'ns2:Space2DDescription' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__Space2DDescription
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__Space2DDescription (1743)
#endif

/* std::vector<ns2__ReverseMode>  has binding name 'std__vectorTemplateOfns2__ReverseMode' for type 'ns2:ReverseMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__ReverseMode
#define SOAP_TYPE_std__vectorTemplateOfns2__ReverseMode (1739)
#endif

/* std::vector<ns2__EFlipMode>  has binding name 'std__vectorTemplateOfns2__EFlipMode' for type 'ns2:EFlipMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__EFlipMode
#define SOAP_TYPE_std__vectorTemplateOfns2__EFlipMode (1737)
#endif

/* std::vector<ns2__PTZPresetTourOperation>  has binding name 'std__vectorTemplateOfns2__PTZPresetTourOperation' for type 'ns2:PTZPresetTourOperation' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__PTZPresetTourOperation
#define SOAP_TYPE_std__vectorTemplateOfns2__PTZPresetTourOperation (1723)
#endif

/* std::vector<ns2__SystemLogUri *>  has binding name 'std__vectorTemplateOfPointerTons2__SystemLogUri' for type 'ns2:SystemLogUri' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__SystemLogUri
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__SystemLogUri (1708)
#endif

/* std::vector<ns2__OnvifVersion *>  has binding name 'std__vectorTemplateOfPointerTons2__OnvifVersion' for type 'ns2:OnvifVersion' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__OnvifVersion
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__OnvifVersion (1701)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfns2__AuxiliaryData' for type 'ns2:AuxiliaryData' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__AuxiliaryData
#define SOAP_TYPE_std__vectorTemplateOfns2__AuxiliaryData (1691)
#endif

/* std::vector<ns2__Dot11Cipher>  has binding name 'std__vectorTemplateOfns2__Dot11Cipher' for type 'ns2:Dot11Cipher' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__Dot11Cipher
#define SOAP_TYPE_std__vectorTemplateOfns2__Dot11Cipher (1668)
#endif

/* std::vector<ns2__Dot11AuthAndMangementSuite>  has binding name 'std__vectorTemplateOfns2__Dot11AuthAndMangementSuite' for type 'ns2:Dot11AuthAndMangementSuite' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__Dot11AuthAndMangementSuite
#define SOAP_TYPE_std__vectorTemplateOfns2__Dot11AuthAndMangementSuite (1667)
#endif

/* std::vector<ns2__NetworkZeroConfiguration *>  has binding name 'std__vectorTemplateOfPointerTons2__NetworkZeroConfiguration' for type 'ns2:NetworkZeroConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__NetworkZeroConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__NetworkZeroConfiguration (1655)
#endif

/* std::vector<ns2__PrefixedIPv6Address *>  has binding name 'std__vectorTemplateOfPointerTons2__PrefixedIPv6Address' for type 'ns2:PrefixedIPv6Address' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__PrefixedIPv6Address
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__PrefixedIPv6Address (1639)
#endif

/* std::vector<ns2__PrefixedIPv4Address *>  has binding name 'std__vectorTemplateOfPointerTons2__PrefixedIPv4Address' for type 'ns2:PrefixedIPv4Address' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__PrefixedIPv4Address
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__PrefixedIPv4Address (1637)
#endif

/* std::vector<ns2__Dot11Configuration *>  has binding name 'std__vectorTemplateOfPointerTons2__Dot11Configuration' for type 'ns2:Dot11Configuration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__Dot11Configuration
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__Dot11Configuration (1631)
#endif

/* std::vector<ns2__Dot3Configuration *>  has binding name 'std__vectorTemplateOfPointerTons2__Dot3Configuration' for type 'ns2:Dot3Configuration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__Dot3Configuration
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__Dot3Configuration (1629)
#endif

/* std::vector<ns2__AudioEncoderConfigurationOption *>  has binding name 'std__vectorTemplateOfPointerTons2__AudioEncoderConfigurationOption' for type 'ns2:AudioEncoderConfigurationOption' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__AudioEncoderConfigurationOption
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__AudioEncoderConfigurationOption (1611)
#endif

/* std::vector<ns2__VideoResolution2 *>  has binding name 'std__vectorTemplateOfPointerTons2__VideoResolution2' for type 'ns2:VideoResolution2' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__VideoResolution2
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__VideoResolution2 (1606)
#endif

/* std::vector<ns2__H264Profile>  has binding name 'std__vectorTemplateOfns2__H264Profile' for type 'ns2:H264Profile' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__H264Profile
#define SOAP_TYPE_std__vectorTemplateOfns2__H264Profile (1603)
#endif

/* std::vector<ns2__Mpeg4Profile>  has binding name 'std__vectorTemplateOfns2__Mpeg4Profile' for type 'ns2:Mpeg4Profile' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__Mpeg4Profile
#define SOAP_TYPE_std__vectorTemplateOfns2__Mpeg4Profile (1602)
#endif

/* std::vector<ns2__VideoResolution *>  has binding name 'std__vectorTemplateOfPointerTons2__VideoResolution' for type 'ns2:VideoResolution' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__VideoResolution
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__VideoResolution (1601)
#endif

/* std::vector<ns2__RotateMode>  has binding name 'std__vectorTemplateOfns2__RotateMode' for type 'ns2:RotateMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__RotateMode
#define SOAP_TYPE_std__vectorTemplateOfns2__RotateMode (1589)
#endif

/* std::vector<ns2__LensProjection *>  has binding name 'std__vectorTemplateOfPointerTons2__LensProjection' for type 'ns2:LensProjection' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__LensProjection
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__LensProjection (1584)
#endif

/* std::vector<ns2__LensDescription *>  has binding name 'std__vectorTemplateOfPointerTons2__LensDescription' for type 'ns2:LensDescription' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__LensDescription
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__LensDescription (1579)
#endif

/* std::vector<float>  has binding name 'std__vectorTemplateOffloat' for type 'xsd:float' */
#ifndef SOAP_TYPE_std__vectorTemplateOffloat
#define SOAP_TYPE_std__vectorTemplateOffloat (1562)
#endif

/* std::vector<int>  has binding name 'std__vectorTemplateOfint' for type 'xsd:int' */
#ifndef SOAP_TYPE_std__vectorTemplateOfint
#define SOAP_TYPE_std__vectorTemplateOfint (1561)
#endif

/* std::vector<ns1__StorageConfiguration *>  has binding name 'std__vectorTemplateOfPointerTons1__StorageConfiguration' for type 'ns1:StorageConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__StorageConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__StorageConfiguration (1557)
#endif

/* std::vector<ns2__Dot11AvailableNetworks *>  has binding name 'std__vectorTemplateOfPointerTons2__Dot11AvailableNetworks' for type 'ns2:Dot11AvailableNetworks' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__Dot11AvailableNetworks
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__Dot11AvailableNetworks (1552)
#endif

/* std::vector<ns2__RelayOutput *>  has binding name 'std__vectorTemplateOfPointerTons2__RelayOutput' for type 'ns2:RelayOutput' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__RelayOutput
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__RelayOutput (1546)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfns2__ReferenceToken' for type 'ns2:ReferenceToken' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__ReferenceToken
#define SOAP_TYPE_std__vectorTemplateOfns2__ReferenceToken (1544)
#endif

/* std::vector<ns2__Dot1XConfiguration *>  has binding name 'std__vectorTemplateOfPointerTons2__Dot1XConfiguration' for type 'ns2:Dot1XConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__Dot1XConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__Dot1XConfiguration (1543)
#endif

/* std::vector<ns2__CertificateWithPrivateKey *>  has binding name 'std__vectorTemplateOfPointerTons2__CertificateWithPrivateKey' for type 'ns2:CertificateWithPrivateKey' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__CertificateWithPrivateKey
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__CertificateWithPrivateKey (1540)
#endif

/* std::vector<ns2__CertificateStatus *>  has binding name 'std__vectorTemplateOfPointerTons2__CertificateStatus' for type 'ns2:CertificateStatus' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__CertificateStatus
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__CertificateStatus (1538)
#endif

/* std::vector<ns2__Certificate *>  has binding name 'std__vectorTemplateOfPointerTons2__Certificate' for type 'ns2:Certificate' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__Certificate
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__Certificate (1536)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfns2__IPv6Address' for type 'ns2:IPv6Address' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__IPv6Address
#define SOAP_TYPE_std__vectorTemplateOfns2__IPv6Address (1530)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfns2__IPv4Address' for type 'ns2:IPv4Address' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__IPv4Address
#define SOAP_TYPE_std__vectorTemplateOfns2__IPv4Address (1529)
#endif

/* std::vector<ns2__NetworkProtocol *>  has binding name 'std__vectorTemplateOfPointerTons2__NetworkProtocol' for type 'ns2:NetworkProtocol' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__NetworkProtocol
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__NetworkProtocol (1527)
#endif

/* std::vector<ns2__NetworkInterface *>  has binding name 'std__vectorTemplateOfPointerTons2__NetworkInterface' for type 'ns2:NetworkInterface' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__NetworkInterface
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__NetworkInterface (1524)
#endif

/* std::vector<ns2__IPAddress *>  has binding name 'std__vectorTemplateOfPointerTons2__IPAddress' for type 'ns2:IPAddress' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__IPAddress
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__IPAddress (1518)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfxsd__token' for type 'xsd:token' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__token
#define SOAP_TYPE_std__vectorTemplateOfxsd__token (1516)
#endif

/* std::vector<ns2__CapabilityCategory>  has binding name 'std__vectorTemplateOfns2__CapabilityCategory' for type 'ns2:CapabilityCategory' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__CapabilityCategory
#define SOAP_TYPE_std__vectorTemplateOfns2__CapabilityCategory (1512)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstd__string
#define SOAP_TYPE_std__vectorTemplateOfstd__string (1511)
#endif

/* std::vector<ns2__User *>  has binding name 'std__vectorTemplateOfPointerTons2__User' for type 'ns2:User' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__User
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__User (1510)
#endif

/* std::vector<ns2__NetworkHost *>  has binding name 'std__vectorTemplateOfPointerTons2__NetworkHost' for type 'ns2:NetworkHost' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__NetworkHost
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__NetworkHost (1507)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfxsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__anyURI
#define SOAP_TYPE_std__vectorTemplateOfxsd__anyURI (1505)
#endif

/* std::vector<ns2__Scope *>  has binding name 'std__vectorTemplateOfPointerTons2__Scope' for type 'ns2:Scope' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__Scope
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__Scope (1504)
#endif

/* std::vector<ns2__BackupFile *>  has binding name 'std__vectorTemplateOfPointerTons2__BackupFile' for type 'ns2:BackupFile' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__BackupFile
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__BackupFile (1500)
#endif

/* std::vector<ns1__Service *>  has binding name 'std__vectorTemplateOfPointerTons1__Service' for type 'ns1:Service' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__Service
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__Service (1493)
#endif

/* std::vector<struct soap_dom_element>  has binding name 'std__vectorTemplateOfxsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__anyType
#define SOAP_TYPE_std__vectorTemplateOfxsd__anyType (1476)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
